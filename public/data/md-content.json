{
  "/docs/fundamentals/what-is-bitcoin": {
    "content": "# What is Bitcoin?\n\nBitcoin is a decentralized digital currency and payment system that operates without a central authority or intermediary. It was created in 2009 by an anonymous person or group using the pseudonym [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto).\n\n## Core Definition\n\n**Bitcoin** (capitalized) refers to the protocol, network, and system.  \n**bitcoin** (lowercase) or **BTC** refers to the currency unit.\n\n## How Bitcoin Works\n\n### The Blockchain\n\nBitcoin uses a **blockchain** - a distributed ledger that records all transactions:\n\n1. **Transactions**: Users send bitcoin to addresses\n2. **Verification**: Network [nodes](/docs/glossary#node) verify [transactions](/docs/glossary#transaction)\n3. **Grouping**: Transactions are grouped into [blocks](/docs/glossary#block)\n4. **Mining**: [Miners](/docs/glossary#mining) compete to add blocks to the chain\n5. **Consensus**: Network agrees on valid blocks\n6. **Immutable**: Once added, blocks cannot be changed\n\n### Addresses & Keys\n\nBitcoin uses public-key cryptography to secure ownership:\n\n**Private Key:**\n- A 256-bit random number (kept secret)\n- Used to sign transactions and prove ownership\n- Anyone with the private key controls the bitcoin\n\n**Public Key:**\n- Derived mathematically from the private key\n- Can be shared publicly\n- Used to verify signatures\n\n**Address:**\n- A hash of the public key (shorter, safer to share)\n- Where others send bitcoin to you\n- Multiple address formats exist (Legacy, SegWit, Taproot)\n\nThe relationship is one-way: private key â†’ public key â†’ address. You cannot reverse-engineer a private key from an address.\n\n### Transaction Lifecycle\n\n1. **Creation**: User constructs a transaction specifying inputs (UTXOs to spend) and outputs (recipient addresses and amounts)\n2. **Signing**: User signs the transaction with their private key, proving ownership of the inputs\n3. **Broadcasting**: Signed transaction is sent to the network\n4. **Mempool**: Transaction waits in the [mempool](/docs/glossary#mempool) (memory pool) of unconfirmed transactions\n5. **Selection**: A miner selects the transaction (typically prioritizing higher fees)\n6. **Inclusion**: Transaction is included in a candidate block\n7. **Mining**: Miner finds valid proof-of-work for the block\n8. **Propagation**: New block spreads across the network\n9. **Confirmation**: Each subsequent block adds another confirmation, increasing security\n\nA transaction with 6 confirmations is generally considered irreversible.\n\n### Network Participants\n\n**Nodes:**\n- [Full nodes](/docs/glossary#full-node): Store complete blockchain, validate all transactions\n- Light nodes: Store minimal data, rely on full nodes\n- Mining nodes: Create new blocks, secure the network\n\n**Miners:**\n- Verify transactions\n- Create new blocks\n- Secure the network through [proof-of-work](/docs/glossary#proof-of-work-pow)\n- Receive [block rewards](/docs/glossary#block-reward) and fees\n\n**Users:**\n- Send and receive bitcoin\n- Control their private keys\n- Participate in the network\n\n## Technical Innovation\n\n### Proof-of-Work\n- Secures the network through computational work\n- Prevents [double-spending](/docs/glossary#double-spend)\n- Reaches [consensus](/docs/glossary#consensus) without central authority\n- Requires significant computational resources\n\n### UTXO Model\n- [Unspent Transaction Outputs](/docs/glossary#utxo-unspent-transaction-output)\n- Each transaction consumes and creates UTXOs\n- Enables parallel transaction processing\n- Clear ownership model\n\n### Merkle Trees\n- Efficient transaction verification\n- Compact block structure\n- Enables [SPV](/docs/glossary#spv-simplified-payment-verification) (Simplified Payment Verification)\n- Cryptographic integrity\n\n## The Many Faces of Bitcoin\n\n### The New Element\n\nBitcoin represents something unprecedented: **Element Zero**, consisting only of energy.\n\n**Proof of Work** is the bridge between the physical and digital worlds. Real energy (electricity, computational power, thermodynamic work) is consumed to maintain the digital scarcity of bitcoin. This is not a bug, but a feature. The energy expenditure is what gives bitcoin its unforgeable costliness, anchoring digital value to physical reality in a way no other digital asset can claim.\n\n### The Currency\n\nBitcoin is **deflationary money with absolute scarcity**. Only 21 million bitcoin will ever exist, a fixed supply that cannot be inflated, diluted, or manipulated.\n\nThis scarcity will produce conditions of human interaction never before seen in monetary history:\n- **Abundance through deflation**: As productivity increases, the value of saved bitcoin grows\n- **Long-term thinking**: Sound money encourages saving and investment over consumption\n- **True price discovery**: Without monetary manipulation, markets can function honestly\n\n### The Commodity\n\nBitcoin can **store value across time**. Like gold, but better:\n- Infinitely divisible\n- Perfectly portable\n- Easily verifiable\n- Impossible to counterfeit\n- Resistant to confiscation\n\n### The Protocol\n\nBitcoin is a protocol that allows for **free and instant transfers of value** across the entire planet.\n\n- **Trustless**: No need to trust any third party\n- **Permissionless**: Anyone can participate without asking permission\n- **Borderless**: Works the same everywhere on Earth\n\n**Bitcoin is a trust machine.** It replaces trust in institutions with mathematical verification.\n\n### The Network\n\n**Miners**: Transform energy into bitcoin. They compete to solve cryptographic puzzles, securing the network and processing transactions. In doing so, they convert raw energy into the most secure monetary network ever created.\n\n**Nodes**: Verify that the network rules were followed. Every node is a server on the Bitcoin network, independently validating every transaction and block. This distributed verification is what makes Bitcoin truly decentralized.\n\n### The Idea\n\nAt its core, Bitcoin is nothing but a **meme**, an idea that replicates itself through human minds.\n\nBitcoin embodies the idea that a **fixed set of rules can exist** around which entire societies can be built, rules that no government, corporation, or individual can change.\n\nIt unlocks the **true power of human cooperation**: voluntary exchange based on mutually agreed rules that cannot be violated.\n\nOnce the concept of sound, digital, decentralized money enters someone's mind, it cannot be unseen. It spreads from person to person, generation to generation, border to border.\n\n### The Threat\n\nBitcoin is under **constant attack** from the most sophisticated entities on this planet:\n- Intelligence agencies (NSA, KGB, Mossad, and countless others)\n- Central banks protecting their monopoly on money\n- Governments seeking to maintain financial control\n- Hackers seeking the largest bug bounty in history\n\n**And it has never been hacked.**\n\nThe network has operated continuously since January 3, 2009, securing hundreds of billions of dollars in value. The only theoretical attack (a 51% attack) would require controlling more computational power than all other miners combined, a feat that grows more impossible as the network expands.\n\nBitcoin cannot be hacked. It can only be adopted.\n",
    "filename": "overview.md"
  },
  "/docs/fundamentals/problems": {
    "content": "# What Problems Did Bitcoin Solve?\n\nBitcoin addresses fundamental challenges in digital currency and distributed systems that had prevented previous attempts at decentralized money.\n\n## The Core Challenges\n\nBefore Bitcoin, decentralized digital currency faced seemingly insurmountable problems:\n\n- **No central authority:** Traditional systems rely on banks/servers to coordinate\n- **Network unreliability:** Nodes fail, messages get lost, partitions occur\n- **Byzantine failures:** Some participants may be malicious or send conflicting information\n- **Timing:** No synchronized clocks or central time source to order events\n\n## The Double-Spending Problem\n\n[Double-spending](/docs/glossary#double-spend) occurs when the same digital currency unit is spent more than once. Unlike physical cash, digital information can be perfectly copied; without protection, the same coin could be sent to multiple recipients simultaneously, destroying the currency's value.\n\n**Traditional solution:** A central authority (bank) maintains the ledger and verifies each transaction. Problem: requires trust in that authority.\n\n**Bitcoin's solution:** A public blockchain where all transactions are visible, ordered into blocks, and secured by [proof-of-work](/docs/glossary#proof-of-work-pow). Nodes independently verify that inputs haven't been spent. The longest chain determines valid transactions, so only the first spend succeeds.\n\n```\nAlice has 1 BTC, attempts to send it to both Bob and Charlie:\nâ†’ Network includes first transaction in block N\nâ†’ Second transaction rejected (input already spent)\nâ†’ Result: Only one transaction succeeds\n```\n\n[Video: Double Spending Problem Explained](https://www.youtube.com/watch?v=yBwDGby1yZA)\n\n## The Two Generals Problem\n\nA classic distributed systems problem: two parties must coordinate action over an unreliable channel, but can never achieve certainty because each confirmation requires its own confirmation, creating infinite regress.\n\n**Bitcoin's solution:** Accept probabilistic finality instead of perfect certainty. Proof-of-work creates objective ordering, and the longest chain rule causes the network to naturally converge. More confirmations = higher certainty (6 confirmations is generally considered irreversible).\n\n[Video: Two Generals Problem Explained](https://www.youtube.com/watch?v=nS9LH5gu65Y)\n\n## Other Problems Solved\n\n| Problem | Traditional Issue | Bitcoin's Solution |\n|---------|------------------|-------------------|\n| **Byzantine Generals** | Malicious nodes send conflicting information | Proof-of-work makes attacks expensive; assumes <50% malicious hash rate |\n| **Trust in Third Parties** | Must trust banks, payment processors, governments | Cryptographic proof replaces institutional trust; no intermediaries |\n| **Inflation** | Central banks can print unlimited money | Fixed 21M supply; predictable issuance; no authority can inflate |\n| **Cross-Border Payments** | Slow (days), expensive, requires intermediaries | Minutes to hours, lower fees, works 24/7, same currency globally |\n| **Financial Inclusion** | Billions unbanked, high barriers, geographic restrictions | Anyone with internet access can participate; no account required |\n\n## The Innovation\n\nBitcoin didn't invent new primitives; it combined existing techniques in a novel way:\n\n- **Cryptography:** Digital signatures, hash functions\n- **Distributed systems:** Peer-to-peer network\n- **Economics:** Incentive alignment\n- **Game theory:** Nash equilibrium makes honest behavior profitable\n\nPrevious digital currency attempts required central authority and couldn't prevent double-spending. Bitcoin achieves decentralized consensus through this combination, proving that trustless digital money is possible.\n",
    "filename": "problems.md"
  },
  "/docs/fundamentals/decentralization": {
    "content": "# Decentralization\n\nDecentralization is the distribution of control across many independent participants rather than a single central authority. It's the foundation of Bitcoin's censorship resistance, resilience, and trustlessness.\n\n## What Decentralization Means\n\nNo single entity controls Bitcoin. Control is distributed across thousands of nodes, multiple mining pools, diverse developers, and a global user base. This means:\n\n- **No central authority:** No government, company, or person controls Bitcoin\n- **No single point of failure:** The network survives even if parts go offline\n- **Open participation:** Anyone can run a node, mine, or contribute to development\n- **Consensus-driven changes:** Protocol changes require broad agreement\n\n## Why It Matters\n\nDecentralization enables Bitcoin's core properties:\n\n| Property | Centralized System | Decentralized (Bitcoin) |\n|----------|-------------------|------------------------|\n| **Censorship** | Authority can block transactions and freeze accounts | No one can block your transactions or freeze your funds |\n| **Resilience** | Single point of failure; can be shut down | Global network with redundant infrastructure |\n| **Trust** | Must trust the central authority | Trust the protocol and code, not people |\n| **Control** | Authority controls your money | You control your private keys |\n\n## How Bitcoin Achieves Decentralization\n\n### Nodes\n\nBitcoin has ~15,000-20,000 reachable full nodes spread across 100+ countries. Each node independently validates every transaction and stores the complete blockchain. No single node is essential; if one goes offline, the network continues.\n\n### Mining\n\nHash rate is distributed across multiple independent mining pools, with the largest typically controlling less than 20% of total hash power. Miners can switch pools freely, preventing any single pool from gaining too much control. Geographic distribution across many countries reduces regulatory risk.\n\n### Development\n\nBitcoin has multiple implementations (Bitcoin Core, Bitcoin Knots, etc.) and an open development process. Changes go through the BIP (Bitcoin Improvement Proposal) process and require community consensus. No single developer or team controls the protocol.\n\n## The Bitcoin Trilemma\n\nThe Bitcoin Trilemma describes the challenge of balancing three critical blockchain properties: **Scalability**, **Security**, and **Decentralization**. Optimizing one typically comes at the cost of another.\n\n### The Three Pillars\n\n| Property | Definition | Bitcoin's Approach |\n|----------|------------|-------------------|\n| **Scalability** | Ability to process many transactions quickly | ~7 TPS, 1 MB blocks (up to ~4 MB with SegWit), 10-min block time |\n| **Security** | Resistance to attacks and manipulation | 700+ EH/s hash rate, proof-of-work, economic incentives |\n| **Decentralization** | Distribution of control across participants | Thousands of global nodes, open participation, multiple mining pools |\n\n### The Trade-offs\n\n| Trade-off | What Happens | Example |\n|-----------|--------------|---------|\n| **Scalability â†” Security** | Larger/faster blocks require more resources â†’ fewer nodes can participate â†’ weaker security | Bitcoin Cash's 32 MB blocks resulted in fewer nodes |\n| **Scalability â†” Decentralization** | Higher hardware requirements â†’ only well-funded entities can run nodes | 100+ MB blocks would exclude most participants |\n| **Security â†” Decentralization** | Higher hash rate requires expensive ASICs â†’ mining power concentrates | ASIC mining improved security but reduced miner diversity |\n\n### Bitcoin's Solution\n\n**Layer 1: Prioritize Security + Decentralization**\n\nBitcoin intentionally limits base-layer scalability to maintain security and decentralization. The philosophy: the settlement layer should be maximally secure and decentralized.\n\n**Layer 2: Scale on Top**\n\nScalability is addressed through Layer 2 solutions that inherit base-layer security:\n\n- **Lightning Network:** Off-chain payment channels enabling millions of TPS with low fees\n- **Sidechains:** Liquid, Rootstock for specific use cases\n- **State/Payment channels:** Direct peer-to-peer transactions\n\n### Historical Examples\n\n| Change | Year | Scalability | Security | Decentralization |\n|--------|------|-------------|----------|------------------|\n| **Bitcoin Cash** (8â†’32 MB blocks) | 2017 | âœ… Higher TPS | âš ï¸ Lower hash rate | âŒ Fewer nodes |\n| **SegWit** (witness data separated) | 2017 | âœ… ~2x capacity | âœ… Maintained | âœ… Soft fork compatible |\n| **Lightning Network** | 2018+ | âœ… Millions TPS | âœ… Base layer intact | âœ… Base layer intact |\n\nBitcoin optimizes for **Security** and **Decentralization**, accepting limited base-layer **Scalability**. This is intentional:\n\n- **Base layer** = Settlement layer (high-value, infrequent transactions)\n- **Layer 2** = Payment layer (low-value, frequent transactions)\n\nThis separation of concerns provides the benefits of all three properties across the stack.\n\n## Threats to Decentralization\n\n| Area | Risk | Mitigation |\n|------|------|------------|\n| **Mining** | Pool consolidation, geographic concentration, ASIC manufacturer influence | Miners can switch pools; competitive market; global distribution |\n| **Nodes** | Growing blockchain size, higher hardware requirements | Pruning, light clients, ongoing optimization |\n| **Development** | Single implementation dominance, few core developers | Multiple implementations, open BIP process, fork ability |\n\n## Measuring Decentralization\n\n**Quantitative:** Node count, hash rate distribution across pools, geographic spread, implementation diversity.\n\n**Qualitative:** Can transactions be censored? Can the network survive targeted attacks? Can anyone participate without permission?\n",
    "filename": "decentralization.md"
  },
  "/docs/fundamentals/trust-model": {
    "content": "# Trust Model\n\nBitcoin's trust model differs fundamentally from traditional finance. Instead of trusting intermediaries (banks, payment processors, governments), Bitcoin uses cryptographic proof and economic incentives to create a **trustless** system: minimal trust, not zero trust.\n\n## Traditional vs Bitcoin Trust\n\n| Aspect | Traditional System | Bitcoin |\n|--------|-------------------|---------|\n| **Who to trust** | Banks, payment processors, governments | The protocol and cryptography |\n| **Single points of failure** | Bank/processor/government failure | None (distributed network) |\n| **Censorship** | Accounts can be frozen, transactions blocked | Resistant (no central authority) |\n| **Reversibility** | Chargebacks, reversals possible | Final after confirmation |\n| **Privacy** | Intermediaries see all transactions | Pseudonymous, no identity required |\n\n## What \"Trustless\" Really Means\n\nYou trust **mathematics and code** rather than **people and institutions**:\n\n- **Cryptographic proof:** Digital signatures prove ownership; hash functions secure the blockchain\n- **Economic incentives:** Miners profit from honest behavior; attacks are prohibitively expensive\n- **Open verification:** Anyone can run a node and independently verify every transaction\n\n## Trust Assumptions\n\n### What You Must Trust\n\n- **Protocol correctness:** Bitcoin works as designed\n- **Cryptography:** SHA-256, ECDSA remain secure\n- **Network honesty:** Majority of hash rate follows the rules\n- **Your own security:** You protect your private keys\n\n### What You Don't Need to Trust\n\nBanks, payment processors, governments, other users, miners (economically incentivized), or developers (code is open-source and auditable).\n\n## Trust Minimization Techniques\n\n**Run a full node:** Verify all transactions yourself instead of trusting others.\n\n**Use open-source software:** Code is publicly auditable with no hidden functionality.\n\n**Self-custody:** Control your own private keys; no third-party can freeze or seize your funds.\n\n## Trust vs Convenience Spectrum\n\n| Approach | Trust Level | Trade-off |\n|----------|-------------|-----------|\n| **Full node + self-custody** | Minimal | Maximum security; requires technical knowledge and resources |\n| **Light wallet** | Medium | Mobile-friendly, fast setup; trusts full nodes for verification |\n| **Custodial wallet/exchange** | High | Easy to use, password recovery; you trust the custodian completely |\n\nBitcoin's philosophy: prefer trust minimization, accept inconvenience for security, verify rather than trust.\n",
    "filename": "trust-model.md"
  },
  "/docs/fundamentals/monetary-properties": {
    "content": "# Monetary Properties\n\nBitcoin exhibits key monetary properties that make it suitable as both a medium of exchange and a store of value. These properties emerge from Bitcoin's technical design and economic model.\n\n## Core Monetary Properties\n\n| Property | Definition | Bitcoin Implementation |\n|----------|------------|----------------------|\n| **Scarcity** | Limited supply that cannot be arbitrarily increased | Fixed 21 million cap, predictable issuance via halving schedule |\n| **Divisibility** | Ability to divide into smaller units | 8 decimal places (1 BTC = 100,000,000 satoshis) |\n| **Portability** | Easy to transport and transfer | Digital, transferable globally via internet, 24/7 |\n| **Durability** | Resistance to wear or destruction | Digital (no degradation), distributed across thousands of nodes |\n| **Fungibility** | All units interchangeable | Technically fungible, though blockchain analysis can trace history |\n| **Acceptability** | Others willing to accept as payment | Growing adoption among millions of users and thousands of merchants |\n\n## Denominations\n\n| Denomination | Symbol | Value in BTC |\n|-------------|--------|--------------|\n| Satoshi | SAT | 0.00000001 |\n| Microbit | ÂµBTC | 0.000001 |\n| Millibit | mBTC | 0.001 |\n| Bitcoin | BTC | 1 |\n\nThe satoshi (named after Bitcoin's creator) is the smallest unit. \"Stacking sats\" has become common terminology for accumulating bitcoin in small amounts.\n\n## Additional Properties\n\n**Verifiability:** Digital signatures prove ownership cryptographically. Anyone can verify transactions on the public blockchain, and counterfeiting is mathematically impossible.\n\n**Programmability:** Bitcoin Script enables conditional transactions: time locks (CLTV, CSV), multisignature requirements, and basic smart contracts.\n\n**Censorship Resistance:** No central authority can block transactions. The global, permissionless network makes shutdown impractical.\n\n## Comparison to Traditional Money\n\n| Property | Fiat Currency | Gold | Bitcoin |\n|----------|--------------|------|---------|\n| **Scarcity** | Can be printed indefinitely | Limited but unknown total | Fixed 21M cap |\n| **Divisibility** | Cents (2 decimals) | Difficult to divide | 8 decimal places |\n| **Portability** | Physical cash limited; digital requires banks | Heavy, expensive to move | Digital, instant global transfer |\n| **Durability** | Paper degrades; digital depends on banks | Excellent | Distributed across thousands of nodes |\n| **Verifiability** | Counterfeiting possible | Requires expertise | Cryptographic proof |\n| **Censorship** | Accounts can be frozen | Physical seizure possible | Resistant (no central control) |\n| **Volatility** | Low (developed countries) | Low | High (currently) |\n| **Acceptance** | Universal (within jurisdiction) | Limited | Growing |\n\n## Economic Functions\n\n**Store of Value:** Scarcity and deflationary supply support long-term value preservation. High short-term volatility, but growing institutional adoption as a \"digital gold\" asset.\n\n**Medium of Exchange:** Base layer handles ~7 TPS with fees that vary by demand. Lightning Network enables fast, low-fee payments for everyday transactions.\n\n**Unit of Account:** Still developing. Prices are primarily quoted in fiat (USD), though some communities price goods in satoshis.\n",
    "filename": "monetary-properties.md"
  },
  "/docs/history/milestones": {
    "content": "# Historical Milestones\n\nBitcoin's history spans from its creation in 2009 to its future supply schedule extending into the 22nd century.\n\n## 2009\n\n### Bitcoin Launch\n\n- **Date**: January 3, 2009\n- **Block**: 0 ([Genesis Block](/docs/glossary#genesis-block))\n- **Block Reward**: 50 BTC\n- **Creator**: [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto)\n\nThe [Genesis Block](/docs/glossary#genesis-block) was mined by Satoshi Nakamoto, marking the birth of the Bitcoin network. The block contains a hidden message in its coinbase transaction: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\" - a reference to a headline from The Times newspaper, highlighting Bitcoin's purpose as an alternative to the traditional financial system.\n\n### First Transaction\n\n- **Date**: January 12, 2009\n- **Details**: Satoshi Nakamoto sent 10 BTC to [Hal Finney](/docs/history/people#hal-finney-1956-2014)\n- **Block**: 170\n\nThis transaction marked the first time Bitcoin was sent from one person to another, demonstrating the peer-to-peer nature of the network.\n\n### First Exchange Rate\n\n- **Date**: October 5, 2009\n- **Rate**: $1 = 1,309.03 BTC\n\nThe first published exchange rate valued Bitcoin at less than $0.001 per coin.\n\n---\n\n## 2010\n\n### Pizza Day\n\n- **Date**: May 22, 2010\n- **Details**: Laszlo Hanyecz paid 10,000 BTC for two pizzas\n\nThe first real-world commercial transaction using Bitcoin. At 2024 prices, those pizzas would be worth hundreds of millions of dollars. May 22 is now celebrated annually as \"Bitcoin Pizza Day.\"\n\n### Mt. Gox Launches\n\n- **Date**: July 17, 2010\n\nMt. Gox launched as the first major Bitcoin exchange, eventually handling over 70% of all Bitcoin transactions before its collapse in 2014.\n\n### Value Overflow Bug\n\n- **Date**: August 15, 2010\n\nA critical bug was discovered that allowed someone to create 184 billion BTC. The bug was quickly fixed with a soft fork, and the invalid transaction was removed from the blockchain.\n\n---\n\n## 2011\n\n### Dollar Parity\n\n- **Date**: February 9, 2011\n- **Price**: $1/BTC\n\nBitcoin reached parity with the US dollar for the first time.\n\n### First Major Rally\n\n- **Date**: June 8, 2011\n- **Price**: $31/BTC\n\nBitcoin's first major price spike, followed by a crash to $2 by November.\n\n---\n\n## 2012\n\n### First Halving\n\n- **Date**: November 28, 2012\n- **Block**: 210,000\n- **New Reward**: 25 BTC\n\nThe first halving reduced the block reward from 50 BTC to 25 BTC.\n\n### Bitcoin Foundation\n\n- **Date**: September 27, 2012\n\nThe Bitcoin Foundation was established to promote Bitcoin development and adoption.\n\n---\n\n## 2013\n\n### Billion Dollar Market Cap\n\n- **Date**: March 28, 2013\n\nBitcoin's market capitalization exceeded $1 billion for the first time.\n\n### First $1,000\n\n- **Date**: November 29, 2013\n- **Price**: $1,000/BTC\n\nBitcoin crossed $1,000 for the first time during a rally driven by Chinese exchange activity.\n\n---\n\n## 2016\n\n### Second Halving\n\n- **Date**: July 9, 2016\n- **Block**: 420,000\n- **New Reward**: 12.5 BTC\n\n---\n\n## 2017\n\n### Bitcoin Cash Fork\n\n- **Date**: August 1, 2017\n\nThe contentious hard fork created Bitcoin Cash (BCH), splitting the community over the block size debate.\n\n### First $20,000\n\n- **Date**: December 17, 2017\n- **Price**: ~$20,000/BTC\n\nBitcoin reached its then all-time high during the 2017 bull run, driven by retail FOMO and ICO speculation.\n\n---\n\n## 2020\n\n### Third Halving\n\n- **Date**: May 11, 2020\n- **Block**: 630,000\n- **New Reward**: 6.25 BTC\n\n---\n\n## 2021\n\n### El Salvador Adoption\n\n- **Date**: September 7, 2021\n\nEl Salvador became the first country to adopt Bitcoin as legal tender.\n\n### All-Time High\n\n- **Date**: November 10, 2021\n- **Price**: ~$69,000/BTC\n\n---\n\n## 2024\n\n### Fourth Halving\n\n- **Date**: April 20, 2024\n- **Block**: 840,000\n- **New Reward**: 3.125 BTC\n\n### Spot Bitcoin ETFs\n\n- **Date**: January 10, 2024\n\nThe SEC approved the first spot Bitcoin ETFs in the United States, opening Bitcoin investment to traditional finance.\n\n---\n\n## Future\n\n### All Coins Issued\n\n- **Date**: ~2140 (estimated)\n- **Block**: ~6,930,000\n- **Significance**: Last new Bitcoin will be created\n\nAfter this date, no new Bitcoin will be created through block rewards. Miners will rely entirely on transaction fees for income.\n",
    "filename": "overview.md"
  },
  "/docs/history/people": {
    "content": "# People in Bitcoin\n\nBitcoin didn't emerge from a vacuum. It was built on decades of cryptographic research and the work of visionary cypherpunks who dreamed of digital cash. This page honors both the pioneers who laid the groundwork and the contributors who brought Bitcoin to life.\n\n## Cryptographic Pioneers\n\nThese individuals created the foundational technologies that Bitcoin combines and builds upon.\n\n### David Chaum\n\n![David Chaum](/images/people/David_Chaum.jpg)\n\n**Contribution:** eCash (1982) - The godfather of cryptocurrency\n\nDavid Chaum is widely regarded as the inventor of digital cash. In 1982, he published \"Blind Signatures for Untraceable Payments,\" introducing the concept of cryptographically secure anonymous payments. His company DigiCash launched eCash in the 1990s, which allowed users to withdraw digital tokens from a bank and spend them anonymously.\n\nWhile eCash ultimately failed commercially (DigiCash went bankrupt in 1998), Chaum's work established the fundamental cryptographic techniques for digital currency, including blind signatures that preserve privacy. His vision of electronic cash that could replicate the anonymity of physical cash directly inspired the cypherpunk movement and later cryptocurrency development.\n\n---\n\n### Adam Back\n\n![Adam Back](/images/people/Adam_Back.jpg)\n\n**Contribution:** Hashcash (1997) - Proof-of-Work for spam prevention\n\nAdam Back is a British cryptographer who invented Hashcash in 1997, a proof-of-work system designed to limit email spam and denial-of-service attacks. The core idea was elegant: require senders to perform computational work before sending an email, making mass spam economically infeasible.\n\nHashcash's proof-of-work mechanism became a critical component of Bitcoin. Satoshi Nakamoto cited Hashcash in the Bitcoin whitepaper, and Bitcoin's mining algorithm is essentially Hashcash applied to transaction validation. Back is one of only two people cited in the Bitcoin whitepaper who are still alive (the other being Wei Dai).\n\nBack is currently CEO of Blockstream, a Bitcoin infrastructure company he co-founded in 2014.\n\n---\n\n### Nick Szabo\n\n![Nick Szabo](/images/people/Nick_Szabo.jpg)\n\n**Contribution:** Bit Gold (1998) - Decentralized digital currency concept\n\nNick Szabo is a computer scientist, legal scholar, and cryptographer who designed Bit Gold in 1998, often called the direct precursor to Bitcoin. Bit Gold proposed a decentralized digital currency where participants would use computational power to solve cryptographic puzzles, with solutions timestamped and published to a distributed registry.\n\nSzabo also coined the term \"smart contracts\" in 1994, describing self-executing contracts with terms written directly into codeâ€”a concept that would later become central to Ethereum and other blockchain platforms.\n\nThe similarities between Bit Gold and Bitcoin are so striking that many have speculated Szabo is Satoshi Nakamoto, which he has denied. Regardless, his intellectual contributions to the conceptual foundations of cryptocurrency are undeniable.\n\n---\n\n### Wei Dai\n\n![Wei Dai](/images/people/Wei_Dai.jpg)\n\n**Contribution:** b-money (1998) - Digital scarcity and distributed consensus\n\nWei Dai is a computer engineer and cryptographer who proposed b-money in 1998, a theoretical system for an anonymous, distributed electronic cash system. His proposal described two protocols: one where all participants maintain a database of account balances, and another using a subset of participants (similar to modern proof-of-stake).\n\nB-money introduced key concepts that would appear in Bitcoin, including:\n- The creation of money through computational work\n- Verification of work by the community\n- A distributed database of transactions\n- Transfer of money by signing messages\n\nSatoshi Nakamoto cited b-money in the Bitcoin whitepaper and personally emailed Wei Dai before Bitcoin's launch. Dai has noted that Bitcoin's implementation differs from b-money, particularly in how Nakamoto elegantly solved the double-spending problem with the blockchain.\n\nThe smallest subunit of Ether (Ethereum's currency) is called a \"wei\" in his honor.\n\n---\n\n## Bitcoin Era\n\nThese individuals were directly involved in Bitcoin's creation, early development, and evangelism.\n\n### Satoshi Nakamoto\n\n**Contribution:** Bitcoin (2008-2010) - Creator of Bitcoin\n\nSatoshi Nakamoto is the pseudonymous person or group who created Bitcoin. On October 31, 2008, Nakamoto published the Bitcoin whitepaper, \"Bitcoin: A Peer-to-Peer Electronic Cash System.\" On January 3, 2009, they mined the Genesis Block, embedding the message: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.\"\n\nSatoshi was active in developing Bitcoin and communicating on forums until December 2010, when they handed over control to Gavin Andresen and disappeared. Their last known communication was an email in April 2011.\n\nKey facts about Satoshi:\n- Mined an estimated 1 million BTC in early blocks (never moved)\n- True identity remains unknown\n- Communicated only through forums, emails, and code\n- Disappeared without cashing out or claiming credit\n\nThe mystery of Satoshi's identity has become part of Bitcoin's mythos. Various candidates have been proposed, including Nick Szabo, Hal Finney, and others, but none have been confirmed. In 2024, a UK court definitively ruled that Craig Wright is not Satoshi Nakamoto.\n\n---\n\n### Hal Finney (1956-2014)\n\n![Hal Finney](/images/people/Hal_Finney.jpg)\n\n**Contribution:** RPOW, PGP 2.0, first Bitcoin transaction recipient\n\nHal Finney was a cryptographic pioneer and one of Bitcoin's most important early contributors. Before Bitcoin, he developed RPOW (Reusable Proofs of Work) in 2004, a system that allowed proof-of-work tokens to be reused as digital cash, building on Adam Back's Hashcash. He was also the lead developer of PGP 2.0 (Pretty Good Privacy), the first widely-used implementation of public key cryptography for email encryption.\n\nFinney was the first person other than Satoshi to run the Bitcoin software, and on January 12, 2009, he received the first Bitcoin transaction: 10 BTC from Satoshi Nakamoto. He immediately began contributing to the codebase, reporting bugs and suggesting improvements. He famously tweeted \"Running bitcoin\" on January 10, 2009.\n\nInterestingly, Finney lived just a few blocks from Dorian Satoshi Nakamoto in Temple City, Californiaâ€”a coincidence that fueled speculation when Dorian was mistakenly identified as Bitcoin's creator by Newsweek in 2014.\n\nFinney was diagnosed with ALS (Lou Gehrig's disease) in 2009 and continued contributing to Bitcoin until his physical limitations made it impossible. He passed away on August 28, 2014, and was cryopreserved by the Alcor Life Extension Foundation.\n\nThe \"Finney attack\" in Bitcoin is named after himâ€”a type of double-spend attack he described where a miner pre-mines a transaction and quickly broadcasts a conflicting one.\n\n---\n\n### Len Sassaman (1980-2011)\n\n![Len Sassaman](/images/people/Len_Sassaman.jpg)\n\n**Contribution:** Cypherpunk, anonymous remailer developer\n\nLen Sassaman was a cypherpunk, privacy advocate, and cryptographer who made significant contributions to anonymity and privacy-preserving technologies. He was a core developer of Mixmaster, the most widely-used anonymous remailer protocol, and worked on various cryptographic privacy tools.\n\nSassaman was embedded in the cypherpunk community that would give rise to Bitcoin. He studied under David Chaum and worked with Hal Finney on PGP-related projects. His work on anonymous communication systems directly relates to Bitcoin's privacy goals.\n\nTragically, Sassaman died by suicide on July 3, 2011, just as Bitcoin was gaining mainstream attention. A tribute was encoded into the Bitcoin blockchain at block 138725.\n\nSome have speculated that Sassaman was involved in Bitcoin's creation due to his technical skills, cypherpunk connections, and the timing of his death relative to Satoshi's disappearance, though there is no concrete evidence.\n\n---\n\n### Gavin Andresen\n\n![Gavin Andresen](/images/people/Gavin_Andresen.jpg)\n\n**Contribution:** Lead developer after Satoshi (2010-2014)\n\nGavin Andresen is a software developer who became the lead maintainer of Bitcoin's code after Satoshi Nakamoto's departure. In late 2010, Satoshi emailed Andresen: \"I've moved on to other things,\" and handed him access to the codebase and the project's alert key.\n\nAndresen was instrumental in Bitcoin's early development and professionalization. He:\n- Founded the Bitcoin Foundation in 2012\n- Advocated for Bitcoin in mainstream and government settings\n- Grew the core development team\n- Managed the transition from a one-person project to an open-source community\n\nHis role diminished after 2014, particularly following the blocksize debate and his controversial endorsement of Craig Wright's claim to be Satoshi in 2016 (which Andresen later said he was \"bamboozled\" about).\n\n---\n\n### Andreas M. Antonopoulos\n\n![Andreas Antonopoulos](/images/people/Andreas_Antonopoulos.jpg)\n\n**Contribution:** Author, educator, Bitcoin evangelist\n\nAndreas M. Antonopoulos is a Greek-British author, speaker, and educator who has become one of the most influential voices in Bitcoin and blockchain education. He is best known for his book \"Mastering Bitcoin\" (2014), a comprehensive technical guide that has become the standard reference for Bitcoin developers.\n\nHis other works include:\n- \"The Internet of Money\" series (collected talks)\n- \"Mastering Ethereum\" (2018)\n- \"Mastering the Lightning Network\" (2021)\n\nAntonopoulos is known for his ability to explain complex technical concepts to general audiences. His YouTube channel and speaking engagements have introduced millions of people to Bitcoin. He has testified before government bodies and advocated for cryptocurrency-friendly policies.\n\nIn 2017, after it was revealed he had not held significant Bitcoin despite years of advocacy, the Bitcoin community donated over 100 BTC to him in appreciation of his educational contributions.\n",
    "filename": "people.md"
  },
  "/docs/history/halvings": {
    "content": "# Bitcoin Halving Schedule\n\nBitcoin's block reward halves every 210,000 blocks, which occurs approximately every 4 years. This creates a predictable, decreasing inflation rate and ensures the total supply will never exceed 21 million BTC.\n\n## Complete Halving Schedule\n\n| Event | Date | Block Height | Block Reward (BTC) | Total BTC Created in Period |\n|-------|------|--------------|-------------------|----------------------------|\n| **Bitcoin Launch** | 3 January 2009 | 0 (genesis block) | 50 | 10,500,000 BTC |\n| **Halving 1** | 28 November 2012 | 210,000 | 25 | 5,250,000 BTC |\n| **Halving 2** | 9 July 2016 | 420,000 | 12.5 | 2,625,000 BTC |\n| **Halving 3** | 11 May 2020 | 630,000 | 6.25 | 1,312,500 BTC |\n| **Halving 4** | 20 April 2024 | 840,000 | 3.125 | 656,250 BTC |\n| **Halving 5** | ~2028 | 1,050,000 | 1.5625 | 328,125 BTC |\n| **Halving 6** | ~2032 | 1,260,000 | 0.78125 | 164,062.5 BTC |\n| **Halving 7** | ~2036 | 1,470,000 | 0.390625 | 82,031.25 BTC |\n| **Halving 8** | ~2040 | 1,680,000 | 0.1953125 | 41,015.625 BTC |\n| **Halving 9** | ~2044 | 1,890,000 | 0.09765625 | 20,507.8125 BTC |\n| **Halving 10** | ~2048 | 2,100,000 | 0.048828125 | 10,253.90625 BTC |\n| **Halving 11** | ~2052 | 2,310,000 | 0.0244140625 | 5,126.953125 BTC |\n| **Halving 12** | ~2056 | 2,520,000 | 0.01220703125 | 2,563.4765625 BTC |\n| **Halving 13** | ~2060 | 2,730,000 | 0.006103515625 | 1,281.73828125 BTC |\n| **Halving 14** | ~2064 | 2,940,000 | 0.0030517578125 | 640.869140625 BTC |\n| **Halving 15** | ~2068 | 3,150,000 | 0.00152587890625 | 320.4345703125 BTC |\n| **Halving 16** | ~2072 | 3,360,000 | 0.000762939453125 | 160.21728515625 BTC |\n| **Halving 17** | ~2076 | 3,570,000 | 0.0003814697265625 | 80.108642578125 BTC |\n| **Halving 18** | ~2080 | 3,780,000 | 0.00019073486328125 | 40.0543212890625 BTC |\n| **Halving 19** | ~2084 | 3,990,000 | 0.000095367431640625 | 20.02716064453125 BTC |\n| **Halving 20** | ~2088 | 4,200,000 | 0.0000476837158203125 | 10.013580322265625 BTC |\n| **Halving 21** | ~2092 | 4,410,000 | 0.00002384185791015625 | 5.0067901611328125 BTC |\n| **Halving 22** | ~2096 | 4,620,000 | 0.000011920928955078125 | 2.50339508056640625 BTC |\n| **Halving 23** | ~2100 | 4,830,000 | 0.0000059604644775390625 | 1.251697540283203125 BTC |\n| **Halving 24** | ~2104 | 5,040,000 | 0.00000298023223876953125 | 0.6258487701416015625 BTC |\n| **Halving 25** | ~2108 | 5,250,000 | 0.000001490116119384765625 | 0.31292438507080078125 BTC |\n| **Halving 26** | ~2112 | 5,460,000 | 0.0000007450580596923828125 | 0.156462192535400390625 BTC |\n| **Halving 27** | ~2116 | 5,670,000 | 0.00000037252902984619140625 | 0.0782310962677001953125 BTC |\n| **Halving 28** | ~2120 | 5,880,000 | 0.000000186264514923095703125 | 0.03911554813385009765625 BTC |\n| **Halving 29** | ~2124 | 6,090,000 | 0.0000000931322574615478515625 | 0.019557774066925048828125 BTC |\n| **Halving 30** | ~2128 | 6,300,000 | 0.00000004656612873077392578125 | 0.0097788870334625244140625 BTC |\n| **Halving 31** | ~2132 | 6,510,000 | 0.000000023283064365386962890625 | 0.00488944351673126220703125 BTC |\n| **Halving 32** | ~2136 | 6,720,000 | 0.0000000116415321826934814453125 | 0.002444721758365631103515625 BTC |\n| **Halving 33+** | After 2140 | After 6,930,000 | 0 BTC | 0 BTC |\n\n**Note**: After halving 33, the subsidy becomes effectively 0 (less than 1 satoshi per block). The last Bitcoin will be mined around December 22, 2137.\n\n## Key Facts\n\n- **Total Halvings**: 32 halving events\n- **Halving Interval**: Every 210,000 blocks (~4 years)\n- **Initial Reward**: 50 BTC per block\n- **Current Reward**: 3.125 BTC per block (after 4th halving in 2024)\n- **Final Halving**: Block 6,720,000 (halving #32)\n- **All Coins Issued**: December 22, 2137 (estimated)\n\nFor more details on the mathematical formula behind halvings, see [Subsidy Equation](/docs/bitcoin/subsidy).\n",
    "filename": "halvings.md"
  },
  "/docs/history/forks": {
    "content": "# Bitcoin Forks History\n\nBitcoin has undergone several protocol upgrades through both soft forks and hard forks. This document provides a comprehensive table of all major forks in Bitcoin's history.\n\n## Understanding Forks\n\nThe fundamental difference between soft forks and hard forks comes down to one thing: **are the consensus rules being tightened or loosened?**\n\n| | Soft Fork | Hard Fork |\n|---|-----------|-----------|\n| **Consensus rules** | Tightened (more restrictive) | Loosened (more permissive) |\n| **Old nodes** | Accept new blocks (still valid under old rules) | Reject new blocks (invalid under old rules) |\n| **Backward compatible** | Yes | No |\n| **Chain split risk** | Possible if contentious | Guaranteed without full upgrade |\n\n### Soft Fork\nA **soft fork** **tightens** the consensus rules. Blocks valid under new rules are always valid under old rules, so old nodes continue to accept them.\n\n**Example**: SegWit made certain transaction formats invalid that were previously valid. Old nodes still accept SegWit blocks because they don't violate the old (looser) rules.\n\n**Can soft forks cause chain splits?** Yes, in certain scenarios:\n- **UASF (User Activated Soft Fork)**: If nodes enforce rules that miners don't follow, the chain can split. The 2017 BIP 148 UASF threatened a split if miners didn't signal for SegWit.\n- **Miner non-compliance**: If significant mining power produces blocks violating new soft fork rules, upgraded nodes reject those blocks, potentially causing a split.\n- **Contentious activation**: When there's community disagreement about whether to activate.\n\n### Hard Fork\nA **hard fork** **loosens** the consensus rules (or changes them incompatibly). Blocks valid under new rules may be invalid under old rules, so old nodes reject them.\n\n**Example**: Bitcoin Cash increased the block size limit from 1 MB to 8 MB. Old nodes reject these larger blocks as invalid, guaranteeing a chain split.\n\n## Complete Fork History Table\n\n| Date | Block Height | Type | Name | BIP(s) | Description | Status |\n|------|--------------|------|------|--------|-------------|--------|\n| **2009-01-03** | 0 | - | Genesis Block | - | Bitcoin network launch | âœ… Active |\n| **2010-08-15** | 74,638 | Hard Fork | Value Overflow Incident | - | Fixed integer overflow bug | âœ… Resolved |\n| **2012-04-01** | 173,805 | Soft Fork | P2SH (Pay-to-Script-Hash) | [BIP 16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki) | Enabled complex scripts via script hashes | âœ… Active |\n| **2013-03-11** | 225,430 | Accidental | BerkeleyDB Fork | - | Database lock limit caused chain split | âœ… Resolved |\n| **2013-03-12** | 225,430 | Soft Fork | Strict DER Encoding | [BIP 66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki) | Required strict DER signature encoding | âœ… Active |\n| **2013-05-15** | 250,000 | Soft Fork | Strict Multisig | [BIP 65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki) | Required NULLDUMMY in multisig | âœ… Active |\n| **2015-12-08** | 388,381 | Soft Fork | CLTV (CheckLockTimeVerify) | [BIP 65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki) | Enabled absolute time locks | âœ… Active |\n| **2016-07-04** | 419,328 | Soft Fork | CSV (CheckSequenceVerify) | [BIP 112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki), [BIP 68](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki), [BIP 113](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki) | Enabled relative time locks | âœ… Active |\n| **2017-08-01** | 478,558 | Hard Fork | Bitcoin Cash | - | Increased block size to 8 MB | ðŸ”€ Split Chain |\n| **2017-08-24** | 481,824 | Soft Fork | Segregated Witness (SegWit) | [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), [BIP 143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki), [BIP 144](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki), [BIP 148](https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki) | Separated witness data, fixed malleability | âœ… Active |\n| **2018-11-15** | 556,766 | Hard Fork | Bitcoin SV | - | Bitcoin Cash fork, increased to 128 MB blocks | ðŸ”€ Split Chain |\n| **2021-11-14** | 709,632 | Soft Fork | Taproot | [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki), [BIP 342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki), [BIP 340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) | Schnorr signatures, improved privacy | âœ… Active |\n\n## Activation Mechanisms\n\n### Soft Fork Activation Methods\n\n1. **BIP 9 (Version Bits)**\n   - Used for: CSV, SegWit, Taproot\n   - Requires: 95% of blocks signal support\n   - Grace period: 2016 blocks (~2 weeks)\n   - Example: Taproot activated via BIP 9\n\n2. **IsSuperMajority (Legacy)**\n   - Used for: P2SH, CLTV\n   - Requires: 75% of last 1000 blocks\n   - Example: P2SH activated via IsSuperMajority\n\n3. **User-Activated Soft Fork (UASF)**\n   - Used for: SegWit (BIP 148)\n   - Community-driven activation\n   - Example: SegWit UASF movement\n\n### Hard Fork Activation\n\nHard forks typically require:\n- All nodes to upgrade simultaneously\n- Or acceptance of chain split\n- Coordination among miners and nodes\n\n## Fork Statistics\n\n### Soft Fork Adoption\n\n| Fork | Activation Date | Current Usage | Adoption Rate |\n|------|----------------|--------------|---------------|\n| P2SH | 2012-04-01 | Multisig, complex scripts | ~15-20% of transactions |\n| CLTV | 2015-12-08 | Time locks, escrow | ~1-2% of transactions |\n| CSV | 2016-07-04 | Lightning Network | Critical for LN |\n| SegWit | 2017-08-24 | Most transactions | ~80% of transactions |\n| Taproot | 2021-11-14 | Modern wallets | ~5-10% of transactions |\n\n### Hard Fork Results\n\n| Fork | Original Chain | New Chain | Current Status |\n|------|----------------|-----------|----------------|\n| Bitcoin Cash | Bitcoin (BTC) | Bitcoin Cash (BCH) | Both chains active |\n| Bitcoin SV | Bitcoin Cash (BCH) | Bitcoin SV (BSV) | Both chains active |\n\n## Timeline Visualization\n\n```\n2009 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Genesis Block\n     â”‚\n2010 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Value Overflow Fix (Hard Fork)\n     â”‚\n2012 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2SH (Soft Fork)\n     â”‚\n2013 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ BerkeleyDB Fork (Accidental)\n     â”‚ Strict DER, Strict Multisig (Soft Forks)\n     â”‚\n2015 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ CLTV (Soft Fork)\n     â”‚\n2016 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ CSV (Soft Fork)\n     â”‚\n2017 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Bitcoin Cash (Hard Fork) â”€â”€â–º BCH\n     â”‚ SegWit (Soft Fork)\n     â”‚\n2018 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Bitcoin SV (Hard Fork) â”€â”€â–º BSV\n     â”‚\n2021 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Taproot (Soft Fork)\n     â”‚\n2024+ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Future upgrades...\n```\n\n## Key Takeaways\n\n1. **Soft Forks are Preferred**: All major protocol upgrades since 2012 have been soft forks\n2. **Backward Compatibility**: Soft forks maintain backward compatibility with old nodes\n3. **Chain Splits**: Hard forks always create splits; soft forks can also split the chain if contentious (e.g., via UASF)\n4. **Activation Methods**: Different activation mechanisms (BIP 9, IsSuperMajority, UASF) with varying risks\n5. **Gradual Adoption**: New features take time to reach full adoption\n\n## Potential Future Soft Forks\n\n- **Covenants**: Restrict how coins can be spent\n- **OP_CTV (CheckTemplateVerify)**: Transaction templates\n- **SIGHASH_ANYPREVOUT**: More flexible signature types\n- **Ephemeral Anchors**: Lightning Network improvements\n\nFor more details on script types and their evolution, see [Script System](/docs/bitcoin/script).\n\n## References\n\n- [Bitcoin BIPs Repository](https://github.com/bitcoin/bips)\n- [Bitcoin Core Release Notes](https://bitcoincore.org/en/releases/)\n- [Bitcoin Wiki - Forks](https://en.bitcoin.it/wiki/Forks)\n- [UASF (User-Activated Soft Fork) History](https://en.bitcoin.it/wiki/UASF)\n",
    "filename": "forks.md"
  },
  "/docs/history/supply": {
    "content": "# Bitcoin Supply Schedule\n\nThe total Bitcoin supply is mathematically fixed at 21 million BTC. The supply schedule follows a predictable formula that ensures no more than 21 million Bitcoin will ever be created.\n\n## Supply Formula\n\nThe total Bitcoin supply follows a geometric series:\n\n```\nTotal Supply = 210,000 Ã— 50 Ã— (1 + 1/2 + 1/4 + 1/8 + ...)\n             = 210,000 Ã— 50 Ã— 2\n             = 21,000,000 BTC\n```\n\nThis geometric series ensures that:\n- Each halving period creates 210,000 blocks\n- Each period creates half the Bitcoin of the previous period\n- The series converges to exactly 21 million BTC\n- After 64 halvings, the subsidy becomes 0\n\n## Key Facts\n\n- **Total Supply**: Exactly 21,000,000 BTC\n- **Halving Interval**: Every 210,000 blocks (~4 years)\n- **Initial Block Reward**: 50 BTC\n- **Current Block Reward**: 3.125 BTC (after 4th halving in 2024)\n- **Total Halvings**: 32 halving events\n- **All Coins Issued**: December 22, 2137 (estimated)\n- **Block Height at Completion**: ~6,930,000\n\n## Supply Schedule Breakdown\n\n| Period | Blocks | Block Reward | Total BTC Created |\n|--------|--------|--------------|-------------------|\n| 0 | 0-209,999 | 50 BTC | 10,500,000 BTC |\n| 1 | 210,000-419,999 | 25 BTC | 5,250,000 BTC |\n| 2 | 420,000-629,999 | 12.5 BTC | 2,625,000 BTC |\n| 3 | 630,000-839,999 | 6.25 BTC | 1,312,500 BTC |\n| 4 | 840,000-1,049,999 | 3.125 BTC | 656,250 BTC |\n| 5 | 1,050,000-1,259,999 | 1.5625 BTC | 328,125 BTC |\n| ... | ... | ... | ... |\n| 32 | 6,720,000-6,929,999 | ~0.00000001 BTC | ~0.01 BTC |\n| 33+ | After 6,930,000 | 0 BTC | 0 BTC |\n\n**Total**: 21,000,000 BTC\n\n## After All Coins Are Issued\n\nOnce all 21 million Bitcoin have been created (around December 22, 2137):\n\n- **No New Bitcoin**: Block rewards will be 0\n- **Miner Income**: Miners will rely entirely on transaction fees\n- **Network Security**: Economic incentives remain through fee collection\n- **Inflation**: Bitcoin becomes deflationary (supply decreases if coins are lost)\n\n## Related Topics\n\n- [Halving Schedule](/docs/history/halvings) - Complete halving schedule with dates\n- [Subsidy Equation](/docs/bitcoin/subsidy) - Mathematical formula and implementation\n",
    "filename": "supply.md"
  },
  "/docs/history/bips": {
    "content": "# Bitcoin Improvement Proposals (BIPs)\n\n[Bitcoin Improvement Proposals](/docs/glossary#bip-bitcoin-improvement-proposal) (BIPs) are the formal mechanism for proposing changes to Bitcoin. They document design decisions, protocol upgrades, and best practices for the Bitcoin ecosystem. BIPs are modeled after Python Enhancement Proposals (PEPs) and were introduced by Amir Taaki in 2011.\n\n## BIP Types\n\n| Type | Description | Examples |\n|------|-------------|----------|\n| **Standards Track** | Changes to the network protocol, transaction validity, or interoperability | BIP 141 (SegWit), BIP 341 (Taproot) |\n| **Informational** | Design issues, guidelines, or general information | BIP 2 (BIP Process) |\n| **Process** | Changes to the BIP process itself | BIP 1, BIP 2 |\n\n---\n\n## Consensus & Protocol BIPs\n\nThese BIPs define changes to the Bitcoin consensus rules and protocol.\n\n### BIP 9 - Version Bits with Timeout and Delay\n\n- **Status**: Final\n- **Activated**: 2016\n- **Description**: Mechanism for deploying soft forks using version bits in block headers. Allows multiple soft forks to be deployed in parallel with defined activation thresholds and timeouts.\n- **Key Concepts**: Miners signal readiness by setting bits in block version field. Activation requires 95% of blocks in a retarget period.\n\n### BIP 16 - Pay to Script Hash (P2SH)\n\n- **Status**: Final\n- **Activated**: April 1, 2012 (Block 173,805)\n- **Description**: Allows transactions to be sent to a script hash instead of a public key hash. The actual script is revealed only when spending.\n- **Impact**: Enabled multisig wallets, complex scripts, and reduced transaction sizes for senders.\n\n### BIP 34 - Block v2, Height in Coinbase\n\n- **Status**: Final\n- **Activated**: March 2013 (Block 227,931)\n- **Description**: Requires block height to be included in coinbase transaction. Ensures all coinbase transactions are unique.\n- **Impact**: Fixed duplicate transaction issue, enabled merged mining.\n\n### BIP 65 - OP_CHECKLOCKTIMEVERIFY (CLTV)\n\n- **Status**: Final\n- **Activated**: December 2015 (Block 388,381)\n- **Description**: Adds an opcode that allows a transaction output to be made unspendable until a specific block height or time.\n- **Use Cases**: Payment channels, escrow, time-locked contracts, inheritance planning.\n\n### BIP 66 - Strict DER Signatures\n\n- **Status**: Final\n- **Activated**: July 2015 (Block 363,724)\n- **Description**: Requires all ECDSA signatures to use strict DER encoding. Fixed signature malleability issues.\n- **Impact**: Security improvement, prerequisite for SegWit.\n\n### BIP 68 - Relative Lock-Time Using Consensus-Enforced Sequence Numbers\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Enables relative time locks based on the age of the referenced output. Uses the sequence field of transaction inputs.\n- **Use Cases**: Lightning Network channels, bidirectional payment channels, revocable transactions.\n\n### BIP 112 - OP_CHECKSEQUENCEVERIFY (CSV)\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Companion to BIP 68. Adds an opcode to verify relative lock-times in scripts.\n- **Use Cases**: Lightning Network, revocable sequences, hash time-locked contracts.\n\n### BIP 113 - Median Time-Past as Endpoint for Lock-Time Calculations\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Uses median time of past 11 blocks instead of block timestamp for time-based lock calculations. Prevents miners from manipulating timestamps.\n\n### BIP 141 - Segregated Witness (SegWit)\n\n- **Status**: Final\n- **Activated**: August 24, 2017 (Block 481,824)\n- **Description**: Major protocol upgrade that separates signature (witness) data from transaction data. Fixes transaction malleability, increases effective block capacity.\n- **Impact**: ~4MB effective block size, enabled Lightning Network, reduced fees for SegWit transactions.\n\n### BIP 143 - Transaction Signature Verification for Version 0 Witness Program\n\n- **Status**: Final\n- **Activated**: August 2017 (with SegWit)\n- **Description**: Defines how signatures are computed for SegWit transactions. Fixes quadratic hashing problem.\n- **Impact**: Improved performance for large transactions, security improvements.\n\n### BIP 144 - Segregated Witness (Peer Services)\n\n- **Status**: Final\n- **Activated**: August 2017 (with SegWit)\n- **Description**: Defines how SegWit transactions are transmitted over the network. New message types for witness data.\n\n### BIP 340 - Schnorr Signatures for secp256k1\n\n- **Status**: Final\n- **Activated**: November 14, 2021 (Block 709,632, with Taproot)\n- **Description**: Introduces Schnorr signatures to Bitcoin. More efficient and enables signature aggregation.\n- **Benefits**: Smaller signatures, batch verification, key aggregation (MuSig), improved privacy.\n\n### BIP 341 - Taproot: SegWit Version 1 Spending Rules\n\n- **Status**: Final\n- **Activated**: November 14, 2021 (Block 709,632)\n- **Description**: Major upgrade introducing Taproot outputs. Combines Schnorr signatures with MAST (Merkle Abstract Syntax Trees).\n- **Impact**: Better privacy (all transactions look similar), lower fees, more flexible smart contracts.\n\n### BIP 342 - Validation of Taproot Scripts\n\n- **Status**: Final\n- **Activated**: November 2021 (with Taproot)\n- **Description**: Defines script validation rules for Taproot. Introduces Tapscript with new opcodes and resource limits.\n\n---\n\n## Wallet & Key Management BIPs\n\nThese BIPs define standards for wallets, key derivation, and seed phrases.\n\n### BIP 32 - Hierarchical Deterministic Wallets\n\n- **Status**: Final\n- **Year**: 2012\n- **Description**: Defines HD wallets that generate a tree of keys from a single seed. Allows unlimited key generation and easy backup.\n- **Impact**: Foundation for modern wallet architecture. One seed phrase backs up all keys.\n\n### BIP 39 - Mnemonic Code for Generating Deterministic Keys\n\n- **Status**: Proposed (widely adopted)\n- **Year**: 2013\n- **Description**: Defines the 12/24-word seed phrases used to backup wallets. Maps entropy to human-readable words.\n- **Word Lists**: 2048 words in multiple languages. English word list is most common.\n- **Security**: 12 words = 128 bits entropy, 24 words = 256 bits entropy.\n\n### BIP 44 - Multi-Account Hierarchy for Deterministic Wallets\n\n- **Status**: Proposed (widely adopted)\n- **Year**: 2014\n- **Description**: Defines the derivation path structure for HD wallets: `m/purpose'/coin_type'/account'/change/address_index`\n- **Path Example**: `m/44'/0'/0'/0/0` for first Bitcoin address.\n\n### BIP 49 - Derivation Scheme for P2WPKH-nested-in-P2SH Addresses\n\n- **Status**: Final\n- **Year**: 2016\n- **Description**: Defines derivation paths for wrapped SegWit addresses (starting with `3`).\n- **Path**: `m/49'/0'/account'/change/address_index`\n\n### BIP 84 - Derivation Scheme for P2WPKH Based Accounts\n\n- **Status**: Proposed\n- **Year**: 2017\n- **Description**: Defines derivation paths for native SegWit addresses (starting with `bc1q`).\n- **Path**: `m/84'/0'/account'/change/address_index`\n\n### BIP 86 - Key Derivation for Single Key P2TR Outputs\n\n- **Status**: Proposed\n- **Year**: 2021\n- **Description**: Defines derivation paths for Taproot addresses (starting with `bc1p`).\n- **Path**: `m/86'/0'/account'/change/address_index`\n\n### BIP 174 - Partially Signed Bitcoin Transactions (PSBT)\n\n- **Status**: Proposed\n- **Year**: 2017\n- **Description**: Standard format for unsigned/partially signed transactions. Enables signing across multiple devices/wallets.\n- **Use Cases**: Hardware wallets, multisig coordination, air-gapped signing.\n\n### BIP 370 - PSBT Version 2\n\n- **Status**: Proposed\n- **Year**: 2021\n- **Description**: Improved PSBT format with better support for adding inputs/outputs during signing process.\n\n---\n\n## Address Format BIPs\n\nThese BIPs define Bitcoin address formats and encoding.\n\n### BIP 13 - Address Format for pay-to-script-hash\n\n- **Status**: Final\n- **Year**: 2012\n- **Description**: Defines P2SH address format. Addresses start with `3` on mainnet.\n\n### BIP 173 - Base32 Address Format for Native v0-16 Witness Outputs (Bech32)\n\n- **Status**: Final\n- **Year**: 2017\n- **Description**: Defines Bech32 encoding for SegWit addresses. Addresses start with `bc1q` on mainnet.\n- **Benefits**: Error detection, all lowercase, more efficient QR codes.\n\n### BIP 350 - Bech32m Format for v1+ Witness Addresses\n\n- **Status**: Final\n- **Year**: 2020\n- **Description**: Modified Bech32 encoding for Taproot and future witness versions. Fixes a mutation weakness in Bech32.\n- **Format**: Taproot addresses start with `bc1p`.\n\n---\n\n## Transaction & Script BIPs\n\n### BIP 125 - Opt-in Full Replace-by-Fee Signaling\n\n- **Status**: Proposed\n- **Year**: 2015\n- **Description**: Allows transactions to signal replaceability. Enables fee bumping by replacing unconfirmed transactions.\n- **Signaling**: Set sequence number < 0xFFFFFFFE on any input.\n\n### BIP 152 - Compact Block Relay\n\n- **Status**: Final\n- **Year**: 2016\n- **Description**: Reduces bandwidth for block propagation. Nodes share short transaction IDs instead of full transactions.\n- **Impact**: Faster block propagation, reduced bandwidth by ~90%.\n\n---\n\n## Lightning Network Related BIPs\n\n### BIP 118 - SIGHASH_ANYPREVOUT for Tapscript\n\n- **Status**: Draft\n- **Description**: New sighash type that allows signatures to apply to any input with the same script. Enables Eltoo payment channels.\n- **Impact**: Would simplify Lightning channel updates, enable channel factories.\n\n---\n\n## Informational BIPs\n\n### BIP 1 - BIP Purpose and Guidelines\n\n- **Status**: Active\n- **Year**: 2011\n- **Description**: Defines what BIPs are and the process for creating them.\n\n### BIP 2 - BIP Process, Revised\n\n- **Status**: Active\n- **Year**: 2016\n- **Description**: Updated BIP process with clearer status definitions and workflow.\n\n---\n\n## Complete BIP Categories Reference\n\n| Category | Key BIPs | Purpose |\n|----------|----------|---------|\n| **Consensus** | 9, 16, 34, 65, 66, 68, 112, 113, 141, 340, 341, 342 | Protocol rules |\n| **Wallet** | 32, 39, 44, 49, 84, 86, 174, 370 | Key management |\n| **Address** | 13, 173, 350 | Address formats |\n| **Transaction** | 125, 152 | Transaction handling |\n| **Future** | 118, 119 | Proposed upgrades |\n\n---\n\n## Resources\n\n- **[Official BIP Repository](https://github.com/bitcoin/bips)** - All BIPs on GitHub\n- **[BIP 2 - BIP Process](https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki)** - How to create a BIP\n- **[Bitcoin Wiki - BIPs](https://en.bitcoin.it/wiki/Bitcoin_Improvement_Proposals)** - Community documentation\n\n---\n\n## Related Topics\n\n- [Forks](/docs/history/forks) - How BIPs become protocol changes\n- [Script System](/docs/bitcoin/script) - Script-related BIPs in action\n",
    "filename": "bips.md"
  },
  "/docs/bitcoin/cryptography": {
    "content": "# Cryptography in Bitcoin\n\nBitcoin relies on several cryptographic primitives to secure transactions, prove ownership, and maintain the integrity of the blockchain. Understanding these cryptographic foundations is essential for grasping how Bitcoin achieves trustless security.\n\n## Overview\n\nBitcoin uses cryptography for three main purposes:\n\n1. **Ownership & Authentication** - Proving you own bitcoin without revealing your private key\n2. **Integrity** - Ensuring data hasn't been tampered with\n3. **Proof-of-Work** - Securing the blockchain through computational work\n\n## Hash Functions\n\n### What is a Hash Function?\n\nA **cryptographic hash function** takes any input data and produces a fixed-size output (the \"hash\" or \"digest\"). Hash functions are one-way: easy to compute, but practically impossible to reverse.\n\n**Properties of Cryptographic Hash Functions:**\n\n| Property | Description |\n|----------|-------------|\n| **Deterministic** | Same input always produces same output |\n| **Fast** | Quick to compute for any input |\n| **One-way** | Cannot derive input from output |\n| **Collision-resistant** | Infeasible to find two inputs with same output |\n| **Avalanche effect** | Small input change = completely different output |\n\n### SHA-256\n\nBitcoin's primary hash function is **SHA-256** (Secure Hash Algorithm, 256-bit).\n\n**Characteristics:**\n- Output: 256 bits (32 bytes, 64 hex characters)\n- Designed by NSA, published in 2001\n- No known practical attacks\n\n**Example:**\n```\nInput:  \"Hello\"\nSHA-256: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\n\nInput:  \"Hello!\"\nSHA-256: 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7\n```\n\nNotice how adding a single character completely changes the output (avalanche effect).\n\n### Double SHA-256 (SHA-256d)\n\nBitcoin often uses **double SHA-256**: `SHA256(SHA256(data))`\n\n**Used for:**\n- Block hashes\n- Transaction IDs (TXIDs)\n- Merkle tree nodes\n- Proof-of-work\n\n**Why double hashing?**\n- Defense against length-extension attacks\n- Additional security margin\n- Historical design choice by Satoshi\n\n### Code: SHA-256 and Double SHA-256\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\nfn sha256(data: &[u8]) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hasher.finalize().into()\n}\n\nfn double_sha256(data: &[u8]) -> [u8; 32] {\n    sha256(&sha256(data))\n}\n\nfn main() {\n    let message = b\"Hello\";\n    println!(\"SHA-256: {}\", hex::encode(sha256(message)));\n    println!(\"Double SHA-256: {}\", hex::encode(double_sha256(message)));\n}\n```\n\n```python\nimport hashlib\n\ndef sha256(data: bytes) -> bytes:\n    return hashlib.sha256(data).digest()\n\ndef double_sha256(data: bytes) -> bytes:\n    \"\"\"Bitcoin's double SHA-256\"\"\"\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\n# Example\nmessage = b\"Hello\"\nprint(f\"SHA-256: {sha256(message).hex()}\")\nprint(f\"Double SHA-256: {double_sha256(message).hex()}\")\n```\n\n```cpp\n#include <openssl/sha.h>\n#include <vector>\n#include <iomanip>\n#include <sstream>\n\nstd::vector<uint8_t> sha256(const std::vector<uint8_t>& data) {\n    std::vector<uint8_t> hash(SHA256_DIGEST_LENGTH);\n    SHA256(data.data(), data.size(), hash.data());\n    return hash;\n}\n\nstd::vector<uint8_t> double_sha256(const std::vector<uint8_t>& data) {\n    return sha256(sha256(data));\n}\n\nstd::string to_hex(const std::vector<uint8_t>& data) {\n    std::stringstream ss;\n    for (auto byte : data) {\n        ss << std::hex << std::setfill('0') << std::setw(2) << (int)byte;\n    }\n    return ss.str();\n}\n\nint main() {\n    std::vector<uint8_t> message = {'H', 'e', 'l', 'l', 'o'};\n    std::cout << \"SHA-256: \" << to_hex(sha256(message)) << std::endl;\n    std::cout << \"Double SHA-256: \" << to_hex(double_sha256(message)) << std::endl;\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction sha256(data) {\n  return crypto.createHash('sha256').update(data).digest();\n}\n\nfunction doubleSha256(data) {\n  return sha256(sha256(data));\n}\n\n// Example\nconst message = Buffer.from('Hello');\nconsole.log(`SHA-256: ${sha256(message).toString('hex')}`);\nconsole.log(`Double SHA-256: ${doubleSha256(message).toString('hex')}`);\n```\n:::\n\n### RIPEMD-160 and Hash160\n\n**RIPEMD-160** produces a 160-bit (20-byte) hash, used in combination with SHA-256.\n\n**Hash160 = RIPEMD160(SHA256(data))**\n\n**Used for:**\n- Bitcoin addresses (P2PKH, P2SH)\n- Shorter than SHA-256, reducing address length\n- Still cryptographically secure\n\n### Code: Hash160\n\n:::code-group\n```rust\nuse ripemd::Ripemd160;\nuse sha2::{Sha256, Digest};\n\nfn hash160(data: &[u8]) -> [u8; 20] {\n    let sha256_hash = Sha256::digest(data);\n    let ripemd_hash = Ripemd160::digest(&sha256_hash);\n    ripemd_hash.into()\n}\n\nfn main() {\n    let public_key = hex::decode(\"02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737\").unwrap();\n    println!(\"Hash160: {}\", hex::encode(hash160(&public_key)));\n}\n```\n\n```python\nimport hashlib\n\ndef hash160(data: bytes) -> bytes:\n    \"\"\"RIPEMD160(SHA256(data)) - used for Bitcoin addresses\"\"\"\n    sha256_hash = hashlib.sha256(data).digest()\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    return ripemd160.digest()\n\n# Hash a public key\npublic_key = bytes.fromhex(\"02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737\")\nprint(f\"Hash160: {hash160(public_key).hex()}\")\n```\n\n```cpp\n#include <openssl/sha.h>\n#include <openssl/ripemd.h>\n\nstd::vector<uint8_t> hash160(const std::vector<uint8_t>& data) {\n    // First SHA-256\n    std::vector<uint8_t> sha256_hash(SHA256_DIGEST_LENGTH);\n    SHA256(data.data(), data.size(), sha256_hash.data());\n    \n    // Then RIPEMD-160\n    std::vector<uint8_t> hash(RIPEMD160_DIGEST_LENGTH);\n    RIPEMD160(sha256_hash.data(), sha256_hash.size(), hash.data());\n    return hash;\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction hash160(data) {\n  const sha256Hash = crypto.createHash('sha256').update(data).digest();\n  return crypto.createHash('ripemd160').update(sha256Hash).digest();\n}\n\n// Hash a public key\nconst publicKey = Buffer.from('02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737', 'hex');\nconsole.log(`Hash160: ${hash160(publicKey).toString('hex')}`);\n```\n:::\n\n## Elliptic Curve Cryptography\n\n### What is ECC?\n\n**Elliptic Curve Cryptography (ECC)** is a public-key cryptography system based on the algebraic structure of elliptic curves over finite fields.\n\n**Why Bitcoin uses ECC:**\n- Smaller key sizes than RSA (256-bit vs 3072-bit for equivalent security)\n- Faster computation\n- Lower bandwidth and storage requirements\n\n### The secp256k1 Curve\n\nBitcoin uses the **secp256k1** elliptic curve, defined by the equation:\n\n```\nyÂ² = xÂ³ + 7 (mod p)\n```\n\n**Parameters:**\n- **p** (prime): 2Â²âµâ¶ - 2Â³Â² - 977\n- **Order (n)**: Number of points on the curve\n- **Generator point (G)**: Fixed starting point for key generation\n\n**Why secp256k1?**\n- Chosen by Satoshi (not the most common curve at the time)\n- Efficiently computable\n- No known weaknesses\n- Parameters are \"nothing up my sleeve\" numbers (verifiably random)\n\n### Key Generation\n\n**Private Key:**\n- Random 256-bit number (1 to n-1)\n- Must be kept secret\n- Generated from cryptographically secure random source\n\n**Public Key:**\n- Derived from private key: `Public Key = Private Key Ã— G`\n- Point multiplication on the elliptic curve\n- Cannot reverse to find private key (discrete logarithm problem)\n- Can be shared publicly\n\n**Key Relationship:**\n```\nRandom Number â†’ Private Key â†’ Public Key â†’ Bitcoin Address\n     (256 bits)    (256 bits)   (512 bits)   (160 bits)\n```\n\n### Code: Key Generation\n\n:::code-group\n```rust\nuse secp256k1::{Secp256k1, SecretKey, PublicKey};\nuse secp256k1::rand::rngs::OsRng;\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate random private key\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    // Serialize keys\n    let private_key_bytes = secret_key.secret_bytes();\n    let public_key_compressed = public_key.serialize();                  // 33 bytes\n    let public_key_uncompressed = public_key.serialize_uncompressed();   // 65 bytes\n    \n    println!(\"Private Key: {}\", hex::encode(private_key_bytes));\n    println!(\"Public Key (compressed): {}\", hex::encode(public_key_compressed));\n    println!(\"Public Key (uncompressed): {}\", hex::encode(public_key_uncompressed));\n}\n```\n\n```python\nimport secrets\nfrom secp256k1 import PrivateKey\n\n# Generate random private key (32 bytes)\nprivate_key_bytes = secrets.token_bytes(32)\nprivate_key = PrivateKey(private_key_bytes)\n\n# Derive public key\npublic_key_compressed = private_key.pubkey.serialize()           # 33 bytes\npublic_key_uncompressed = private_key.pubkey.serialize(False)    # 65 bytes\n\nprint(f\"Private Key: {private_key_bytes.hex()}\")\nprint(f\"Public Key (compressed): {public_key_compressed.hex()}\")\nprint(f\"Public Key (uncompressed): {public_key_uncompressed.hex()}\")\n```\n\n```cpp\n#include <secp256k1.h>\n#include <random>\n\nint main() {\n    // Create context\n    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n    \n    // Generate random private key (use proper CSPRNG in production)\n    unsigned char private_key[32];\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(0, 255);\n    for (int i = 0; i < 32; i++) {\n        private_key[i] = dis(gen);\n    }\n    \n    // Verify private key is valid\n    while (!secp256k1_ec_seckey_verify(ctx, private_key)) {\n        for (int i = 0; i < 32; i++) private_key[i] = dis(gen);\n    }\n    \n    // Derive public key\n    secp256k1_pubkey pubkey;\n    secp256k1_ec_pubkey_create(ctx, &pubkey, private_key);\n    \n    // Serialize public key (compressed)\n    unsigned char public_key_compressed[33];\n    size_t len = 33;\n    secp256k1_ec_pubkey_serialize(ctx, public_key_compressed, &len, \n                                   &pubkey, SECP256K1_EC_COMPRESSED);\n    \n    secp256k1_context_destroy(ctx);\n}\n```\n\n```javascript\nconst { randomBytes } = require('crypto');\nconst secp256k1 = require('secp256k1');\n\n// Generate random private key\nlet privateKey;\ndo {\n  privateKey = randomBytes(32);\n} while (!secp256k1.privateKeyVerify(privateKey));\n\n// Derive public key\nconst publicKeyCompressed = secp256k1.publicKeyCreate(privateKey, true);    // 33 bytes\nconst publicKeyUncompressed = secp256k1.publicKeyCreate(privateKey, false); // 65 bytes\n\nconsole.log(`Private Key: ${privateKey.toString('hex')}`);\nconsole.log(`Public Key (compressed): ${Buffer.from(publicKeyCompressed).toString('hex')}`);\nconsole.log(`Public Key (uncompressed): ${Buffer.from(publicKeyUncompressed).toString('hex')}`);\n```\n:::\n\n### The Discrete Logarithm Problem\n\n**Why can't you derive the private key from the public key?**\n\nGiven `Q = k Ã— G` where:\n- `Q` is the public key (known)\n- `G` is the generator point (known)\n- `k` is the private key (unknown)\n\nFinding `k` requires solving the **Elliptic Curve Discrete Logarithm Problem (ECDLP)**, which is computationally infeasible for sufficiently large numbers.\n\n**Security Level:**\n- 256-bit private key = ~128 bits of security\n- Would take billions of years with current technology\n- Quantum computers could theoretically break this (see future considerations)\n\n## Digital Signatures\n\n### What is a Digital Signature?\n\nA **digital signature** proves:\n1. **Authenticity** - Message came from the claimed sender\n2. **Integrity** - Message hasn't been altered\n3. **Non-repudiation** - Sender cannot deny sending\n\n### ECDSA (Elliptic Curve Digital Signature Algorithm)\n\nBitcoin originally used **ECDSA** for all signatures.\n\n**Signing Process:**\n1. Hash the message: `z = SHA256(message)`\n2. Generate random number `k` (nonce)\n3. Calculate point `R = k Ã— G`\n4. Calculate signature: `s = kâ»Â¹(z + r Ã— privateKey) mod n`\n5. Signature is the pair `(r, s)`\n\n**Verification Process:**\n1. Hash the message: `z = SHA256(message)`\n2. Calculate: `u1 = z Ã— sâ»Â¹ mod n`\n3. Calculate: `u2 = r Ã— sâ»Â¹ mod n`\n4. Calculate point: `P = u1 Ã— G + u2 Ã— PublicKey`\n5. Signature valid if `P.x = r`\n\n**ECDSA Characteristics:**\n- Signature size: 70-72 bytes (DER encoded)\n- Requires secure random nonce `k`\n- Reusing `k` exposes private key!\n\n### Code: ECDSA Signing and Verification\n\n:::code-group\n```rust\nuse secp256k1::{Secp256k1, SecretKey, Message};\nuse sha2::{Sha256, Digest};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Private key\n    let private_key = SecretKey::from_slice(\n        &hex::decode(\"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\").unwrap()\n    ).unwrap();\n    \n    // Message to sign\n    let message = b\"Hello, Bitcoin!\";\n    let message_hash = Sha256::digest(message);\n    let msg = Message::from_digest_slice(&message_hash).unwrap();\n    \n    // Sign\n    let signature = secp.sign_ecdsa(&msg, &private_key);\n    println!(\"Message Hash: {}\", hex::encode(message_hash));\n    println!(\"Signature: {}\", hex::encode(signature.serialize_compact()));\n    \n    // Verify\n    let public_key = private_key.public_key(&secp);\n    let is_valid = secp.verify_ecdsa(&msg, &signature, &public_key).is_ok();\n    println!(\"Signature valid: {}\", is_valid);\n}\n```\n\n```python\nimport hashlib\nfrom secp256k1 import PrivateKey\n\n# Private key (use secrets.token_bytes(32) for real applications)\nprivate_key = PrivateKey(bytes.fromhex(\n    \"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\"\n))\n\n# Message to sign\nmessage = b\"Hello, Bitcoin!\"\nmessage_hash = hashlib.sha256(message).digest()\n\n# Sign\nsignature = private_key.ecdsa_sign(message_hash)\nsignature_der = private_key.ecdsa_serialize(signature)\n\nprint(f\"Message Hash: {message_hash.hex()}\")\nprint(f\"Signature (DER): {signature_der.hex()}\")\n\n# Verify\nis_valid = private_key.pubkey.ecdsa_verify(message_hash, signature)\nprint(f\"Signature valid: {is_valid}\")\n```\n\n```cpp\n#include <secp256k1.h>\n#include <openssl/sha.h>\n#include <cstring>\n\nint main() {\n    secp256k1_context* ctx = secp256k1_context_create(\n        SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY\n    );\n    \n    // Private key (initialize from hex in production)\n    unsigned char private_key[32];\n    // hex: \"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\"\n    \n    // Message hash\n    const char* message = \"Hello, Bitcoin!\";\n    unsigned char message_hash[SHA256_DIGEST_LENGTH];\n    SHA256((unsigned char*)message, strlen(message), message_hash);\n    \n    // Sign\n    secp256k1_ecdsa_signature signature;\n    secp256k1_ecdsa_sign(ctx, &signature, message_hash, private_key, NULL, NULL);\n    \n    // Serialize signature\n    unsigned char sig_serialized[64];\n    secp256k1_ecdsa_signature_serialize_compact(ctx, sig_serialized, &signature);\n    \n    // Get public key and verify\n    secp256k1_pubkey pubkey;\n    secp256k1_ec_pubkey_create(ctx, &pubkey, private_key);\n    int is_valid = secp256k1_ecdsa_verify(ctx, &signature, message_hash, &pubkey);\n    \n    secp256k1_context_destroy(ctx);\n    return 0;\n}\n```\n\n```javascript\nconst crypto = require('crypto');\nconst secp256k1 = require('secp256k1');\n\n// Private key\nconst privateKey = Buffer.from(\n  'e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'\n);\n\n// Message to sign\nconst message = Buffer.from('Hello, Bitcoin!');\nconst messageHash = crypto.createHash('sha256').update(message).digest();\n\n// Sign\nconst sigObj = secp256k1.ecdsaSign(messageHash, privateKey);\nconsole.log(`Message Hash: ${messageHash.toString('hex')}`);\nconsole.log(`Signature: ${Buffer.from(sigObj.signature).toString('hex')}`);\n\n// Verify\nconst publicKey = secp256k1.publicKeyCreate(privateKey);\nconst isValid = secp256k1.ecdsaVerify(sigObj.signature, messageHash, publicKey);\nconsole.log(`Signature valid: ${isValid}`);\n```\n:::\n\n### Schnorr Signatures\n\n**Schnorr signatures** were introduced with the Taproot upgrade (2021).\n\n**Advantages over ECDSA:**\n- **Simpler** - Mathematically cleaner\n- **Smaller** - Fixed 64-byte signatures\n- **Linearity** - Enables key and signature aggregation\n- **Provably secure** - Better security proofs\n- **Batch verification** - Faster validation of multiple signatures\n\n**Signature Aggregation:**\nMultiple signatures can be combined into one, enabling:\n- **MuSig** - Multi-signature schemes that look like single signatures\n- **Privacy** - Multi-party transactions appear as single-party\n- **Efficiency** - Reduced transaction size and fees\n\n### Code: BIP-340 Schnorr Tagged Hash\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\nfn tagged_hash(tag: &str, msg: &[u8]) -> [u8; 32] {\n    let tag_hash = Sha256::digest(tag.as_bytes());\n    let mut hasher = Sha256::new();\n    hasher.update(&tag_hash);\n    hasher.update(&tag_hash);\n    hasher.update(msg);\n    hasher.finalize().into()\n}\n\nfn main() {\n    let challenge = tagged_hash(\"BIP0340/challenge\", b\"some data\");\n    println!(\"Challenge hash: {}\", hex::encode(challenge));\n}\n```\n\n```python\nimport hashlib\n\ndef tagged_hash(tag: str, msg: bytes) -> bytes:\n    \"\"\"BIP-340 tagged hash for domain separation\"\"\"\n    tag_hash = hashlib.sha256(tag.encode()).digest()\n    return hashlib.sha256(tag_hash + tag_hash + msg).digest()\n\n# Example tags used in Bitcoin\nchallenge = tagged_hash(\"BIP0340/challenge\", b\"some data\")\naux = tagged_hash(\"BIP0340/aux\", b\"random auxiliary data\")\nnonce = tagged_hash(\"BIP0340/nonce\", b\"nonce derivation input\")\n\nprint(f\"Challenge hash: {challenge.hex()}\")\n```\n:::\n\n### Signing a Bitcoin Transaction\n\nWhen you spend bitcoin:\n\n1. **Construct transaction** with inputs and outputs\n2. **Create signature hash** (sighash) of transaction data\n3. **Sign** the sighash with your private key\n4. **Include signature** in transaction's witness/scriptSig\n5. **Broadcast** transaction to network\n6. **Nodes verify** signature matches public key and transaction\n\n## Merkle Trees\n\n### What is a Merkle Tree?\n\nA **Merkle tree** (or hash tree) is a data structure that efficiently summarizes and verifies large datasets.\n\n**Structure:**\n```\n                    Merkle Root\n                   /            \\\n              Hash AB          Hash CD\n             /      \\         /      \\\n         Hash A   Hash B   Hash C   Hash D\n            |        |        |        |\n           Tx A    Tx B     Tx C     Tx D\n```\n\n### How Bitcoin Uses Merkle Trees\n\n**Block Structure:**\n- Each block contains a **Merkle root** in its header\n- Merkle root summarizes all transactions in the block\n- Changing any transaction changes the Merkle root\n\n**Benefits:**\n1. **Efficient verification** - Prove transaction inclusion with O(log n) hashes\n2. **Compact proofs** - SPV nodes don't need full blockchain\n3. **Data integrity** - Any tampering is immediately detectable\n\n### Merkle Proofs (SPV)\n\n**Simplified Payment Verification** allows lightweight clients to verify transactions without downloading the full blockchain.\n\n**To prove Tx B is in a block:**\n```\nProvide: Hash A, Hash CD\nClient calculates:\n  1. Hash B (from Tx B)\n  2. Hash AB = SHA256(Hash A + Hash B)\n  3. Merkle Root = SHA256(Hash AB + Hash CD)\n  4. Compare with block header's Merkle root\n```\n\n### Code: Merkle Tree and Proof Verification\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\nfn double_sha256(data: &[u8]) -> [u8; 32] {\n    let first = Sha256::digest(data);\n    Sha256::digest(&first).into()\n}\n\nfn merkle_root(mut hashes: Vec<[u8; 32]>) -> [u8; 32] {\n    if hashes.is_empty() {\n        return [0u8; 32];\n    }\n    \n    while hashes.len() > 1 {\n        // Duplicate last if odd\n        if hashes.len() % 2 == 1 {\n            hashes.push(*hashes.last().unwrap());\n        }\n        \n        // Hash pairs\n        hashes = hashes\n            .chunks(2)\n            .map(|pair| {\n                let mut combined = Vec::with_capacity(64);\n                combined.extend_from_slice(&pair[0]);\n                combined.extend_from_slice(&pair[1]);\n                double_sha256(&combined)\n            })\n            .collect();\n    }\n    \n    hashes[0]\n}\n\nfn verify_merkle_proof(tx_hash: [u8; 32], proof: &[[u8; 32]], \n                       root: [u8; 32], mut index: usize) -> bool {\n    let mut current = tx_hash;\n    for sibling in proof {\n        let mut combined = Vec::with_capacity(64);\n        if index % 2 == 0 {\n            combined.extend_from_slice(&current);\n            combined.extend_from_slice(sibling);\n        } else {\n            combined.extend_from_slice(sibling);\n            combined.extend_from_slice(&current);\n        }\n        current = double_sha256(&combined);\n        index /= 2;\n    }\n    current == root\n}\n```\n\n```python\nimport hashlib\n\ndef double_sha256(data: bytes) -> bytes:\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\ndef merkle_root(tx_hashes: list) -> bytes:\n    \"\"\"Calculate Merkle root from transaction hashes\"\"\"\n    if len(tx_hashes) == 0:\n        return bytes(32)\n    if len(tx_hashes) == 1:\n        return tx_hashes[0]\n    \n    # Duplicate last hash if odd number\n    if len(tx_hashes) % 2 == 1:\n        tx_hashes = tx_hashes + [tx_hashes[-1]]\n    \n    # Hash pairs\n    next_level = []\n    for i in range(0, len(tx_hashes), 2):\n        combined = tx_hashes[i] + tx_hashes[i + 1]\n        next_level.append(double_sha256(combined))\n    \n    return merkle_root(next_level)\n\ndef verify_merkle_proof(tx_hash: bytes, proof: list, root: bytes, index: int) -> bool:\n    \"\"\"Verify transaction inclusion using Merkle proof\"\"\"\n    current = tx_hash\n    for sibling in proof:\n        if index % 2 == 0:\n            current = double_sha256(current + sibling)\n        else:\n            current = double_sha256(sibling + current)\n        index //= 2\n    return current == root\n\n# Example: 4 transactions\ntx_hashes = [double_sha256(f\"tx{i}\".encode()) for i in range(4)]\nroot = merkle_root(tx_hashes)\nprint(f\"Merkle Root: {root.hex()}\")\n```\n\n```cpp\n#include <vector>\n#include <array>\n#include <openssl/sha.h>\n\nusing Hash = std::array<uint8_t, 32>;\n\nHash double_sha256(const std::vector<uint8_t>& data) {\n    Hash first, second;\n    SHA256(data.data(), data.size(), first.data());\n    SHA256(first.data(), first.size(), second.data());\n    return second;\n}\n\nHash merkle_root(std::vector<Hash> hashes) {\n    if (hashes.empty()) return Hash{};\n    \n    while (hashes.size() > 1) {\n        // Duplicate last if odd\n        if (hashes.size() % 2 == 1) {\n            hashes.push_back(hashes.back());\n        }\n        \n        // Hash pairs\n        std::vector<Hash> next_level;\n        for (size_t i = 0; i < hashes.size(); i += 2) {\n            std::vector<uint8_t> combined;\n            combined.insert(combined.end(), hashes[i].begin(), hashes[i].end());\n            combined.insert(combined.end(), hashes[i+1].begin(), hashes[i+1].end());\n            next_level.push_back(double_sha256(combined));\n        }\n        hashes = std::move(next_level);\n    }\n    \n    return hashes[0];\n}\n```\n:::\n\n## Address Encoding\n\n### Base58Check\n\n**Base58** encoding uses 58 characters (excluding 0, O, I, l to avoid confusion):\n\n```\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n```\n\n**Base58Check** adds a checksum:\n1. Add version byte prefix\n2. Calculate checksum: `SHA256(SHA256(data))` (first 4 bytes)\n3. Append checksum to data\n4. Encode in Base58\n\n**Used for:** Legacy addresses (1..., 3...)\n\n### Bech32 and Bech32m\n\n**Bech32** encoding (BIP-173) is used for SegWit addresses:\n\n**Characteristics:**\n- Case-insensitive\n- Better error detection (BCH codes)\n- QR code friendly\n- Prefix: `bc1` for mainnet, `tb1` for testnet\n\n**Address Types:**\n- `bc1q...` - Native SegWit (P2WPKH, P2WSH) - Bech32\n- `bc1p...` - Taproot (P2TR) - Bech32m\n\n**Bech32m** (BIP-350) is a modified version for Taproot addresses with improved error detection.\n\n### Code: Address Generation (Full Pipeline)\n\n:::code-group\n```rust\nuse bitcoin::{\n    Network, PrivateKey, PublicKey, Address,\n    secp256k1::{Secp256k1, rand},\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate private key\n    let (secret_key, _) = secp.generate_keypair(&mut rand::thread_rng());\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    \n    // Derive public key\n    let public_key = PublicKey::from_private_key(&secp, &private_key);\n    \n    // Generate addresses\n    let p2pkh = Address::p2pkh(&public_key, Network::Bitcoin);\n    let p2wpkh = Address::p2wpkh(&public_key, Network::Bitcoin).unwrap();\n    \n    println!(\"Private Key (WIF): {}\", private_key);\n    println!(\"Public Key: {}\", public_key);\n    println!(\"P2PKH Address: {}\", p2pkh);\n    println!(\"P2WPKH Address: {}\", p2wpkh);\n}\n```\n\n```python\nimport hashlib\nimport secrets\nfrom secp256k1 import PrivateKey\n\n# Base58 alphabet\nBASE58_ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef base58_encode(data: bytes) -> str:\n    num = int.from_bytes(data, 'big')\n    result = \"\"\n    while num > 0:\n        num, rem = divmod(num, 58)\n        result = BASE58_ALPHABET[rem] + result\n    for byte in data:\n        if byte == 0:\n            result = '1' + result\n        else:\n            break\n    return result\n\ndef base58check_encode(version: bytes, payload: bytes) -> str:\n    data = version + payload\n    checksum = hashlib.sha256(hashlib.sha256(data).digest()).digest()[:4]\n    return base58_encode(data + checksum)\n\ndef hash160(data: bytes) -> bytes:\n    sha256_hash = hashlib.sha256(data).digest()\n    return hashlib.new('ripemd160', sha256_hash).digest()\n\n# Bech32 encoding (simplified)\nBECH32_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n\ndef bech32_polymod(values):\n    GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\n    chk = 1\n    for v in values:\n        b = chk >> 25\n        chk = ((chk & 0x1ffffff) << 5) ^ v\n        for i in range(5):\n            chk ^= GEN[i] if ((b >> i) & 1) else 0\n    return chk\n\ndef bech32_encode(hrp: str, data: list) -> str:\n    values = [ord(c) >> 5 for c in hrp] + [0] + [ord(c) & 31 for c in hrp] + data\n    polymod = bech32_polymod(values + [0]*6) ^ 1\n    checksum = [(polymod >> 5*(5-i)) & 31 for i in range(6)]\n    return hrp + \"1\" + \"\".join(BECH32_CHARSET[d] for d in data + checksum)\n\ndef convertbits(data, frombits, tobits, pad=True):\n    acc, bits, ret = 0, 0, []\n    maxv = (1 << tobits) - 1\n    for value in data:\n        acc = (acc << frombits) | value\n        bits += frombits\n        while bits >= tobits:\n            bits -= tobits\n            ret.append((acc >> bits) & maxv)\n    if pad and bits:\n        ret.append((acc << (tobits - bits)) & maxv)\n    return ret\n\ndef generate_addresses():\n    \"\"\"Generate all address types from a single private key\"\"\"\n    # 1. Generate private key\n    private_key_bytes = secrets.token_bytes(32)\n    private_key = PrivateKey(private_key_bytes)\n    \n    # 2. Get compressed public key\n    public_key = private_key.pubkey.serialize()\n    \n    # 3. Hash160 the public key\n    pubkey_hash = hash160(public_key)\n    \n    # 4. Generate addresses\n    # P2PKH (Legacy) - starts with '1'\n    p2pkh = base58check_encode(b'\\x00', pubkey_hash)\n    \n    # P2WPKH (Native SegWit) - starts with 'bc1q'\n    witness_program = convertbits(list(pubkey_hash), 8, 5)\n    p2wpkh = bech32_encode(\"bc\", [0] + witness_program)\n    \n    return {\n        \"private_key\": private_key_bytes.hex(),\n        \"public_key\": public_key.hex(),\n        \"pubkey_hash\": pubkey_hash.hex(),\n        \"p2pkh_address\": p2pkh,\n        \"p2wpkh_address\": p2wpkh,\n    }\n\nresult = generate_addresses()\nprint(f\"Private Key: {result['private_key']}\")\nprint(f\"Public Key: {result['public_key']}\")\nprint(f\"P2PKH Address: {result['p2pkh_address']}\")\nprint(f\"P2WPKH Address: {result['p2wpkh_address']}\")\n```\n:::\n\n## Cryptographic Security Assumptions\n\n### What Bitcoin Assumes\n\nBitcoin's security relies on these assumptions holding true:\n\n| Assumption | If Broken |\n|------------|-----------|\n| SHA-256 is collision-resistant | Could create invalid blocks |\n| SHA-256 is preimage-resistant | Could forge proof-of-work |\n| ECDLP is hard | Private keys could be derived from public keys |\n| Random number generation is secure | Private keys could be predicted |\n\n### Quantum Computing Considerations\n\n**Potential Threats:**\n- **Shor's algorithm** could break ECDSA/Schnorr (public key â†’ private key)\n- **Grover's algorithm** could speed up SHA-256 attacks (but only quadratic speedup)\n\n**Current Status:**\n- No quantum computer capable of breaking Bitcoin exists today\n- Estimates suggest decades before practical quantum threats\n- Bitcoin community is researching post-quantum solutions\n- Addresses that haven't revealed public keys are safer\n\n**Mitigations:**\n- Don't reuse addresses (limits public key exposure)\n- Post-quantum signature schemes being researched\n- Soft fork could add quantum-resistant signatures\n\n## Summary\n\n| Cryptographic Primitive | Purpose in Bitcoin |\n|------------------------|-------------------|\n| SHA-256 | Block hashing, TXIDs, PoW |\n| SHA-256d (double) | Block headers, Merkle trees |\n| RIPEMD-160 | Address generation (Hash160) |\n| secp256k1 (ECC) | Key pairs, signatures |\n| ECDSA | Legacy transaction signatures |\n| Schnorr | Taproot signatures, aggregation |\n| Merkle Trees | Transaction summarization, SPV proofs |\n| Base58Check | Legacy address encoding |\n| Bech32/Bech32m | SegWit/Taproot address encoding |\n\n## Resources\n\n- **[Bitcoin Developer Guide - Transactions](https://developer.bitcoin.org/devguide/transactions.html)** - Official documentation on transaction signing\n- **[Learn Me a Bitcoin](https://learnmeabitcoin.com)** - Visual explanations of Bitcoin cryptography\n- **[BIP-340: Schnorr Signatures](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)** - Schnorr signature specification\n- **[SEC 2: Recommended Elliptic Curve Domain Parameters](https://www.secg.org/sec2-v2.pdf)** - secp256k1 specification\n- **[libsecp256k1](https://github.com/bitcoin-core/secp256k1)** - Bitcoin Core's optimized secp256k1 C library\n\n## Related Topics\n\n- [What is Bitcoin?](/docs/fundamentals/what-is-bitcoin) - High-level Bitcoin overview\n- [Trust Model](/docs/fundamentals/trust-model) - How cryptography enables trustlessness\n- [Consensus Mechanism](/docs/fundamentals/consensus) - How cryptographic proofs secure consensus\n- [Script System](/docs/bitcoin/script) - How signatures are verified in Bitcoin Script\n- [Mining: Proof-of-Work](/docs/mining/proof-of-work) - How SHA-256 secures the blockchain\n",
    "filename": "cryptography.md"
  },
  "/docs/bitcoin/consensus": {
    "content": "# Consensus Mechanism\n\nBitcoin uses a **consensus mechanism** to achieve agreement among network participants about which transactions are valid and in what order they occurred. This consensus is reached without a central authority through a combination of cryptographic proof and economic incentives.\n\n## What is Consensus?\n\n### Definition\n\n**Consensus** means that all honest participants in the Bitcoin network agree on:\n- Which transactions are valid\n- The order of transactions\n- The current state of the blockchain\n- Which blocks are part of the canonical chain\n\n### Why Consensus Matters\n\n**Without Consensus:**\n- Different nodes see different transaction histories\n- Double-spending possible\n- No agreement on balances\n- System breaks down\n\n**With Consensus:**\n- All nodes agree on transaction history\n- Double-spending prevented\n- Consistent view of balances\n- System functions correctly\n\n## Bitcoin's Consensus Mechanism\n\n### Proof-of-Work (PoW)\n\nBitcoin uses **Proof-of-Work** as its consensus mechanism:\n\n1. **Mining:** Miners compete to solve cryptographic puzzles\n2. **Difficulty:** Puzzle difficulty adjusts to maintain ~10 minute blocks\n3. **Validation:** First miner to solve broadcasts block to network\n4. **Verification:** Other nodes verify the block is valid\n5. **Acceptance:** Valid blocks are added to blockchain\n6. **Consensus:** Longest valid chain is accepted as truth\n\n### How It Works\n\n**Step 1: Transaction Collection**\n- Miners collect transactions from mempool\n- Verify transactions are valid\n- Select transactions for block\n\n**Step 2: Block Construction**\n- Create block header with:\n  - Previous block hash\n  - Merkle root of transactions\n  - Timestamp\n  - Difficulty target\n  - Nonce (variable)\n\n**Step 3: Mining (Proof-of-Work)**\n- Hash block header repeatedly\n- Try different nonce values\n- Find hash below difficulty target\n- Requires significant computational work\n\n**Step 4: Block Propagation**\n- Miner broadcasts block to network\n- Other nodes receive block\n- Nodes verify block validity\n\n**Step 5: Chain Selection**\n- Nodes accept longest valid chain\n- Blocks build on previous blocks\n- Consensus emerges from longest chain\n\n## Consensus Rules\n\n### What Nodes Agree On\n\n**Transaction Validity:**\n- Valid signatures\n- Sufficient funds (UTXO exists)\n- No double-spending\n- Follows protocol rules\n\n**Block Validity:**\n- Valid transactions\n- Correct block structure\n- Valid proof-of-work\n- Follows consensus rules\n\n**Chain Validity:**\n- All blocks are valid\n- Blocks link correctly\n- Longest chain is canonical\n- Consensus on chain state\n\n### Consensus Rules vs Policy\n\n**Consensus Rules (Hard Rules):**\n- Must be followed by all nodes\n- Violation = invalid block/transaction\n- Examples: 21 million supply cap, block size limit\n- Changes require hard fork\n\n**Policy Rules (Soft Rules):**\n- Node-specific preferences\n- Can differ between nodes\n- Examples: Minimum fee, relay policy\n- Changes don't require consensus\n\n## Achieving Consensus\n\n### The Longest Chain Rule\n\n**Principle:**\n- The chain with the most cumulative proof-of-work is valid\n- All nodes accept the longest valid chain\n- Consensus emerges naturally\n\n**Why It Works:**\n- Honest miners extend longest chain\n- Attackers need >50% hash rate to compete\n- Economic incentives favor longest chain\n- Network converges on single chain\n\n### Block Confirmation\n\n**How Confirmations Work:**\n1. **Block 0:** Transaction included in block\n2. **Block 1:** Another block built on top\n3. **Block 2:** Another block built on top\n4. **Block 3+:** More blocks = more confirmations\n\n**Why More Confirmations = More Security:**\n- Each block adds more proof-of-work\n- Reversing requires redoing all work\n- More blocks = exponentially harder to reverse\n- 6 confirmations = standard for high-value transactions\n\n### Network Synchronization\n\n**How Nodes Stay in Sync:**\n- Nodes constantly share blocks\n- New blocks propagate through network\n- Nodes verify and accept valid blocks\n- Network converges on same chain\n\n**Handling Disagreements:**\n- Temporary forks can occur\n- Network resolves by accepting longest chain\n- Shorter chain is abandoned\n- Consensus restored\n\n## Security Through Consensus\n\n### 51% Attack\n\n**What It Is:**\n- Attacker controls >50% of network hash rate\n- Can create longer chain than honest network\n- Can reverse transactions\n- Can double-spend\n\n**Why It's Difficult:**\n- Requires massive hash rate\n- Extremely expensive\n- Unprofitable for attackers\n- Network would notice and respond\n\n**Current Protection:**\n- Bitcoin hash rate: ~700+ EH/s\n- Cost to attack: Billions of dollars\n- Economic incentives prevent attack\n- Network is highly secure\n\n### Economic Security\n\n**Mining Incentives:**\n- Miners rewarded for honest behavior\n- Block reward + transaction fees\n- Attacking is unprofitable\n- Economic security through incentives\n\n**Cost of Attack:**\n- Hardware costs\n- Electricity costs\n- Opportunity cost (could mine honestly)\n- Network would fork away\n\n## Consensus Properties\n\n### Finality\n\n**Definition:** Once consensus is reached, it cannot be reversed.\n\n**Bitcoin's Finality:**\n- **Probabilistic:** More confirmations = more finality\n- **Practical Finality:** 6+ confirmations is effectively final\n- **Theoretical Reversibility:** Possible but extremely expensive\n- **Economic Finality:** Cost to reverse exceeds benefit\n\n### Liveness\n\n**Definition:** System continues to produce new blocks.\n\n**Bitcoin's Liveness:**\n- Blocks produced every ~10 minutes\n- Network continues even if some nodes fail\n- Mining continues as long as miners participate\n- System is resilient\n\n### Safety\n\n**Definition:** System doesn't produce conflicting states.\n\n**Bitcoin's Safety:**\n- All nodes agree on same chain\n- No double-spending\n- Consistent transaction history\n- Single source of truth\n\n## Consensus Challenges\n\n### Network Partitions\n\n**What Happens:**\n- Network splits into separate groups\n- Each group mines its own chain\n- When reconnected, longest chain wins\n- Shorter chain is abandoned\n\n**Resolution:**\n- Network automatically resolves\n- Longest chain becomes canonical\n- Transactions in shorter chain are invalid\n- Consensus restored\n\n### Temporary Forks\n\n**Common Occurrence:**\n- Two blocks found simultaneously\n- Network temporarily has two chains\n- Next block determines winner\n- Consensus quickly restored\n\n**Impact:**\n- Usually resolves in next block\n- Minimal disruption\n- Part of normal operation\n- Not a security issue\n\n## Consensus vs Other Mechanisms\n\n### Proof-of-Stake (PoS)\n\n**Differences:**\n- PoS: Validators stake coins\n- PoW: Miners use computational work\n- PoS: Lower energy consumption\n- PoW: More proven, higher security\n\n**Bitcoin's Choice:**\n- Proof-of-Work chosen for security\n- Energy cost is security feature\n- More battle-tested\n- Simpler economic model\n\n### Byzantine Fault Tolerance\n\n**Bitcoin's Approach:**\n- Handles Byzantine failures\n- Assumes <50% malicious\n- Economic incentives prevent attacks\n- Practical Byzantine fault tolerance\n\n## Related Topics\n\n- [What is Bitcoin?](/docs/fundamentals/what-is-bitcoin) - High-level Bitcoin overview\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - How Bitcoin solves consensus problems\n- [Decentralization](/docs/fundamentals/decentralization) - How consensus affects scalability and decentralization\n- [Mining: Proof-of-Work](/docs/mining/proof-of-work) - Detailed explanation of mining\n- [Mining: Difficulty Adjustment](/docs/mining/difficulty) - How difficulty maintains consensus\n",
    "filename": "consensus.md"
  },
  "/docs/bitcoin/script": {
    "content": "# Bitcoin Script\nBitcoin uses a scripting system for transactions. Script is simple, stack-based (LIFO) and processed from left to right. It is intentionally not Turing-complete, with no loops.\n\n## Script Types Evolution\n\nBitcoin's [script](/docs/glossary#script) system has evolved over time, introducing new output types (address formats) that improve security, privacy, and efficiency. Each script type represents a different way to lock and unlock Bitcoin.\n\n| Script Type | Full Name | Introduced | Block Height | BIP | Description |\n|-------------|-----------|------------|--------------|:---:|-------------|\n| **P2PKH** | Pay-to-Pubkey-Hash | January 2009 | 0 (Genesis) | â€” | Original script type. Uses hash of public key. Addresses start with `1`. |\n| **P2SH** | Pay-to-Script-Hash | April 2012 | 173,805 | [16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki) | Allows complex scripts to be represented by a hash. Addresses start with `3`. |\n| **P2WPKH** | Pay-to-Witness-Pubkey-Hash | August 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | SegWit version of P2PKH. Witness data separated from transaction. Addresses start with `bc1q`. |\n| **P2WSH** | Pay-to-Witness-Script-Hash | August 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | SegWit version of P2SH. For complex scripts in witness. Addresses start with `bc1q`. |\n| **P2TR** | Pay-to-Taproot | November 2021 | 709,632 | [341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) | Taproot output type. Single signature or MAST (Merkle Abstract Syntax Tree). Addresses start with `bc1p`. |\n\n### P2PKH (Pay-to-Pubkey-Hash)\n\n- **Introduced**: January 3, 2009 ([Genesis Block](/docs/glossary#genesis-block))\n- **Block Height**: 0\n- **Address Format**: Starts with `1` (e.g., `1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa`) - uses [Base58](/docs/glossary#base58) encoding\n- **Description**: The original Bitcoin script type. Funds are locked to a hash of the recipient's public key. The sender must provide the public key and a signature to spend.\n- **Status**: Still widely used, but being gradually replaced by more efficient script types.\n\n### P2SH (Pay-to-Script-Hash)\n\n- **Introduced**: April 1, 2012\n- **Block Height**: 173,805\n- **[BIP](/docs/glossary#bip-bitcoin-improvement-proposal)**: [BIP 16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki)\n- **Address Format**: Starts with `3` (e.g., `3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy`) - uses Base58 encoding\n- **Description**: Allows complex scripts ([multisig](/docs/glossary#multisig-multi-signature), timelocks, etc.) to be represented by a single hash. The actual script is revealed only when spending. Enables multisig [wallets](/docs/glossary#wallet) and other advanced features.\n- **Status**: Widely used for multisig wallets and other complex scripts.\n\n### P2WPKH (Pay-to-Witness-Pubkey-Hash)\n\n- **Introduced**: August 24, 2017\n- **Block Height**: 481,824\n- **BIP**: [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) ([Segregated Witness](/docs/glossary#segwit-segregated-witness))\n- **Address Format**: [Bech32](/docs/glossary#bech32), starts with `bc1q` (e.g., `bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4`)\n- **Description**: SegWit version of P2PKH. [Witness](/docs/glossary#witness) data (signatures) is moved outside the [transaction](/docs/glossary#transaction), reducing transaction size and fees. Provides better scalability and fixes [transaction malleability](/docs/glossary#transaction-malleability).\n- **Status**: Increasingly adopted, offers lower fees than P2PKH.\n\n### P2WSH (Pay-to-Witness-Script-Hash)\n\n- **Introduced**: August 24, 2017\n- **Block Height**: 481,824\n- **BIP**: [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) (Segregated Witness)\n- **Address Format**: Bech32, starts with `bc1q` (e.g., `bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3`)\n- **Description**: SegWit version of P2SH. Allows complex scripts in the witness section. Used for multisig and other advanced scripts with SegWit benefits.\n- **Status**: Used for SegWit-compatible multisig wallets.\n\n### P2TR (Pay-to-Taproot)\n\n- **Introduced**: November 14, 2021\n- **Block Height**: 709,632\n- **BIP**: [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) ([Taproot](/docs/glossary#taproot))\n- **Address Format**: Bech32m, starts with `bc1p` (e.g., `bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297`)\n- **Description**: Latest script type. Can represent either a single signature or a [Merkle tree](/docs/glossary#merkle-tree) of scripts ([MAST](/docs/glossary#mast-merkle-abstract-syntax-tree)). Provides better privacy (all transactions look the same on-chain) and efficiency. Enables advanced features like [Schnorr signatures](/docs/glossary#schnorr-signature).\n- **Status**: Modern standard, offering the best privacy and efficiency.\n\n### Script Type Adoption Timeline\n\n```\n2009 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2PKH: Original script type (Genesis Block)\n     â”‚\n2012 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2SH: Complex scripts via hash (Block 173,805)\n     â”‚\n2017 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2WPKH & P2WSH: SegWit introduces witness separation\n     â”‚ (Block 481,824)\n     â”‚\n2021 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2TR: Taproot with Schnorr signatures and MAST\n     â”‚ (Block 709,632)\n```\n\n### Key Improvements\n\n- **P2SH**: Enabled complex scripts without revealing them until spending\n- **SegWit (P2WPKH/P2WSH)**: Reduced transaction size, lower fees, fixed malleability\n- **Taproot (P2TR)**: Better privacy, efficiency, and enables Schnorr signatures\n\n---\n\n## Understanding P2PKH Script Execution\n\n### The P2PKH Script Pattern\n\nThe most common Bitcoin script pattern is **Pay-to-Pubkey-Hash (P2PKH)**:\n\n**Locking Script ([scriptPubKey](/docs/glossary#scriptpubkey)):**\n```\nOP_DUP OP_HASH160 <pubkeyhash> OP_EQUALVERIFY OP_CHECKSIG\n```\n\n**Unlocking Script ([scriptSig](/docs/glossary#scriptsig)):**\n```\n<signature> <publickey>\n```\n\n### Step-by-Step Execution Flow\n\nWhen someone spends a P2PKH output, the unlocking script runs **first**, then the locking script runs. They are concatenated together:\n\n```\n[<signature> <publickey>] [OP_DUP OP_HASH160 <pubkeyhash> OP_EQUALVERIFY OP_CHECKSIG]\n```\n\nHere's what happens step by step:\n\n#### Step 1: Unlocking Script Executes\nThe spender provides their signature and public key:\n\n```\nStack: []\n```\n\n**Execute:** `<signature>` (pushes signature onto stack)\n```\nStack: [signature]\n```\n\n**Execute:** `<publickey>` (pushes public key onto stack)\n```\nStack: [signature, publickey]\n```\n\n#### Step 2: Locking Script Executes\n\n**Execute:** `OP_DUP`\n- **What it duplicates:** The top item on the stack, which is the **public key**\n- **Why:** We need to keep the original public key for signature verification later, but we also need to hash it to compare with the pubkeyhash\n- **Result:**\n```\nStack: [signature, publickey, publickey]\n```\n\n**Execute:** `OP_HASH160`\n- Hashes the top item (the duplicated public key) with SHA-256, then RIPEMD-160\n- **Result:**\n```\nStack: [signature, publickey, hash160(publickey)]\n```\n\n**Execute:** `<pubkeyhash>` (OP_PUSHDATA)\n- Pushes the pubkeyhash that was stored in the original output\n- This is the hash of the recipient's public key\n- **Result:**\n```\nStack: [signature, publickey, hash160(publickey), pubkeyhash]\n```\n\n**Execute:** `OP_EQUALVERIFY`\n- Compares `hash160(publickey)` with `pubkeyhash`\n- If they're equal, removes both from stack and continues\n- If not equal, script fails (transaction invalid)\n- **Result (if equal):**\n```\nStack: [signature, publickey]\n```\n\n**Execute:** `OP_CHECKSIG`\n- Pops the public key (top of stack)\n- Pops the signature (below public key)\n- Verifies the signature is valid for this transaction using the public key\n- Pushes 1 if valid, 0 if invalid\n- **Result (if valid):**\n```\nStack: [1]\n```\n\n### Why OP_DUP is Needed\n\nThe `OP_DUP` is crucial because:\n\n1. **We need the public key twice:**\n   - Once to hash it and compare with the stored `pubkeyhash` (proves the spender owns the key)\n   - Once to verify the signature (proves the spender authorized the transaction)\n\n2. **Without OP_DUP:**\n   - If we hashed the public key first, we'd lose the original public key\n   - We couldn't verify the signature because `OP_CHECKSIG` needs the actual public key, not its hash\n\n3. **The flow:**\n   ```\n   publickey â†’ OP_DUP â†’ [publickey, publickey]\n                      â†’ Hash one copy â†’ Compare with pubkeyhash\n                      â†’ Keep other copy â†’ Verify signature\n   ```\n\n### Visual Summary\n\n```\nInitial Stack: []\n                    â†“\nUnlocking Script: <signature> <publickey>\n                    â†“\nStack: [signature, publickey]\n                    â†“\nOP_DUP (duplicates publickey)\n                    â†“\nStack: [signature, publickey, publickey]\n                    â†“\nOP_HASH160 (hashes top publickey)\n                    â†“\nStack: [signature, publickey, hash160(publickey)]\n                    â†“\nOP_PUSHDATA <pubkeyhash>\n                    â†“\nStack: [signature, publickey, hash160(publickey), pubkeyhash]\n                    â†“\nOP_EQUALVERIFY (compares hashes, removes both if equal)\n                    â†“\nStack: [signature, publickey]\n                    â†“\nOP_CHECKSIG (verifies signature with public key)\n                    â†“\nStack: [1] âœ… Transaction valid!\n```\n\n---\n\n## Reasons to Lock Transactions\n\nBitcoin scripts can lock transactions for various reasons. Here are the main categories:\n\n### 1. Time-Based Locks\n\n#### Absolute Time Lock (OP_CHECKLOCKTIMEVERIFY / CLTV)\nLocks funds until a specific block height or timestamp.\n\n**Use Cases:**\n- **Escrow:** Funds locked until a future date\n- **Inheritance:** Funds accessible only after a certain time\n- **Vesting:** Gradual release of funds over time\n- **Dead man's switch:** Funds become accessible if owner doesn't check in\n\n**Example:**\n```\n<locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\n#### Relative Time Lock (OP_CHECKSEQUENCEVERIFY / CSV)\nLocks funds for a relative time period (e.g., \"can't spend until 1000 blocks after this transaction is confirmed\").\n\n**Use Cases:**\n- **Payment channels:** Enforce channel closure delays\n- **Replace-by-fee protection:** Prevent immediate double-spending\n- **Escrow with relative timing:** Funds locked relative to transaction confirmation\n\n**Example:**\n```\n<relative_locktime> OP_CHECKSEQUENCEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\n### 2. Multi-Signature Locks\n\nRequires multiple signatures to spend (e.g., 2-of-3, 3-of-5).\n\n**Use Cases:**\n- **Shared custody:** Multiple people must agree to spend\n- **Corporate wallets:** Requires multiple executives to sign\n- **Backup security:** One key can be stored securely offline\n- **Family funds:** Requires multiple family members to agree\n\n**Example:**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\nRequires 2 valid signatures from 3 possible public keys.\n\n### 3. Hash Preimage Locks\n\nRequires knowledge of a secret (preimage) that hashes to a known value.\n\n**Use Cases:**\n- **Oracle-based conditions:** Oracle reveals secret when condition is met\n- **Donation milestones:** Secret revealed when donation goal reached\n- **Commitment schemes:** Prove knowledge of secret without revealing it\n- **Atomic swaps:** Cross-chain exchanges\n\n**Example:**\n```\nOP_HASH256\nOP_PUSH <hash_value>\nOP_EQUALVERIFY\nOP_DROP\n<pubkey> OP_CHECKSIG\n```\n\n### 4. Conditional Locks\n\nUses OP_IF/OP_ELSE to create multiple spending paths.\n\n**Use Cases:**\n- **Refund mechanisms:** One path for normal spending, another for refund\n- **Escrow with conditions:** Different spending paths based on conditions\n- **Time-based conditions:** Different keys for different time periods\n- **Multi-party agreements:** Different parties can spend under different conditions\n\n**Example:**\n```\nOP_IF\n  <pubkey1> OP_CHECKSIG\nOP_ELSE\n  <pubkey2> OP_CHECKSIG\nOP_ENDIF\n```\n\n### 5. Anyone-Can-Spend (No Lock)\n\nTechnically not a \"lock\" - anyone can spend by providing any data.\n\n**Use Cases:**\n- **Data storage:** Using OP_RETURN outputs\n- **Burning coins:** Making funds unspendable\n- **Future upgrades:** Reserved for future script types\n\n**Example:**\n```\nOP_RETURN <data>\n```\n\n### 6. Complex Combined Locks\n\nCombining multiple conditions:\n\n**Examples:**\n- **Time-locked multisig:** Requires multiple signatures AND a time lock\n- **Preimage + signature:** Requires secret knowledge AND signature\n- **Conditional timelock:** Different time locks for different parties\n\n**Example:**\n```\nOP_IF\n  <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP\n  OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\nOP_ELSE\n  <pubkey4> OP_CHECKSIG\nOP_ENDIF\n```\n\n### 7. Other Locking Mechanisms\n\n#### Pay-to-Script-Hash (P2SH)\nLocks funds to a script hash. The actual script is revealed when spending.\n\n**Use Cases:**\n- **Complex scripts:** Hide script complexity until spending\n- **Reduced transaction size:** Script only included when spending\n- **Standardization:** Enables more complex scripts in standard transactions\n\n**Example:**\n```\nOP_HASH160 <scripthash> OP_EQUAL\n```\n\n#### Segregated Witness (SegWit)\nSimilar to P2SH but with witness data separated.\n\n**Use Cases:**\n- **Transaction malleability fix:** Prevents transaction ID changes\n- **Block size efficiency:** Witness data doesn't count toward block size\n- **Future upgrades:** Enables new features like Taproot\n\n---\n\n## Summary Table\n\n| Lock Type | Opcode/Pattern | Use Case | Example |\n|-----------|---------------|----------|---------|\n| **Time Lock (Absolute)** | OP_CHECKLOCKTIMEVERIFY | Escrow, inheritance | Lock until block 6930300 |\n| **Time Lock (Relative)** | OP_CHECKSEQUENCEVERIFY | Payment channels | Lock for 1000 blocks |\n| **Multi-Signature** | OP_CHECKMULTISIG | Shared custody | 2-of-3 signatures required |\n| **Hash Preimage** | OP_HASH256 + OP_EQUALVERIFY | Oracle conditions | Secret must be revealed |\n| **Conditional** | OP_IF/OP_ELSE | Multiple paths | Different keys for different conditions |\n| **P2SH** | OP_HASH160 + OP_EQUAL | Complex scripts | Script hash in output |\n| **Anyone-Can-Spend** | OP_RETURN | Data storage | Burn coins, store data |\n\n---\n\n## Key Takeaways\n\n1. **OP_DUP in P2PKH:** Duplicates the public key so we can both hash it (to verify ownership) and use it (to verify signature)\n\n2. **Transaction locks serve many purposes:**\n   - Security (multisig, time locks)\n   - Automation (oracle-based conditions)\n   - Flexibility (conditional spending paths)\n   - Efficiency (P2SH, SegWit)\n\n3. **Locks can be combined:** You can have time-locked multisig, conditional preimage locks, etc.\n\n4. **Scripts execute when spending:** The locking script is stored with the output, but only executes when someone tries to spend it\n\n5. **All locks are cryptographic:** They rely on mathematical properties (hashes, signatures, time) rather than trusted third parties\n",
    "filename": "execution.md"
  },
  "/docs/bitcoin/op-codes": {
    "content": "# Bitcoin OP Codes\n\nBitcoin Script uses a stack-based programming language with various opcodes (operation codes) that perform different functions. This document provides a list of Bitcoin OP codes with explanations and code examples.\n\n## OP Code Categories\n\nBitcoin OP codes can be categorized into several groups:\n- **Stack Operations**: Manipulate the stack\n- **Arithmetic Operations**: Mathematical operations\n- **Cryptographic Operations**: Hash functions and signature verification\n- **Bitwise Operations**: Logical operations on bits\n- **Control Flow**: Conditional execution\n- **String Operations**: String manipulation\n- **Splice Operations**: Data manipulation\n- **Reserved/Disabled**: Opcodes that are disabled or reserved\n\n## Stack Operations\n\n### OP_DUP\n**Code**: `0x76`  \n**Function**: Duplicates the top stack item  \n**Example**:\n```\nStack before: [value]\nOP_DUP\nStack after: [value, value]\n```\n\n### OP_DROP\n**Code**: `0x75`  \n**Function**: Removes the top stack item  \n**Example**:\n```\nStack before: [value1, value2]\nOP_DROP\nStack after: [value1]\n```\n\n### OP_SWAP\n**Code**: `0x7c`  \n**Function**: Swaps the top two stack items  \n**Example**:\n```\nStack before: [value1, value2]\nOP_SWAP\nStack after: [value2, value1]\n```\n\n### OP_OVER\n**Code**: `0x78`  \n**Function**: Copies the second-to-top stack item to the top  \n**Example**:\n```\nStack before: [value1, value2]\nOP_OVER\nStack after: [value1, value2, value1]\n```\n\n### OP_ROT\n**Code**: `0x79`  \n**Function**: Rotates the top three stack items  \n**Example**:\n```\nStack before: [value1, value2, value3]\nOP_ROT\nStack after: [value2, value3, value1]\n```\n\n### OP_2DROP\n**Code**: `0x6d`  \n**Function**: Removes the top two stack items  \n**Example**:\n```\nStack before: [value1, value2, value3]\nOP_2DROP\nStack after: [value1]\n```\n\n### OP_2DUP\n**Code**: `0x6e`  \n**Function**: Duplicates the top two stack items  \n**Example**:\n```\nStack before: [value1, value2]\nOP_2DUP\nStack after: [value1, value2, value1, value2]\n```\n\n## Arithmetic Operations\n\n### OP_ADD\n**Code**: `0x93`  \n**Function**: Adds the top two stack items  \n**Example**:\n```\nStack before: [5, 3]\nOP_ADD\nStack after: [8]\n```\n\n### OP_SUB\n**Code**: `0x94`  \n**Function**: Subtracts the top stack item from the second-to-top  \n**Example**:\n```\nStack before: [5, 3]\nOP_SUB\nStack after: [2]\n```\n\n### OP_MUL\n**Code**: `0x95`  \n**Function**: Multiplies the top two stack items  \n**Example**:\n```\nStack before: [5, 3]\nOP_MUL\nStack after: [15]\n```\n\n### OP_DIV\n**Code**: `0x96`  \n**Function**: Divides the second-to-top by the top stack item  \n**Example**:\n```\nStack before: [15, 3]\nOP_DIV\nStack after: [5]\n```\n\n### OP_MOD\n**Code**: `0x97`  \n**Function**: Computes modulo (remainder) of division  \n**Example**:\n```\nStack before: [7, 3]\nOP_MOD\nStack after: [1]\n```\n\n### OP_LSHIFT\n**Code**: `0x98`  \n**Function**: Left bitwise shift  \n**Example**:\n```\nStack before: [4, 2]  (4 << 2)\nOP_LSHIFT\nStack after: [16]\n```\n\n### OP_RSHIFT\n**Code**: `0x99`  \n**Function**: Right bitwise shift  \n**Example**:\n```\nStack before: [16, 2]  (16 >> 2)\nOP_RSHIFT\nStack after: [4]\n```\n\n## Comparison Operations\n\n### OP_EQUAL\n**Code**: `0x87`  \n**Function**: Returns 1 if inputs are equal, 0 otherwise  \n**Example**:\n```\nStack before: [value1, value2]\nOP_EQUAL\nStack after: [1]  (if equal) or [0] (if not equal)\n```\n\n### OP_EQUALVERIFY\n**Code**: `0x88`  \n**Function**: Same as OP_EQUAL but runs OP_VERIFY afterward  \n**Example**:\n```\nStack before: [value1, value2]\nOP_EQUALVERIFY\nStack after: []  (if equal, script continues; if not, script fails)\n```\n\n### OP_1ADD\n**Code**: `0x8b`  \n**Function**: Adds 1 to the top stack item  \n**Example**:\n```\nStack before: [5]\nOP_1ADD\nStack after: [6]\n```\n\n### OP_1SUB\n**Code**: `0x8c`  \n**Function**: Subtracts 1 from the top stack item  \n**Example**:\n```\nStack before: [5]\nOP_1SUB\nStack after: [4]\n```\n\n### OP_NEGATE\n**Code**: `0x8f`  \n**Function**: Negates the top stack item  \n**Example**:\n```\nStack before: [5]\nOP_NEGATE\nStack after: [-5]\n```\n\n### OP_ABS\n**Code**: `0x90`  \n**Function**: Absolute value of the top stack item  \n**Example**:\n```\nStack before: [-5]\nOP_ABS\nStack after: [5]\n```\n\n### OP_NOT\n**Code**: `0x91`  \n**Function**: Returns 1 if input is 0, 0 otherwise  \n**Example**:\n```\nStack before: [0]\nOP_NOT\nStack after: [1]\n\nStack before: [5]\nOP_NOT\nStack after: [0]\n```\n\n### OP_0NOTEQUAL\n**Code**: `0x92`  \n**Function**: Returns 1 if input is not 0, 0 otherwise  \n**Example**:\n```\nStack before: [5]\nOP_0NOTEQUAL\nStack after: [1]\n\nStack before: [0]\nOP_0NOTEQUAL\nStack after: [0]\n```\n\n## Cryptographic Operations\n\n### OP_RIPEMD160\n**Code**: `0xa6`  \n**Function**: Computes RIPEMD-160 hash  \n**Example**:\n```\nStack before: [data]\nOP_RIPEMD160\nStack after: [hash160_result]\n```\n\n### OP_SHA1\n**Code**: `0xa7`  \n**Function**: Computes SHA-1 hash  \n**Example**:\n```\nStack before: [data]\nOP_SHA1\nStack after: [sha1_result]\n```\n\n### OP_SHA256\n**Code**: `0xa8`  \n**Function**: Computes SHA-256 hash  \n**Example**:\n```\nStack before: [data]\nOP_SHA256\nStack after: [sha256_result]\n```\n\n### OP_HASH160\n**Code**: `0xa9`  \n**Function**: Computes SHA-256 then RIPEMD-160 (used in P2PKH)  \n**Example**:\n```\nStack before: [public_key]\nOP_HASH160\nStack after: [hash160(sha256(public_key))]\n```\n\n### OP_HASH256\n**Code**: `0xaa`  \n**Function**: Computes double SHA-256 (used in block hashing)  \n**Example**:\n```\nStack before: [data]\nOP_HASH256\nStack after: [sha256(sha256(data))]\n```\n\n### OP_CHECKSIG\n**Code**: `0xac`  \n**Function**: Verifies a signature against a public key  \n**Example**:\n```\nStack before: [signature, public_key]\nOP_CHECKSIG\nStack after: [1]  (if valid) or [0] (if invalid)\n```\n\n### OP_CHECKSIGVERIFY\n**Code**: `0xad`  \n**Function**: Same as OP_CHECKSIG but runs OP_VERIFY afterward  \n**Example**:\n```\nStack before: [signature, public_key]\nOP_CHECKSIGVERIFY\nStack after: []  (if valid, script continues; if invalid, script fails)\n```\n\n### OP_CHECKMULTISIG\n**Code**: `0xae`  \n**Function**: Verifies multiple signatures against multiple public keys  \n**Example**:\n```\nStack before: [sig1, sig2, pubkey1, pubkey2, pubkey3, 2, 3]\nOP_CHECKMULTISIG\nStack after: [1]  (if 2 of 3 signatures are valid)\n```\n\n### OP_CHECKMULTISIGVERIFY\n**Code**: `0xaf`  \n**Function**: Same as OP_CHECKMULTISIG but runs OP_VERIFY afterward  \n\n## Bitwise Operations\n\n### OP_AND\n**Code**: `0x84`  \n**Function**: Bitwise AND operation  \n**Example**:\n```\nStack before: [0b1010, 0b1100]  (10, 12)\nOP_AND\nStack after: [0b1000]  (8)\n```\n\n### OP_OR\n**Code**: `0x85`  \n**Function**: Bitwise OR operation  \n**Example**:\n```\nStack before: [0b1010, 0b1100]  (10, 12)\nOP_OR\nStack after: [0b1110]  (14)\n```\n\n### OP_XOR\n**Code**: `0x86`  \n**Function**: Bitwise XOR operation  \n**Example**:\n```\nStack before: [0b1010, 0b1100]  (10, 12)\nOP_XOR\nStack after: [0b0110]  (6)\n```\n\n## Control Flow\n\n### OP_IF\n**Code**: `0x63`  \n**Function**: If the top stack item is not 0, statements are executed  \n**Example**:\n```\nOP_IF\n  <statements>\nOP_ENDIF\n```\n\n### OP_NOTIF\n**Code**: `0x64`  \n**Function**: If the top stack item is 0, statements are executed  \n**Example**:\n```\nOP_NOTIF\n  <statements>\nOP_ENDIF\n```\n\n### OP_ELSE\n**Code**: `0x67`  \n**Function**: Marks the beginning of an else block  \n**Example**:\n```\nOP_IF\n  <statements>\nOP_ELSE\n  <statements>\nOP_ENDIF\n```\n\n### OP_ENDIF\n**Code**: `0x68`  \n**Function**: Ends an if/else block  \n\n### OP_VERIFY\n**Code**: `0x69`  \n**Function**: Marks transaction as invalid if top stack value is not true  \n**Example**:\n```\nStack before: [1]\nOP_VERIFY\nStack after: []  (script continues)\n\nStack before: [0]\nOP_VERIFY\nStack after: []  (script fails, transaction invalid)\n```\n\n### OP_RETURN\n**Code**: `0x6a`  \n**Function**: Immediately marks transaction as invalid (used for data storage)  \n**Example**:\n```\nOP_RETURN <data>\n# Transaction is invalid, but data is stored on blockchain\n```\n\n## Time Lock Operations\n\n### OP_CHECKLOCKTIMEVERIFY (CLTV)\n**Code**: `0xb1`  \n**Function**: Verifies that transaction is locked until a specific time/block  \n**Example**:\n```\n<locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\n### OP_CHECKSEQUENCEVERIFY (CSV)\n**Code**: `0xb2`  \n**Function**: Verifies relative time lock (used in Lightning Network)  \n**Example**:\n```\n<relative_locktime> OP_CHECKSEQUENCEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\n## Push Operations\n\n### OP_PUSHDATA1 through OP_PUSHDATA75\n**Codes**: `0x01` - `0x4b`  \n**Function**: Push data onto the stack  \n**Example**:\n```\nOP_PUSHDATA1 <length> <data>\n```\n\n### OP_0 / OP_FALSE\n**Code**: `0x00`  \n**Function**: Pushes empty array (interpreted as false)  \n\n### OP_1 through OP_16\n**Codes**: `0x51` - `0x60`  \n**Function**: Push numbers 1-16 onto the stack  \n**Example**:\n```\nOP_1  # Pushes 1\nOP_5  # Pushes 5\nOP_16 # Pushes 16\n```\n\n### OP_1NEGATE\n**Code**: `0x4f`  \n**Function**: Pushes -1 onto the stack  \n\n## Reserved/Disabled Opcodes\n\nMany opcodes are reserved or disabled for security reasons:\n- **OP_CAT** (0x7e): Disabled - could be used to create large scripts\n- **OP_SUBSTR** (0x7f): Disabled\n- **OP_LEFT** (0x80): Disabled\n- **OP_RIGHT** (0x81): Disabled\n- **OP_INVERT** (0x83): Disabled\n- **OP_2MUL** (0x8d): Disabled\n- **OP_2DIV** (0x8e): Disabled\n\n## Common Script Patterns\n\n### P2PKH (Pay-to-Pubkey-Hash)\n```\nLocking Script:\nOP_DUP OP_HASH160 <pubkeyhash> OP_EQUALVERIFY OP_CHECKSIG\n\nUnlocking Script:\n<signature> <publickey>\n```\n\n### P2SH (Pay-to-Script-Hash)\n```\nLocking Script:\nOP_HASH160 <scripthash> OP_EQUAL\n\nUnlocking Script:\n<redeem_script> <signatures...>\n```\n\n### Multisig (2-of-3)\n```\nLocking Script:\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n\nUnlocking Script:\nOP_0 <signature1> <signature2>\n```\n\n### Time Lock\n```\nLocking Script:\n<locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n\nUnlocking Script:\n<signature>\n```\n\n## OP Code Reference Table\n\n| OP Code | Hex | Name | Function | Status |\n|---------|-----|------|----------|--------|\n| 0x00 | OP_0 | Push empty array | Pushes false | âœ… Active |\n| 0x51-0x60 | OP_1-OP_16 | Push 1-16 | Pushes number | âœ… Active |\n| 0x63 | OP_IF | If statement | Conditional execution | âœ… Active |\n| 0x64 | OP_NOTIF | If not statement | Conditional execution | âœ… Active |\n| 0x67 | OP_ELSE | Else block | Conditional execution | âœ… Active |\n| 0x68 | OP_ENDIF | End if block | Ends conditional | âœ… Active |\n| 0x69 | OP_VERIFY | Verify | Checks top stack item | âœ… Active |\n| 0x6a | OP_RETURN | Return | Marks invalid, stores data | âœ… Active |\n| 0x75 | OP_DROP | Drop | Removes top stack item | âœ… Active |\n| 0x76 | OP_DUP | Duplicate | Duplicates top stack item | âœ… Active |\n| 0x77 | OP_NIP | Nip | Removes second stack item | âœ… Active |\n| 0x78 | OP_OVER | Over | Copies second-to-top | âœ… Active |\n| 0x79 | OP_ROT | Rotate | Rotates top 3 items | âœ… Active |\n| 0x7a | OP_SWAP | Swap | Swaps top 2 items | âœ… Active |\n| 0x7c | OP_SWAP | Swap | Swaps top 2 items | âœ… Active |\n| 0x87 | OP_EQUAL | Equal | Checks equality | âœ… Active |\n| 0x88 | OP_EQUALVERIFY | Equal verify | Equal + verify | âœ… Active |\n| 0x93 | OP_ADD | Add | Addition | âœ… Active |\n| 0x94 | OP_SUB | Subtract | Subtraction | âœ… Active |\n| 0x95 | OP_MUL | Multiply | Multiplication | âœ… Active |\n| 0x96 | OP_DIV | Divide | Division | âœ… Active |\n| 0x97 | OP_MOD | Modulo | Remainder | âœ… Active |\n| 0xa6 | OP_RIPEMD160 | RIPEMD-160 | Hash function | âœ… Active |\n| 0xa7 | OP_SHA1 | SHA-1 | Hash function | âœ… Active |\n| 0xa8 | OP_SHA256 | SHA-256 | Hash function | âœ… Active |\n| 0xa9 | OP_HASH160 | Hash160 | SHA256 + RIPEMD160 | âœ… Active |\n| 0xaa | OP_HASH256 | Hash256 | Double SHA-256 | âœ… Active |\n| 0xac | OP_CHECKSIG | Check signature | Verifies signature | âœ… Active |\n| 0xad | OP_CHECKSIGVERIFY | Check sig verify | Checksig + verify | âœ… Active |\n| 0xae | OP_CHECKMULTISIG | Check multisig | Verifies multiple sigs | âœ… Active |\n| 0xaf | OP_CHECKMULTISIGVERIFY | Check multisig verify | Multisig + verify | âœ… Active |\n| 0xb1 | OP_CHECKLOCKTIMEVERIFY | CLTV | Absolute time lock | âœ… Active |\n| 0xb2 | OP_CHECKSEQUENCEVERIFY | CSV | Relative time lock | âœ… Active |\n\n## Related Topics\n\n- [Script System](/docs/bitcoin/script) - How Bitcoin Script works\n- [OP_RETURN Debate](/docs/controversies/op-return) - Controversy about OP_RETURN usage\n",
    "filename": "codes.md"
  },
  "/docs/bitcoin/blocks": {
    "content": "# Bitcoin Network Block Propagation\n\nThis document explains how blocks propagate through the Bitcoin network, including the gossip protocol, validation process, and orphan block handling.\n\n## Block Propagation Flow\n\n### 1. Block Discovery and Initial Broadcast\n\nWhen a miner finds a new block:\n\n1. **Miner solves proof-of-work puzzle** - Finds a valid nonce\n2. **Creates valid block** - Includes transactions from mempool\n3. **Immediately broadcasts** - Sends to all connected peers (8-10 first-hop nodes)\n4. **First-hop nodes validate** - Each node checks the block\n5. **First-hop nodes forward** - Send to their peers (50-100 second-hop nodes)\n6. **Your node receives** - Eventually gets the block from one or more peers\n7. **Your node validates** - Thoroughly checks the block\n8. **Your node forwards** - Sends to peers who haven't seen it yet\n\n### 2. Gossip Protocol Mechanism\n\n**Key Rule**: Nodes never re-broadcast blocks back to the peer that sent them.\n\n**What happens:**\n- Peer A sends you the block\n- You validate and accept it\n- You forward to Peers D, E, F (but NOT back to Peer A)\n- This prevents infinite loops and network flooding\n\n### 3. Block Validation Process\n\nEach node performs comprehensive validation:\n\n1. **Header Validation**\n   - Proof-of-work meets difficulty target\n   - Timestamp is reasonable\n   - Version is acceptable\n   - Previous block hash is correct\n\n2. **Transaction Validation**\n   - All transactions are valid\n   - No double-spends\n   - Proper signatures\n   - UTXO references are correct\n   - Consensus rules compliance\n\n3. **Merkle Tree Verification**\n   - Merkle root matches transactions\n   - Tree structure is valid\n\n4. **Chain Validity**\n   - Builds on valid previous block\n   - Maintains blockchain integrity\n\n## Orphan Block Scenarios\n\n### Simultaneous Block Discovery\n\nSometimes two miners find blocks at nearly the same time, creating a temporary fork:\n\n```\nBlock 850,000 (everyone agrees)\n       â”‚\n       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n       â”‚             â”‚             â”‚\n  Block A      Block B (orphan) Block C\n  (main chain)      â”‚\n       â”‚        Block D\n  Block E       (also orphaned)\n  (main chain)\n       â”‚\n    Winner!\n```\n\n### Timeline of Fork Resolution\n\n```\nTime 0:00    Miner A finds Block A\nTime 0:01    Miner B finds Block B (almost simultaneously)\nTime 0:02    Network splits - some nodes see A first, others see B\nTime 0:05    Some miners start building on Block A\nTime 0:06    Other miners start building on Block B\nTime 0:10    Block E found building on Block A\nTime 0:11    Chain A is now longer (more proof-of-work)\nTime 0:12    All nodes converge on Chain A\nTime 0:13    Block B and Block D become orphans\nTime 0:14    Orphaned transactions return to mempool\n```\n\n### What Happens to Orphaned Blocks\n\n- Block B and Block D are discarded\n- Unique transactions from orphans return to mempool\n- Miners' work on orphaned blocks is wasted\n- Network automatically converges on longest chain\n- This is why exchanges wait for 6 confirmations\n\n## Propagation Timing\n\n### Typical Network Performance\n\n- **Time 0:00**: Miner finds block\n- **Time 0:01**: First-hop nodes receive and validate\n- **Time 0:02**: Second-hop nodes receive\n- **Time 0:05**: Your node receives block\n- **Time 0:10**: Most of network has the block\n- **Time 0:30**: Entire network is synchronized\n\n**Average propagation time**: 10-30 seconds\n**Fast propagation**: 5-10 seconds\n**Slow propagation**: 30-60 seconds\n\n### Factors Affecting Propagation Speed\n\n**Fast Propagation:**\n- Well-connected nodes (many peers)\n- High-bandwidth connections\n- Geographic proximity to miners\n- Low network congestion\n\n**Slow Propagation:**\n- Few peer connections\n- Low-bandwidth connections\n- Geographic distance from miners\n- Network congestion\n- Firewall restrictions\n\n## Network Topology\n\n### Typical Node Connections\n\nA typical Bitcoin node has:\n- **8-10 outbound connections** - You connect TO other nodes\n- **8-10 inbound connections** - Other nodes connect TO you\n- **Total: 16-20 peer connections**\n\n### Connection Types\n\n**Inbound Connections (to your node):**\n- Other nodes connect TO you\n- You provide blocks to them\n- Limited by your upload bandwidth\n\n**Outbound Connections (from your node):**\n- You connect TO other nodes\n- You request blocks from them\n- Limited by your download bandwidth\n\n## Security Considerations\n\n### Why Validation is Critical\n\nEvery node validates every block because:\n\n- **No central authority to trust**\n- **Prevents invalid blocks from spreading**\n- **Ensures consensus rules are followed**\n- **Protects against malicious actors**\n- **Maintains network integrity**\n\nIf a node doesn't validate:\n- It could spread invalid blocks\n- It could be tricked by attackers\n- It could harm the network\n\n### Economic Incentives\n\n**Miners are incentivized to:**\n- Find blocks quickly (first to market)\n- Broadcast blocks immediately (avoid orphaning)\n- Include high-fee transactions\n- Follow consensus rules (avoid rejection)\n\n**Nodes are incentivized to:**\n- Validate blocks (maintain network health)\n- Relay blocks quickly (help the network)\n- Stay connected (receive updates)\n\n## Monitoring Block Propagation\n\n### What You Can Observe\n\nWhen monitoring your node, you can track:\n\n1. **Block Arrival Time**: When your node receives a new block\n2. **Peer Information**: Which peers are connected and their characteristics\n3. **Propagation Timing**: Time between blocks\n4. **Network Health**: Connection quality and peer diversity\n5. **Validation Performance**: How quickly your node validates blocks\n\n### Key Metrics\n\n- **Block interval**: Time between consecutive blocks (target: 10 minutes)\n- **Propagation delay**: Time from block discovery to your node receiving it\n- **Peer count**: Number of active connections\n- **Bandwidth usage**: Data transferred to/from peers\n- **Validation time**: How long your node takes to validate blocks\n\n## Conclusion\n\nBitcoin's block propagation mechanism is designed to be:\n\n- **Decentralized**: No single point of failure\n- **Resilient**: Multiple paths for block propagation\n- **Secure**: Every node validates every block\n- **Efficient**: Gossip protocol prevents network flooding\n- **Self-healing**: Orphan blocks are automatically resolved\n\nUnderstanding this process helps explain why Bitcoin is robust and why your node plays an important role in maintaining network health.\n\n## Resources\n\n- **[mempool.space](https://mempool.space)** - Real-time block explorer and mempool visualization\n",
    "filename": "propagation.md"
  },
  "/docs/bitcoin/subsidy": {
    "content": "# The Bitcoin Subsidy Equation\n\nThe Bitcoin block subsidy is the amount of new Bitcoin created with each block. It follows a predictable mathematical formula that halves every 210,000 blocks, creating Bitcoin's fixed supply schedule.\n\n## The Equation\n\n### Mathematical Formula\n\n```\nBlock Subsidy = 50 / (2^halvings)\n\nWhere:\n  halvings = block_height / 210,000\n```\n\n### Implementation\n\nIn Bitcoin Core (`validation.cpp`):\n\n```cpp\nCAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n{\n    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;\n    // Force block reward to zero when right shift is undefined.\n    if (halvings >= 64)\n        return 0;\n\n    CAmount nSubsidy = 50 * COIN;\n    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n    nSubsidy >>= halvings;\n    return nSubsidy;\n}\n```\n\n### Code Implementation\n\n:::code-group\n```rust\n/// Calculate block subsidy based on block height.\n///\n/// # Arguments\n///\n/// * `block_height` - Current block height\n///\n/// # Returns\n///\n/// Block subsidy in BTC\nfn get_block_subsidy(block_height: u64) -> f64 {\n    let halvings = block_height / 210_000;\n    let block_subsidy = 50.0 / (2.0_f64.powi(halvings as i32));\n    block_subsidy\n}\n```\n\n```python\ndef get_block_subsidy(block_height):\n    \"\"\"\n    Calculate block subsidy based on block height.\n    \n    Args:\n        block_height: Current block height\n        \n    Returns:\n        Block subsidy in BTC\n    \"\"\"\n    halvings = block_height // 210000\n    block_subsidy = 50.0 / (2 ** halvings)\n    return block_subsidy\n```\n\n```cpp\n#include <cstdint>\n#include <cmath>\n\n/**\n * Calculate block subsidy based on block height.\n * \n * @param block_height Current block height\n * @return Block subsidy in BTC\n */\ndouble get_block_subsidy(uint64_t block_height) {\n    uint64_t halvings = block_height / 210000;\n    double block_subsidy = 50.0 / std::pow(2.0, static_cast<double>(halvings));\n    return block_subsidy;\n}\n```\n\n```javascript\n/**\n * Calculate block subsidy based on block height.\n * \n * @param {number} blockHeight - Current block height\n * @returns {number} Block subsidy in BTC\n */\nfunction getBlockSubsidy(blockHeight) {\n    const halvings = Math.floor(blockHeight / 210000);\n    const blockSubsidy = 50.0 / Math.pow(2, halvings);\n    return blockSubsidy;\n}\n```\n:::\n\n## How It Works\n\n### Step-by-Step Calculation\n\n1. **Calculate Halvings**: Divide block height by 210,000\n   ```\n   halvings = block_height / 210000\n   ```\n\n2. **Apply Exponential Decay**: Divide initial subsidy by 2^halvings\n   ```\n   subsidy = 50 / (2^halvings)\n   ```\n\n3. **Result**: The block subsidy in BTC\n\n### Example Calculations\n\n**Block 0 (Genesis Block):**\n```\nhalvings = 0 / 210000 = 0\nsubsidy = 50 / (2^0) = 50 / 1 = 50 BTC\n```\n\n**Block 210,000 (First Halving):**\n```\nhalvings = 210000 / 210000 = 1\nsubsidy = 50 / (2^1) = 50 / 2 = 25 BTC\n```\n\n**Block 420,000 (Second Halving):**\n```\nhalvings = 420000 / 210000 = 2\nsubsidy = 50 / (2^2) = 50 / 4 = 12.5 BTC\n```\n\n**Block 630,000 (Third Halving):**\n```\nhalvings = 630000 / 210000 = 3\nsubsidy = 50 / (2^3) = 50 / 8 = 6.25 BTC\n```\n\n**Block 840,000 (Fourth Halving):**\n```\nhalvings = 840000 / 210000 = 4\nsubsidy = 50 / (2^4) = 50 / 16 = 3.125 BTC\n```\n\n**Block 1,050,000 (Fifth Halving):**\n```\nhalvings = 1050000 / 210000 = 5\nsubsidy = 50 / (2^5) = 50 / 32 = 1.5625 BTC\n```\n\n### Total Supply Calculation\n\nThe total Bitcoin supply follows a geometric series:\n\n```\nTotal Supply = 210,000 Ã— 50 Ã— (1 + 1/2 + 1/4 + 1/8 + ...)\n             = 210,000 Ã— 50 Ã— 2\n             = 21,000,000 BTC\n```\n\n**Key Points:**\n- Each halving period creates 210,000 blocks\n- Each period creates half the Bitcoin of the previous period\n- The series converges to exactly 21 million BTC\n- After 64 halvings, the subsidy becomes 0\n\n## Economic Implications\n\n### Supply Schedule\n\nThe subsidy equation creates a **predictable and decreasing supply**:\n\n1. **Fixed Total Supply**: Exactly 21 million BTC will ever exist\n2. **Exponential Decay**: Supply growth decreases exponentially\n3. **Predictable**: Everyone knows the exact supply schedule\n4. **No Surprises**: No sudden changes or arbitrary adjustments\n\n### Mining Economics\n\n**Block Reward = Block Subsidy + Transaction Fees**\n\n- **Early Years**: Subsidy dominated (50 BTC >> fees)\n- **Current Era**: Fees becoming more important (3.125 BTC + fees)\n- **Future**: Fees will be primary income source (subsidy â†’ 0)\n\n### Inflation Rate\n\nBitcoin's inflation rate decreases over time:\n\n```\nInflation Rate = (New BTC per year) / (Total BTC in circulation) Ã— 100%\n\nExample:\n- New BTC per year: 3.125 Ã— 6 Ã— 24 Ã— 365 â‰ˆ 164,250 BTC (after 4 halvings)\n- Total in circulation: ~19,700,000 BTC\n- Inflation rate: ~0.83% per year\n```\n\n**Trend:**\n- **Early periods**: Very high inflation (small base, high issuance)\n- **Mid periods**: Moderate inflation (decreasing issuance)\n- **Later periods**: Low inflation (<1% per year)\n- **Future**: Eventually becomes deflationary (lower than gold)\n\n## Key Properties\n\n### 1. Predictability\n\n- **Exact Formula**: No ambiguity about future supply\n- **Transparent**: Anyone can calculate supply at any time\n- **Unchangeable**: Requires consensus to modify (extremely unlikely)\n\n### 2. Scarcity\n\n- **Fixed Supply**: 21 million BTC maximum\n- **Decreasing Issuance**: New supply decreases over time\n- **Deflationary**: Eventually becomes deflationary (more lost than created)\n\n### 3. Security\n\n- **Mining Incentive**: Subsidy rewards miners for securing the network\n- **Transition to Fees**: As subsidy decreases, fees become more important\n- **Long-term Security**: Fee market must support network security\n\n## Block Reward Components\n\n### Total Block Reward\n\n```\nTotal Block Reward = Block Subsidy + Transaction Fees\n```\n\n**Example:**\n```\nBlock Subsidy: 3.125 BTC (after 4 halvings)\nTransaction Fees: 0.5 BTC\nTotal Block Reward: 3.625 BTC\n```\n\n### Fee Percentage\n\nAs subsidy decreases, fees become a larger percentage of block rewards. The relationship follows:\n\n- **Early halvings**: Fees are small percentage of total reward\n- **Later halvings**: Fees become increasingly important\n- **Future**: Fees will be primary source of miner income\n\n## Implementation Details\n\n### Halving Interval\n\n- **Blocks per Halving**: 210,000 blocks\n- **Time per Halving**: ~4 years (at 10 minutes per block)\n- **Calculation**: 210,000 Ã— 10 minutes = 2,100,000 minutes â‰ˆ 4 years\n\n### Precision\n\n- **Initial Subsidy**: 50 BTC = 5,000,000,000 satoshis\n- **After 33 Halvings**: 50 / (2^33) â‰ˆ 0.000000006 BTC â‰ˆ 0.6 satoshis\n- **After 34 Halvings**: Effectively 0 (less than 1 satoshi)\n\n### Edge Cases\n\n**Block Height 0 (Genesis Block):**\n- Halvings = 0\n- Subsidy = 50 BTC\n\n**Block Height Exactly at Halving:**\n- Block 210,000: halvings = 1, subsidy = 25 BTC\n- Block 420,000: halvings = 2, subsidy = 12.5 BTC\n\n**Very High Block Heights:**\n- After 64 halvings (block 13,440,000), subsidy = 0\n- This is far in the future (~2140+)\n\n## Visual Representation\n\nThe subsidy equation creates a **step function** that halves every 210,000 blocks:\n\n```\nSubsidy (BTC)\n      â”‚\n50    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n25    â”‚        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n12.5  â”‚                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n6.25  â”‚                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n3.125 â”‚                                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n1.5625â”‚                                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n      â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Blocks\n       0      210k    420k    630k    840k    1050k\n```\n\n## Code Examples\n\n### Calculate Subsidy for Any Block\n\n:::code-group\n```rust\nfn calculate_subsidy(block_height: u64) -> f64 {\n    let halvings = block_height / 210_000;\n    if halvings >= 64 {\n        return 0.0;\n    }\n    50.0 / 2.0_f64.powi(halvings as i32)\n}\n\n// Examples\nfn main() {\n    println!(\"{}\", calculate_subsidy(0));        // 50.0\n    println!(\"{}\", calculate_subsidy(210_000));  // 25.0\n    println!(\"{}\", calculate_subsidy(840_000));  // 3.125\n    println!(\"{}\", calculate_subsidy(1_050_000)); // 1.5625\n}\n```\n\n```python\ndef calculate_subsidy(block_height):\n    \"\"\"Calculate block subsidy for given height.\"\"\"\n    halvings = block_height // 210000\n    if halvings >= 64:\n        return 0\n    return 50.0 / (2 ** halvings)\n\n# Examples\nprint(calculate_subsidy(0))        # 50.0\nprint(calculate_subsidy(210000))   # 25.0\nprint(calculate_subsidy(840000))   # 3.125\nprint(calculate_subsidy(1050000))  # 1.5625\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cmath>\n\ndouble calculate_subsidy(uint64_t block_height) {\n    uint64_t halvings = block_height / 210000;\n    if (halvings >= 64) {\n        return 0.0;\n    }\n    return 50.0 / std::pow(2.0, static_cast<double>(halvings));\n}\n\n// Examples\nint main() {\n    std::cout << calculate_subsidy(0) << std::endl;        // 50.0\n    std::cout << calculate_subsidy(210000) << std::endl;   // 25.0\n    std::cout << calculate_subsidy(840000) << std::endl;   // 3.125\n    std::cout << calculate_subsidy(1050000) << std::endl;  // 1.5625\n    return 0;\n}\n```\n\n```javascript\nfunction calculateSubsidy(blockHeight) {\n    const halvings = Math.floor(blockHeight / 210000);\n    if (halvings >= 64) {\n        return 0;\n    }\n    return 50.0 / Math.pow(2, halvings);\n}\n\n// Examples\nconsole.log(calculateSubsidy(0));        // 50.0\nconsole.log(calculateSubsidy(210000));   // 25.0\nconsole.log(calculateSubsidy(840000));   // 3.125\nconsole.log(calculateSubsidy(1050000));  // 1.5625\n```\n:::\n\n### Calculate Total Supply Up to Block\n\n:::code-group\n```rust\nfn total_supply_up_to_block(block_height: u64) -> f64 {\n    let mut total = 0.0;\n    let mut current_height: u64 = 0;\n    \n    while current_height <= block_height {\n        let halvings = current_height / 210_000;\n        if halvings >= 64 {\n            break;\n        }\n        \n        let period_start = halvings * 210_000;\n        let period_end = std::cmp::min((halvings + 1) * 210_000, block_height + 1);\n        let blocks_in_period = period_end - period_start;\n        \n        let subsidy = 50.0 / 2.0_f64.powi(halvings as i32);\n        total += blocks_in_period as f64 * subsidy;\n        \n        current_height = period_end;\n    }\n    \n    total\n}\n\n// Example: Total supply calculation\nfn main() {\n    println!(\"{}\", total_supply_up_to_block(840_000)); // ~19,687,500 BTC\n}\n```\n\n```python\ndef total_supply_up_to_block(block_height):\n    \"\"\"Calculate total Bitcoin supply up to given block height.\"\"\"\n    total = 0\n    current_height = 0\n    \n    while current_height <= block_height:\n        halvings = current_height // 210000\n        if halvings >= 64:\n            break\n        \n        period_start = halvings * 210000\n        period_end = min((halvings + 1) * 210000, block_height + 1)\n        blocks_in_period = period_end - period_start\n        \n        subsidy = 50.0 / (2 ** halvings)\n        total += blocks_in_period * subsidy\n        \n        current_height = period_end\n    \n    return total\n\n# Example: Total supply calculation\nprint(total_supply_up_to_block(840000))  # ~19,687,500 BTC\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n\ndouble total_supply_up_to_block(uint64_t block_height) {\n    double total = 0.0;\n    uint64_t current_height = 0;\n    \n    while (current_height <= block_height) {\n        uint64_t halvings = current_height / 210000;\n        if (halvings >= 64) {\n            break;\n        }\n        \n        uint64_t period_start = halvings * 210000;\n        uint64_t period_end = std::min((halvings + 1) * 210000, block_height + 1);\n        uint64_t blocks_in_period = period_end - period_start;\n        \n        double subsidy = 50.0 / std::pow(2.0, static_cast<double>(halvings));\n        total += static_cast<double>(blocks_in_period) * subsidy;\n        \n        current_height = period_end;\n    }\n    \n    return total;\n}\n\n// Example: Total supply calculation\nint main() {\n    std::cout << total_supply_up_to_block(840000) << std::endl; // ~19,687,500 BTC\n    return 0;\n}\n```\n\n```javascript\nfunction totalSupplyUpToBlock(blockHeight) {\n    let total = 0;\n    let currentHeight = 0;\n    \n    while (currentHeight <= blockHeight) {\n        const halvings = Math.floor(currentHeight / 210000);\n        if (halvings >= 64) {\n            break;\n        }\n        \n        const periodStart = halvings * 210000;\n        const periodEnd = Math.min((halvings + 1) * 210000, blockHeight + 1);\n        const blocksInPeriod = periodEnd - periodStart;\n        \n        const subsidy = 50.0 / Math.pow(2, halvings);\n        total += blocksInPeriod * subsidy;\n        \n        currentHeight = periodEnd;\n    }\n    \n    return total;\n}\n\n// Example: Total supply calculation\nconsole.log(totalSupplyUpToBlock(840000)); // ~19,687,500 BTC\n```\n:::\n\n### Find Next Halving Block\n\n:::code-group\n```rust\nfn next_halving_block(current_height: u64) -> u64 {\n    let current_halvings = current_height / 210_000;\n    let next_halving_height = (current_halvings + 1) * 210_000;\n    next_halving_height\n}\n\n// Example\nfn main() {\n    println!(\"{}\", next_halving_block(850_000)); // 1050000\n}\n```\n\n```python\ndef next_halving_block(current_height):\n    \"\"\"Find the next halving block height.\"\"\"\n    current_halvings = current_height // 210000\n    next_halving_height = (current_halvings + 1) * 210000\n    return next_halving_height\n\n# Example\nprint(next_halving_block(850000))  # 1050000\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n\nuint64_t next_halving_block(uint64_t current_height) {\n    uint64_t current_halvings = current_height / 210000;\n    uint64_t next_halving_height = (current_halvings + 1) * 210000;\n    return next_halving_height;\n}\n\n// Example\nint main() {\n    std::cout << next_halving_block(850000) << std::endl; // 1050000\n    return 0;\n}\n```\n\n```javascript\nfunction nextHalvingBlock(currentHeight) {\n    const currentHalvings = Math.floor(currentHeight / 210000);\n    const nextHalvingHeight = (currentHalvings + 1) * 210000;\n    return nextHalvingHeight;\n}\n\n// Example\nconsole.log(nextHalvingBlock(850000)); // 1050000\n```\n:::\n\n## Economic Theory\n\n### Why This Design?\n\n1. **Predictable Scarcity**: Creates known, decreasing supply\n2. **Mining Incentive**: Rewards early adopters and miners\n3. **Fee Transition**: Gradually shifts to fee-based security\n4. **Deflationary**: Eventually becomes deflationary asset\n\n### Comparison to Traditional Money\n\n**Fiat Currency:**\n- Supply controlled by central banks\n- Can be increased arbitrarily\n- Inflation is policy decision\n\n**Bitcoin:**\n- Supply controlled by mathematical formula\n- Cannot be changed without consensus\n- Inflation decreases predictably\n\n## Security Considerations\n\n### Mining Incentives\n\n**Early Bitcoin:**\n- High subsidy (50 BTC) attracted miners\n- Security primarily from subsidy\n\n**Current Bitcoin:**\n- Moderate subsidy (3.125 BTC) + fees\n- Security from both subsidy and fees\n\n**Future Bitcoin:**\n- Low/no subsidy, primarily fees\n- Security must come from fee market\n\n### Fee Market Development\n\nAs subsidy decreases, the fee market becomes critical:\n\n1. **Transaction Demand**: More transactions = more fees\n2. **Block Space Competition**: Limited space increases fees\n3. **Network Security**: Fees must support mining costs\n\n## Summary\n\nThe Bitcoin subsidy equation:\n\n- **Formula**: `Subsidy = 50 / (2^halvings)` where `halvings = height / 210000`\n- **Halving Interval**: Every 210,000 blocks (~4 years)\n- **Total Supply**: Exactly 21 million BTC\n- **Future**: Subsidy decreases to 0, fees become primary income\n- **Economic Impact**: Creates predictable, decreasing inflation\n\nThis mathematical formula is fundamental to Bitcoin's monetary policy and ensures a fixed, predictable supply schedule that no central authority can change.\n\n---\n\n## Resources\n\n- **[Bitcoin Core Source: validation.cpp](https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp)** - Subsidy calculation implementation\n\n## References\n\n- [Bitcoin Wiki: Controlled Supply](https://en.bitcoin.it/wiki/Controlled_supply)\n",
    "filename": "equation.md"
  },
  "/docs/bitcoin/rpc": {
    "content": "# Bitcoin RPC Commands Reference\n\nThis document provides a guide for interacting with your Bitcoin [node](/docs/glossary#node) using both curl and bitcoin-cli commands via [RPC](/docs/glossary#rpc-remote-procedure-call).\n\n> **Try it live!** Test these commands directly in the [Bitcoin CLI Terminal](/terminal). Connected to mainnet, no setup required.\n\n## Quick Command Reference\n\n### Essential Commands\n- [1. Blockchain Information](#1-blockchain-information) - `btc getblockchaininfo`\n- [2. Network Information](#2-network-information) - `btc getnetworkinfo`\n- [3. Memory Pool Information](#3-memory-pool-information) - `btc getmempoolinfo`\n- [4. Block Information](#4-get-block-information) - `btc getblock`, `btc getbestblockhash`\n- [5. Transaction Information](#5-transaction-information) - `btc getrawtransaction`\n\n### Wallet Commands\n- [6. Wallet Information](#6-wallet-information) - `btc getwalletinfo`, `btc listwallets`\n- [7. Wallet Management](#13-wallet-management-commands) - `btc loadwallet`, `btc unloadwallet`\n\n### Advanced Monitoring\n- [8. Index Information](#7-index-information) - `btc getindexinfo`\n- [9. [UTXO Set](/docs/glossary#utxo-set) Information](#8-utxo-set-information) - `btc gettxoutsetinfo`\n- [10. [Peer](/docs/glossary#peer) Information](#9-peer-information) - `btc getpeerinfo`\n- [11. [ZMQ](/docs/glossary#zmq-zeromq) Notifications](#11-zmq-notifications) - Real-time [block](/docs/glossary#block) and [transaction](/docs/glossary#transaction) notifications\n\n### Quick Aliases\n```bash\n# Set up your alias (use environment variables for security)\n# Replace <path-to-bitcoin-cli> with your actual bitcoin-cli path\nalias btc='<path-to-bitcoin-cli> -rpcuser=$BITCOIN_RPC_USER -rpcpassword=$BITCOIN_RPC_PASSWORD -rpcport=$BITCOIN_RPC_PORT'\n\n# Most used commands\nbtc getblockchaininfo | jq '{blocks, verificationprogress}'\nbtc getindexinfo\nbtc getwalletinfo | jq '{walletname, txcount, balance}'\nbtc listwallets\n```\n\n### Security Setup\n\n```bash\n# Set environment variables (replace with your actual credentials)\nexport BITCOIN_RPC_USER=\"your_username\"\nexport BITCOIN_RPC_PASSWORD=\"your_password\"\nexport BITCOIN_RPC_PORT=\"8332\"\n\n# Configure RPC credentials securely\n# Use your preferred method for secure credential storage\n```\n\n## Basic RPC Structure\n\n```bash\n# Set up alias for easier use\n# Replace <path-to-bitcoin-cli> with your actual bitcoin-cli path\nalias btc='<path-to-bitcoin-cli> -rpcuser=$BITCOIN_RPC_USER -rpcpassword=$BITCOIN_RPC_PASSWORD -rpcport=$BITCOIN_RPC_PORT'\n\n# Then use simple commands\nbtc <method_name> [parameters]\n```\n\n## Programmatic RPC Access\n\nFor building applications, you can interact with Bitcoin Core RPC programmatically:\n\n:::code-group\n```rust\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\nuse std::collections::HashMap;\n\n#[derive(Serialize)]\nstruct RpcRequest {\n    jsonrpc: &'static str,\n    id: &'static str,\n    method: String,\n    params: Vec<Value>,\n}\n\n#[derive(Deserialize)]\nstruct RpcResponse {\n    result: Option<Value>,\n    error: Option<Value>,\n}\n\n/// Centralized service for Bitcoin node RPC communication\nstruct BitcoinRPCService {\n    rpc_url: String,\n    rpc_user: String,\n    rpc_password: String,\n    client: Client,\n}\n\nimpl BitcoinRPCService {\n    fn new(rpc_url: &str, rpc_user: &str, rpc_password: &str) -> Self {\n        Self {\n            rpc_url: rpc_url.to_string(),\n            rpc_user: rpc_user.to_string(),\n            rpc_password: rpc_password.to_string(),\n            client: Client::builder()\n                .timeout(std::time::Duration::from_secs(5))\n                .build()\n                .unwrap(),\n        }\n    }\n\n    fn rpc_call(&self, method: &str, params: Vec<Value>) -> Result<Value, Box<dyn std::error::Error>> {\n        let request = RpcRequest {\n            jsonrpc: \"1.0\",\n            id: \"client\",\n            method: method.to_string(),\n            params,\n        };\n\n        let response: RpcResponse = self.client\n            .post(&self.rpc_url)\n            .basic_auth(&self.rpc_user, Some(&self.rpc_password))\n            .json(&request)\n            .send()?\n            .json()?;\n\n        Ok(response.result.unwrap_or(Value::Null))\n    }\n\n    // Convenience methods\n    fn get_blockchain_info(&self) -> Result<Value, Box<dyn std::error::Error>> {\n        self.rpc_call(\"getblockchaininfo\", vec![])\n    }\n\n    fn get_block_count(&self) -> Result<Value, Box<dyn std::error::Error>> {\n        self.rpc_call(\"getblockcount\", vec![])\n    }\n\n    fn get_block(&self, block_hash: &str, verbosity: i32) -> Result<Value, Box<dyn std::error::Error>> {\n        self.rpc_call(\"getblock\", vec![json!(block_hash), json!(verbosity)])\n    }\n\n    fn get_mempool_info(&self) -> Result<Value, Box<dyn std::error::Error>> {\n        self.rpc_call(\"getmempoolinfo\", vec![])\n    }\n\n    fn estimate_smart_fee(&self, target_blocks: i32) -> Result<Value, Box<dyn std::error::Error>> {\n        self.rpc_call(\"estimatesmartfee\", vec![json!(target_blocks)])\n    }\n}\n\n// Usage\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let rpc = BitcoinRPCService::new(\"http://127.0.0.1:8332\", \"user\", \"password\");\n    let info = rpc.get_blockchain_info()?;\n    println!(\"Block height: {}\", info[\"blocks\"]);\n    Ok(())\n}\n```\n\n```python\nimport os\nimport requests\nfrom typing import Dict, Any, Optional, List\n\nclass BitcoinRPCService:\n    \"\"\"Centralized service for Bitcoin node RPC communication.\"\"\"\n\n    def __init__(self, rpc_url: str, rpc_user: Optional[str] = None, \n                 rpc_password: Optional[str] = None, cookie_file: Optional[str] = None):\n        self.rpc_url = rpc_url\n        self.rpc_user = rpc_user\n        self.rpc_password = rpc_password\n        self.cookie_file = cookie_file\n        self.timeout = 5\n\n    def rpc_call(self, method: str, params: Optional[List] = None) -> Dict[str, Any]:\n        \"\"\"Make an RPC call to Bitcoin node.\"\"\"\n        if params is None:\n            params = []\n\n        payload = {\n            \"jsonrpc\": \"1.0\",\n            \"id\": \"monitor\",\n            \"method\": method,\n            \"params\": params\n        }\n\n        # Prepare authentication\n        auth = None\n        if self.cookie_file and os.path.exists(self.cookie_file):\n            with open(self.cookie_file, 'r') as f:\n                cookie = f.read().strip()\n            if ':' in cookie:\n                username, password = cookie.split(':', 1)\n                auth = (username, password)\n        elif self.rpc_user and self.rpc_password:\n            auth = (self.rpc_user, self.rpc_password)\n\n        response = requests.post(\n            self.rpc_url,\n            json=payload,\n            auth=auth,\n            timeout=self.timeout\n        )\n        return response.json()\n\n    # Convenience methods\n    def get_blockchain_info(self) -> Dict[str, Any]:\n        return self.rpc_call(\"getblockchaininfo\")\n\n    def get_block_count(self) -> Dict[str, Any]:\n        return self.rpc_call(\"getblockcount\")\n\n    def get_block(self, block_hash: str, verbosity: int = 1) -> Dict[str, Any]:\n        return self.rpc_call(\"getblock\", [block_hash, verbosity])\n\n    def get_mempool_info(self) -> Dict[str, Any]:\n        return self.rpc_call(\"getmempoolinfo\")\n\n    def estimate_smart_fee(self, target_blocks: int = 6) -> Dict[str, Any]:\n        return self.rpc_call(\"estimatesmartfee\", [target_blocks])\n\n# Usage\nrpc = BitcoinRPCService(\"http://127.0.0.1:8332\", \"user\", \"password\")\ninfo = rpc.get_blockchain_info()\nprint(f\"Block height: {info['result']['blocks']}\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\n/**\n * Centralized service for Bitcoin node RPC communication\n */\nclass BitcoinRPCService {\nprivate:\n    std::string rpc_url;\n    std::string rpc_user;\n    std::string rpc_password;\n    \n    static size_t write_callback(void* contents, size_t size, size_t nmemb, std::string* userp) {\n        userp->append((char*)contents, size * nmemb);\n        return size * nmemb;\n    }\n\npublic:\n    BitcoinRPCService(const std::string& url, const std::string& user, const std::string& password)\n        : rpc_url(url), rpc_user(user), rpc_password(password) {}\n\n    json rpc_call(const std::string& method, const json& params = json::array()) {\n        CURL* curl = curl_easy_init();\n        std::string response_string;\n        \n        json payload = {\n            {\"jsonrpc\", \"1.0\"},\n            {\"id\", \"client\"},\n            {\"method\", method},\n            {\"params\", params}\n        };\n        \n        std::string post_data = payload.dump();\n        std::string auth = rpc_user + \":\" + rpc_password;\n        \n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, rpc_url.c_str());\n            curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data.c_str());\n            curl_easy_setopt(curl, CURLOPT_USERPWD, auth.c_str());\n            curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n            curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);\n            curl_easy_setopt(curl, CURLOPT_TIMEOUT, 5L);\n            \n            struct curl_slist* headers = nullptr;\n            headers = curl_slist_append(headers, \"Content-Type: application/json\");\n            curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n            \n            curl_easy_perform(curl);\n            curl_slist_free_all(headers);\n            curl_easy_cleanup(curl);\n        }\n        \n        return json::parse(response_string);\n    }\n\n    // Convenience methods\n    json get_blockchain_info() { return rpc_call(\"getblockchaininfo\"); }\n    json get_block_count() { return rpc_call(\"getblockcount\"); }\n    json get_block(const std::string& hash, int verbosity = 1) {\n        return rpc_call(\"getblock\", {hash, verbosity});\n    }\n    json get_mempool_info() { return rpc_call(\"getmempoolinfo\"); }\n    json estimate_smart_fee(int target_blocks = 6) {\n        return rpc_call(\"estimatesmartfee\", {target_blocks});\n    }\n};\n\n// Usage\nint main() {\n    BitcoinRPCService rpc(\"http://127.0.0.1:8332\", \"user\", \"password\");\n    auto info = rpc.get_blockchain_info();\n    std::cout << \"Block height: \" << info[\"result\"][\"blocks\"] << std::endl;\n    return 0;\n}\n```\n\n```javascript\nconst axios = require('axios');\n\nclass BitcoinRPCService {\n  constructor(rpcUrl, rpcUser, rpcPassword) {\n    this.rpcUrl = rpcUrl;\n    this.auth = { username: rpcUser, password: rpcPassword };\n    this.timeout = 5000;\n  }\n\n  async rpcCall(method, params = []) {\n    const payload = {\n      jsonrpc: '1.0',\n      id: 'client',\n      method: method,\n      params: params\n    };\n\n    const response = await axios.post(this.rpcUrl, payload, {\n      auth: this.auth,\n      timeout: this.timeout,\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n    return response.data;\n  }\n\n  // Convenience methods\n  async getBlockchainInfo() {\n    return this.rpcCall('getblockchaininfo');\n  }\n\n  async getBlockCount() {\n    return this.rpcCall('getblockcount');\n  }\n\n  async getBlock(blockHash, verbosity = 1) {\n    return this.rpcCall('getblock', [blockHash, verbosity]);\n  }\n\n  async getMempoolInfo() {\n    return this.rpcCall('getmempoolinfo');\n  }\n\n  async estimateSmartFee(targetBlocks = 6) {\n    return this.rpcCall('estimatesmartfee', [targetBlocks]);\n  }\n}\n\n// Usage\nconst rpc = new BitcoinRPCService('http://127.0.0.1:8332', 'user', 'password');\nconst info = await rpc.getBlockchainInfo();\nconsole.log(`Block height: ${info.result.blocks}`);\n```\n:::\n\n## Essential Node Information Commands\n\n### 1. Blockchain Information\n\n```bash\nbtc getblockchaininfo\n```\n\n**Key fields to monitor:**\n- `blocks`: Current block height\n- `headers`: Number of headers downloaded\n- `verificationprogress`: Sync progress (0.0 to 1.0)\n- `initialblockdownload`: Whether still in IBD\n- `pruned`: Whether node is pruned\n\n### 2. Network Information\n\n```bash\nbtc getnetworkinfo\n```\n\n**Key fields:**\n- `connections`: Total peer connections\n- `connections_in`: Incoming connections\n- `connections_out`: Outgoing connections\n- `version`: Bitcoin Core version\n- `subversion`: Detailed version info\n\n### 3. Memory Pool Information\n\n```bash\nbtc getmempoolinfo\n```\n\n**Key fields:**\n- `size`: Number of transactions in mempool\n- `bytes`: Total mempool size in bytes\n- `total_fee`: Total fees in mempool\n\n## Transaction and Block Commands\n\n### 4. Get Block Information\n\n```bash\n# Get latest block hash\nbtc getbestblockhash\n\n# Get block by hash\nbtc getblock <block_hash>\n\n# Get block by height\nbtc getblockhash <height>\n```\n\n### 5. Transaction Information\n\n```bash\n# Get transaction by ID\nbtc getrawtransaction <txid> true\n\n# Get transaction from mempool\nbtc getmempoolentry <txid>\n```\n\n## Wallet Commands (if wallet is loaded)\n\n### 6. Wallet Information\n\n```bash\n# List wallets\nbtc listwallets\n\n# Get wallet info\nbtc getwalletinfo\n\n# Get balance\nbtc getbalance\n```\n\n## Advanced Diagnostic Commands\n\n### 7. Index Information\n\n```bash\n# Check if transaction index is available\nbtc getindexinfo\n```\n\n### 8. UTXO Set Information\n\n```bash\n# Get UTXO set statistics (can be slow)\nbtc gettxoutsetinfo\n```\n\n### 9. Peer Information\n\n```bash\n# Get peer information\nbtc getpeerinfo\n```\n\n## Troubleshooting Commands\n\n### 10. Node Status\n\n```bash\n# Get general node information\nbtc getgeneralinfo\n\n# Get memory usage information\nbtc getmemoryinfo\n\n# Get RPC server information\nbtc getrpcinfo\n```\n\n### 11. Mining Information\n\n```bash\n# Get mining information\nbtc getmininginfo\n```\n\n## JSON Output Formatting\n\nTo make the output more readable, pipe through `jq`:\n\n```bash\n# Install jq if not available: brew install jq\nbtc getblockchaininfo | jq '{blocks, verificationprogress}'\n```\n\n## Indexing and Background Process Monitoring\n\n### 12. Transaction Index Monitoring\n```bash\n# Check indexing status\nbtc getindexinfo\n\n# Calculate indexing progress percentage (most useful command)\nbtc getindexinfo | jq '.txindex.best_block_height / 918464 * 100'\n\n# Check if indexing is complete\nbtc getindexinfo | jq '.txindex.synced'\n\n# Monitor indexing in real-time (updates every 30 seconds)\nwatch -n 30 'btc getindexinfo | jq \".txindex.best_block_height\"'\n\n# Quick progress check (shows percentage)\nbtc getindexinfo | jq '.txindex.best_block_height / 918464 * 100'\n```\n\n### 13. Wallet Management Commands\n```bash\n# List all loaded wallets\nbtc listwallets\n\n# Get info about specific wallet\nbtc -rpcwallet=<walletname> getwalletinfo\n\n# Unload a wallet (removes from memory)\nbtc unloadwallet <walletname>\n\n# Load a wallet\nbtc loadwallet <walletname>\n\n# Get transactions from specific wallet\nbtc -rpcwallet=<walletname> listtransactions \"*\" 100\n\n# Get balance from specific wallet\nbtc -rpcwallet=<walletname> getbalance\n```\n\n### 14. Log Monitoring\n```bash\n# Check recent indexing progress in logs\ntail -20 ~/.bitcoin/debug.log | grep -i index\n\n# Monitor logs in real-time\ntail -f ~/.bitcoin/debug.log | grep -i index\n\n# Check for errors in logs\ngrep -i error ~/.bitcoin/debug.log | tail -10\n```\n\n### 15. Pruning Status\n```bash\n# Check if node is pruned\nbtc getblockchaininfo | jq '{pruned, pruneheight}'\n\n# Get UTXO set info (can be slow)\nbtc gettxoutsetinfo | jq '{total_amount, transactions, height}'\n```\n\n## Useful Resources\n\n### Block Explorers and Monitoring\n\n- **[mempool.space](https://mempool.space)** - Real-time Bitcoin mempool and block explorer\n- **[Clark Moody's Bitcoin Dashboard](https://dashboard.clarkmoody.com)** - Bitcoin metrics and analytics\n- **[Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)** - Bitcoin Core source code repository\n\n### Additional Tools\n\n- Use block explorers to verify transactions\n- Monitor network metrics and statistics\n- Track mempool activity and fee rates\n- Analyze blockchain data\n\n## Troubleshooting Commands\n\n### 16. Connection and Sync Issues\n```bash\n# Test RPC connection\nbtc getblockchaininfo | jq '.chain'\n\n# Check network status\nbtc getnetworkinfo | jq '{connections, connections_in, connections_out}'\n\n# Verify wallet is accessible\nbtc getwalletinfo | jq '{walletname, txcount, balance}'\n\n# Check if node is still syncing\nbtc getblockchaininfo | jq '{verificationprogress, initialblockdownload}'\n```\n\n## 11. ZMQ Notifications\n\nZeroMQ (ZMQ) provides real-time notifications for blockchain events, enabling instant detection of new blocks and transactions without polling.\n\n### Configuration\nAdd to your `bitcoin.conf`:\n```ini\n# ZMQ Notifications\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28333\nzmqpubrawblock=tcp://127.0.0.1:28334\nzmqpubrawtx=tcp://127.0.0.1:28335\n```\n\n### Benefits\n- **Instant notifications** - No polling delays\n- **Lower resource usage** - No constant RPC calls\n- **Better reliability** - Catches blocks even after node restarts\n- **Real-time monitoring** - Perfect for blockchain monitoring applications\n\n### Usage with Monitor\n```bash\n# The monitor automatically tries ZMQ first, falls back to polling\npython3 scripts/monitor_blockchain.py --continuous\n\n# Custom ZMQ endpoint\npython3 scripts/monitor_blockchain.py --continuous --zmq-endpoint tcp://127.0.0.1:28332\n```\n\n### Verification\n```bash\n# Check if ZMQ is enabled in Bitcoin logs\ngrep -i zmq ~/.bitcoin/debug.log\n\n# Check Bitcoin help for ZMQ options\nbitcoind -h | grep zmq\n```\n",
    "filename": "guide.md"
  },
  "/docs/mining/overview": {
    "content": "# Bitcoin Mining Overview\n\n## What is Bitcoin Mining?\n\nBitcoin mining is the process by which new Bitcoin transactions are verified and added to the blockchain. Miners compete to solve cryptographic puzzles using computational power, and the first miner to solve the puzzle gets to add the next block to the blockchain and receive a reward.\n\n## How Mining Works\n\n### Block Creation Process\n\n1. **Transaction Collection**: Miners collect pending transactions from the mempool\n2. **Block Construction**: Miners assemble transactions into a candidate block\n3. **Proof-of-Work**: Miners repeatedly hash the block header with different nonce values\n4. **Difficulty Target**: The hash must be below a certain target (determined by network difficulty)\n5. **Block Discovery**: When a miner finds a valid hash, they broadcast the block to the network\n6. **Block Validation**: Other nodes verify the block and add it to their blockchain\n7. **Reward**: The successful miner receives the block reward plus transaction fees\n\n### Mining Hardware\n\n- **ASIC Miners**: Application-Specific Integrated Circuits designed specifically for Bitcoin mining (most efficient)\n- **GPU Mining**: Graphics Processing Units (less efficient than ASICs, rarely profitable)\n- **CPU Mining**: Central Processing Units (least efficient, primarily educational)\n\n### Mining Pools\n\nMost miners join mining pools to:\n- **Reduce Variance**: Share rewards with other miners\n- **Consistent Payouts**: Receive smaller but regular payments\n- **Lower Barrier**: Don't need to find a full block individually\n- **Combine Hash Power**: Pool hash rate increases chances of finding blocks\n\n## Key Concepts\n\n- **Proof-of-Work**: Cryptographic puzzle that miners solve\n- **Block Reward**: Currently 3.125 BTC per block (after 2024 halving)\n- **Difficulty**: Adjusts every 2016 blocks to maintain ~10 minute block times\n- **Pool Mining**: Miners combine resources to share rewards\n- **Hash Rate**: Measure of mining power (network: ~700 EH/s)\n\n## Related Topics\n\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How the mining algorithm works\n- [Difficulty Adjustment](/docs/mining/difficulty) - How difficulty adjusts to maintain block times\n- [Mining Economics](/docs/mining/economics) - Block rewards, fees, and profitability\n",
    "filename": "overview.md"
  },
  "/docs/mining/proof-of-work": {
    "content": "# Proof-of-Work Mechanism\n\nBitcoin uses a **[proof-of-work](/docs/glossary#proof-of-work-pow)** [consensus](/docs/glossary#consensus) mechanism where [miners](/docs/glossary#mining) compete to solve a cryptographic puzzle. This process secures the network and validates [transactions](/docs/glossary#transaction).\n\n## How It Works\n\n1. **Block Construction**: Miners collect transactions from the [mempool](/docs/glossary#mempool-memory-pool) and create a candidate [block](/docs/glossary#block)\n2. **Nonce Search**: Miners repeatedly [hash](/docs/glossary#hash) the [block header](/docs/glossary#block-header) with different [nonce](/docs/glossary#nonce) values\n3. **Difficulty Target**: The hash must be below a certain target (set by network [difficulty](/docs/glossary#difficulty))\n4. **Success**: When a miner finds a valid hash, they broadcast the block to the network\n5. **Reward**: The miner receives the [block reward](/docs/glossary#block-reward) (currently 3.125 BTC) plus [transaction fees](/docs/glossary#transaction-fee)\n\n## Mining Difficulty\n\n- **Adjustment**: Every 2016 blocks (~2 weeks), the difficulty adjusts based on network [hash rate](/docs/glossary#hash-rate)\n- **Target**: Maintains ~10 minute average [block time](/docs/glossary#block-time)\n- **Current Network Hash Rate**: ~700 EH/s (exahashes per second)\n- **See Also**: [Difficulty Adjustment](/docs/mining/difficulty) for detailed explanation\n\n## Technical Details\n\n### Block Headers\n- **Size**: 80 bytes of block metadata\n- **Components**: Version, previous block hash, [merkle root](/docs/glossary#merkle-root), timestamp, [difficulty target](/docs/glossary#difficulty-target), nonce\n- **Hash Function**: [SHA256D](/docs/glossary#sha256d) (double SHA-256)\n\n### Nonce Space\n- **Range**: 0 to 4,294,967,295 (2^32 - 1)\n- **Exhaustion**: If all nonces fail, miners change the [coinbase transaction](/docs/glossary#coinbase-transaction) or timestamp\n- **Search Space**: Effectively unlimited through coinbase modifications\n\n### Target Difficulty\n- **Network-Wide**: All miners compete against the same target\n- **Dynamic**: Adjusts every 2016 blocks based on actual vs. target block time\n- **Purpose**: Maintains consistent block production rate\n\n## Hash Function: SHA256D\n\nBitcoin uses a double SHA-256 hash function:\n\n```\nhash = SHA256(SHA256(block_header))\n```\n\nThis means:\n1. First SHA-256 hash of the block header\n2. Second SHA-256 hash of the first hash result\n3. Result must be below the network difficulty target\n\n## Mining Process Flow\n\n```\n1. Collect Transactions\n   â†“\n2. Build Block Header\n   â†“\n3. Hash Block Header\n   â†“\n4. Check if Hash < Target\n   â”œâ”€ Yes â†’ Broadcast Block â†’ Receive Reward\n   â””â”€ No â†’ Increment Nonce â†’ Repeat from Step 3\n```\n\n## Educational Value\n\n### What You'll Learn\n1. **Block Construction**: How Bitcoin blocks are built\n2. **Mining Algorithms**: SHA256D hash function\n3. **Network Protocol**: RPC communication with Bitcoin node\n4. **Difficulty Adjustment**: How network difficulty works\n5. **Economic Incentives**: Why mining is competitive\n\n### Technical Concepts\n- **Block Headers**: 80-byte block metadata\n- **Coinbase Transactions**: Special reward transactions\n- **[Merkle Trees](/docs/glossary#merkle-tree)**: Transaction organization\n- **Nonce Space**: 4.3 billion possible values\n- **Difficulty Target**: Network-wide mining target\n\n## Related Topics\n\n- [Overview](/docs/mining) - Mining architecture and concepts\n- [Mining Economics](/docs/mining/economics) - Rewards and profitability\n",
    "filename": "proof-of-work.md"
  },
  "/docs/mining/difficulty": {
    "content": "# Difficulty Adjustment\n\nBitcoin's difficulty adjustment is a critical mechanism that maintains the network's target block time of approximately 10 minutes. Every 2016 blocks (~2 weeks), the network automatically adjusts the mining difficulty based on the actual time it took to mine the previous 2016 blocks.\n\n## How Difficulty Adjustment Works\n\n### Adjustment Formula\n\nThe difficulty adjusts every **2016 blocks** (approximately every 2 weeks) using the formula:\n\n```\nNew Difficulty = Old Difficulty Ã— (Target Time / Actual Time)\n```\n\nWhere:\n- **Target Time**: 2016 blocks Ã— 10 minutes = 20,160 minutes (2 weeks)\n- **Actual Time**: Time it took to mine the previous 2016 blocks\n\n### Adjustment Rules\n\n- **If blocks were mined too fast** (less than 2 weeks): Difficulty increases\n- **If blocks were mined too slow** (more than 2 weeks): Difficulty decreases\n- **Maximum adjustment**: Â±4x per period (prevents extreme swings)\n\n## Why Difficulty Adjustment Exists\n\n### Maintaining Block Time\n\n- **Target**: ~10 minutes per block\n- **Purpose**: Predictable block creation rate\n- **Benefit**: Consistent transaction confirmation times\n\n### Network Security\n\n- **Hash Rate Changes**: Network hash rate fluctuates\n- **Hardware Improvements**: New ASICs increase network hash rate\n- **Miner Participation**: Miners join/leave the network\n- **Adaptation**: Difficulty adjusts to maintain security\n\n### Economic Stability\n\n- **Predictable Rewards**: Miners can estimate earnings\n- **Consistent Block Times**: Users know confirmation times\n- **Network Health**: Prevents too-fast or too-slow block creation\n\n## Historical Difficulty Adjustments\n\n### Early Bitcoin (2009-2012)\n- **Difficulty**: Very low (could mine with CPU)\n- **Adjustments**: Frequent large increases as hash rate grew\n- **Network**: Small, growing hash rate\n\n### ASIC Era (2013-Present)\n- **Difficulty**: Rapidly increasing\n- **Adjustments**: Regular increases as ASICs improved\n- **Network**: Massive hash rate growth\n\n### Current State (2024)\n- **Difficulty**: ~700+ trillion (extremely high)\n- **Adjustments**: More stable, smaller percentage changes\n- **Network**: Mature, large hash rate\n\n## Difficulty Metrics\n\n### Current Network Stats\n- **Block Time**: Maintained at ~10 minutes average\n- **Hash Rate**: ~700 EH/s (exahashes per second)\n- **Difficulty**: Adjusts every 2016 blocks\n- **Adjustment Frequency**: Approximately every 2 weeks\n\n### Difficulty Calculation\n\nThe difficulty target is calculated from the block header:\n- **Target Hash**: Maximum hash value that's considered valid\n- **Lower Target**: Higher difficulty (harder to find valid hash)\n- **Higher Target**: Lower difficulty (easier to find valid hash)\n\n## Impact on Miners\n\n### Hash Rate Changes\n\nWhen network hash rate increases:\n- **Difficulty increases** in next adjustment\n- **Same hardware** produces fewer valid hashes\n- **Mining becomes harder** for all miners\n\nWhen network hash rate decreases:\n- **Difficulty decreases** in next adjustment\n- **Same hardware** produces more valid hashes\n- **Mining becomes easier** for all miners\n\n### Profitability Considerations\n\n- **Difficulty increases**: Reduce profitability (unless hash rate increases)\n- **Difficulty decreases**: Increase profitability (if hash rate stays same)\n- **Long-term trend**: Difficulty generally increases over time\n\n## Technical Details\n\n### Block Header Fields\n\nThe difficulty is encoded in the block header's `nBits` field:\n- **Compact representation**: 32-bit value\n- **Target calculation**: Converts nBits to full 256-bit target\n- **Validation**: Block hash must be less than target\n\n### Adjustment Algorithm\n\n:::code-group\n```rust\n/// Simplified difficulty adjustment\n///\n/// # Arguments\n///\n/// * `old_difficulty` - Previous difficulty value\n/// * `actual_time` - Time in minutes to mine 2016 blocks\n/// * `target_time` - Target time (default: 20160 minutes)\n///\n/// # Returns\n///\n/// New difficulty value\nfn adjust_difficulty(old_difficulty: f64, actual_time: f64, target_time: f64) -> f64 {\n    // Default target_time: 2016 blocks Ã— 10 minutes = 20,160 minutes\n    let target_time = if target_time == 0.0 { 20160.0 } else { target_time };\n    \n    let mut ratio = target_time / actual_time;\n    \n    // Limit adjustment to Â±4x\n    ratio = ratio.clamp(0.25, 4.0);\n    \n    old_difficulty * ratio\n}\n\nfn main() {\n    // Example: blocks mined in 18,000 minutes (faster than target)\n    let new_diff = adjust_difficulty(100_000.0, 18_000.0, 20_160.0);\n    println!(\"New difficulty: {}\", new_diff); // ~112,000\n}\n```\n\n```python\ndef adjust_difficulty(old_difficulty, actual_time, target_time=20160):\n    \"\"\"\n    Simplified difficulty adjustment.\n    \n    Args:\n        old_difficulty: Previous difficulty value\n        actual_time: Time in minutes to mine 2016 blocks\n        target_time: Target time (2016 blocks Ã— 10 minutes = 20,160 minutes)\n    \n    Returns:\n        New difficulty value\n    \"\"\"\n    ratio = target_time / actual_time\n    \n    # Limit adjustment to Â±4x\n    ratio = max(0.25, min(4.0, ratio))\n    \n    new_difficulty = old_difficulty * ratio\n    return new_difficulty\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n\n/**\n * Simplified difficulty adjustment.\n * \n * @param old_difficulty Previous difficulty value\n * @param actual_time Time in minutes to mine 2016 blocks\n * @param target_time Target time (2016 blocks Ã— 10 minutes = 20,160 minutes)\n * @return New difficulty value\n */\ndouble adjust_difficulty(double old_difficulty, double actual_time, double target_time = 20160.0) {\n    double ratio = target_time / actual_time;\n    \n    // Limit adjustment to Â±4x\n    ratio = std::clamp(ratio, 0.25, 4.0);\n    \n    double new_difficulty = old_difficulty * ratio;\n    return new_difficulty;\n}\n\nint main() {\n    // Example: blocks mined in 18,000 minutes (faster than target)\n    double new_diff = adjust_difficulty(100000.0, 18000.0);\n    std::cout << \"New difficulty: \" << new_diff << std::endl; // ~112,000\n    return 0;\n}\n```\n\n```javascript\n/**\n * Simplified difficulty adjustment.\n * \n * @param {number} oldDifficulty - Previous difficulty value\n * @param {number} actualTime - Time in minutes to mine 2016 blocks\n * @param {number} targetTime - Target time (default: 20160 minutes)\n * @returns {number} New difficulty value\n */\nfunction adjustDifficulty(oldDifficulty, actualTime, targetTime = 20160) {\n    let ratio = targetTime / actualTime;\n    \n    // Limit adjustment to Â±4x\n    ratio = Math.max(0.25, Math.min(4.0, ratio));\n    \n    const newDifficulty = oldDifficulty * ratio;\n    return newDifficulty;\n}\n\n// Example: blocks mined in 18,000 minutes (faster than target)\nconst newDiff = adjustDifficulty(100_000, 18_000);\nconsole.log(`New difficulty: ${newDiff}`); // ~112,000\n```\n:::\n\n### Validation\n\n- **Every 2016 blocks**: Check if adjustment needed\n- **Block height**: Must be multiple of 2016\n- **Genesis block**: Block 0, no adjustment\n- **First adjustment**: Block 2016\n\n## Related Topics\n\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How the mining algorithm works\n- [Mining Economics](/docs/mining/economics) - How difficulty affects profitability\n- [Overview](/docs/mining/overview) - General mining concepts\n",
    "filename": "difficulty.md"
  },
  "/docs/mining/economics": {
    "content": "# Mining Economics\n\n## Block Rewards\n\n- **Current Reward**: 3.125 BTC per block (after 2024 halving)\n- **Next Halving**: 2028 (reward will be 1.5625 BTC)\n- **Transaction Fees**: Variable, typically 0.1-1 BTC per block\n- **Total Reward**: Block reward + transaction fees\n\n## Pool Mining Benefits\n\n- **Consistent Payouts**: Small but regular rewards\n- **Reduced Variance**: Share rewards with other miners\n- **Lower Barrier**: Don't need to find a full block\n- **Educational**: Learn how mining works\n\n## Individual Mining Reality\n\n- **Probability**: Finding a block solo is extremely unlikely\n- **Time to Block**: Could take years or never happen\n- **Pool Mining**: Better for learning and small contributions\n\n## Cost Analysis\n\n### Electricity Costs\n- **Power Consumption**: Varies by hardware (CPU, GPU, ASIC)\n- **Cost Calculation**: Power consumption (W) Ã— Hours Ã— Electricity rate ($/kWh)\n- **Consideration**: Mining profitability depends heavily on electricity costs\n- **Regional Variation**: Electricity rates vary significantly by location\n\n### Revenue Expectations\n- **Solo Mining**: Extremely low probability of finding blocks for individual miners\n- **Pool Mining**: More consistent payouts based on hash rate contribution\n- **ASIC Mining**: Higher hash rate but significant upfront investment\n- **CPU/GPU Mining**: Lower hash rate, primarily educational or hobbyist\n\n## Mining Profitability Factors\n\n### Network Hash Rate\n- **Current**: ~700 EH/s (exahashes per second)\n- **Trend**: Increasing over time\n- **Impact**: Makes solo mining less profitable\n\n### Difficulty Adjustment\n- **Frequency**: Every 2016 blocks (~2 weeks)\n- **Purpose**: Maintains ~10 minute block times\n- **Effect**: Adjusts to network hash rate\n- **See Also**: [Difficulty Adjustment](/docs/mining/difficulty) for detailed explanation\n\n### Block Rewards\n- **Halving Schedule**: Every 210,000 blocks (~4 years)\n- **Current**: 3.125 BTC per block\n- **Future**: Will decrease to 0 by 2140\n\n### Transaction Fees\n- **Variable**: Depends on network congestion\n- **Current Average**: 0.1-1 BTC per block\n- **Future**: Will become primary miner income after halvings\n\n## Pool Mining Economics\n\n### How Pool Mining Works\n1. Miners contribute hash power to pool\n2. Pool finds blocks collectively\n3. Rewards distributed based on contribution\n4. More consistent payouts than solo mining\n\n### Pool Fees\n- **Typical Fee**: 1-2% of rewards\n- **Payout Threshold**: Minimum amount before payout\n- **Payment Frequency**: Daily or weekly\n\n### Expected Returns\n- **Hash Rate Dependent**: Returns scale with hash rate contribution\n- **Pool Share**: Miners receive rewards proportional to their hash rate\n- **Realistic Expectations**: \n  - CPU/GPU mining: Primarily educational, minimal returns\n  - ASIC mining: Can be profitable with low electricity costs\n  - Pool mining: More predictable than solo mining\n- **Break-Even Analysis**: Consider hardware costs, electricity, and pool fees\n\n## Related Topics\n\n- [Overview](/docs/mining) - Mining architecture\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How mining works\n- [Difficulty Adjustment](/docs/mining/difficulty) - How difficulty affects profitability\n",
    "filename": "economics.md"
  },
  "/docs/mining/mempool": {
    "content": "# The Mempool\n\nThe **mempool** (memory pool) is Bitcoin's waiting room for unconfirmed transactions. When you broadcast a transaction, it doesn't immediately go into a block. It first enters the mempool, where it waits for a miner to include it in the next block.\n\nEvery full node maintains its own mempool. There is no single, global mempool; each node has its own view of pending transactions, though they generally converge through transaction propagation across the network.\n\n## How the Mempool Works\n\n### Transaction Lifecycle\n\n1. **Broadcast**: User signs and broadcasts a transaction\n2. **Validation**: Nodes verify the transaction is valid (correct signatures, sufficient funds, proper format)\n3. **Mempool Entry**: Valid transactions enter the node's mempool\n4. **Propagation**: Nodes relay transactions to their peers\n5. **Selection**: Miners select transactions from their mempool to include in blocks\n6. **Confirmation**: Once included in a block, the transaction leaves the mempool\n\n### Mempool Policies\n\nEach node can set its own mempool policies:\n\n- **Size Limit**: Maximum memory allocated to the mempool (default: 300 MB in Bitcoin Core)\n- **Minimum Fee Rate**: Transactions below this rate are rejected\n- **Transaction Expiration**: Transactions may be dropped after a period (default: 2 weeks)\n- **Replace-by-Fee**: Whether to accept transaction replacements\n\n## Fee Market Dynamics\n\nThe mempool creates a **fee market** where users bid for block space.\n\n### How Fees Work\n\n- Transactions pay fees measured in **satoshis per virtual byte (sat/vB)**\n- Miners prioritize higher-fee transactions (more profit per block)\n- When blocks are full, low-fee transactions wait longer\n- Fee rates fluctuate based on demand for block space\n\n### Fee Estimation\n\nWallets estimate fees by analyzing the mempool:\n\n```\nCurrent mempool state:\nâ”œâ”€â”€ 1-2 blocks: 50+ sat/vB (high priority)\nâ”œâ”€â”€ 3-6 blocks: 20-50 sat/vB (medium priority)\nâ”œâ”€â”€ 7+ blocks: 10-20 sat/vB (low priority)\nâ””â”€â”€ Eventually: 1-10 sat/vB (no rush)\n```\n\nDuring congestion, fees spike. During quiet periods, even 1 sat/vB transactions confirm quickly.\n\n### Mempool Congestion\n\nWhen transaction volume exceeds block capacity:\n\n1. **Mempool grows**: Unconfirmed transactions accumulate\n2. **Fees rise**: Users bid higher to get confirmed faster\n3. **Low-fee eviction**: Nodes drop lowest-fee transactions when mempool is full\n4. **Backlog clears**: Eventually, transaction volume decreases and the mempool empties\n\n## Replace-by-Fee (RBF)\n\n**RBF** allows replacing an unconfirmed transaction with a new version paying a higher fee.\n\n### How RBF Works\n\n1. Original transaction signals RBF capability (sequence number < 0xfffffffe)\n2. User broadcasts replacement with higher fee\n3. Nodes replace the original with the new transaction\n4. Miners see only the higher-fee version\n\n### RBF Use Cases\n\n- **Fee bumping**: Speed up a stuck transaction\n- **Payment updates**: Change the amount or destination before confirmation\n- **Consolidation**: Combine outputs more efficiently\n\n### Full RBF vs Opt-in RBF\n\n- **Opt-in RBF**: Only transactions that signal RBF can be replaced (current default)\n- **Full RBF**: Any unconfirmed transaction can be replaced (controversial, increasingly adopted)\n\n## Child Pays for Parent (CPFP)\n\nAn alternative to RBF for fee bumping.\n\n### How CPFP Works\n\n1. Parent transaction is stuck with low fee\n2. Create a child transaction spending the parent's output\n3. Child pays a high enough fee to cover both transactions\n4. Miners include both (they want the child's high fee)\n\n### CPFP vs RBF\n\n| Aspect | RBF | CPFP |\n|--------|-----|------|\n| Who can bump | Sender only | Sender or recipient |\n| Requires | RBF signaling | Spendable output |\n| Efficiency | More efficient | Uses extra block space |\n\n## Mempool Visualization\n\nThe mempool can be visualized as a queue sorted by fee rate:\n\n```\nBlock Space Available: ~1 MB (4 MWU)\n\nFee Rate (sat/vB)\n    â”‚\n100+â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in next block\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆ\n 50 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in 1-3 blocks\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n 20 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in 3-6 blocks\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n 10 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† May wait hours/days\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n  1 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† May never confirm\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n      Transaction Volume (by size)\n```\n\n## Mempool Sniping and Games\n\n### Transaction Pinning\n\nAn attack where someone prevents a transaction from being replaced:\n\n1. Attacker creates a low-fee child transaction\n2. Child is large, making CPFP expensive\n3. Original transaction is \"pinned\" and hard to bump\n\nThis is a concern for Lightning Network and other Layer 2 protocols.\n\n### Front-Running\n\nWatching the mempool to exploit pending transactions:\n\n1. See a profitable pending transaction\n2. Create your own transaction with higher fee\n3. Your transaction confirms first\n\nCommon in DeFi on other chains, less relevant for Bitcoin's simpler transactions.\n\n## Mempool Tools and Resources\n\n> **Query the mempool yourself!** Try `getmempoolinfo` and `getrawmempool` in the [Bitcoin CLI Terminal](/terminal). Real mainnet data, no setup required.\n\n### Mempool Explorers\n\n- **[mempool.space](https://mempool.space)**: Beautiful visualization of mempool and fee estimates\n- **[jochen-hoenicke.de/queue](https://jochen-hoenicke.de/queue/)**: Historical mempool data\n- **[mempoolexplorer.com](https://mempoolexplorer.com)**: Detailed mempool analytics\n\n### What You Can Learn\n\n- Current fee rates for different confirmation targets\n- Mempool size and growth trends\n- Transaction propagation status\n- Historical congestion patterns\n\n## Implications for Users\n\n### Sending Transactions\n\n1. **Check mempool first**: See current fee rates before sending\n2. **Use appropriate fees**: Overpaying wastes money; underpaying causes delays\n3. **Enable RBF**: Always signal RBF for flexibility\n4. **Batch transactions**: Combine multiple payments to save fees\n\n### Receiving Transactions\n\n1. **Wait for confirmations**: Unconfirmed transactions can be replaced or dropped\n2. **Check RBF status**: RBF transactions are more easily double-spent before confirmation\n3. **Monitor mempool**: Track your incoming transaction's position\n\n## Technical Details\n\n### Mempool Data Structures\n\nBitcoin Core maintains several structures:\n\n- **mapTx**: Main transaction storage, indexed multiple ways\n- **Ancestor/Descendant tracking**: For CPFP calculations\n- **Fee rate buckets**: For efficient transaction selection\n\n### Transaction Relay Policies\n\nNot all valid transactions are relayed:\n\n- **Dust limit**: Outputs below ~546 sats are non-standard\n- **OP_RETURN size**: Limited to 80 bytes by default (policy, not consensus)\n- **Non-standard scripts**: Some valid scripts aren't relayed\n\n### Mempool Accept Rules\n\nTransactions must pass:\n\n1. **Consensus rules**: Valid signatures, scripts, amounts\n2. **Standardness rules**: Follow common patterns\n3. **Policy rules**: Meet node's minimum fee, size limits\n4. **Package rules**: Ancestor/descendant limits (25 transactions, 101 KB)\n\n## Summary\n\nThe mempool is the heartbeat of Bitcoin's transaction processing:\n\n- **Waiting room**: Where transactions queue for confirmation\n- **Fee market**: Creates price discovery for block space\n- **Strategic space**: RBF and CPFP allow fee management\n- **Per-node**: Each node has its own mempool view\n\nUnderstanding the mempool helps you:\n- Set appropriate fees\n- Troubleshoot stuck transactions\n- Understand network congestion\n- Make informed timing decisions\n\n## Related Topics\n\n- [Mining Economics](/docs/mining/economics) - How miners profit from fees\n- [Block Construction](/docs/mining/block-construction) - How miners select transactions\n- [Proof-of-Work](/docs/mining/proof-of-work) - The mining process\n\n## Resources\n\n- [mempool.space](https://mempool.space) - Real-time mempool visualization\n- [Bitcoin Core mempool documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-limits.md) - Technical details\n",
    "filename": "mempool.md"
  },
  "/docs/mining/block-construction": {
    "content": "# Block Construction\n\nBlock construction is the process by which miners assemble a new block from pending transactions. This is where the mempool meets the blockchain. Miners must decide which transactions to include, how to order them, and how to structure the block for maximum profit while following consensus rules.\n\n## Anatomy of a Block\n\nA Bitcoin block consists of two main parts:\n\n### Block Header (80 bytes)\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Version (4 bytes)                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Previous Block Hash (32 bytes)                  â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Merkle Root (32 bytes)                          â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Timestamp (4 bytes)                             â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Difficulty Target (4 bytes)                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Nonce (4 bytes)                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Block Body\n\n- **Coinbase Transaction**: First transaction, creates new bitcoin\n- **Regular Transactions**: Payments selected from the mempool\n\n## The Coinbase Transaction\n\nThe coinbase transaction is special: it's the only transaction that creates new bitcoin.\n\n### Structure\n\n```\nInputs:\n  - No previous output (creates coins from nothing)\n  - Coinbase data: Arbitrary data (up to 100 bytes)\n    - Must include block height (BIP34)\n    - Often includes miner identifier, messages, extra nonce\n\nOutputs:\n  - Block reward: Currently 3.125 BTC (after April 2024 halving)\n  - Transaction fees: Sum of all fees from included transactions\n  - Can have multiple outputs (pool payouts, etc.)\n```\n\n### Famous Coinbase Messages\n\n- **Genesis Block**: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\"\n- **Block 629999** (pre-halving): \"NYTimes 09/Apr/2020 With $2.3T Injection, Fed's Plan Far Exceeds 2008 Rescue\"\n\n### Coinbase Maturity\n\nCoinbase outputs cannot be spent until 100 blocks have passed. This prevents issues if the block is orphaned.\n\n## Transaction Selection\n\nMiners want to maximize revenue, which means selecting transactions that pay the highest fees per unit of block space.\n\n### The Knapsack Problem\n\nBlock construction is a variant of the knapsack optimization problem:\n\n- **Constraint**: Block weight limit (4 million weight units â‰ˆ 1 MB base + 3 MB witness)\n- **Objective**: Maximize total fees\n- **Complication**: Transaction dependencies (child transactions require parents)\n\n### Fee Rate Priority\n\nTransactions are generally sorted by **fee rate** (satoshis per virtual byte):\n\n```\nPriority Queue:\n1. Tx A: 100 sat/vB, 250 vB â†’ 25,000 sats fee\n2. Tx B: 80 sat/vB, 500 vB â†’ 40,000 sats fee\n3. Tx C: 50 sat/vB, 200 vB â†’ 10,000 sats fee\n...\n```\n\n### Ancestor Fee Rate\n\nWhen transactions have dependencies, miners calculate the **ancestor fee rate**:\n\n```\nParent Tx: 10 sat/vB, 200 vB\nChild Tx: 100 sat/vB, 150 vB\n\nAncestor fee rate of child = (10Ã—200 + 100Ã—150) / (200 + 150)\n                           = 17,000 / 350 = 48.6 sat/vB\n```\n\nThis is how CPFP (Child Pays for Parent) works: the child's high fee pulls the parent along.\n\n### Block Template Algorithm\n\nBitcoin Core's `getblocktemplate` uses this approach:\n\n1. **Sort by ancestor fee rate**: Calculate effective fee rate for each transaction\n2. **Add highest-fee transactions**: Fill the block greedily\n3. **Handle dependencies**: Include all ancestors when adding a transaction\n4. **Respect limits**: Stay within weight and sigop limits\n5. **Update calculations**: Recalculate fee rates as transactions are added\n\n## Block Weight and SegWit\n\nSince SegWit (2017), blocks use **weight** instead of raw size:\n\n```\nBlock Weight = (Base Size Ã— 4) + Witness Size\n\nMaximum Block Weight = 4,000,000 weight units (4 MWU)\n```\n\n### Practical Capacity\n\n- **Non-SegWit transactions**: ~1 MB per block\n- **All SegWit transactions**: Up to ~2.3 MB per block\n- **Typical mixed blocks**: ~1.5-2 MB\n\n### Why Weight Matters for Miners\n\nSegWit transactions are \"discounted\" because their witness data costs less weight. This means:\n\n- SegWit transactions can pay lower absolute fees for the same priority\n- Miners can fit more transactions in a block\n- More fees collected overall\n\n## Constructing the Merkle Root\n\nAll transactions in a block are hashed into a **Merkle tree**:\n\n```\n                    Merkle Root\n                   /           \\\n              Hash AB          Hash CD\n             /      \\         /      \\\n         Hash A    Hash B   Hash C   Hash D\n           |         |        |        |\n          Tx A      Tx B     Tx C     Tx D\n```\n\n### Why Merkle Trees?\n\n- **Efficient verification**: Prove a transaction is in a block with O(log n) hashes\n- **Compact proofs**: SPV wallets only need the Merkle path, not the full block\n- **Tamper detection**: Any change to any transaction changes the root\n\n### Merkle Tree Construction\n\n1. Hash each transaction (double SHA-256)\n2. Pair hashes and hash together\n3. If odd number, duplicate the last hash\n4. Repeat until one hash remains (the root)\n\n## The Block Template\n\nWhen a miner requests work, they receive a **block template**:\n\n```json\n{\n  \"version\": 536870912,\n  \"previousblockhash\": \"00000000000000000002a7c...\",\n  \"transactions\": [\n    {\n      \"txid\": \"abc123...\",\n      \"fee\": 25000,\n      \"weight\": 1000\n    },\n    ...\n  ],\n  \"coinbasevalue\": 312510000,\n  \"target\": \"00000000000000000004b3f...\",\n  \"mintime\": 1699999999,\n  \"mutable\": [\"time\", \"transactions\", \"coinbase\"]\n}\n```\n\n### Template Updates\n\nMiners should update their template:\n\n- **Every few seconds**: To include new high-fee transactions\n- **When a new block arrives**: Previous block hash changes\n- **When transactions confirm**: Remove now-invalid transactions\n\n## Empty Blocks\n\nSometimes miners produce **empty blocks** (only coinbase transaction):\n\n### Why Empty Blocks?\n\n1. **Speed**: Immediately after finding a block, miners start on the next\n2. **Validation lag**: New block's transactions aren't yet validated\n3. **Profit**: Block reward alone is still profitable\n\n### SPV Mining\n\nSome pools practice \"SPV mining\":\n\n1. See new block header from competitor\n2. Start mining on top immediately (without validating transactions)\n3. If the previous block was invalid, their block is also invalid\n\nThis is risky but provides a head start.\n\n## Extra Nonce\n\nThe 4-byte nonce in the header provides only 2Â³Â² possibilities, which is not enough for modern ASICs.\n\n### Expanding the Search Space\n\nMiners use additional variables:\n\n1. **Extra nonce in coinbase**: Arbitrary data that changes the Merkle root\n2. **Timestamp**: Can be adjusted within limits\n3. **Version bits**: Some bits can be rolled\n\n```\nSearch space:\n- Nonce: 4 bytes â†’ 2Â³Â² combinations\n- Extra nonce: 4-8 bytes â†’ 2Â³Â²-2â¶â´ combinations\n- Combined: Effectively unlimited\n```\n\n## Block Propagation Incentives\n\nMiners want their blocks to propagate quickly:\n\n### Compact Blocks (BIP 152)\n\nInstead of sending full blocks:\n\n1. Send block header + short transaction IDs\n2. Receiver reconstructs from mempool\n3. Request only missing transactions\n\nReduces block propagation from megabytes to kilobytes.\n\n### FIBRE Network\n\nA private relay network for miners:\n\n- Uses forward error correction\n- Optimized routing\n- Reduces orphan risk from slow propagation\n\n## Practical Example\n\nBuilding a block step by step:\n\n```\n1. Start with empty block\n   - Weight used: 0 / 4,000,000\n   - Fees collected: 0\n\n2. Create coinbase transaction\n   - Block reward: 3.125 BTC\n   - Reserve space for coinbase: ~200 weight units\n\n3. Select transactions from mempool\n   - Tx1: 50 sat/vB, 500 vB, 25,000 sat fee âœ“\n   - Tx2: 45 sat/vB, 1000 vB, 45,000 sat fee âœ“\n   - Tx3: 40 sat/vB, 800 vB, 32,000 sat fee âœ“\n   ...continue until block is full...\n\n4. Calculate Merkle root from all transactions\n\n5. Assemble block header\n   - Version: 0x20000000\n   - Previous hash: [from chain tip]\n   - Merkle root: [calculated]\n   - Timestamp: [current time]\n   - Bits: [current difficulty]\n   - Nonce: [start searching]\n\n6. Mine (search for valid nonce)\n```\n\n## Summary\n\nBlock construction is where mining meets economics:\n\n- **Coinbase creates new bitcoin** plus collects all fees\n- **Transaction selection** optimizes for fee revenue\n- **Merkle trees** provide efficient verification\n- **Weight limits** determine block capacity\n- **Propagation speed** affects orphan risk\n\nMiners balance:\n- Including high-fee transactions (more profit)\n- Keeping blocks small (faster propagation)\n- Updating templates (fresh transactions)\n- Starting quickly (after new block found)\n\n## Related Topics\n\n- [Mempool](/docs/mining/mempool) - Where transactions wait\n- [Proof-of-Work](/docs/mining/proof-of-work) - Finding valid blocks\n- [Mining Economics](/docs/mining/economics) - Revenue and costs\n- [Mining Pools](/docs/mining/pools) - Collaborative mining\n\n## Resources\n\n- [BIP 152: Compact Blocks](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)\n- [Bitcoin Core getblocktemplate](https://developer.bitcoin.org/reference/rpc/getblocktemplate.html)\n",
    "filename": "block-construction.md"
  },
  "/docs/mining/pools": {
    "content": "# Mining Pools\n\nA **mining pool** is a collective of miners who combine their computational resources to increase their chances of finding blocks. When the pool finds a block, the reward is distributed among participants based on their contributed work.\n\nSolo mining is like playing the lottery: you might wait years for a payout. Pool mining provides regular, predictable income at the cost of sharing rewards.\n\n## Why Mining Pools Exist\n\n### The Variance Problem\n\nConsider a solo miner with 0.001% of total network hashrate:\n\n- **Expected time to find a block**: ~1,000,000 blocks Ã· 0.00001 = 100,000,000 minutes â‰ˆ **190 years**\n- **Block reward**: 3.125 BTC (when you finally find one)\n- **Reality**: You might find one tomorrow, or never\n\nThis variance is unacceptable for anyone running mining as a business.\n\n### Pool Solution\n\nBy combining hashpower:\n\n- **Regular payouts**: Daily or even hourly\n- **Predictable income**: Based on contributed work\n- **Reduced variance**: Pool finds blocks frequently\n- **Small miner viability**: Even small operations can profit\n\n## How Mining Pools Work\n\n### Basic Flow\n\n```\n1. Miner connects to pool\n2. Pool sends work (block template)\n3. Miner searches for valid shares\n4. Miner submits shares to pool\n5. Pool validates shares and credits miner\n6. When pool finds a block, distribute rewards\n```\n\n### Shares vs Blocks\n\n**Shares** are proof that a miner is working:\n\n- A share is a hash that meets a lower difficulty than the network target\n- Easy to find (every few seconds)\n- Proves miner is honestly hashing\n- Pool uses shares to measure contribution\n\n**Blocks** are what actually pays:\n\n- A hash that meets the full network difficulty\n- Rare (pool might find one every few hours)\n- Contains the actual bitcoin reward\n\n```\nNetwork difficulty: 00000000000000000004b3f...\nPool share difficulty: 00000000004b3f...\n                       â†‘ Much easier target\n```\n\n### Contribution Tracking\n\nPools track each miner's work:\n\n```\nMiner A: 1,000,000 shares (10 TH/s)\nMiner B: 500,000 shares (5 TH/s)\nMiner C: 100,000 shares (1 TH/s)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal:   1,600,000 shares\n\nBlock found! Reward: 3.125 BTC\n\nMiner A: 3.125 Ã— (1,000,000 / 1,600,000) = 1.953 BTC\nMiner B: 3.125 Ã— (500,000 / 1,600,000) = 0.977 BTC\nMiner C: 3.125 Ã— (100,000 / 1,600,000) = 0.195 BTC\n```\n\n## Payout Schemes\n\nDifferent pools use different methods to distribute rewards.\n\n### Pay Per Share (PPS)\n\n- **How it works**: Pool pays fixed amount per share, regardless of whether blocks are found\n- **Miner risk**: None; guaranteed payment for work\n- **Pool risk**: High; pool absorbs variance\n- **Fees**: Higher (2-4%) to compensate pool risk\n\n```\nShare submitted â†’ Immediate credit\nNo waiting for blocks\nPool takes the gamble\n```\n\n### Full Pay Per Share (FPPS)\n\n- **Like PPS, but**: Also includes estimated transaction fees\n- **Benefit**: Miners get share of fees, not just block reward\n- **Popular because**: Transaction fees are increasingly important\n\n### Pay Per Last N Shares (PPLNS)\n\n- **How it works**: When block found, reward distributed based on last N shares\n- **Miner risk**: Medium; payment depends on luck and timing\n- **Pool risk**: Lower; only pays when blocks found\n- **Fees**: Lower (1-2%)\n- **Loyalty rewarded**: Miners who stay connected get better returns\n\n```\nBlock found!\nLook at last 1,000,000 shares\nYour 50,000 shares = 5% of reward\n```\n\n### PROP (Proportional)\n\n- **How it works**: Reward split proportionally among all shares since last block\n- **Problem**: Vulnerable to pool hopping\n- **Rarely used**: PPLNS is preferred\n\n### Score-Based\n\n- **How it works**: Recent shares weighted more heavily\n- **Benefit**: Discourages pool hopping\n- **Complexity**: Harder to understand and verify\n\n## Pool Protocols\n\n### Stratum (v1)\n\nThe dominant mining protocol since 2012:\n\n```\nPool â†’ Miner: Here's the block template\nMiner â†’ Pool: Here's a valid share\nPool â†’ Miner: Share accepted, new work\n```\n\n**Characteristics**:\n- Simple and widely supported\n- Pool controls block template completely\n- Miner just hashes what they're told\n\n**Downsides**:\n- Miners can't choose transactions\n- Pool has complete control over block content\n- Potential for censorship\n\n### Stratum V2\n\nModern replacement addressing Stratum v1's issues:\n\n**Key improvements**:\n- **Job negotiation**: Miners can propose their own block templates\n- **Encryption**: Communication is encrypted and authenticated\n- **Efficiency**: Binary protocol (not JSON), less bandwidth\n- **Decentralization**: Miners regain some sovereignty\n\n```\nTraditional (Stratum v1):\nPool â†’ Miner: \"Hash this exact template\"\n\nStratum V2 (with job negotiation):\nMiner â†’ Pool: \"Here's my proposed template\"\nPool â†’ Miner: \"Approved, hash it\"\n```\n\n### BetterHash (Predecessor to Stratum V2)\n\nMatt Corallo's proposal that influenced Stratum V2:\n\n- Miners construct their own blocks\n- Pool only provides coinbase and validates shares\n- Never widely adopted, but ideas live on\n\n## Centralization Concerns\n\nMining pools create centralization pressure:\n\n### The Problem\n\n```\nTop pools control majority of hashrate:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Foundry USA     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 31.94%  â”‚\nâ”‚ AntPool         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 14.98%           â”‚\nâ”‚ F2Pool          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 12.90%            â”‚\nâ”‚ ViaBTC          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 10.32%             â”‚\nâ”‚ SpiderPool      â–ˆâ–ˆâ–ˆ 7.14%                â”‚\nâ”‚ MARA Pool       â–ˆâ–ˆ 5.75%                 â”‚\nâ”‚ Others          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 16.97%          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Risks**:\n- Pool operator could censor transactions\n- Pool could attempt double-spend attacks\n- Government could pressure large pools\n- Collusion between pools\n\n### Mitigating Factors\n\n- **Miners can switch pools**: Instant exit if pool misbehaves\n- **Pool reputation matters**: Bad behavior means losing miners\n- **Stratum V2**: Gives miners more control\n- **Geographic distribution**: Pools operate in different jurisdictions\n\n### Decentralized Pools\n\nAttempts to remove pool operators:\n\n**P2Pool** (historical):\n- Miners run pool nodes\n- Separate blockchain tracks shares\n- No central operator\n- Died due to complexity and variance for small miners\n\n**Braidpool** (in development):\n- Modern attempt at decentralized pooling\n- Uses DAG structure for share tracking\n- Still experimental\n\n## Choosing a Pool\n\nFactors to consider:\n\n### Payout Method\n- **PPS/FPPS**: Stable income, higher fees\n- **PPLNS**: Variable income, lower fees, rewards loyalty\n\n### Fees\n- Range from 0% to 4%\n- Consider fee vs payout method trade-off\n\n### Minimum Payout\n- Some pools hold funds until threshold\n- Lower threshold = more frequent payouts\n- Higher threshold = lower transaction fee percentage\n\n### Server Locations\n- Closer servers = less latency\n- Less latency = fewer stale shares\n- Stale shares = lost money\n\n### Transparency\n- Can you verify payouts?\n- Is hashrate displayed accurately?\n- What's the pool's track record?\n\n### Stratum V2 Support\n- Gives you more control\n- Better for network decentralization\n- Still being adopted\n\n## Pool Economics\n\n### Pool Revenue\n\n```\nBlock reward:           3.125 BTC\nAverage transaction fees: 0.25 BTC\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal per block:        3.375 BTC\n\nPool finds 10 blocks/day:\nDaily revenue: 33.75 BTC\n```\n\n### Pool Costs\n\n- **Infrastructure**: Servers, bandwidth, monitoring\n- **Development**: Software maintenance\n- **Operations**: Staff, support\n- **Variance buffer**: Reserve for unlucky streaks (PPS pools)\n\n### Miner Economics\n\n```\nYour hashrate: 100 TH/s\nNetwork hashrate: 500 EH/s\nYour share: 0.00002%\n\nDaily block rewards: 450 blocks Ã— 3.375 BTC = 1,518.75 BTC\nYour share: 1,518.75 Ã— 0.00002% = 0.000304 BTC/day\n\nAt $60,000/BTC: ~$18/day revenue\nElectricity: ~$12/day (varies widely)\nProfit: ~$6/day\n```\n\n## Setting Up Pool Mining\n\n### Requirements\n\n1. **Mining hardware**: ASICs for Bitcoin\n2. **Pool account**: Register with chosen pool\n3. **Mining software**: CGMiner, BFGMiner, or manufacturer software\n4. **Wallet**: For receiving payouts\n\n### Basic Configuration\n\n```\nPool URL: stratum+tcp://pool.example.com:3333\nUsername: your_wallet_address.worker_name\nPassword: x (often ignored)\n```\n\n### Multiple Pools (Failover)\n\n```\nPrimary: pool1.example.com:3333\nSecondary: pool2.example.com:3333\nTertiary: pool3.example.com:3333\n```\n\nIf primary fails, automatically switch to secondary.\n\n## Summary\n\nMining pools solve the variance problem:\n\n- **Combine resources**: Small miners can participate\n- **Regular payouts**: Predictable income\n- **Shared risk**: Pool absorbs variance (PPS) or shares it (PPLNS)\n\nTrade-offs:\n- **Fees**: Pools take 1-4%\n- **Centralization**: Large pools control significant hashrate\n- **Control**: Traditional pools control block construction\n\nThe future is moving toward:\n- **Stratum V2**: More miner control\n- **Decentralized pools**: No central operator\n- **Transaction selection**: Miners choosing what to include\n\n## Related Topics\n\n- [Mining Economics](/docs/mining/economics) - Profitability calculations\n- [Block Construction](/docs/mining/block-construction) - How blocks are built\n- [Proof-of-Work](/docs/mining/proof-of-work) - The mining algorithm\n- [Hardware Evolution](/docs/mining/hardware) - Mining equipment history\n\n## Resources\n\n- [Stratum V2](https://stratumprotocol.org/) - Next-generation mining protocol\n- [Braidpool](https://github.com/braidpool/braidpool) - Decentralized pool project\n- [Mining Pool Stats](https://miningpoolstats.stream/bitcoin) - Pool hashrate distribution\n",
    "filename": "pools.md"
  },
  "/docs/mining/hardware": {
    "content": "# Mining Hardware Evolution\n\nBitcoin mining hardware has undergone a remarkable evolution, from hobbyists running CPUs on laptops to industrial-scale operations with purpose-built silicon. This progression represents one of the fastest hardware development cycles in computing history, driven by the economic incentives of proof-of-work mining.\n\n## The Four Eras of Mining Hardware\n\n### Era 1: CPU Mining (2009-2010)\n\n**The Beginning**\n\nWhen Satoshi launched Bitcoin, mining was done on ordinary computer CPUs:\n\n- **Hardware**: Intel/AMD desktop processors\n- **Hashrate**: 1-20 MH/s\n- **Power**: 50-150W\n- **Efficiency**: ~0.1 MH/J\n- **Who mined**: Cypherpunks, early adopters, Satoshi\n\n**Why CPUs Work**\n\nSHA-256 (Bitcoin's hash function) is computationally simple:\n- Bitwise operations (AND, OR, XOR)\n- 32-bit additions\n- No complex branching\n- Highly parallelizable\n\nCPUs can do this, but they're general-purpose. Most of their transistors do things irrelevant to hashing.\n\n**The End of CPU Mining**\n\nBy late 2010, GPU mining emerged. CPU miners quickly became unprofitable and disappeared.\n\n### Era 2: GPU Mining (2010-2013)\n\n**The GPU Advantage**\n\nGraphics cards excel at parallel computation:\n\n- **Hardware**: AMD Radeon, NVIDIA GeForce\n- **Hashrate**: 10-800 MH/s\n- **Power**: 100-300W\n- **Efficiency**: ~2-4 MH/J\n- **Improvement**: 10-50x over CPUs\n\n**Why GPUs Excel**\n\n```\nCPU: 4-8 cores, each very fast, complex\n     Good at: varied tasks, branching logic\n     \nGPU: 1000+ cores, each slower, simpler\n     Good at: same operation on many data points\n     Perfect for: trying billions of nonces\n```\n\n**The GPU Mining Era**\n\n- AMD cards preferred (better for SHA-256)\n- Mining farms with racks of graphics cards\n- Gaming GPU shortages began\n- Some miners used OpenCL/CUDA optimizations\n\n**Popular GPU Mining Cards**\n\n| Card | Hashrate | Power | Era |\n|------|----------|-------|-----|\n| ATI Radeon 5870 | 400 MH/s | 200W | 2010 |\n| AMD Radeon 7970 | 700 MH/s | 250W | 2012 |\n| AMD R9 290X | 900 MH/s | 300W | 2013 |\n\n### Era 3: FPGA Mining (2011-2013)\n\n**Field Programmable Gate Arrays**\n\nFPGAs are chips that can be reconfigured for specific tasks:\n\n- **Hardware**: Xilinx, Altera FPGAs\n- **Hashrate**: 100-800 MH/s\n- **Power**: 20-80W\n- **Efficiency**: ~10-20 MH/J\n- **Improvement**: 5-10x efficiency over GPUs\n\n**FPGA Advantages**\n\n- Much more power efficient than GPUs\n- Could be reprogrammed if algorithm changed\n- Lower heat generation\n\n**FPGA Disadvantages**\n\n- Expensive development\n- Limited availability\n- Required technical expertise\n- Quickly obsoleted by ASICs\n\n**Short-Lived Era**\n\nFPGAs were a transitional technology. The efficiency gains made ASICs inevitable and economically viable.\n\n### Era 4: ASIC Mining (2013-Present)\n\n**Application-Specific Integrated Circuits**\n\nASICs are chips designed to do one thing only: SHA-256 hashing.\n\n- **Hardware**: Custom silicon from Bitmain, MicroBT, Canaan, etc.\n- **Hashrate**: 1 TH/s â†’ 250+ TH/s (2013 â†’ 2024)\n- **Power**: 500-3500W per unit\n- **Efficiency**: 100 J/TH â†’ 15 J/TH (improving constantly)\n- **Improvement**: 1000x+ over GPUs\n\n**Why ASICs Dominate**\n\n```\nGPU: General-purpose silicon\n     - 30% doing hashing\n     - 70% doing other stuff\n\nASIC: Purpose-built silicon\n     - 100% doing hashing\n     - Nothing wasted\n```\n\nEvery transistor in an ASIC is dedicated to SHA-256. No graphics processing, no floating point, no cache hierarchy, just hashing.\n\n## ASIC Evolution\n\n### Generation Timeline\n\n| Era | Example | Hashrate | Efficiency | Year |\n|-----|---------|----------|------------|------|\n| Gen 1 | Avalon 1 | 66 GH/s | 9,000 J/TH | 2013 |\n| Gen 2 | Antminer S1 | 180 GH/s | 2,000 J/TH | 2013 |\n| Gen 3 | Antminer S5 | 1.15 TH/s | 510 J/TH | 2014 |\n| Gen 4 | Antminer S7 | 4.7 TH/s | 250 J/TH | 2015 |\n| Gen 5 | Antminer S9 | 14 TH/s | 100 J/TH | 2016 |\n| Gen 6 | Antminer S17 | 56 TH/s | 45 J/TH | 2019 |\n| Gen 7 | Antminer S19 | 95 TH/s | 34 J/TH | 2020 |\n| Gen 8 | Antminer S19 XP | 140 TH/s | 21 J/TH | 2022 |\n| Gen 9 | Antminer S21 | 200 TH/s | 17.5 J/TH | 2023 |\n| Gen 10 | Antminer S21 XP | 270 TH/s | 13.5 J/TH | 2024 |\n\n### Process Node Shrinks\n\nASIC efficiency improves primarily through semiconductor process improvements:\n\n```\n2013: 110nm, 55nm\n2014: 28nm\n2016: 16nm\n2018: 7nm\n2020: 5nm\n2023: 3nm (emerging)\n```\n\nSmaller transistors = less power per hash = better efficiency.\n\n### Major Manufacturers\n\n**Bitmain (China)**\n- Market leader, Antminer series\n- Founded 2013 by Jihan Wu and Micree Zhan\n- Controversial: BCH support, internal conflicts\n- Products: S9, S17, S19, S21 series\n\n**MicroBT (China)**\n- Strong competitor, Whatsminer series\n- Founded 2016 by former Bitmain engineer\n- Known for reliability\n- Products: M20, M30, M50, M60 series\n\n**Canaan (China)**\n- First ASIC manufacturer (Avalon)\n- Publicly traded (NASDAQ: CAN)\n- Products: Avalon series\n\n**Intel (USA)**\n- Entered market 2022 with Blockscale\n- Focused on efficiency\n- Exited market 2024\n\n**Bitfury (Netherlands/USA)**\n- Vertically integrated (makes and uses chips)\n- Known for immersion cooling\n- Products: Clarke, Bitfury B8\n\n## Efficiency Metrics\n\n### Joules per Terahash (J/TH)\n\nThe key efficiency metric:\n\n```\nJ/TH = Watts Ã· (Terahashes per second)\n\nExample: 3000W machine doing 100 TH/s\nEfficiency = 3000 Ã· 100 = 30 J/TH\n```\n\nLower is better. Modern machines: 15-25 J/TH.\n\n### Hashrate per Dollar\n\nConsider total cost of ownership:\n\n```\nMachine cost: $5,000\nHashrate: 100 TH/s\nLifespan: 3 years\n\nCost per TH/s/year: $5,000 Ã· 100 Ã· 3 = $16.67\n```\n\n### Break-Even Analysis\n\n```\nRevenue per TH/day: ~$0.08 (varies with difficulty and price)\nElectricity cost: $0.05/kWh\nMachine efficiency: 25 J/TH\n\nPower per TH/day: 25 J/s Ã— 86,400 s = 2.16 MJ = 0.6 kWh\nElectricity per TH/day: 0.6 Ã— $0.05 = $0.03\n\nProfit per TH/day: $0.08 - $0.03 = $0.05\n```\n\n## Industrial Mining Operations\n\n### Scale\n\nModern mining farms:\n\n- **Hashrate**: 1-50 EH/s (exahashes per second)\n- **Power**: 50-500 MW\n- **Machines**: 10,000-100,000+ ASICs\n- **Investment**: $100M-$1B+\n\n### Infrastructure Requirements\n\n**Power**\n- Cheap electricity is critical ($0.02-0.05/kWh ideal)\n- Substations, transformers, distribution\n- Often: stranded energy, renewables, flared gas\n\n**Cooling**\n- ASICs generate enormous heat\n- Air cooling: fans, ducting, outdoor air\n- Immersion cooling: machines submerged in dielectric fluid\n- Target: 15-25Â°C ambient\n\n**Networking**\n- Low latency to pools\n- Redundant connections\n- Monitoring systems\n\n**Security**\n- Physical security (machines are valuable)\n- Cybersecurity (prevent hashrate theft)\n- Fire suppression\n\n### Geographic Distribution\n\nMining gravitates toward cheap power:\n\n- **United States**: Texas (wind), Georgia (nuclear), Wyoming\n- **Canada**: Quebec (hydro), Alberta\n- **Kazakhstan**: Coal power (declining due to regulations)\n- **Russia**: Siberia (hydro, cold climate)\n- **Nordic countries**: Hydro, geothermal, cold\n- **Middle East**: UAE, Oman (cheap natural gas)\n\n## Home Mining\n\n### Is It Viable?\n\nFor most people in most places: marginally, or no.\n\n**Challenges**:\n- Electricity costs ($0.10-0.30/kWh residential)\n- Noise (70-80 dB, like a vacuum cleaner)\n- Heat (3kW space heater per machine)\n- Space and ventilation\n\n**Where It Works**:\n- Cheap or free electricity\n- Cold climates (use heat)\n- Off-grid (solar, hydro)\n- Learning/hobby purposes\n\n### Home Mining Options\n\n**Full ASIC**\n- Antminer S9 (old, cheap, inefficient)\n- Small new units (Antminer S19 nano)\n- Noise and heat issues\n\n**USB/Low-power**\n- FutureBit Apollo\n- Nerdminer (ESP32)\n- Not profitable, but educational\n\n**Heating Integration**\n- Heatbit, Hestiia\n- ASIC mining as home heating\n- Heat is a feature, not waste\n\n## The ASIC Trap\n\n### No Escape\n\nOnce ASICs exist, there's no going back:\n\n1. **ASICs are 10,000x more efficient** than GPUs\n2. **GPU miners can't compete**\n3. **ASIC investment creates lock-in**\n4. **Algorithm changes would destroy investment**\n\n### ASIC Resistance (Other Coins)\n\nSome cryptocurrencies tried to resist ASICs:\n\n- **Memory-hard algorithms**: Ethereum (Ethash), Monero (RandomX)\n- **Frequent algorithm changes**: Monero\n- **ASIC-resistant designs**: Often just delays ASICs\n\nBitcoin's position: ASICs are a feature, not a bug. They represent committed capital that can't be repurposed.\n\n## Future Trends\n\n### Efficiency Limits\n\nPhysical limits are approaching:\n\n- **3nm/2nm processes**: Near atomic scale\n- **Thermodynamic limits**: Minimum energy per computation\n- **Diminishing returns**: Each generation improves less\n\n### Immersion Cooling\n\nSubmerging ASICs in dielectric fluid:\n\n- **Better cooling**: Removes heat more efficiently\n- **Overclocking**: Run chips faster\n- **Longevity**: Less thermal stress\n- **Density**: More machines per space\n\n### Stranded Energy\n\nMining as flexible load:\n\n- **Flared gas**: Capture otherwise wasted energy\n- **Curtailed renewables**: Use excess wind/solar\n- **Grid balancing**: Ramp up/down based on demand\n- **Remote locations**: Monetize energy that can't reach grid\n\n### Vertical Integration\n\nLarge miners building their own chips:\n\n- **Reduce reliance on Bitmain/MicroBT**\n- **Custom optimizations**\n- **Supply chain control**\n- **Examples**: Bitfury, Intel (briefly), Block/Square (planned)\n\n## Summary\n\nThe evolution of mining hardware:\n\n| Era | Technology | Efficiency Gain | Timeline |\n|-----|------------|-----------------|----------|\n| 1 | CPU | Baseline | 2009-2010 |\n| 2 | GPU | 10-50x | 2010-2013 |\n| 3 | FPGA | 5-10x | 2011-2013 |\n| 4 | ASIC | 1000x+ | 2013-present |\n\nKey takeaways:\n\n- **ASICs dominate** and will continue to\n- **Efficiency is everything**: J/TH determines profitability\n- **Industrial scale** is increasingly dominant\n- **Hardware is expensive** and depreciates quickly\n- **Location matters**: Cheap power wins\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - What the hardware computes\n- [Mining Economics](/docs/mining/economics) - Profitability analysis\n- [Mining Pools](/docs/mining/pools) - How miners collaborate\n- [Difficulty Adjustment](/docs/mining/difficulty) - How network responds to hashrate\n\n## Resources\n\n- [ASIC Miner Value](https://www.asicminervalue.com/) - Profitability calculator\n- [Hashrate Index](https://hashrateindex.com/) - Mining market data\n- [Cambridge Bitcoin Electricity Consumption Index](https://ccaf.io/cbeci) - Network energy use\n",
    "filename": "hardware.md"
  },
  "/docs/mining/attacks": {
    "content": "# Mining Attacks\n\nBitcoin's proof-of-work security model is designed to make attacks economically irrational. However, understanding potential attacks is crucial for appreciating Bitcoin's security properties and the incentives that protect the network.\n\nThis section covers theoretical attacks on Bitcoin mining, their costs, and why they generally don't happen.\n\n## The 51% Attack\n\nThe most discussed attack on Bitcoin: what if someone controls more than half the network's hashrate?\n\n### What It Enables\n\nWith >50% hashrate, an attacker can:\n\n1. **Double-spend**: Reverse their own transactions\n2. **Block transactions**: Prevent specific transactions from confirming\n3. **Empty blocks**: Mine blocks with no transactions (censorship)\n\n### What It Doesn't Enable\n\nEven with 51%, an attacker **cannot**:\n\n- **Steal coins**: Can't create valid signatures for others' coins\n- **Change consensus rules**: Can't create coins, change block rewards\n- **Spend anyone's coins**: Only their own (for double-spends)\n- **Modify historical transactions**: Only recent blocks (cost increases with depth)\n\n### How It Works\n\n```\nHonest chain:    A â†’ B â†’ C â†’ D â†’ E â†’ F\n                              â†‘\n                        Attacker buys something\n                        \nAttacker mines secretly:\n                 A â†’ B â†’ C â†’ D'â†’ E'â†’ F'â†’ G'\n                              â†‘\n                        Same coins spent differently\n                        \nWhen attacker's chain is longer, it becomes the valid chain.\nThe honest chain is orphaned. Double-spend succeeds.\n```\n\n### Cost Analysis\n\n**Renting Hashrate**\n\nAt 500 EH/s network hashrate, 51% = 250 EH/s\n\n```\nCost to rent 250 EH/s:\n- Hardware doesn't exist to rent at this scale\n- Would require owning majority of world's ASICs\n- Estimated cost: $10-20 billion in equipment alone\n- Plus electricity, facilities, etc.\n```\n\n**Opportunity Cost**\n\nIf you have 51% hashrate, honest mining is extremely profitable:\n\n```\n51% of block rewards:\n- 225 blocks/day Ã— 3.375 BTC Ã— 51% = 387 BTC/day\n- At $60,000/BTC = $23M per day\n- $8.5 billion per year\n\nWhy attack when honest mining is this lucrative?\n```\n\n### Historical Non-Attacks\n\nNo successful 51% attack on Bitcoin mainnet has ever occurred. The economics don't work:\n\n- Cost exceeds potential gain\n- Attack destroys value of the asset you're attacking\n- Your own holdings lose value\n- Criminal liability is enormous\n\n### Detection\n\n51% attacks are visible:\n\n- Sudden hashrate spike from unknown source\n- Chain reorganizations (reorgs)\n- Confirmed transactions disappearing\n\n### Defenses\n\n- **Wait for confirmations**: More confirmations = harder to reverse\n- **6 confirmations**: Traditional standard (~1 hour)\n- **Large amounts**: Wait for more confirmations\n- **Economic finality**: Eventually, attack cost exceeds transaction value\n\n## Selfish Mining\n\nA subtle attack where miners can gain unfair advantage with less than 50% hashrate.\n\n### How It Works\n\nNormal mining: Find a block â†’ immediately broadcast it\n\nSelfish mining:\n1. Find a block â†’ **keep it secret**\n2. Continue mining on your secret chain\n3. If honest miners catch up, release your block\n4. You get the reward, honest miners' work is wasted\n\n### The Strategy\n\n```\nScenario: Selfish miner has 30% hashrate\n\n1. Selfish miner finds block A\n   Secret chain: [A]\n   Public chain: []\n   \n2. Keep mining secretly\n   If selfish miner finds B before public finds anything:\n   Secret chain: [A, B]  â† 2 block lead\n   \n3. When public finds a block:\n   - If selfish lead â‰¥ 2: release one block, maintain lead\n   - If selfish lead = 1: race to propagate\n   - If selfish lead = 0: lost this round\n```\n\n### Profitability Threshold\n\nSelfish mining becomes profitable above ~33% hashrate (with optimal network position) or ~25% (with network advantages).\n\nBelow this threshold, the strategy loses money compared to honest mining.\n\n### Why It Rarely Happens\n\n1. **Threshold is high**: Need significant hashrate\n2. **Detection risk**: Unusual block timing patterns\n3. **Pool transparency**: Large pools are monitored\n4. **Reputation damage**: Discovered selfish mining destroys trust\n5. **Coordination**: Requires all pool miners to participate\n\n### Defenses\n\n- **Uniform tie-breaking**: Nodes randomly choose between equal-height blocks\n- **Timestamp analysis**: Detect anomalous block timing\n- **Pool monitoring**: Watch for suspicious behavior\n\n## Block Withholding Attack\n\nAn attack by pool miners against their own pool.\n\n### How It Works\n\n1. Miner joins a pool\n2. Submits partial shares (proving work)\n3. When finding a valid block, **doesn't submit it**\n4. Pool pays miner for shares but gets no blocks\n\n### Impact\n\n- Pool loses revenue (missing blocks)\n- Attacker earns from shares but sabotages pool\n- Other pool members subsidize the attacker\n\n### Motivation\n\n- Competitor pools attacking each other\n- Extortion\n- Spite\n\n### Defenses\n\n- **Statistical analysis**: Detect miners who never find blocks\n- **Stratum V2**: Better work validation\n- **Reputation systems**: Track miner history\n\n## Fee Sniping\n\nMiners stealing high-fee transactions from other miners' blocks.\n\n### How It Works\n\n```\nBlock N contains a transaction with 10 BTC in fees (unusually high)\n\nAttacker sees Block N, thinks:\n\"If I mine an alternative Block N with that transaction, \nI get those 10 BTC instead.\"\n\nAttacker mines competing Block N' including the high-fee tx.\n```\n\n### Requirements\n\n- Very high-fee transaction (worth the orphan risk)\n- Significant hashrate (to win the race)\n- Quick reaction (see block, start mining alternative)\n\n### Why It's Rare\n\n- Need to out-mine honest miners extending Block N\n- Costs the block reward if you lose\n- Not worth it for normal fees\n\n### Prevention\n\n- **nLockTime**: Transactions can specify earliest block\n- **CLTV**: Similar lock-time mechanism\n- **Low fees**: Don't create tempting targets\n\n## Transaction Pinning\n\nAn attack relevant to Layer 2 protocols like Lightning.\n\n### How It Works\n\n1. Attacker creates a low-fee transaction spending the same output\n2. Transaction is large, making CPFP expensive\n3. Victim's transaction can't confirm\n4. Time-sensitive protocols (Lightning) may fail\n\n### Impact on Lightning\n\nLightning channels have time-locked transactions. If these can't confirm:\n\n- Attacker might steal funds\n- Force-close may fail\n- Victim loses money\n\n### Defenses\n\n- **Package relay**: Let related transactions propagate together\n- **Anchor outputs**: Pre-planned fee-bumping mechanisms\n- **v3 transactions**: New policy to limit pinning\n\n## Time-Warp Attack\n\nExploiting timestamp manipulation over difficulty adjustment periods.\n\n### How It Works\n\nDifficulty adjusts every 2016 blocks based on timestamps.\n\n```\nNormal: 2016 blocks in 2 weeks â†’ difficulty unchanged\n\nAttack:\n1. Set first block timestamp = minimum allowed\n2. Set last block timestamp = maximum allowed\n3. Period appears longer than 2 weeks\n4. Difficulty decreases artificially\n5. Mine faster, get more rewards\n```\n\n### Requirements\n\n- Majority hashrate (to control timestamps)\n- Patience (takes many difficulty periods)\n- Coordination (all block timestamps must be manipulated)\n\n### Why It's Theoretical\n\n- Requires 51% hashrate (major attack already)\n- Slow payoff (months to exploit)\n- Easily detected\n- Could be fixed with soft fork\n\n## Eclipse Attack\n\nIsolating a node from the real network.\n\n### How It Works\n\n1. Attacker surrounds victim with malicious nodes\n2. Victim only connects to attacker's nodes\n3. Attacker feeds victim a fake chain\n4. Victim accepts invalid transactions\n\n### Impact\n\n- Victim might accept unconfirmed transactions\n- Victim might mine on wrong chain\n- Victim might accept double-spends\n\n### Defenses\n\n- **More connections**: Connect to many diverse peers\n- **DNS seeds**: Use multiple bootstrap sources\n- **Manual peering**: Add known-good peers\n- **Outbound connections**: Prioritize connections you initiate\n\n## Finney Attack\n\nNamed after [Hal Finney](/docs/history/people#hal-finney-1956-2014), this is a race between broadcasting blocks and transactions.\n\n### How It Works\n\n1. Attacker mines block containing tx spending to themselves\n2. Keep block secret\n3. Spend same coins at merchant (buy something)\n4. Immediately broadcast secret block\n5. Merchant's transaction is now invalid\n\n### Requirements\n\n- Find a block (significant hashrate)\n- Execute purchase very quickly (before someone else finds a block)\n- Merchant accepts 0-confirmation transactions\n\n### Defense\n\n- **Wait for confirmations**: Even 1 confirmation defeats this\n- **Don't accept 0-conf**: For significant amounts\n\n## Goldfinger Attack\n\nAttack Bitcoin not for profit, but for destruction.\n\n### Motivation\n\n- Nation-state wanting to kill Bitcoin\n- Competitor (central bank?) wanting to discredit crypto\n- Ideological opposition\n\n### Method\n\n- Acquire massive hashrate regardless of cost\n- Use it to disrupt the network\n- Not trying to profit; trying to destroy\n\n### Defense\n\n- **Sheer scale**: 500+ EH/s is hard to match\n- **Decentralization**: No single point of attack\n- **Adaptability**: Network can respond (emergency difficulty adjustment, algorithm change)\n- **Resilience**: Bitcoin has survived many attacks and attempts\n\n### Reality Check\n\nThis attack requires:\n\n- Billions of dollars\n- Global supply chain capture\n- Sustained attack (one-time disruption isn't fatal)\n- Facing legal consequences in every jurisdiction\n\n## Summary\n\nBitcoin's mining attacks show why the security model works:\n\n| Attack | Requirement | Profitability | Likelihood |\n|--------|-------------|---------------|------------|\n| 51% Attack | >50% hashrate | Usually negative | Very low |\n| Selfish Mining | >25-33% hashrate | Marginal | Low |\n| Block Withholding | Pool participation | Negative-sum | Low |\n| Fee Sniping | High fees + hashrate | Rarely worthwhile | Very low |\n| Time-Warp | 51% + patience | Possible | Theoretical |\n| Eclipse | Network control | Situation-specific | Possible |\n\n**The key insight**: Bitcoin is protected by economics, not just cryptography. Attacks are possible but rarely profitable.\n\nMost attacks require:\n- Enormous capital expenditure\n- Destroying the value of your investment\n- Obvious detection\n- Criminal liability\n\nHonest mining is almost always more profitable than attacking.\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - The security mechanism\n- [Mining Economics](/docs/mining/economics) - Why honest mining pays\n- [Difficulty Adjustment](/docs/mining/difficulty) - How network responds\n- [Consensus Mechanism](/docs/fundamentals/consensus) - How Bitcoin achieves agreement\n\n## Resources\n\n- [Selfish Mining Paper](https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf) - Original academic analysis\n- [Bitcoin Security Model](https://nakamotoinstitute.org/library/security-model/) - Comprehensive overview\n",
    "filename": "attacks.md"
  },
  "/docs/wallets/overview": {
    "content": "# Bitcoin Wallet Overview\n\n## What is a Bitcoin Wallet?\n\nA Bitcoin wallet is a software application or device that allows users to store, send, and receive Bitcoin. Despite the name, a wallet doesn't actually \"store\" Bitcoin. Bitcoin exists only on the blockchain. Instead, a wallet stores the **private keys** needed to access and control Bitcoin addresses.\n\n### Key Concepts\n\n- **Private Key**: Secret cryptographic key that proves ownership of Bitcoin\n- **Public Key**: Derived from private key, used to generate addresses\n- **Address**: Public identifier where Bitcoin can be received (like an account number)\n- **UTXO**: Unspent Transaction Output, the actual \"coins\" on the blockchain\n- **Seed Phrase**: Human-readable backup of private keys (12-24 words)\n\n## Types of Wallets\n\n### By Storage Location\n\n#### Hot Wallets\n- **Online**: Connected to the internet\n- **Examples**: Mobile apps, web wallets, exchange wallets\n- **Pros**: Easy to use, quick access\n- **Cons**: More vulnerable to hacking\n\n#### Cold Wallets\n- **Offline**: Not connected to the internet\n- **Examples**: Hardware wallets, paper wallets\n- **Pros**: More secure, less vulnerable to attacks\n- **Cons**: Less convenient for frequent transactions\n\n### By Control\n\n#### Custodial Wallets\n- **Third-party control**: Exchange or service holds your keys\n- **Examples**: Coinbase, Binance wallets\n- **Pros**: Easy recovery, user-friendly\n- **Cons**: You don't control your keys (\"not your keys, not your coins\")\n\n#### Non-Custodial Wallets\n- **Self-custody**: You control your private keys\n- **Examples**: Electrum, Bitcoin Core, hardware wallets\n- **Pros**: Full control, more secure\n- **Cons**: You're responsible for key management\n\n### By Technology\n\n#### Full Node Wallets\n- **Bitcoin Core**: Downloads entire blockchain\n- **Pros**: Maximum privacy, validates all transactions\n- **Cons**: Requires significant storage and bandwidth\n\n#### SPV (Simplified Payment Verification) Wallets\n- **Light clients**: Don't download full blockchain\n- **Pros**: Faster setup, less storage\n- **Cons**: Less privacy, relies on other nodes\n\n#### Hardware Wallets\n- **Physical devices**: Ledger, Trezor, Coldcard\n- **Pros**: Excellent security, keys never leave device\n- **Cons**: Cost, requires physical device\n\n## How Wallets Work\n\n### Key Generation\n\n1. **Random Generation**: Private key is randomly generated (256 bits)\n2. **Public Key Derivation**: Public key derived using elliptic curve cryptography\n3. **Address Creation**: Address generated from public key using hash functions\n4. **Address Types**: P2PKH, P2SH, P2WPKH, P2TR (Taproot)\n\n### Transaction Process\n\n1. **UTXO Selection**: Wallet chooses which UTXOs to spend\n2. **Transaction Creation**: Builds transaction with inputs and outputs\n3. **Signing**: Signs transaction with private key(s)\n4. **Broadcasting**: Sends transaction to Bitcoin network\n5. **Confirmation**: Transaction included in a block\n\n### Address Management\n\n- **HD Wallets**: Hierarchical Deterministic wallets generate addresses from a single seed\n- **Key Derivation**: Uses BIP32/BIP44 standards\n- **Address Reuse**: Generally discouraged for privacy\n- **Change Addresses**: New addresses created for change outputs\n\n## Creating a Wallet\n\n### Software Wallet (Bitcoin Core)\n\n```bash\n# Install Bitcoin Core\n# Download from bitcoin.org\n\n# Start Bitcoin Core (will create wallet.dat)\nbitcoind -daemon\n\n# Create new wallet\nbitcoin-cli createwallet \"mywallet\"\n\n# Get new address\nbitcoin-cli getnewaddress\n\n# Get wallet info\nbitcoin-cli getwalletinfo\n```\n\n### Software Wallet (Electrum)\n\n1. **Download**: Get Electrum from electrum.org\n2. **Install**: Run installer for your platform\n3. **Create Wallet**: \n   - Choose \"Standard wallet\"\n   - Select \"Create a new seed\"\n   - Save seed phrase securely\n4. **Set Password**: Choose encryption password\n5. **Ready**: Wallet is created and ready to use\n\n### Hardware Wallet\n\n1. **Purchase**: Buy hardware wallet (Ledger, Trezor, etc.)\n2. **Initialize**: Follow device instructions\n3. **Generate Seed**: Device generates 24-word seed phrase\n4. **Backup Seed**: Write down seed phrase (never digital!)\n5. **Set PIN**: Create PIN for device access\n6. **Install Software**: Install companion app (Ledger Live, etc.)\n7. **Connect**: Connect device and create Bitcoin account\n\n### Programmatic Wallet Creation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey, PrivateKey,\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate key pair\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    // Create private key\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    \n    // Create public key and address (P2PKH)\n    let public_key = PublicKey::new(public_key);\n    let address = Address::p2pkh(&public_key, Network::Bitcoin);\n    \n    println!(\"Private Key (WIF): {}\", private_key);\n    println!(\"Address: {}\", address);\n}\n```\n\n```python\nfrom bitcoin import *\n\n# Generate private key\nprivate_key = random_key()\n\n# Derive public key\npublic_key = privtopub(private_key)\n\n# Generate address (P2PKH)\naddress = pubtoaddr(public_key)\n\nprint(f\"Private Key: {private_key}\")\nprint(f\"Address: {address}\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate random private key (256 bits)\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    // Derive public key\n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Generate P2PKH address\n    bc::wallet::ec_private private_key(secret, bc::wallet::ec_private::mainnet);\n    bc::wallet::payment_address address(public_key);\n    \n    std::cout << \"Private Key (WIF): \" << private_key.encoded() << std::endl;\n    std::cout << \"Address: \" << address.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { randomBytes } = require('crypto');\n\n// Generate key pair\nconst keyPair = bitcoin.ECPair.makeRandom();\n\n// Get private key (WIF format)\nconst privateKey = keyPair.toWIF();\n\n// Generate address (P2PKH)\nconst { address } = bitcoin.payments.p2pkh({ \n  pubkey: keyPair.publicKey \n});\n\nconsole.log('Private Key:', privateKey);\nconsole.log('Address:', address);\n```\n:::\n\n## Wallet Security Best Practices\n\n### Private Key Management\n\n- **Never share**: Never share your private keys or seed phrase\n- **Secure storage**: Store seed phrases offline, physically secure\n- **Multiple backups**: Create multiple backups in different locations\n- **No digital storage**: Never store seed phrases on computers or cloud\n\n### Security Measures\n\n- **Use hardware wallets**: For significant amounts\n- **Enable 2FA**: Where possible (for custodial wallets)\n- **Verify addresses**: Always verify receiving addresses\n- **Test transactions**: Send small amounts first\n- **Keep software updated**: Update wallet software regularly\n\n### Backup Strategies\n\n- **Seed phrase backup**: Write down seed phrase, store securely\n- **Multiple locations**: Keep backups in different physical locations\n- **Test recovery**: Verify you can recover wallet from seed phrase\n- **Encryption**: Encrypt backups if storing digitally (but prefer physical)\n\n## Wallet Features\n\n### Basic Features\n\n- **Send Bitcoin**: Create and broadcast transactions\n- **Receive Bitcoin**: Generate addresses for receiving\n- **View Balance**: Check UTXO balance\n- **Transaction History**: View past transactions\n\n### Advanced Features\n\n- **Multi-signature**: Require multiple signatures (multisig)\n- **Coin Control**: Manually select which UTXOs to spend\n- **Fee Estimation**: Calculate appropriate transaction fees\n- **Replace-by-Fee (RBF)**: Replace unconfirmed transactions\n- **PSBT Support**: Partially Signed Bitcoin Transactions\n\n## Related Topics\n\n- [Coin Selection](/docs/wallets/coin-selection) - How wallets choose UTXOs to spend\n- [Multisig](/docs/wallets/multisig) - Multi-signature wallet concepts\n- [Transaction Creation](/docs/wallets/transactions) - How to create and sign transactions\n",
    "filename": "overview.md"
  },
  "/docs/wallets/coin-selection": {
    "content": "# Coin Selection Algorithms\n\n[Coin selection](/docs/glossary#coin-selection) is the process of choosing which [UTXOs](/docs/glossary#utxo-unspent-transaction-output) (Unspent Transaction Outputs) to spend when creating a Bitcoin [transaction](/docs/glossary#transaction). This is a critical [wallet](/docs/glossary#wallet) function that affects [transaction fees](/docs/glossary#transaction-fee), privacy, and efficiency.\n\n## The Challenge\n\nGiven:\n- A set of available UTXOs\n- A payment amount to send\n- A target fee rate\n\nSelect UTXOs such that:\n- Total input value > total output value\n- Fee rate >= required minimum fee rate\n- Transaction is valid and efficient\n\n## Transaction Requirements\n\n### Basic Structure\n\n```\nTransaction:\n  Inputs: Selected UTXOs\n  Outputs:\n    - Payment output (destination + amount)\n    - Change output (optional, back to wallet)\n  Fee: Inputs - Outputs\n```\n\n### Fee Rate Calculation\n\n```\nFee Rate = (Total Input Value - Total Output Value) / Virtual Transaction Size\n```\n\n**[Virtual Transaction Size (vBytes)](/docs/glossary#vbyte-virtual-byte):**\n- Defined in [BIP](/docs/glossary#bip-bitcoin-improvement-proposal) 141 ([SegWit](/docs/glossary#segwit-segregated-witness))\n- [Weight units](/docs/glossary#weight-units) / 4\n- Accounts for [witness](/docs/glossary#witness) data differently\n\n### Effective Value\n\nThe **effective value** of a UTXO accounts for the cost to spend it:\n\n```\neffective_value = amount - (input_vbytes Ã— fee_rate)\n```\n\nThis is critical for coin selection: a small UTXO might have negative effective value at high fee rates.\n\n:::code-group\n```rust\n/// Calculate effective value of a coin at a given fee rate\n/// effective_value = amount - (input_vbytes * fee_rate)\nfn effective_value(coin: &Coin, fee_rate: Decimal) -> Decimal {\n    coin.amount - (input_vbytes(&coin.address) * fee_rate)\n}\n\n// Filter out coins with negative effective value\nlet useful_coins: Vec<Coin> = coins\n    .iter()\n    .filter(|c| effective_value(c, fee_rate) > Decimal::ZERO)\n    .cloned()\n    .collect();\n```\n\n```python\ndef effective_value(coin: dict, fee_rate: float) -> float:\n    \"\"\"Calculate effective value of a UTXO at a given fee rate.\n    \n    Args:\n        coin: UTXO with 'amount' and 'address' fields\n        fee_rate: Fee rate in BTC/vB\n    \n    Returns:\n        Effective value (can be negative for dust UTXOs)\n    \"\"\"\n    spend_cost = input_vbytes(coin['address']) * fee_rate\n    return coin['amount'] - spend_cost\n\n# Example: At 10 sat/vB, filter out negative effective value UTXOs\nfee_rate = 0.0000001  # 10 sat/vB in BTC/vB\nuseful_coins = [c for c in coins if effective_value(c, fee_rate) > 0]\n```\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/**\n * Calculate effective value of a coin at a given fee rate\n * effective_value = amount - (input_vbytes * fee_rate)\n */\ndouble effective_value(const Coin& coin, double fee_rate) {\n    return coin.amount - (input_vbytes(coin.address) * fee_rate);\n}\n\n// Filter out coins with negative effective value\nstd::vector<Coin> useful_coins;\nstd::copy_if(coins.begin(), coins.end(), std::back_inserter(useful_coins),\n    [fee_rate](const Coin& c) {\n        return effective_value(c, fee_rate) > 0;\n    });\n```\n\n```javascript\n/**\n * Calculate effective value of a coin at a given fee rate\n * effective_value = amount - (input_vbytes * fee_rate)\n * \n * @param {Object} coin - UTXO with 'amount' and 'address' fields\n * @param {number} feeRate - Fee rate in BTC/vB\n * @returns {number} Effective value (can be negative for dust UTXOs)\n */\nfunction effectiveValue(coin, feeRate) {\n    const spendCost = inputVbytes(coin.address) * feeRate;\n    return coin.amount - spendCost;\n}\n\n// Example: At 10 sat/vB, filter out negative effective value UTXOs\nconst feeRate = 0.0000001; // 10 sat/vB in BTC/vB\nconst usefulCoins = coins.filter(c => effectiveValue(c, feeRate) > 0);\n```\n:::\n\n## UTXO Characteristics\n\n### Different Script Types\n\nUTXOs can have different [script](/docs/glossary#script) types, affecting transaction size:\n\n1. **[P2PKH](/docs/glossary#p2pkh-pay-to-pubkey-hash) (Legacy)**: ~148 bytes per input\n2. **[P2SH](/docs/glossary#p2sh-pay-to-script-hash)**: ~91 bytes per input\n3. **[P2WPKH](/docs/glossary#p2wpkh-pay-to-witness-pubkey-hash) (SegWit v0)**: ~68 bytes per input\n4. **[P2TR](/docs/glossary#p2tr-pay-to-taproot) ([Taproot](/docs/glossary#taproot))**: ~58 bytes per input\n\n:::code-group\n```rust\nfn input_vbytes(address: &str) -> Decimal {\n    if address.starts_with(\"bc1p\") || address.starts_with(\"tb1p\") {\n        dec!(57.5)   // Taproot (p2tr)\n    } else if address.starts_with(\"bc1q\") || address.starts_with(\"tb1q\") {\n        dec!(68)     // Native SegWit (p2wpkh)\n    } else if address.starts_with(\"2\") || address.starts_with(\"3\") {\n        dec!(91)     // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        dec!(148)    // Legacy (p2pkh)\n    }\n}\n\nfn output_vbytes(address: &str) -> Decimal {\n    if address.starts_with(\"bc1p\") || address.starts_with(\"tb1p\") {\n        dec!(43)     // Taproot\n    } else if address.starts_with(\"bc1q\") || address.starts_with(\"tb1q\") {\n        dec!(31)     // Native SegWit\n    } else if address.starts_with(\"2\") || address.starts_with(\"3\") {\n        dec!(32)     // P2SH\n    } else {\n        dec!(34)     // Legacy\n    }\n}\n```\n\n```python\ndef input_vbytes(address: str) -> float:\n    \"\"\"Calculate virtual bytes for spending a UTXO based on address type.\"\"\"\n    if address.startswith(('bc1p', 'tb1p', 'bcrt1p')):\n        return 57.5   # Taproot (p2tr)\n    elif address.startswith(('bc1q', 'tb1q', 'bcrt1q')):\n        return 68.0   # Native SegWit (p2wpkh)\n    elif address.startswith(('2', '3')):\n        return 91.0   # Nested SegWit (p2sh-p2wpkh)\n    else:\n        return 148.0  # Legacy (p2pkh)\n\ndef output_vbytes(address: str) -> float:\n    \"\"\"Calculate virtual bytes for an output based on address type.\"\"\"\n    if address.startswith(('bc1p', 'tb1p', 'bcrt1p')):\n        return 43.0   # Taproot\n    elif address.startswith(('bc1q', 'tb1q', 'bcrt1q')):\n        return 31.0   # Native SegWit\n    elif address.startswith(('2', '3')):\n        return 32.0   # P2SH\n    else:\n        return 34.0   # Legacy\n```\n\n```cpp\n#include <string>\n\n/**\n * Calculate virtual bytes for spending a UTXO based on address type.\n */\ndouble input_vbytes(const std::string& address) {\n    if (address.rfind(\"bc1p\", 0) == 0 || address.rfind(\"tb1p\", 0) == 0 || \n        address.rfind(\"bcrt1p\", 0) == 0) {\n        return 57.5;   // Taproot (p2tr)\n    } else if (address.rfind(\"bc1q\", 0) == 0 || address.rfind(\"tb1q\", 0) == 0 || \n               address.rfind(\"bcrt1q\", 0) == 0) {\n        return 68.0;   // Native SegWit (p2wpkh)\n    } else if (address[0] == '2' || address[0] == '3') {\n        return 91.0;   // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        return 148.0;  // Legacy (p2pkh)\n    }\n}\n\n/**\n * Calculate virtual bytes for an output based on address type.\n */\ndouble output_vbytes(const std::string& address) {\n    if (address.rfind(\"bc1p\", 0) == 0 || address.rfind(\"tb1p\", 0) == 0 || \n        address.rfind(\"bcrt1p\", 0) == 0) {\n        return 43.0;   // Taproot\n    } else if (address.rfind(\"bc1q\", 0) == 0 || address.rfind(\"tb1q\", 0) == 0 || \n               address.rfind(\"bcrt1q\", 0) == 0) {\n        return 31.0;   // Native SegWit\n    } else if (address[0] == '2' || address[0] == '3') {\n        return 32.0;   // P2SH\n    } else {\n        return 34.0;   // Legacy\n    }\n}\n```\n\n```javascript\n/**\n * Calculate virtual bytes for spending a UTXO based on address type.\n * @param {string} address - Bitcoin address\n * @returns {number} Virtual bytes required\n */\nfunction inputVbytes(address) {\n    if (address.startsWith('bc1p') || address.startsWith('tb1p') || \n        address.startsWith('bcrt1p')) {\n        return 57.5;   // Taproot (p2tr)\n    } else if (address.startsWith('bc1q') || address.startsWith('tb1q') || \n               address.startsWith('bcrt1q')) {\n        return 68.0;   // Native SegWit (p2wpkh)\n    } else if (address.startsWith('2') || address.startsWith('3')) {\n        return 91.0;   // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        return 148.0;  // Legacy (p2pkh)\n    }\n}\n\n/**\n * Calculate virtual bytes for an output based on address type.\n * @param {string} address - Bitcoin address\n * @returns {number} Virtual bytes required\n */\nfunction outputVbytes(address) {\n    if (address.startsWith('bc1p') || address.startsWith('tb1p') || \n        address.startsWith('bcrt1p')) {\n        return 43.0;   // Taproot\n    } else if (address.startsWith('bc1q') || address.startsWith('tb1q') || \n               address.startsWith('bcrt1q')) {\n        return 31.0;   // Native SegWit\n    } else if (address.startsWith('2') || address.startsWith('3')) {\n        return 32.0;   // P2SH\n    } else {\n        return 34.0;   // Legacy\n    }\n}\n```\n:::\n\n### Example UTXOs\n\n```\nUTXO 1: P2WPKH, 1.5 BTC\nUTXO 2: P2TR, 0.8 BTC\nUTXO 3: P2PKH, 0.3 BTC\n```\n\n**Transaction Size Impact:**\n- Using UTXO 1: Smaller transaction (SegWit)\n- Using UTXO 3: Larger transaction (Legacy)\n- Same fee rate = different absolute fees\n\n## Coin Selection Strategies\n\n### 1. Largest First (Greedy)\n\n**Algorithm:**\n1. Sort UTXOs by value (largest first)\n2. Select UTXOs until sum >= payment + estimated fee\n3. Create change output if needed\n\n:::code-group\n```rust\nfn select_largest_first(\n    coins: &[Coin],\n    target: Decimal,\n    fee_rate: Decimal\n) -> Result<(Vec<Coin>, Decimal), String> {\n    // Sort by amount descending\n    let mut sorted: Vec<Coin> = coins.to_vec();\n    sorted.sort_by(|a, b| b.amount.partial_cmp(&a.amount).unwrap());\n    \n    let mut selected: Vec<Coin> = Vec::new();\n    let mut total = Decimal::ZERO;\n    \n    for coin in sorted {\n        selected.push(coin.clone());\n        total += coin.amount;\n        \n        let estimated_fee = estimate_fee(selected.len(), fee_rate);\n        \n        if total >= target + estimated_fee {\n            return Ok((selected, total - target - estimated_fee));\n        }\n    }\n    \n    Err(\"Insufficient funds\".to_string())\n}\n```\n\n```python\ndef select_largest_first(coins, target_amount, fee_rate):\n    \"\"\"Select coins using largest-first greedy algorithm.\"\"\"\n    # Sort by amount descending\n    sorted_coins = sorted(coins, key=lambda c: c['amount'], reverse=True)\n    \n    selected = []\n    total = Decimal('0')\n    \n    for coin in sorted_coins:\n        selected.append(coin)\n        total += coin['amount']\n        \n        # Estimate fee based on selected inputs\n        estimated_fee = estimate_fee(len(selected), fee_rate)\n        \n        if total >= target_amount + estimated_fee:\n            return selected, total - target_amount - estimated_fee\n    \n    raise ValueError(\"Insufficient funds\")\n```\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <utility>\n\n/**\n * Select coins using largest-first greedy algorithm.\n * @return pair of (selected coins, change amount)\n */\nstd::pair<std::vector<Coin>, double> select_largest_first(\n    std::vector<Coin> coins,\n    double target_amount,\n    double fee_rate\n) {\n    // Sort by amount descending\n    std::sort(coins.begin(), coins.end(), [](const Coin& a, const Coin& b) {\n        return a.amount > b.amount;\n    });\n    \n    std::vector<Coin> selected;\n    double total = 0.0;\n    \n    for (const auto& coin : coins) {\n        selected.push_back(coin);\n        total += coin.amount;\n        \n        // Estimate fee based on selected inputs\n        double estimated_fee = estimate_fee(selected.size(), fee_rate);\n        \n        if (total >= target_amount + estimated_fee) {\n            return {selected, total - target_amount - estimated_fee};\n        }\n    }\n    \n    throw std::runtime_error(\"Insufficient funds\");\n}\n```\n\n```javascript\n/**\n * Select coins using largest-first greedy algorithm.\n * @param {Array} coins - Array of coin objects with 'amount' property\n * @param {number} targetAmount - Target amount to reach\n * @param {number} feeRate - Fee rate for estimation\n * @returns {Object} Object with 'selected' coins and 'change' amount\n */\nfunction selectLargestFirst(coins, targetAmount, feeRate) {\n    // Sort by amount descending\n    const sortedCoins = [...coins].sort((a, b) => b.amount - a.amount);\n    \n    const selected = [];\n    let total = 0;\n    \n    for (const coin of sortedCoins) {\n        selected.push(coin);\n        total += coin.amount;\n        \n        // Estimate fee based on selected inputs\n        const estimatedFee = estimateFee(selected.length, feeRate);\n        \n        if (total >= targetAmount + estimatedFee) {\n            return {\n                selected,\n                change: total - targetAmount - estimatedFee\n            };\n        }\n    }\n    \n    throw new Error('Insufficient funds');\n}\n```\n:::\n\n**Pros:**\n- Simple to implement\n- Minimizes number of inputs\n- Fast execution\n\n**Cons:**\n- May overpay fees\n- Poor privacy (uses largest UTXOs)\n- May create dust change\n\n### 2. Smallest First\n\n**Algorithm:**\n1. Sort UTXOs by value (smallest first)\n2. Select UTXOs until sum >= payment + estimated fee\n3. Create change output if needed\n\n**Pros:**\n- Consolidates small UTXOs\n- Better privacy (uses smaller UTXOs)\n- Cleans up wallet\n\n**Cons:**\n- More inputs = larger transaction\n- Higher fees for many inputs\n- Slower (more inputs to sign)\n\n### 3. Exact Match\n\n**Algorithm:**\n1. Look for UTXO that exactly matches payment + fee\n2. If found, use it\n3. Otherwise, fall back to other strategy\n\n**Pros:**\n- No change output needed\n- Optimal for specific cases\n- Clean transaction\n\n**Cons:**\n- Rarely finds exact match\n- Usually requires fallback\n\n### 4. Branch and Bound\n\n**Algorithm:**\n1. Try all combinations of UTXOs\n2. Find combination that minimizes:\n   - Transaction size\n   - Change amount\n   - Number of inputs\n3. Select optimal combination\n\n**Pros:**\n- Optimal solution\n- Minimizes fees\n- Best privacy\n\n**Cons:**\n- Computationally expensive\n- Slow for many UTXOs\n- May not be practical\n\n### 5. Random Selection\n\n**Algorithm:**\n1. Randomly select UTXOs\n2. Continue until sum >= payment + fee\n3. Create change if needed\n\n**Pros:**\n- Good privacy\n- Unpredictable pattern\n- Simple implementation\n\n**Cons:**\n- May not be optimal\n- Could select inefficient combination\n\n## Fee Calculation\n\n### Estimating Transaction Size\n\n**Base Size:**\n- Transaction header: 10 bytes\n- Input count: 1-9 bytes (varint)\n- Output count: 1-9 bytes (varint)\n\n**Input Size:**\n- Previous output: 36 bytes\n- Script length: 1-9 bytes (varint)\n- Script: Variable (depends on script type)\n- Sequence: 4 bytes\n\n**Output Size:**\n- Value: 8 bytes\n- Script length: 1-9 bytes (varint)\n- Script: Variable (typically 22-34 bytes)\n\n**Witness Size (SegWit):**\n- Witness data: Variable\n- Counted differently in weight calculation\n\n### Virtual Size Calculation\n\n```\nWeight = (Base Size Ã— 3) + Total Size\nVirtual Size = Weight / 4\n```\n\n:::code-group\n```rust\n/// Calculate the total virtual size of a transaction\n/// tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\nfn calculate_tx_vsize(inputs: &[Coin], output_addresses: &[&str]) -> Decimal {\n    let overhead = dec!(10.5);\n    \n    let input_size: Decimal = inputs.iter()\n        .map(|c| input_vbytes(&c.address))\n        .sum();\n    \n    let output_size: Decimal = output_addresses.iter()\n        .map(|addr| output_vbytes(addr))\n        .sum();\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    (overhead + input_size + output_size).ceil()\n}\n```\n\n```python\ndef calculate_tx_vsize(inputs: list, output_addresses: list) -> int:\n    \"\"\"Calculate virtual size of a transaction.\n    \n    Args:\n        inputs: List of UTXOs to spend\n        output_addresses: List of destination addresses\n    \n    Returns:\n        Virtual size in vbytes (rounded up)\n    \"\"\"\n    import math\n    \n    # Transaction overhead: ~10.5 vB\n    overhead = 10.5\n    \n    # Sum input sizes based on address types\n    input_size = sum(input_vbytes(coin['address']) for coin in inputs)\n    \n    # Sum output sizes based on address types\n    output_size = sum(output_vbytes(addr) for addr in output_addresses)\n    \n    # Round up to be safe\n    return math.ceil(overhead + input_size + output_size)\n```\n\n```cpp\n#include <vector>\n#include <string>\n#include <cmath>\n#include <numeric>\n\n/**\n * Calculate the total virtual size of a transaction\n * tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\n */\nint calculate_tx_vsize(\n    const std::vector<Coin>& inputs,\n    const std::vector<std::string>& output_addresses\n) {\n    // Transaction overhead: ~10.5 vB\n    double overhead = 10.5;\n    \n    // Sum input sizes based on address types\n    double input_size = std::accumulate(inputs.begin(), inputs.end(), 0.0,\n        [](double sum, const Coin& coin) {\n            return sum + input_vbytes(coin.address);\n        });\n    \n    // Sum output sizes based on address types\n    double output_size = std::accumulate(output_addresses.begin(), output_addresses.end(), 0.0,\n        [](double sum, const std::string& addr) {\n            return sum + output_vbytes(addr);\n        });\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    return static_cast<int>(std::ceil(overhead + input_size + output_size));\n}\n```\n\n```javascript\n/**\n * Calculate the total virtual size of a transaction\n * tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\n * \n * @param {Array} inputs - List of UTXOs to spend\n * @param {Array} outputAddresses - List of destination addresses\n * @returns {number} Virtual size in vbytes (rounded up)\n */\nfunction calculateTxVsize(inputs, outputAddresses) {\n    // Transaction overhead: ~10.5 vB\n    const overhead = 10.5;\n    \n    // Sum input sizes based on address types\n    const inputSize = inputs.reduce(\n        (sum, coin) => sum + inputVbytes(coin.address), 0\n    );\n    \n    // Sum output sizes based on address types\n    const outputSize = outputAddresses.reduce(\n        (sum, addr) => sum + outputVbytes(addr), 0\n    );\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    return Math.ceil(overhead + inputSize + outputSize);\n}\n```\n:::\n\n### Fee Calculation Example\n\n```\nPayment: 1.0 BTC\nFee Rate: 1 sat/vB\n\nSelected UTXOs:\n  - UTXO 1 (P2WPKH): 1.2 BTC\n  - UTXO 2 (P2TR): 0.5 BTC\n\nTransaction Size: 250 vBytes\nFee: 250 sats\nChange: 1.7 - 1.0 - 0.0000025 = 0.6999975 BTC\n```\n\n## Change Output Creation\n\n### When to Create Change\n\nCreate change output if:\n- Selected UTXOs > Payment + Fee + Dust Threshold\n- Change amount > dust threshold (typically 546 sats)\n\n### Dust Threshold\n\nDust outputs are uneconomical to spend:\n- **Standard**: 546 sats\n- **Rationale**: Fee to spend would exceed value\n- **Policy**: Many nodes reject dust outputs\n\n### Change Output Optimization\n\n**Options:**\n1. **Create change**: If amount > dust threshold\n2. **Donate to miner**: If amount < dust threshold\n3. **Increase payment**: If change would be dust\n\n## Implementation Considerations\n\n### Iterative Approach\n\n1. **Estimate fee**: Based on initial UTXO selection\n2. **Select UTXOs**: Using chosen strategy\n3. **Calculate actual fee**: Based on actual transaction size\n4. **Adjust if needed**: If fee doesn't meet target\n\n### Fee Rate Targets\n\n**Common Fee Rates:**\n- **Low priority**: 1-5 sat/vB\n- **Medium priority**: 5-10 sat/vB\n- **High priority**: 10-50 sat/vB\n- **Urgent**: 50+ sat/vB\n\n### Validation\n\nBefore finalizing transaction:\n1. **Verify inputs**: Ensure UTXOs are still unspent\n2. **Check balance**: Ensure sufficient funds\n3. **Validate fee**: Ensure fee rate meets target\n4. **Check size**: Ensure transaction is valid size\n\n## Best Practices\n\n### For Wallet Developers\n\n1. **Use SegWit**: Prefer SegWit UTXOs (smaller size)\n2. **Minimize inputs**: Fewer inputs = smaller transaction\n3. **Optimize change**: Avoid dust change outputs\n4. **Privacy**: Consider privacy implications\n5. **Fee estimation**: Accurate fee estimation is critical\n\n### For Users\n\n1. **Consolidate UTXOs**: Periodically consolidate small UTXOs\n2. **Use SegWit**: Prefer SegWit addresses\n3. **Monitor fees**: Be aware of current fee rates\n4. **Batch payments**: Combine multiple payments when possible\n\n## Common Issues\n\n### Insufficient Funds\n\n**Problem**: Selected UTXOs don't cover payment + fee\n\n**Solution**:\n- Select more UTXOs\n- Reduce payment amount\n- Wait for more funds\n\n### Fee Too Low\n\n**Problem**: Calculated fee rate below target\n\n**Solution**:\n- Select fewer UTXOs (if possible)\n- Increase fee manually\n- Use higher fee rate\n\n### Dust Change\n\n**Problem**: Change output would be dust\n\n**Solution**:\n- Donate to miner (include in fee)\n- Increase payment amount\n- Select different UTXOs\n\n## Summary\n\nCoin selection is a critical wallet function:\n\n- **Multiple strategies**: Different approaches for different goals\n- **Fee optimization**: Balance between fees and efficiency\n- **Privacy considerations**: UTXO selection affects privacy\n- **Transaction sizing**: Different script types affect size\n- **Change management**: Handle change outputs appropriately\n\nUnderstanding coin selection helps build efficient and user-friendly Bitcoin wallets.\n",
    "filename": "algorithms.md"
  },
  "/docs/wallets/multisig": {
    "content": "# Multisig Wallets\n\nMulti-signature (multisig) wallets require multiple signatures to spend funds. This provides enhanced security, shared custody, and flexible access control.\n\n## What is Multisig?\n\nA multisig wallet requires M-of-N signatures:\n- **M**: Minimum number of signatures required\n- **N**: Total number of possible signers\n- **Example**: 2-of-3 means 2 signatures from 3 possible keys\n\n### Common Configurations\n\n- **2-of-2**: Two parties must both sign (partnership)\n- **2-of-3**: Two of three parties must sign (backup key)\n- **3-of-5**: Three of five parties must sign (corporate)\n- **M-of-N**: Flexible configuration\n\n## Multisig Script Patterns\n\n### Legacy Multisig (P2SH)\n\n**Script Pattern:**\n```\nOP_M <pubkey1> <pubkey2> ... <pubkeyN> OP_N OP_CHECKMULTISIG\n```\n\n**Example (2-of-3):**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Spending Script:**\n```\nOP_0 <sig1> <sig2>\n```\n\n**Note**: OP_0 is a bug workaround (dummy value before signatures)\n\n### SegWit Multisig (P2WSH)\n\n**Redeem Script:**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Script Hash:**\n```\nOP_0 <scripthash>\n```\n\n**Spending:**\n- Witness: `<sig1> <sig2> <redeem_script>`\n- More efficient than legacy\n\n### Taproot Multisig (P2TR)\n\n**Modern Approach:**\n- Uses Taproot script trees\n- More efficient\n- Better privacy\n- More complex implementation\n\n## Creating Multisig Wallets\n\n### Step 1: Generate Keys\n\nEach party generates their own key:\n\n```bash\n# Generate private key\nbitcoin-cli getnewaddress\n\n# Or use external tool\n# Each party keeps their private key secure\n```\n\n### Step 2: Create Multisig Address\n\n```bash\n# Create 2-of-3 multisig\nbitcoin-cli createmultisig 2 \\\n  '[\"<pubkey1>\", \"<pubkey2>\", \"<pubkey3>\"]'\n```\n\nReturns:\n- **Address**: Multisig address to receive funds\n- **Redeem Script**: Script needed to spend\n- **Descriptor**: Modern descriptor format\n\n### Step 3: Fund the Address\n\nSend Bitcoin to the multisig address:\n\n```bash\nbitcoin-cli sendtoaddress <multisig_address> <amount>\n```\n\n## Spending from Multisig\n\n### Step 1: Create Transaction\n\n```bash\n# Create raw transaction\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '{\"<destination>\": <amount>}'\n```\n\n### Step 2: Sign with First Key\n\n```bash\n# Sign with key 1\nbitcoin-cli signrawtransactionwithkey <hex> \\\n  '[\"<privkey1>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 3: Sign with Second Key\n\n```bash\n# Sign with key 2 (using partially signed transaction)\nbitcoin-cli signrawtransactionwithkey <partially_signed_hex> \\\n  '[\"<privkey2>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 4: Broadcast\n\n```bash\n# Broadcast fully signed transaction\nbitcoin-cli sendrawtransaction <fully_signed_hex>\n```\n\n## Key Management\n\n### Key Storage\n\n**Best Practices:**\n- **Distributed**: Each party stores their own key\n- **Secure**: Use hardware wallets or secure storage\n- **Backup**: Backup keys securely\n- **Recovery**: Plan for key loss\n\n### Key Security\n\n**Options:**\n1. **Hardware Wallets**: Most secure\n2. **Paper Wallets**: Offline storage\n3. **Encrypted Storage**: Encrypted files\n4. **Custodial**: Third-party custody (less secure)\n\n## Use Cases\n\n### 1. Shared Custody\n\n**Example**: Business partnership\n- **2-of-2**: Both partners must agree\n- **Use case**: Business funds\n- **Benefit**: No single point of failure\n\n### 2. Backup Security\n\n**Example**: Personal wallet with backup\n- **2-of-3**: You + Backup key + Hardware key\n- **Use case**: Personal funds with backup\n- **Benefit**: Can recover if one key lost\n\n### 3. Corporate Wallets\n\n**Example**: Company treasury\n- **3-of-5**: Three executives must sign\n- **Use case**: Corporate funds\n- **Benefit**: Distributed control\n\n### 4. Family Funds\n\n**Example**: Family savings\n- **2-of-4**: Two family members must agree\n- **Use case**: Shared family funds\n- **Benefit**: Prevents single person control\n\n## Security Considerations\n\n### Advantages\n\n1. **No Single Point of Failure**: Multiple keys required\n2. **Distributed Trust**: No single party controls funds\n3. **Backup Options**: Can lose some keys\n4. **Flexible Access**: Different M-of-N configurations\n\n### Risks\n\n1. **Key Loss**: If too many keys lost, funds locked\n2. **Coordination**: Requires multiple parties\n3. **Complexity**: More complex than single-sig\n4. **Key Compromise**: If M keys compromised, funds at risk\n\n### Best Practices\n\n1. **Secure Key Storage**: Use hardware wallets\n2. **Backup Strategy**: Plan for key loss\n3. **Key Distribution**: Don't store all keys together\n4. **Regular Testing**: Test spending process\n5. **Documentation**: Document key locations and recovery\n\n## Implementation Details\n\n### Script Execution\n\n**Multisig Script:**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Execution:**\n1. Push M (2)\n2. Push pubkeys (3)\n3. Push N (3)\n4. OP_CHECKMULTISIG:\n   - Pops N, then N pubkeys\n   - Pops M, then M signatures\n   - Verifies M signatures match M of N pubkeys\n   - Returns 1 if valid, 0 if invalid\n\n### Transaction Size\n\n**Multisig Transactions:**\n- **Larger**: More signatures = larger transaction\n- **2-of-3 P2SH**: ~250-300 bytes\n- **2-of-3 P2WSH**: ~200-250 bytes (witness)\n- **Fees**: Higher fees due to size\n\n## Common Issues\n\n### Insufficient Signatures\n\n**Problem**: Not enough signatures to spend\n\n**Solution**:\n- Collect required number of signatures\n- Ensure all signers are available\n- Use backup keys if needed\n\n### Key Loss\n\n**Problem**: Too many keys lost\n\n**Solution**:\n- Use remaining keys (if M still available)\n- If M keys lost, funds are locked\n- Plan for key recovery\n\n### Coordination Challenges\n\n**Problem**: Difficult to coordinate multiple signers\n\n**Solution**:\n- Use signing services\n- Batch transactions\n- Plan signing sessions\n- Use hardware wallets for convenience\n\n## Summary\n\nMultisig wallets provide:\n\n- **Enhanced Security**: Multiple keys required\n- **Shared Custody**: Distributed control\n- **Backup Options**: Can lose some keys\n- **Flexible Access**: Various M-of-N configurations\n- **Corporate Use**: Suitable for organizations\n\nUnderstanding multisig is essential for building secure Bitcoin wallets and managing funds with multiple parties.\n",
    "filename": "concepts.md"
  },
  "/docs/wallets/transactions": {
    "content": "# Bitcoin Transaction Creation\n\nCreating Bitcoin transactions programmatically involves selecting inputs, creating outputs, calculating fees, signing, and broadcasting. This guide covers the complete process.\n\n## Transaction Structure\n\n### Basic Components\n\n```\nTransaction:\n  Version: 4 bytes\n  Input Count: VarInt\n  Inputs: Array of inputs\n  Output Count: VarInt\n  Outputs: Array of outputs\n  Locktime: 4 bytes\n  Witness: (if SegWit)\n```\n\n### Input Structure\n\n```\nInput:\n  Previous TXID: 32 bytes\n  Previous Output Index: 4 bytes\n  Script Length: VarInt\n  Script: Variable\n  Sequence: 4 bytes\n```\n\n### Output Structure\n\n```\nOutput:\n  Value: 8 bytes (satoshis)\n  Script Length: VarInt\n  Script: Variable (typically 22-34 bytes)\n```\n\n### Serializing a Transaction Output\n\n:::code-group\n```rust\nuse bech32::{self, FromBase32, ToBase32};\n\nstruct Output {\n    value: u64,\n    witness_version: u8,\n    witness_data: Vec<u8>,\n}\n\nimpl Output {\n    fn new() -> Self {\n        Self {\n            value: 0,\n            witness_version: 0,\n            witness_data: Vec::new(),\n        }\n    }\n\n    /// Create output from address and value in satoshis\n    fn from_options(addr: &str, value: u64) -> Result<Self, bech32::Error> {\n        let (hrp, data, variant) = bech32::decode(addr)?;\n        \n        let witness_version = data[0].to_u8();\n        let witness_program = Vec::<u8>::from_base32(&data[1..])?;\n        \n        Ok(Self {\n            value,\n            witness_version,\n            witness_data: witness_program,\n        })\n    }\n\n    /// Serialize output for transaction\n    fn serialize(&self) -> Vec<u8> {\n        let mut r = Vec::new();\n        \n        // Value: 8 bytes (little-endian)\n        r.extend_from_slice(&self.value.to_le_bytes());\n        \n        // Script length\n        let script_length = 1 + 1 + self.witness_data.len();\n        r.push(script_length as u8);\n        \n        // Witness version + data length + witness data\n        r.push(self.witness_version);\n        r.push(self.witness_data.len() as u8);\n        r.extend_from_slice(&self.witness_data);\n        \n        r\n    }\n}\n```\n\n```python\nfrom struct import pack\nfrom bech32py import bech32\n\nclass Output:\n    def __init__(self):\n        self.value = 0\n        self.witness_version = 0\n        self.witness_data = b\"\"\n\n    @classmethod\n    def from_options(cls, addr: str, value: int):\n        \"\"\"Create output from address and value in satoshis.\"\"\"\n        self = cls()\n        # Decode bech32 address to get witness version and program\n        hrp, data = bech32.decode(addr)\n        self.witness_version = data[0]\n        # Convert 5-bit values to 8-bit bytes\n        witness_program = bech32.convertbits(data[1:], 5, 8, False)\n        self.witness_data = bytes(witness_program)\n        self.value = value\n        return self\n\n    def serialize(self):\n        \"\"\"Serialize output for transaction.\"\"\"\n        r = b\"\"\n        # Value: 8 bytes (little-endian)\n        r += pack(\"<Q\", self.value)\n        # Script length\n        script_length = 1 + 1 + len(self.witness_data)\n        r += pack(\"<B\", script_length)\n        # Witness version + data length + witness data\n        r += pack(\"<B\", self.witness_version)\n        r += pack(\"<B\", len(self.witness_data))\n        r += self.witness_data\n        return r\n```\n\n```cpp\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <bech32.h>  // Assumes a bech32 library\n\nclass Output {\npublic:\n    uint64_t value = 0;\n    uint8_t witness_version = 0;\n    std::vector<uint8_t> witness_data;\n\n    Output() = default;\n\n    /**\n     * Create output from address and value in satoshis\n     */\n    static Output from_options(const std::string& addr, uint64_t value) {\n        Output self;\n        \n        // Decode bech32 address\n        auto [hrp, data] = bech32::decode(addr);\n        \n        self.witness_version = data[0];\n        // Convert 5-bit to 8-bit values\n        self.witness_data = bech32::convertbits(\n            std::vector<uint8_t>(data.begin() + 1, data.end()),\n            5, 8, false\n        );\n        self.value = value;\n        \n        return self;\n    }\n\n    /**\n     * Serialize output for transaction\n     */\n    std::vector<uint8_t> serialize() const {\n        std::vector<uint8_t> r;\n        \n        // Value: 8 bytes (little-endian)\n        for (int i = 0; i < 8; ++i) {\n            r.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFF));\n        }\n        \n        // Script length\n        uint8_t script_length = 1 + 1 + static_cast<uint8_t>(witness_data.size());\n        r.push_back(script_length);\n        \n        // Witness version + data length + witness data\n        r.push_back(witness_version);\n        r.push_back(static_cast<uint8_t>(witness_data.size()));\n        r.insert(r.end(), witness_data.begin(), witness_data.end());\n        \n        return r;\n    }\n};\n```\n\n```javascript\nconst bech32 = require('@savingsatoshi/bech32js');\n\nclass Output {\n  constructor() {\n    this.value = 0;\n    this.witness_version = 0;\n    this.witness_data = Buffer.alloc(0);\n  }\n\n  static from_options(addr, value) {\n    const self = new this();\n    // Decode bech32 address\n    const decoded = bech32.bech32_decode(addr);\n    const words = decoded[1];\n    \n    self.witness_version = words[0];\n    // Convert 5-bit to 8-bit values\n    const witness_program = bech32.fromWords(words.slice(1));\n    self.witness_data = Buffer.from(witness_program);\n    self.value = value;\n    return self;\n  }\n\n  serialize() {\n    // Value: 8 bytes (little-endian)\n    const valueBuffer = Buffer.alloc(8);\n    const value = BigInt(this.value);\n    valueBuffer.writeUInt32LE(Number(value & 0xffffffffn), 0);\n    valueBuffer.writeUInt32LE(Number((value >> 32n) & 0xffffffffn), 4);\n    \n    // Script length\n    const script_length = 1 + 1 + this.witness_data.length;\n    \n    return Buffer.concat([\n      valueBuffer,\n      Buffer.from([script_length]),\n      Buffer.from([this.witness_version]),\n      Buffer.from([this.witness_data.length]),\n      this.witness_data\n    ]);\n  }\n}\n```\n:::\n\n## Step-by-Step Process\n\n### Step 1: Select UTXOs\n\nChoose which UTXOs to spend:\n\n```bash\n# List available UTXOs\nbitcoin-cli listunspent\n\n# Select UTXOs (coin selection algorithm)\n# Total value >= payment + fee\n```\n\n### Step 2: Create Raw Transaction\n\n```bash\n# Create transaction\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"abc123...\", \"vout\":0}]' \\\n  '{\"<destination_address>\": 0.001}'\n```\n\n**Parameters:**\n- **Inputs**: Array of UTXOs to spend\n- **Outputs**: Destination address and amount\n\n:::code-group\n```rust\nuse std::process::Command;\nuse serde_json::{json, Value};\n\nfn bcli(cmd: &str) -> Result<String, String> {\n    let args: Vec<&str> = cmd.split_whitespace().collect();\n    let output = Command::new(\"bitcoin-cli\")\n        .arg(\"-signet\")\n        .args(&args)\n        .output()\n        .map_err(|e| e.to_string())?;\n    \n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n    } else {\n        Err(String::from_utf8_lossy(&output.stderr).trim().to_string())\n    }\n}\n\n// Build inputs from selected UTXOs\nlet inputs: Vec<Value> = selected_utxos.iter()\n    .map(|utxo| json!({\"txid\": utxo.txid, \"vout\": utxo.vout}))\n    .collect();\n\n// Build outputs (payment + change)\nlet outputs = json!({\n    destination_address: payment_amount,\n    change_address: change_amount\n});\n\n// Create raw transaction\nlet inputs_json = serde_json::to_string(&inputs).unwrap();\nlet outputs_json = serde_json::to_string(&outputs).unwrap();\nlet unsigned_tx = bcli(&format!(\"createrawtransaction '{}' '{}'\", inputs_json, outputs_json))?;\n```\n\n```python\nimport json\nfrom subprocess import run\n\ndef bcli(cmd: str):\n    \"\"\"Execute bitcoin-cli command.\"\"\"\n    res = run(\n        [\"bitcoin-cli\", \"-signet\"] + cmd.split(\" \"),\n        capture_output=True, encoding=\"utf-8\"\n    )\n    if res.returncode == 0:\n        return res.stdout.strip()\n    raise Exception(res.stderr.strip())\n\n# Build inputs from selected UTXOs\ninputs = [{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]} for utxo in selected_utxos]\n\n# Build outputs (payment + change)\noutputs = {\n    destination_address: float(payment_amount),\n    change_address: float(change_amount)\n}\n\n# Create raw transaction\ninputs_json = json.dumps(inputs)\noutputs_json = json.dumps(outputs)\nunsigned_tx = bcli(f\"createrawtransaction {inputs_json} {outputs_json}\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <stdexcept>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstd::string bcli(const std::string& cmd) {\n    std::string full_cmd = \"bitcoin-cli -signet \" + cmd;\n    std::array<char, 128> buffer;\n    std::string result;\n    \n    FILE* pipe = popen(full_cmd.c_str(), \"r\");\n    if (!pipe) {\n        throw std::runtime_error(\"popen() failed\");\n    }\n    \n    while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {\n        result += buffer.data();\n    }\n    \n    int status = pclose(pipe);\n    if (status != 0) {\n        throw std::runtime_error(\"Command failed: \" + result);\n    }\n    \n    // Trim trailing newline\n    if (!result.empty() && result.back() == '\\n') {\n        result.pop_back();\n    }\n    return result;\n}\n\n// Build inputs from selected UTXOs\njson inputs = json::array();\nfor (const auto& utxo : selected_utxos) {\n    inputs.push_back({{\"txid\", utxo.txid}, {\"vout\", utxo.vout}});\n}\n\n// Build outputs (payment + change)\njson outputs = {\n    {destination_address, payment_amount},\n    {change_address, change_amount}\n};\n\n// Create raw transaction\nstd::string inputs_json = inputs.dump();\nstd::string outputs_json = outputs.dump();\nstd::string unsigned_tx = bcli(\"createrawtransaction '\" + inputs_json + \"' '\" + outputs_json + \"'\");\n```\n\n```javascript\nconst { execSync } = require('child_process');\n\nfunction bcli(cmd) {\n  const result = execSync(`bitcoin-cli -signet ${cmd}`, { encoding: 'utf-8' });\n  return result.trim();\n}\n\n// Build inputs from selected UTXOs\nconst inputs = selectedUtxos.map(utxo => ({\n  txid: utxo.txid,\n  vout: utxo.vout\n}));\n\n// Build outputs (payment + change)\nconst outputs = {\n  [destinationAddress]: paymentAmount,\n  [changeAddress]: changeAmount\n};\n\n// Create raw transaction\nconst inputsJson = JSON.stringify(inputs);\nconst outputsJson = JSON.stringify(outputs);\nconst unsignedTx = bcli(`createrawtransaction '${inputsJson}' '${outputsJson}'`);\n```\n:::\n\n### Step 3: Sign Transaction\n\n```bash\n# Sign transaction\nbitcoin-cli signrawtransactionwithwallet <hex>\n```\n\n**For Multisig:**\n```bash\n# Sign with specific key\nbitcoin-cli signrawtransactionwithkey <hex> \\\n  '[\"<private_key>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 4: Broadcast Transaction\n\n```bash\n# Broadcast to network\nbitcoin-cli sendrawtransaction <signed_hex>\n```\n\n:::code-group\n```rust\nuse serde_json::Value;\n\n// Sign the transaction\nlet sign_result = bcli(&format!(\"signrawtransactionwithwallet {}\", unsigned_tx))?;\nlet signed_data: Value = serde_json::from_str(&sign_result)?;\n\nif !signed_data[\"complete\"].as_bool().unwrap_or(false) {\n    return Err(\"Transaction signing incomplete\".into());\n}\n\nlet signed_tx = signed_data[\"hex\"].as_str().unwrap();\n\n// Broadcast transaction (0 = no maxfeerate protection)\nlet txid = bcli(&format!(\"sendrawtransaction {} 0\", signed_tx))?;\nprintln!(\"Transaction broadcast: {}\", txid);\n```\n\n```python\nimport json\n\n# Sign the transaction\nsign_result = bcli(f\"signrawtransactionwithwallet {unsigned_tx}\")\nsigned_data = json.loads(sign_result)\n\nif not signed_data.get(\"complete\"):\n    raise Exception(\"Transaction signing incomplete\")\n\nsigned_tx = signed_data[\"hex\"]\n\n# Broadcast transaction (0 = no maxfeerate protection)\ntxid = bcli(f\"sendrawtransaction {signed_tx} 0\")\nprint(f\"Transaction broadcast: {txid}\")\n```\n\n```cpp\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\n// Sign the transaction\nstd::string sign_result = bcli(\"signrawtransactionwithwallet \" + unsigned_tx);\njson signed_data = json::parse(sign_result);\n\nif (!signed_data.value(\"complete\", false)) {\n    throw std::runtime_error(\"Transaction signing incomplete\");\n}\n\nstd::string signed_tx = signed_data[\"hex\"].get<std::string>();\n\n// Broadcast transaction (0 = no maxfeerate protection)\nstd::string txid = bcli(\"sendrawtransaction \" + signed_tx + \" 0\");\nstd::cout << \"Transaction broadcast: \" << txid << std::endl;\n```\n\n```javascript\n// Sign the transaction\nconst signResult = bcli(`signrawtransactionwithwallet ${unsignedTx}`);\nconst signedData = JSON.parse(signResult);\n\nif (!signedData.complete) {\n  throw new Error('Transaction signing incomplete');\n}\n\nconst signedTx = signedData.hex;\n\n// Broadcast transaction (0 = no maxfeerate protection)\nconst txid = bcli(`sendrawtransaction ${signedTx} 0`);\nconsole.log(`Transaction broadcast: ${txid}`);\n```\n:::\n\n## Fee Calculation\n\n### Estimating Transaction Size\n\n**Base Transaction:**\n- Version: 4 bytes\n- Input count: 1-9 bytes\n- Output count: 1-9 bytes\n- Locktime: 4 bytes\n\n**Per Input:**\n- Previous output: 36 bytes\n- Script length: 1-9 bytes\n- Script: Variable (depends on script type)\n- Sequence: 4 bytes\n\n**Per Output:**\n- Value: 8 bytes\n- Script length: 1-9 bytes\n- Script: Variable (typically 22-34 bytes)\n\n### Virtual Size (SegWit)\n\n```\nWeight = (Base Size Ã— 3) + Total Size\nVirtual Size = Weight / 4\n```\n\n### Fee Calculation\n\n```\nFee = Transaction Size (vBytes) Ã— Fee Rate (sat/vB)\n```\n\n**Example:**\n```\nTransaction Size: 250 vBytes\nFee Rate: 10 sat/vB\nFee: 2,500 sats\n```\n\n## Change Outputs\n\n### When to Create Change\n\nCreate change output if:\n- Input value > Payment + Fee + Dust Threshold\n- Change amount > Dust threshold (546 sats)\n\n### Change Output Creation\n\n```bash\n# Include change output\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '{\"<destination>\": 0.001, \"<change_address>\": 0.0005}'\n```\n\n## Signing Process\n\n### Single Signature\n\n**P2PKH:**\n```\nScript: <signature> <public_key>\n```\n\n**P2WPKH:**\n```\nWitness: <signature> <public_key>\n```\n\n### Multisig Signing\n\n**Process:**\n1. Create transaction\n2. Sign with first key\n3. Sign with second key (using partially signed tx)\n4. Continue until M signatures collected\n5. Broadcast fully signed transaction\n\n## Transaction Validation\n\n### Before Broadcasting\n\n1. **Check Inputs**: Verify UTXOs are still unspent\n2. **Verify Balance**: Ensure sufficient funds\n3. **Validate Fee**: Check fee meets minimum\n4. **Check Size**: Ensure transaction is valid size\n5. **Verify Signatures**: All signatures valid\n\n### Common Validation Errors\n\n- **Insufficient funds**: Not enough input value\n- **Invalid signature**: Signature doesn't match\n- **Double spend**: UTXO already spent\n- **Dust output**: Output below dust threshold\n- **Fee too low**: Fee below minimum\n\n## Best Practices\n\n### For Developers\n\n1. **Fee Estimation**: Accurate fee estimation is critical\n2. **UTXO Management**: Efficient coin selection\n3. **Error Handling**: Handle all error cases\n4. **Validation**: Validate before broadcasting\n5. **Testing**: Test on testnet first\n\n### For Users\n\n1. **Verify Address**: Double-check destination address\n2. **Check Fee**: Ensure reasonable fee\n3. **Wait for Confirmation**: Don't assume immediate confirmation\n4. **Backup**: Backup transaction if needed\n5. **Monitor**: Track transaction status\n\n## Common Issues\n\n### Transaction Stuck\n\n**Problem**: Transaction not confirming\n\n**Solutions:**\n- Wait for confirmation\n- Use Replace-by-Fee (RBF) if enabled\n- Increase fee (if possible)\n- Wait for mempool to clear\n\n### Insufficient Fee\n\n**Problem**: Fee too low, transaction rejected\n\n**Solutions:**\n- Increase fee rate\n- Use higher priority\n- Wait for lower network activity\n\n### Invalid Transaction\n\n**Problem**: Transaction rejected by network\n\n**Causes:**\n- Invalid signature\n- Double spend\n- Dust output\n- Invalid script\n\n**Solution**: Fix issue and recreate transaction\n\n## Advanced Topics\n\n### Replace-by-Fee (RBF)\n\n**Enable RBF:**\n```bash\n# Set sequence to enable RBF\n# Sequence < 0xFFFFFFFF - 1\n```\n\n**Replace Transaction:**\n```bash\n# Create replacement with higher fee\nbitcoin-cli createrawtransaction ... --replaceable\n```\n\n### Partially Signed Bitcoin Transactions (PSBT)\n\n**Create PSBT:**\n```bash\nbitcoin-cli walletcreatefundedpsbt \\\n  '[]' \\\n  '[{\"<address>\": <amount>}]'\n```\n\n**Sign PSBT:**\n```bash\nbitcoin-cli walletprocesspsbt <psbt>\n```\n\n**Finalize PSBT:**\n```bash\nbitcoin-cli finalizepsbt <psbt>\n```\n\n## Summary\n\nTransaction creation involves:\n\n- **UTXO Selection**: Choose inputs to spend\n- **Output Creation**: Create payment and change outputs\n- **Fee Calculation**: Calculate appropriate fees\n- **Signing**: Sign with private keys\n- **Broadcasting**: Send to network\n- **Validation**: Verify transaction is valid\n\nUnderstanding transaction creation is essential for building Bitcoin wallets and applications.\n",
    "filename": "creation.md"
  },
  "/docs/lightning/basics": {
    "content": "# Lightning Network: Getting Started\n\nThe Lightning Network is a second-layer payment protocol built on top of Bitcoin. It enables instant, low-cost payments by opening payment channels between nodes.\n\n## What is the Lightning Network?\n\n### Key Concepts\n\n- **Payment Channels**: Two-way payment channels between nodes\n- **Off-Chain Transactions**: Most transactions happen off the blockchain\n- **Instant Payments**: Payments settle immediately\n- **Low Fees**: Minimal fees compared to on-chain transactions\n- **Scalability**: Can handle millions of transactions per second\n\n### How It Works\n\n1. **Open Channel**: Two parties lock Bitcoin in a 2-of-2 multisig address\n2. **Update Balance**: Parties exchange signed transactions updating channel balance\n3. **Close Channel**: Final state is broadcast to Bitcoin blockchain\n4. **Route Payments**: Payments can route through multiple channels\n\n## Node Setup\n\n### Prerequisites\n\n- **Bitcoin Node**: Fully synced Bitcoin Core node\n- **Lightning Node**: LND, CLN, or other Lightning implementation\n- **Network**: Signet (testnet) or mainnet\n\n### Bitcoin Node Configuration\n\nAdd to your `bitcoin.conf`:\n\n```ini\n# ZMQ Notifications (required for Lightning)\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28333\n\n# Other Lightning-friendly settings\ntxindex=1\n```\n\n**Important**: Bitcoin Core must be built **with ZMQ enabled** for Lightning to work.\n\n### Lightning Node Configuration (LND)\n\nCreate `lnd.conf`:\n\n```ini\n[Application Options]\ndebuglevel=info\nmaxpendingchannels=10\n\n[Bitcoin]\nbitcoin.active=1\nbitcoin.signet=1\nbitcoin.node=bitcoind\n\n[Bitcoind]\nbitcoind.rpchost=localhost\nbitcoind.rpcuser=your_rpc_user\nbitcoind.rpcpass=your_rpc_password\nbitcoind.zmqpubrawblock=tcp://127.0.0.1:28332\nbitcoind.zmqpubrawtx=tcp://127.0.0.1:28333\n```\n\nStart LND:\n\n```bash\nlnd --configfile=/path/to/lnd.conf\n```\n\n## Funding Your Lightning Node\n\n### Step 1: Create Wallet\n\nIf using Bitcoin Core with a wallet:\n\n```bash\n# Create wallet\nbitcoin-cli -signet createwallet wallet_000\n\n# Import descriptor (if you have one)\nbitcoin-cli -signet -rpcwallet=wallet_000 importdescriptors \\\n  '[{\"desc\":\"tr(tprv8...)\", \"timestamp\":0, \"active\":true}]'\n```\n\n### Step 2: Get Lightning Address\n\nGet a deposit address from your Lightning node:\n\n```bash\n# Using lncli (LND CLI)\nlncli newaddress p2wkh\n```\n\n### Step 3: Fund the Address\n\nSend Bitcoin to the Lightning node address:\n\n```bash\n# Send from Bitcoin Core wallet\nbitcoin-cli -signet -rpcwallet=wallet_000 sendtoaddress \\\n  address=\"tb1p...\" amount=0.01 fee_rate=1\n```\n\nWait for confirmation (typically 1-6 blocks).\n\n## Opening Channels\n\n### Connect to a Peer\n\n```bash\n# Connect to a Lightning node\nlncli connect <pubkey>@<host>:<port>\n```\n\nExample:\n```bash\nlncli connect 02dbe21ebbd6253b2b0ba1f30cba7331e6e6d48aa289f15bf6d2f267b6c6480fa1@signet.bosschallenge.xyz:9735\n```\n\n### Open Channel\n\n```bash\n# Open a channel with 50,000 satoshis\nlncli openchannel --node_key=<pubkey> --local_amt=50000000\n```\n\n**Channel Opening Process:**\n1. Create funding transaction (2-of-2 multisig)\n2. Wait for confirmation (typically 1-6 blocks)\n3. Channel becomes active\n4. Can start making payments\n\n### Check Channel Status\n\n```bash\n# List channels\nlncli listchannels\n\n# Get channel info\nlncli getchaninfo <channel_id>\n```\n\n## Creating and Paying Invoices\n\n### Create Invoice\n\n```bash\n# Create invoice for 1000 satoshis\nlncli addinvoice --amt=1000 --memo=\"Payment for services\"\n```\n\nThis returns a payment request (BOLT11 invoice) starting with `lntbs` (signet) or `lnbc` (mainnet).\n\n### Pay Invoice\n\n```bash\n# Pay an invoice\nlncli payinvoice <invoice_string>\n```\n\n**Payment Process:**\n1. Node finds route to destination\n2. Creates HTLCs along the route\n3. Payment propagates through network\n4. Preimage is revealed\n5. HTLCs are settled\n\n### Check Payment Status\n\n```bash\n# List payments\nlncli listpayments\n\n# Get payment details\nlncli trackpayment <payment_hash>\n```\n\n## Basic Operations\n\n### Get Node Info\n\n```bash\n# Get your node's information\nlncli getinfo\n```\n\nShows:\n- Node public key\n- Number of channels\n- Network (signet/mainnet)\n- Version information\n\n### List Peers\n\n```bash\n# List connected peers\nlncli listpeers\n```\n\n### Channel Balance\n\n```bash\n# Get channel balance\nlncli channelbalance\n```\n\nShows:\n- Local balance (your funds in channels)\n- Remote balance (peer's funds)\n- Pending open channels\n\n### Network Info\n\n```bash\n# Get network graph information\nlncli describegraph\n```\n\n## Common Tasks\n\n### Task 1: Pay an Invoice\n\n1. Receive invoice from another node\n2. Use `lncli payinvoice <invoice>` to pay\n3. Payment routes through network automatically\n4. Extract preimage for verification\n\n### Task 2: Lookup Channel Policy\n\n```bash\n# Get channel information\nlncli getchaninfo <channel_id>\n\n# Parse JSON to find base_fee_msat\nlncli getchaninfo <channel_id> | jq '.base_fee_msat'\n```\n\n### Task 3: Custom Route Payment\n\n```bash\n# Pay via specific route\nlncli sendpayment \\\n  --dest=<destination_pubkey> \\\n  --amt=<amount_satoshis> \\\n  --final_cltv_delta=144 \\\n  --route=<route_json>\n```\n\n## Troubleshooting\n\n### Channel Not Opening\n\n- **Check Bitcoin node**: Ensure it's synced and ZMQ is enabled\n- **Check funding**: Ensure you have enough balance\n- **Check connectivity**: Ensure peer is reachable\n- **Check logs**: Review LND logs for errors\n\n### Payment Failing\n\n- **Insufficient balance**: Check channel balance\n- **No route**: Network may not have path to destination\n- **Channel unbalance**: Channel may be one-sided\n- **Fee too high**: Routing fees may exceed payment amount\n\n### Node Not Starting\n\n- **Check Bitcoin connection**: Ensure Bitcoin node is running\n- **Check ZMQ**: Verify ZMQ is configured correctly\n- **Check permissions**: Ensure LND can access Bitcoin RPC\n- **Check logs**: Review error messages\n\n## Best Practices\n\n### Security\n\n- **Backup wallet**: Always backup your Lightning wallet seed\n- **Secure RPC**: Use strong RPC credentials\n- **Firewall**: Restrict access to Lightning ports\n- **Updates**: Keep Lightning node software updated\n\n### Channel Management\n\n- **Balance channels**: Keep channels balanced for routing\n- **Monitor capacity**: Watch channel capacity\n- **Close unused channels**: Free up capital\n- **Diversify peers**: Connect to multiple well-connected nodes\n\n### Network Participation\n\n- **Announce channels**: Help with network routing\n- **Reasonable fees**: Set competitive routing fees\n- **Maintain uptime**: Keep node online for routing\n- **Monitor network**: Stay aware of network health\n\n## Next Steps\n\n- Learn about [HTLCs and Routing](/docs/lightning/routing)\n- Understand [Channel Lifecycle](/docs/lightning/channels)\n- Explore [Onion Routing](/docs/lightning/onion)\n\n## Resources\n\n- [BOLT Specifications](https://github.com/lightning/bolts)\n- [LND Documentation](https://docs.lightning.engineering/)\n- [Lightning Network Explorer](https://1ml.com/)\n",
    "filename": "getting-started.md"
  },
  "/docs/lightning/routing": {
    "content": "# Lightning Routing Fees\n\nLightning routing fees are how nodes earn income for forwarding payments. Understanding fee calculation is essential for both routing nodes and payment senders.\n\n## Fee Structure\n\nLightning fees consist of two components:\n\n1. **Base Fee**: Fixed fee per HTLC (in millisatoshis)\n2. **Proportional Fee**: Percentage of payment amount (in parts per million)\n\n### Fee Formula\n\n```\nTotal Fee = Base Fee + (Payment Amount Ã— Proportional Fee / 1,000,000)\n```\n\n:::code-group\n```rust\n/// Calculate the fee for forwarding an amount through a channel\n/// Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\nfn calculate_fee(amount_msat: u64, base_fee_msat: u64, proportional_fee_ppm: u64) -> u64 {\n    base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nfn main() {\n    let fee = calculate_fee(100_000_000, 1000, 10);\n    println!(\"Total fee: {} msat\", fee);  // Output: 2000 msat\n}\n```\n\n```python\ndef calculate_fee(amount_msat: int, base_fee_msat: int, proportional_fee_ppm: int) -> int:\n    \"\"\"Calculate the routing fee for forwarding an amount.\n    \n    Args:\n        amount_msat: Amount to forward in millisatoshis\n        base_fee_msat: Fixed fee per HTLC in millisatoshis\n        proportional_fee_ppm: Proportional fee in parts per million\n    \n    Returns:\n        Total fee in millisatoshis (using integer division per BOLT 7)\n    \"\"\"\n    return base_fee_msat + (amount_msat * proportional_fee_ppm // 1_000_000)\n\n# Example: 100,000 sats with 1000 msat base + 10 ppm\nfee = calculate_fee(100_000_000, 1000, 10)\nprint(f\"Total fee: {fee} msat\")  # Output: 2000 msat\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n\n/**\n * Calculate the fee for forwarding an amount through a channel\n * Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n */\nuint64_t calculate_fee(uint64_t amount_msat, uint64_t base_fee_msat, uint64_t proportional_fee_ppm) {\n    return base_fee_msat + (amount_msat * proportional_fee_ppm / 1000000);\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nint main() {\n    uint64_t fee = calculate_fee(100000000, 1000, 10);\n    std::cout << \"Total fee: \" << fee << \" msat\" << std::endl;  // Output: 2000 msat\n    return 0;\n}\n```\n\n```javascript\n/**\n * Calculate the fee for forwarding an amount through a channel\n * Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n * \n * @param {BigInt} amountMsat - Amount to forward in millisatoshis\n * @param {BigInt} baseFeeMsat - Fixed fee per HTLC in millisatoshis\n * @param {BigInt} proportionalFeePpm - Proportional fee in parts per million\n * @returns {BigInt} Total fee in millisatoshis\n */\nfunction calculateFee(amountMsat, baseFeeMsat, proportionalFeePpm) {\n    return baseFeeMsat + (amountMsat * proportionalFeePpm / 1_000_000n);\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nconst fee = calculateFee(100_000_000n, 1000n, 10n);\nconsole.log(`Total fee: ${fee} msat`);  // Output: 2000 msat\n```\n:::\n\n### Example\n\nGiven:\n- Base fee: 1000 msat\n- Proportional fee: 10 ppm (parts per million)\n- Payment amount: 100,000 sats (100,000,000 msat)\n\nCalculation:\n```\nBase Fee = 1000 msat\nProportional Fee = 100,000,000 Ã— 10 / 1,000,000 = 1000 msat\nTotal Fee = 1000 + 1000 = 2000 msat (2 sats)\n```\n\n## Routing Policy\n\nEach node advertises a **routing policy** that specifies:\n\n- `fee_base_msat`: Base fee in millisatoshis\n- `fee_proportional_millionths`: Proportional fee in parts per million\n- `cltv_delta`: Required expiry delta (in blocks)\n\n### Example Policy\n\n```json\n{\n  \"fee_base_msat\": 1000,\n  \"fee_proportional_millionths\": 10,\n  \"cltv_delta\": 40\n}\n```\n\nThis means:\n- 1000 msat base fee per HTLC\n- 10 ppm proportional fee\n- Requires 40 block expiry delta\n\n## Fee Calculation Along a Route\n\nWhen calculating fees for a multi-hop route, fees accumulate:\n\n### Example Route\n\n```\nAlice â†’ Bob â†’ Carol â†’ Dave\nPayment: 100,000 sats\n\nBob's Policy:\n  Base: 1000 msat\n  Proportional: 10 ppm\n\nCarol's Policy:\n  Base: 2000 msat\n  Proportional: 500 ppm\n\nDave (final hop, no fee)\n```\n\n### Calculation\n\n**Step 1: Calculate fee to Carol (from Bob)**\n```\nBase: 1000 msat\nProportional: 100,000,000 Ã— 10 / 1,000,000 = 1000 msat\nTotal: 2000 msat\nAmount to Carol: 100,000,000 + 2000 = 100,002,000 msat\n```\n\n**Step 2: Calculate fee to Dave (from Carol)**\n```\nBase: 2000 msat\nProportional: 100,002,000 Ã— 500 / 1,000,000 = 50,001 msat\nTotal: 52,001 msat\nAmount to Dave: 100,002,000 + 52,001 = 100,054,001 msat\n```\n\n**Total Fee Paid**: 54,001 msat (54 sats)\n\n## HTLC Amount Calculation\n\nFor each hop, the HTLC amount includes:\n- Original payment amount\n- All fees accumulated up to that point\n\n### Backward Calculation\n\nStarting from the final amount, work backwards:\n\n```\nFinal Amount (to Dave): 100,054,001 msat\n\nCarol's HTLC to Dave: 100,054,001 msat\n  (includes: 100,000,000 + 2000 + 52,001)\n\nBob's HTLC to Carol: 100,002,000 msat\n  (includes: 100,000,000 + 2000)\n\nAlice's HTLC to Bob: 100,000,000 msat\n  (original payment)\n```\n\n:::code-group\n```rust\n/// Represents a hop in the payment route\nstruct Hop {\n    channel_name: String,\n    cltv_delta: u32,\n    base_fee_msat: u64,\n    proportional_fee_ppm: u64,\n}\n\n/// Represents calculated HTLC values for a hop\nstruct HtlcHop {\n    channel_name: String,\n    htlc_amount_msat: u64,\n    htlc_expiry: u32,\n}\n\n/// Calculate HTLC values working backwards from destination\nfn calculate_route_backwards(\n    hops: &[Hop],\n    final_amount_msat: u64,\n    min_final_cltv: u32,\n    block_height: u32,\n) -> Vec<HtlcHop> {\n    let mut htlc_hops = Vec::with_capacity(hops.len());\n    \n    // Start with final hop values\n    let mut current_amount = final_amount_msat;\n    let mut current_expiry = block_height + min_final_cltv;\n    \n    // Process hops in reverse order\n    for i in (0..hops.len()).rev() {\n        let hop = &hops[i];\n        \n        htlc_hops.push(HtlcHop {\n            channel_name: hop.channel_name.clone(),\n            htlc_amount_msat: current_amount,\n            htlc_expiry: current_expiry,\n        });\n        \n        // Calculate values for previous hop\n        if i > 0 {\n            let fee = hop.base_fee_msat + \n                      (current_amount * hop.proportional_fee_ppm / 1_000_000);\n            current_amount += fee;\n            current_expiry += hop.cltv_delta;\n        }\n    }\n    \n    htlc_hops.reverse();\n    htlc_hops\n}\n```\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Hop:\n    channel_name: str\n    cltv_delta: int\n    base_fee_msat: int\n    proportional_fee_ppm: int\n\n@dataclass\nclass HtlcHop:\n    channel_name: str\n    htlc_amount_msat: int\n    htlc_expiry: int\n\ndef calculate_route_backwards(\n    hops: List[Hop],\n    final_amount_msat: int,\n    min_final_cltv: int,\n    block_height: int\n) -> List[HtlcHop]:\n    \"\"\"Calculate HTLC values for each hop, working backwards.\"\"\"\n    htlc_hops = []\n    \n    # Start with final hop values\n    current_amount = final_amount_msat\n    current_expiry = block_height + min_final_cltv\n    \n    # Process hops in reverse order\n    for i in range(len(hops) - 1, -1, -1):\n        hop = hops[i]\n        \n        # Store current values for this hop\n        htlc_hops.append(HtlcHop(\n            channel_name=hop.channel_name,\n            htlc_amount_msat=current_amount,\n            htlc_expiry=current_expiry\n        ))\n        \n        # Calculate values for previous hop (if not first hop)\n        if i > 0:\n            fee = hop.base_fee_msat + (current_amount * hop.proportional_fee_ppm // 1_000_000)\n            current_amount += fee\n            current_expiry += hop.cltv_delta\n    \n    return list(reversed(htlc_hops))\n```\n\n```cpp\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <algorithm>\n\nstruct Hop {\n    std::string channel_name;\n    uint32_t cltv_delta;\n    uint64_t base_fee_msat;\n    uint64_t proportional_fee_ppm;\n};\n\nstruct HtlcHop {\n    std::string channel_name;\n    uint64_t htlc_amount_msat;\n    uint32_t htlc_expiry;\n};\n\n/**\n * Calculate HTLC values working backwards from destination\n */\nstd::vector<HtlcHop> calculate_route_backwards(\n    const std::vector<Hop>& hops,\n    uint64_t final_amount_msat,\n    uint32_t min_final_cltv,\n    uint32_t block_height\n) {\n    std::vector<HtlcHop> htlc_hops;\n    htlc_hops.reserve(hops.size());\n    \n    // Start with final hop values\n    uint64_t current_amount = final_amount_msat;\n    uint32_t current_expiry = block_height + min_final_cltv;\n    \n    // Process hops in reverse order\n    for (int i = static_cast<int>(hops.size()) - 1; i >= 0; --i) {\n        const Hop& hop = hops[i];\n        \n        htlc_hops.push_back({\n            hop.channel_name,\n            current_amount,\n            current_expiry\n        });\n        \n        // Calculate values for previous hop\n        if (i > 0) {\n            uint64_t fee = hop.base_fee_msat + \n                          (current_amount * hop.proportional_fee_ppm / 1000000);\n            current_amount += fee;\n            current_expiry += hop.cltv_delta;\n        }\n    }\n    \n    std::reverse(htlc_hops.begin(), htlc_hops.end());\n    return htlc_hops;\n}\n```\n\n```javascript\n/**\n * Represents a hop in the payment route\n * @typedef {Object} Hop\n * @property {string} channelName\n * @property {number} cltvDelta\n * @property {BigInt} baseFeeMsat\n * @property {BigInt} proportionalFeePpm\n */\n\n/**\n * Represents calculated HTLC values for a hop\n * @typedef {Object} HtlcHop\n * @property {string} channelName\n * @property {BigInt} htlcAmountMsat\n * @property {number} htlcExpiry\n */\n\n/**\n * Calculate HTLC values working backwards from destination\n * @param {Hop[]} hops - Array of hops in the route\n * @param {BigInt} finalAmountMsat - Final payment amount\n * @param {number} minFinalCltv - Minimum CLTV for final hop\n * @param {number} blockHeight - Current block height\n * @returns {HtlcHop[]} Calculated HTLC values for each hop\n */\nfunction calculateRouteBackwards(hops, finalAmountMsat, minFinalCltv, blockHeight) {\n    const htlcHops = [];\n    \n    // Start with final hop values\n    let currentAmount = finalAmountMsat;\n    let currentExpiry = blockHeight + minFinalCltv;\n    \n    // Process hops in reverse order\n    for (let i = hops.length - 1; i >= 0; i--) {\n        const hop = hops[i];\n        \n        htlcHops.push({\n            channelName: hop.channelName,\n            htlcAmountMsat: currentAmount,\n            htlcExpiry: currentExpiry\n        });\n        \n        // Calculate values for previous hop\n        if (i > 0) {\n            const fee = hop.baseFeeMsat + \n                       (currentAmount * hop.proportionalFeePpm / 1_000_000n);\n            currentAmount += fee;\n            currentExpiry += hop.cltvDelta;\n        }\n    }\n    \n    return htlcHops.reverse();\n}\n```\n:::\n\n## Integer Division\n\n**Important**: Lightning uses **integer division** for fee calculation (as per BOLT 7).\n\nThis means:\n- Round down (floor) any fractional results\n- No rounding up\n- Can lead to small discrepancies\n\n### Example\n\n```\nPayment: 1,000,000 msat\nProportional Fee: 3 ppm\n\nCalculation: 1,000,000 Ã— 3 / 1,000,000 = 3 msat âœ“\n\nBut if payment was 999,999 msat:\n999,999 Ã— 3 / 1,000,000 = 2.999997 msat\nInteger division: 2 msat (rounded down)\n```\n\n## Fee Economics\n\n### For Routing Nodes\n\n**Revenue Sources:**\n- Base fees from each forwarded payment\n- Proportional fees based on payment size\n\n**Costs:**\n- Channel liquidity (locked capital)\n- Risk of failed payments\n- Operational costs (node maintenance)\n\n**Optimization:**\n- Set competitive but profitable fees\n- Balance liquidity across channels\n- Monitor network conditions\n\n### For Payment Senders\n\n**Considerations:**\n- Total fee across route\n- Payment success probability\n- Route length (more hops = more fees)\n\n**Optimization:**\n- Find routes with lower fees\n- Use direct channels when possible\n- Consider payment splitting (MPP)\n\n## Fee Limits\n\n### Maximum Fees\n\nThere's no hard limit on fees, but:\n- Very high fees reduce payment success\n- Market forces keep fees reasonable\n- Nodes compete for routing business\n\n### Minimum Fees\n\nSome nodes set minimum fees to:\n- Cover operational costs\n- Discourage spam\n- Ensure profitability\n\n## Fee Discovery\n\n### How Senders Find Fees\n\n1. **Network Graph**: Query network for channel policies\n2. **Route Calculation**: Calculate fees for potential routes\n3. **Fee Comparison**: Compare routes by total fee\n4. **Route Selection**: Choose route with acceptable fees\n\n### Fee Updates\n\nNodes can update their fees:\n- Change base fee\n- Change proportional fee\n- Update channel policies\n\nChanges take effect immediately for new payments.\n\n## Best Practices\n\n### For Routing Nodes\n\n1. **Competitive Pricing**: Set fees that attract routing\n2. **Monitor Market**: Adjust fees based on network conditions\n3. **Balance Channels**: Maintain liquidity for routing\n4. **Transparent Policies**: Clearly advertise fee structure\n\n### For Payment Senders\n\n1. **Compare Routes**: Check fees across different routes\n2. **Direct Channels**: Use direct channels to avoid fees\n3. **Payment Size**: Larger payments pay more in proportional fees\n4. **Route Optimization**: Balance fees vs. success probability\n\n## Common Issues\n\n### Fees Too High\n\n**Problem**: Route has very high fees\n\n**Solutions**:\n- Try different routes\n- Use direct channels\n- Split payment (MPP)\n- Wait for better routing conditions\n\n### Fees Not Calculated Correctly\n\n**Problem**: Fee calculation doesn't match expected\n\n**Solutions**:\n- Check integer division\n- Verify policy values\n- Account for all hops\n- Include base and proportional fees\n\n## Summary\n\nLightning routing fees:\n\n- **Two components**: Base fee + proportional fee\n- **Accumulate**: Fees add up along the route\n- **Integer division**: Use floor division for calculations\n- **Economic incentive**: Rewards nodes for routing\n- **Market driven**: Competition keeps fees reasonable\n\nUnderstanding fees helps both routing nodes optimize revenue and payment senders minimize costs.\n",
    "filename": "fees.md"
  },
  "/docs/lightning/channels": {
    "content": "# Lightning Payment Channels\n\nPayment channels are the fundamental building block of the Lightning Network. They enable off-chain transactions between two parties with on-chain settlement.\n\n## What is a Payment Channel?\n\nA [payment channel](/docs/glossary#payment-channel) is a 2-of-2 [multisig](/docs/glossary#multisig-multi-signature) address that locks Bitcoin between two parties. The parties can update the channel balance off-chain without broadcasting to Bitcoin.\n\n### Key Properties\n\n- **2-of-2 Multisig**: Both parties must sign to spend\n- **Off-Chain Updates**: Balance changes happen off-chain\n- **On-Chain Settlement**: Final state broadcast to Bitcoin\n- **Bidirectional**: Payments can flow both directions\n\n## Channel Lifecycle\n\n### 1. Channel Opening\n\n**[Channel Funding](/docs/glossary#channel-funding) Transaction:**\n- Creates 2-of-2 multisig output\n- Locks Bitcoin from both parties\n- Broadcast to Bitcoin network\n- Wait for confirmation (typically 1-6 [blocks](/docs/glossary#block))\n\n**Opening Process:**\n```\n1. Alice and Bob agree to open channel\n2. Create funding transaction (2-of-2 multisig)\n3. Exchange commitment transactions\n4. Broadcast funding transaction\n5. Wait for confirmation\n6. Channel becomes active\n```\n\n### 2. Channel Active\n\n**Off-Chain Updates:**\n- Parties exchange signed commitment transactions\n- Each update reflects new balance\n- No Bitcoin transaction needed\n- Instant and free\n\n**Update Process:**\n```\n1. Alice wants to send 10,000 sats to Bob\n2. Create new commitment transaction:\n   - Old: Alice 50,000, Bob 50,000\n   - New: Alice 40,000, Bob 60,000\n3. Exchange signed commitments\n4. Revoke old commitment\n5. Balance updated (off-chain)\n```\n\n### 3. Channel Closing\n\n**[Channel Closing](/docs/glossary#channel-closing) Options:**\n\n1. **[Cooperative Close](/docs/glossary#cooperative-close)**: Both parties agree\n   - Create closing [transaction](/docs/glossary#transaction)\n   - Both parties sign\n   - Broadcast to Bitcoin\n   - Fast and cheap\n\n2. **[Force Close](/docs/glossary#force-close)**: One party closes unilaterally\n   - Broadcast latest [commitment transaction](/docs/glossary#commitment-transaction)\n   - Wait for [time lock](/docs/glossary#time-lock)\n   - More expensive (higher fees)\n\n3. **Breach Close**: One party tries to cheat\n   - Other party can punish\n   - Takes cheater's funds\n   - Security mechanism\n\n## Channel States\n\n### Opening States\n\n1. **Pending Open**: Funding transaction created, waiting confirmation\n2. **Opening**: Funding confirmed, channel becoming active\n3. **Active**: Channel ready for payments\n\n### Active States\n\n1. **Normal**: Channel operating normally\n2. **Pending HTLC**: HTLC in channel, waiting resolution\n3. **Closing**: Channel being closed\n\n### Closing States\n\n1. **Pending Close**: Closing transaction broadcast\n2. **Closed**: Channel fully closed on-chain\n\n## Commitment Transactions\n\n### Structure\n\nEach commitment transaction represents the current channel state:\n\n```\nInput: Funding transaction output (2-of-2 multisig)\nOutputs:\n  - Alice's balance (to Alice's address)\n  - Bob's balance (to Bob's address)\n  - Any HTLCs (if present)\n```\n\n### Revocation\n\nWhen channel updates:\n1. **New commitment**: Create new commitment transaction\n2. **Revoke old**: Exchange revocation secrets\n3. **Security**: Old commitment becomes invalid\n\n### Why Revocation?\n\nPrevents cheating:\n- If Alice tries to broadcast old commitment\n- Bob can use revocation secret to take all funds\n- Incentivizes honest behavior\n\n## Channel Capacity\n\n### Total Capacity\n\nChannel capacity = sum of both parties' contributions:\n\n```\nAlice contributes: 100,000 sats\nBob contributes: 50,000 sats\nTotal capacity: 150,000 sats\n```\n\n### Available Balance\n\nEach party's available balance:\n\n```\nInitial: Alice 100,000, Bob 50,000\nAfter payment: Alice 90,000, Bob 60,000\n```\n\n### Liquidity\n\nFor routing, need balance in direction of payment:\n\n```\nAlice â†’ Bob: Need Alice to have balance\nBob â†’ Alice: Need Bob to have balance\n```\n\n## Channel Types\n\n### Public Channels\n\n- **Announced**: Advertised to network\n- **Routing**: Can route payments for others\n- **Discovery**: Visible in network graph\n- **Use case**: Routing nodes\n\n### Private Channels\n\n- **Unannounced**: Not advertised\n- **Direct only**: Only for direct payments\n- **Privacy**: Not visible in network\n- **Use case**: Private payments\n\n## Channel Management\n\n### Opening Channels\n\n**Considerations:**\n- **Capacity**: How much to lock\n- **Peer selection**: Choose reliable peers\n- **Fees**: Opening and closing fees\n- **Uptime**: Peer should be online\n\n### Closing Channels\n\n**When to close:**\n- Channel no longer needed\n- Need to free capital\n- Peer is unreliable\n- Rebalancing channels\n\n**How to close:**\n- **Cooperative**: Fastest and cheapest\n- **Force close**: If peer unresponsive\n- **Wait for timelock**: After force close\n\n### Rebalancing\n\n**Problem**: Channel becomes one-sided\n\n**Solution**: Rebalance channels:\n- Open new channels\n- Close unbalanced channels\n- Use circular payments\n- Use rebalancing services\n\n## Channel Security\n\n### Commitment Security\n\n- **Revocation secrets**: Prevent old state broadcast\n- **Timelocks**: Give time to respond to cheating\n- **Watchtowers**: Monitor for cheating attempts\n\n### Force Close Protection\n\n- **Timelock**: Time to respond to force close\n- **Penalty**: Cheater loses funds\n- **Watchtower**: Third party monitors\n\n### Best Practices\n\n1. **Backup**: Always backup channel state\n2. **Monitor**: Watch for suspicious activity\n3. **Update**: Keep software updated\n4. **Secure**: Protect private keys\n\n## Channel Economics\n\n### Costs\n\n- **Opening**: On-chain transaction fee\n- **Closing**: On-chain transaction fee\n- **Capital**: Locked in channel\n- **Opportunity cost**: Can't use locked funds\n\n### Benefits\n\n- **Instant payments**: No on-chain wait\n- **Low fees**: Minimal per-payment cost\n- **Privacy**: Off-chain transactions\n- **Scalability**: Millions of transactions\n\n### ROI Calculation\n\n```\nChannel opening cost: 10,000 sats\nRouting fees earned: 1,000 sats/month\nBreak-even: 10 months\n```\n\n## Common Issues\n\n### Channel Unbalanced\n\n**Problem**: All funds on one side\n\n**Solution**:\n- Rebalance channels\n- Open new channels\n- Use rebalancing services\n\n### Channel Stuck\n\n**Problem**: Can't close channel\n\n**Solution**:\n- Force close if needed\n- Contact peer\n- Wait for timelock\n\n### Insufficient Capacity\n\n**Problem**: Not enough balance for payment\n\n**Solution**:\n- Open larger channel\n- Receive payment first\n- Use different route\n\n## Summary\n\nPayment channels enable:\n\n- **Off-chain transactions**: Fast and cheap\n- **Bidirectional payments**: Both directions\n- **On-chain settlement**: Final state on Bitcoin\n- **Security**: Commitment and revocation\n- **Scalability**: Millions of transactions\n\nUnderstanding channels is essential for using and routing on the Lightning Network.\n",
    "filename": "concepts.md"
  },
  "/docs/lightning/onion": {
    "content": "# Lightning Onion Routing\n\nLightning Network uses Sphinx onion routing to provide privacy and security for payments. Each hop in a route only knows the previous and next hop, not the full route or payment details.\n\n## What is Onion Routing?\n\nOnion routing is a technique where data is encrypted in layers, like an onion. Each hop peels off one layer, revealing only the information needed for that hop.\n\n### Key Properties\n\n- **Privacy**: Each hop only knows immediate neighbors\n- **Integrity**: HMACs prevent tampering\n- **Source Hiding**: Sender identity is hidden\n- **Path Hiding**: Full route is not revealed\n\n## Sphinx Protocol\n\nLightning uses the Sphinx protocol (based on Tor's design) adapted for payment routing.\n\n### How It Works\n\n1. **Sender creates onion**: Encrypts payment data in layers\n2. **Each hop processes**: Peels off one layer, forwards to next\n3. **Final hop**: Receives payment details\n4. **Response path**: Preimage propagates back (unencrypted)\n\n### Visual Representation\n\n```\nOnion Packet Structure:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Layer 1 (for Hop 1)                 â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚\nâ”‚  â”‚ Layer 2 (for Hop 2)           â”‚  â”‚\nâ”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚\nâ”‚  â”‚  â”‚ Layer 3 (for Hop 3)     â”‚  â”‚  â”‚\nâ”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚\nâ”‚  â”‚  â”‚  â”‚ Payment Data      â”‚  â”‚  â”‚  â”‚\nâ”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚\nâ”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Onion Packet Structure\n\n### Components\n\n1. **Version**: Protocol version (currently 0)\n2. **Public Key**: Ephemeral public key for this hop\n3. **HMAC**: Message authentication code\n4. **Payload**: Encrypted routing data\n5. **Routing Information**: Next hop details\n\n### Per-Hop Data\n\nEach layer contains:\n- **Short Channel ID**: Channel to use\n- **Amount to Forward**: HTLC amount\n- **Outgoing CLTV**: Expiry for outgoing HTLC\n- **Payment Data**: TLV fields (for final hop)\n\n## Encryption Process\n\n### Layer Construction\n\nFor each hop, sender:\n1. **Generate ephemeral key**: Create temporary key pair\n2. **ECDH**: Derive shared secret with hop's public key\n3. **Encrypt payload**: Use shared secret to encrypt data\n4. **Add HMAC**: Create authentication code\n5. **Wrap in next layer**: Encrypt for previous hop\n\n### Cryptographic Primitives\n\n- **ECDH**: Elliptic Curve Diffie-Hellman (key exchange)\n- **ChaCha20**: Stream cipher (encryption)\n- **HMAC-SHA256**: Message authentication\n- **XOR**: Exclusive OR (mixing)\n\n## Processing at Each Hop\n\n### Hop 1 (First Hop)\n\n1. **Receive onion**: Get encrypted packet\n2. **ECDH**: Derive shared secret with ephemeral key\n3. **Decrypt**: Peel off outer layer\n4. **Verify HMAC**: Check message integrity\n5. **Extract data**: Get routing information\n6. **Forward**: Send to next hop\n\n### Intermediate Hops\n\nSame process:\n1. Receive onion\n2. Decrypt layer\n3. Verify HMAC\n4. Extract routing info\n5. Forward to next hop\n\n### Final Hop\n\n1. Receive onion\n2. Decrypt final layer\n3. Verify HMAC\n4. Extract payment data\n5. Create HTLC\n6. Reveal preimage (when payment received)\n\n## Privacy Guarantees\n\n### What Each Hop Knows\n\n**Intermediate Hops:**\n- Previous hop (who sent to them)\n- Next hop (where to forward)\n- HTLC amount and expiry\n- **NOT**: Sender identity\n- **NOT**: Final destination\n- **NOT**: Full route\n- **NOT**: Total payment amount\n\n**Final Hop:**\n- Previous hop\n- Payment amount\n- Payment data (TLV)\n- **NOT**: Sender identity\n- **NOT**: Full route\n\n### What is Hidden\n\n- **Sender identity**: Not revealed to any hop\n- **Full route**: Each hop only knows neighbors\n- **Payment purpose**: Not visible to intermediate hops\n- **Total amount**: Intermediate hops don't know final amount\n\n## Security Properties\n\n### Integrity\n\n- **HMAC verification**: Each hop verifies message hasn't been tampered\n- **Replay protection**: Prevents replay attacks\n- **Tamper detection**: Any modification is detected\n\n### Authentication\n\n- **Public keys**: Each hop identified by public key\n- **Key derivation**: Shared secrets derived from public keys\n- **No impersonation**: Can't fake hop identity\n\n### Forward Secrecy\n\n- **Ephemeral keys**: Each payment uses new keys\n- **No correlation**: Can't link payments\n- **Temporary secrets**: Keys only valid for one payment\n\n## Onion Packet Size\n\n### Fixed Size\n\n- **1300 bytes**: Standard onion packet size\n- **Fixed regardless of route length**: Same size for 2 hops or 20 hops\n- **Padding**: Unused space filled with random data\n\n### Why Fixed Size?\n\n- **Traffic analysis resistance**: Can't determine route length\n- **Uniform appearance**: All packets look the same\n- **Privacy**: Route length is hidden\n\n## Implementation Details\n\n### Session Key\n\nSender generates random session key for each payment:\n- **32 bytes**: Random value\n- **Used for**: Deriving shared secrets\n- **Ephemeral**: Only used for this payment\n\n### Associated Data\n\nAdditional data included in encryption:\n- **32 bytes**: Payment-related data\n- **Included in**: HMAC calculation\n- **Purpose**: Additional authentication\n\n### Payload Construction\n\nFor each hop:\n1. Create payload with routing info\n2. Encrypt with shared secret\n3. Add HMAC\n4. Wrap in previous layer\n\n## Common Issues\n\n### HMAC Verification Failure\n\n**Problem**: HMAC doesn't match\n\n**Causes**:\n- Tampering\n- Encryption error\n- Key derivation error\n\n**Solution**: Reject packet, payment fails\n\n### Decryption Failure\n\n**Problem**: Can't decrypt layer\n\n**Causes**:\n- Wrong key\n- Corrupted packet\n- Version mismatch\n\n**Solution**: Reject packet, payment fails\n\n## Best Practices\n\n### For Implementers\n\n1. **Follow spec**: Implement BOLT 4 exactly\n2. **Test vectors**: Use provided test vectors\n3. **Cryptographic primitives**: Use secure implementations\n4. **Error handling**: Handle failures gracefully\n\n### For Users\n\n1. **Trust routing**: Onion routing handles privacy\n2. **Route selection**: Choose diverse routes\n3. **Payment size**: Vary payment sizes\n4. **Timing**: Vary payment timing\n\n## Summary\n\nOnion routing provides:\n\n- **Privacy**: Each hop only knows neighbors\n- **Security**: HMACs prevent tampering\n- **Source hiding**: Sender identity protected\n- **Path hiding**: Full route not revealed\n- **Fixed size**: Route length hidden\n\nUnderstanding onion routing helps explain how Lightning provides privacy while enabling efficient payment routing.\n",
    "filename": "routing.md"
  },
  "/docs/development/getting-started": {
    "content": "# Getting Started with Bitcoin Development\n\nBitcoin development spans multiple layers, from low-level protocol work to high-level application development. This guide covers the programming languages, tools, and approaches used across the Bitcoin ecosystem to help you choose the right path for your goals.\n\n> **Hands-on learning:** Try Bitcoin RPC commands directly in the [Bitcoin CLI Terminal](/terminal). No node setup required.\n\n## Programming Languages in Bitcoin\n\n### C++ (Bitcoin Core)\n\nThe reference implementation of Bitcoin is written in C++.\n\n**Used for:**\n- Bitcoin Core development\n- Performance-critical applications\n- Protocol-level changes\n- Consensus code\n\n**Key libraries:**\n- **libbitcoin**: Comprehensive Bitcoin library\n- **libsecp256k1**: Optimized elliptic curve library (used by Bitcoin Core)\n\n**When to use:**\n- Contributing to Bitcoin Core\n- Building nodes or mining software\n- Maximum performance requirements\n\n```cpp\n// Example: Creating a simple transaction hash\n#include <bitcoin/bitcoin.hpp>\n\nbc::hash_digest tx_hash = bc::bitcoin_hash(tx_data);\n```\n\n### Rust\n\nIncreasingly popular for Bitcoin development due to memory safety and performance.\n\n**Used for:**\n- Lightning implementations (LDK)\n- Wallet libraries\n- Cryptographic tools\n- New protocol implementations\n\n**Key libraries:**\n- **rust-bitcoin**: Core Bitcoin data structures\n- **rust-lightning (LDK)**: Lightning Development Kit\n- **bdk (Bitcoin Dev Kit)**: Modern wallet library\n- **rust-miniscript**: Policy to script compiler\n\n**When to use:**\n- New Bitcoin applications\n- Security-critical code\n- Modern wallet development\n- Lightning applications\n\n```rust\n// Example: Creating a Bitcoin address\nuse bitcoin::{Address, Network, PublicKey};\n\nlet address = Address::p2pkh(&public_key, Network::Bitcoin);\n```\n\n### Python\n\nExcellent for scripting, prototyping, and learning.\n\n**Used for:**\n- Rapid prototyping\n- Data analysis and research\n- Educational tools\n- Automation scripts\n- API integrations\n\n**Key libraries:**\n- **python-bitcoinlib**: Core Bitcoin library\n- **bip32**: HD wallet derivation\n- **ecdsa**: Elliptic curve operations\n- **requests**: API interactions\n\n**When to use:**\n- Learning Bitcoin internals\n- Quick scripts and tools\n- Data analysis\n- API wrappers\n\n```python\n# Example: Decode a raw transaction\nfrom bitcoin.core import CTransaction\n\ntx = CTransaction.deserialize(bytes.fromhex(raw_tx_hex))\nprint(f\"Transaction has {len(tx.vin)} inputs and {len(tx.vout)} outputs\")\n```\n\n### JavaScript/TypeScript\n\nDominant in web applications and increasingly in Bitcoin tooling.\n\n**Used for:**\n- Web wallets and applications\n- Browser extensions\n- Node.js backends\n- Frontend interfaces\n\n**Key libraries:**\n- **bitcoinjs-lib**: Bitcoin library\n- **bip39/bip32**: Mnemonic and HD derivation\n- **noble-secp256k1**: Cryptographic primitives\n- **bolt11**: Lightning invoice encoding\n\n**When to use:**\n- Web applications\n- Browser-based wallets\n- Full-stack development\n- Rapid development\n\n```typescript\n// Example: Generate a new address\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst keyPair = bitcoin.ECPair.makeRandom();\nconst { address } = bitcoin.payments.p2wpkh({ \n  pubkey: keyPair.publicKey \n});\n```\n\n### Go\n\nPopular for infrastructure and server applications.\n\n**Used for:**\n- Lightning implementations (lnd)\n- Server infrastructure\n- APIs and backends\n- DevOps tooling\n\n**Key libraries:**\n- **btcd**: Alternative full node implementation\n- **lnd**: Lightning Network Daemon\n- **btcutil**: Bitcoin utilities\n\n**When to use:**\n- Lightning node development\n- Backend services\n- Infrastructure tools\n- High-concurrency applications\n\n```go\n// Example: Connect to lnd\nimport \"github.com/lightningnetwork/lnd/lnrpc\"\n\nclient := lnrpc.NewLightningClient(conn)\ninfo, _ := client.GetInfo(ctx, &lnrpc.GetInfoRequest{})\n```\n\n## Development Approaches\n\n### 1. Full Node Development\n\nWorking directly with Bitcoin Core or alternative implementations.\n\n**What you'll do:**\n- Run and configure full nodes\n- Use RPC interface for queries\n- Contribute to protocol development\n- Understand consensus rules\n\n**Getting started:**\n1. Install Bitcoin Core\n2. Sync the blockchain (or use testnet/signet)\n3. Enable RPC interface\n4. Explore `bitcoin-cli` commands\n\n```bash\n# Basic node setup\nbitcoind -daemon\nbitcoin-cli getblockchaininfo\nbitcoin-cli getmempoolinfo\n```\n\n### 2. Wallet Development\n\nBuilding applications that manage keys and create transactions.\n\n**What you'll do:**\n- Generate and manage keys\n- Create and sign transactions\n- Implement coin selection\n- Handle address types (P2PKH, P2WPKH, P2TR)\n\n**Key concepts:**\n- BIP32 (HD wallets)\n- BIP39 (Mnemonic phrases)\n- BIP44/49/84/86 (Derivation paths)\n- PSBT (Partially Signed Bitcoin Transactions)\n\n**Getting started:**\n1. Choose a wallet library (BDK, bitcoinjs-lib, etc.)\n2. Learn key derivation\n3. Understand transaction structure\n4. Implement on testnet first\n\n### 3. Lightning Development\n\nBuilding on the Lightning Network for instant, low-fee payments.\n\n**What you'll do:**\n- Run Lightning nodes\n- Open and manage channels\n- Create payment applications\n- Handle invoices and payments\n\n**Approaches:**\n- **LND + API**: Run lnd, use REST/gRPC API\n- **LDK**: Embed Lightning in your application\n- **Core Lightning**: Plugin-based development\n- **Eclair**: JVM-based implementation\n\n**Getting started:**\n1. Set up a Lightning node (lnd, Core Lightning, or Eclair)\n2. Connect to testnet\n3. Open channels with test nodes\n4. Build a simple payment application\n\n### 4. Script and Smart Contract Development\n\nWorking with Bitcoin's scripting system.\n\n**What you'll do:**\n- Write Bitcoin scripts\n- Create custom spending conditions\n- Work with timelocks and hashlocks\n- Implement multisig schemes\n\n**Key concepts:**\n- OP codes and stack operations\n- P2SH and P2WSH\n- Taproot and Tapscript\n- Miniscript for policy compilation\n\n**Getting started:**\n1. Learn basic OP codes\n2. Understand script execution\n3. Use miniscript for complex policies\n4. Test on signet\n\n## Development Networks\n\n### Mainnet\n\nThe real Bitcoin network. Use only for production applications.\n\n**Characteristics:**\n- Real value at stake\n- ~10 minute block times\n- Full transaction fees\n\n### Testnet\n\nLong-running test network. Coins have no value.\n\n**Characteristics:**\n- Free testnet coins from faucets\n- Can have unpredictable block times\n- Occasionally reset\n\n**Getting coins:**\n- [coinfaucet.eu/en/btc-testnet/](https://coinfaucet.eu/en/btc-testnet/)\n- [testnet-faucet.mempool.co/](https://testnet-faucet.mempool.co/)\n\n### Signet\n\nMore controlled test network with consistent block production.\n\n**Characteristics:**\n- Predictable block times\n- Controlled by signers\n- Better for development\n\n**Getting coins:**\n- [signet.bc-2.jp/](https://signet.bc-2.jp/)\n- [alt.signetfaucet.com/](https://alt.signetfaucet.com/)\n\n### Regtest\n\nLocal, private test network. You control everything.\n\n**Characteristics:**\n- Instant block generation\n- Complete control\n- No external dependencies\n- Ideal for unit testing\n\n```bash\n# Start regtest\nbitcoind -regtest -daemon\n\n# Generate blocks (mine to your address)\nbitcoin-cli -regtest generatetoaddress 101 <your-address>\n```\n\n## Essential Tools\n\n### Block Explorers\n\n- **[mempool.space](https://mempool.space)**: Beautiful, open-source explorer\n- **[blockstream.info](https://blockstream.info)**: Blockstream's explorer\n- **[blockchain.info](https://www.blockchain.com/explorer)**: Popular web explorer\n\n### Development Tools\n\n- **[Bitcoin Core](https://bitcoincore.org/)**: Reference implementation\n- **[Polar](https://lightningpolar.com/)**: One-click Lightning networks for testing\n- **[Sparrow Wallet](https://sparrowwallet.com/)**: Advanced wallet for testing\n- **[Electrum](https://electrum.org/)**: Lightweight wallet with console\n\n### APIs and Services\n\n- **[mempool.space API](https://mempool.space/docs/api)**: Block and transaction data\n- **[Blockstream Esplora](https://github.com/Blockstream/esplora)**: Self-hostable API\n- **[getblock.io](https://getblock.io/)**: Node-as-a-service\n\n### Documentation\n\n- **[Bitcoin Developer Reference](https://developer.bitcoin.org/)**: Official documentation\n- **[BIPs](https://github.com/bitcoin/bips)**: Bitcoin Improvement Proposals\n- **[BOLTs](https://github.com/lightning/bolts)**: Lightning specifications\n- **[Learning Bitcoin from the Command Line](https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line)**: Command line tutorial\n\n## Development Workflow\n\n### 1. Start with Regtest\n\n```bash\n# Create a regtest environment\nbitcoind -regtest -daemon\nbitcoin-cli -regtest createwallet \"dev\"\nbitcoin-cli -regtest -generate 101\n```\n\n### 2. Move to Signet/Testnet\n\nOnce your code works locally, test on public networks:\n\n```bash\n# Connect to signet\nbitcoind -signet -daemon\nbitcoin-cli -signet getblockchaininfo\n```\n\n### 3. Security Review\n\nBefore mainnet:\n- Audit key management\n- Review transaction construction\n- Check fee calculations\n- Test edge cases\n\n### 4. Deploy to Mainnet\n\nOnly after thorough testing:\n- Start with small amounts\n- Monitor transactions\n- Have rollback plans\n\n## Common Pitfalls\n\n### Security\n\n- **Never hardcode keys**: Use environment variables or secure storage\n- **Validate all inputs**: Especially amounts and addresses\n- **Use established libraries**: Don't roll your own crypto\n- **Test on testnet first**: Always\n\n### Transaction Construction\n\n- **Calculate fees properly**: Too low = stuck, too high = waste\n- **Handle dust**: Outputs below ~546 sats may be unspendable\n- **Sign correctly**: Verify signatures before broadcasting\n- **Use PSBT**: For multi-party or hardware wallet signing\n\n### Network\n\n- **Handle reorgs**: Transactions can be reversed until deeply confirmed\n- **Wait for confirmations**: 6 blocks for high-value transactions\n- **Don't trust unconfirmed**: Zero-conf can be double-spent\n\n## Summary\n\nBitcoin development offers many paths:\n\n| Language | Best For | Key Library |\n|----------|----------|-------------|\n| C++ | Bitcoin Core, performance | libbitcoin |\n| Rust | Modern apps, security | rust-bitcoin, BDK |\n| Python | Learning, scripting | python-bitcoinlib |\n| JavaScript | Web apps | bitcoinjs-lib |\n| Go | Lightning, infrastructure | btcd, lnd |\n\nStart small, use testnet, and build incrementally. The Bitcoin development community is welcoming; ask questions and contribute back.\n\n## Related Topics\n\n- [Blockchain Monitoring](/docs/development/monitoring) - Monitor blocks and transactions\n- [Pool Mining](/docs/development/mining) - Mining development\n- [Price Tracking](/docs/development/tools) - API integrations\n- [RPC Guide](/docs/bitcoin/rpc) - Bitcoin Core RPC commands\n\n## Resources\n\n- [Bitcoin Developer Mailing List](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n- [Bitcoin Stack Exchange](https://bitcoin.stackexchange.com/)\n- [Bitcoin Optech](https://bitcoinops.org/) - Technical newsletter\n- [Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)\n",
    "filename": "getting-started.md"
  },
  "/docs/development/testing": {
    "content": "# Testing & Debugging Bitcoin Applications\n\nTesting Bitcoin applications requires special considerations due to the financial nature of the software and the complexity of the protocol. This guide covers testing strategies, debugging techniques, and best practices.\n\n## Testing Networks\n\n### Regtest (Recommended for Development)\n\nRegtest provides a completely controlled environment where you can instantly generate blocks.\n\n**Setup:**\n\n```bash\n# Start Bitcoin Core in regtest mode\nbitcoind -regtest -daemon\n\n# Create a wallet\nbitcoin-cli -regtest createwallet \"test\"\n\n# Generate initial blocks (need 100+ for spendable coins)\nbitcoin-cli -regtest -generate 101\n```\n\n**Advantages:**\n- Instant block generation\n- No network dependencies\n- Complete control over timing\n- Reproducible tests\n\n### Signet (Recommended for Integration Testing)\n\nSignet provides a more realistic testing environment with predictable block times.\n\n```bash\n# Start Bitcoin Core in signet mode\nbitcoind -signet -daemon\n\n# Check sync status\nbitcoin-cli -signet getblockchaininfo\n```\n\n### Testnet (Legacy Testing)\n\nTestnet mimics mainnet but with worthless coins.\n\n```bash\nbitcoind -testnet -daemon\nbitcoin-cli -testnet getblockchaininfo\n```\n\n## Unit Testing Strategies\n\n### Testing Address Generation\n\n:::code-group\n```rust\n#[test]\nfn test_address_generation() {\n    let pubkey = PublicKey::from_str(\n        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\n    ).unwrap();\n    let address = Address::p2wpkh(&pubkey, Network::Bitcoin).unwrap();\n    assert!(address.to_string().starts_with(\"bc1q\"));\n}\n```\n\n```python\ndef test_address_generation():\n    from bitcoin.wallet import P2PKHBitcoinAddress\n    pubkey = bytes.fromhex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')\n    addr = P2PKHBitcoinAddress.from_pubkey(pubkey)\n    assert str(addr).startswith('m') or str(addr).startswith('n')\n```\n\n```cpp\nBOOST_AUTO_TEST_CASE(test_address_generation) {\n    bc::ec_compressed pubkey;\n    bc::decode_base16(pubkey, \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\");\n    auto addr = bc::wallet::payment_address(pubkey);\n    BOOST_CHECK(addr.encoded().substr(0, 1) == \"1\");\n}\n```\n\n```javascript\ntest('generates valid P2WPKH address', () => {\n  const pubkey = Buffer.from('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', 'hex');\n  const { address } = bitcoin.payments.p2wpkh({ pubkey, network: bitcoin.networks.bitcoin });\n  expect(address).toMatch(/^bc1q/);\n});\n```\n:::\n\n### Testing Transaction Construction\n\n:::code-group\n```rust\n#[test]\nfn test_transaction() {\n    let tx = Transaction { version: 2, lock_time: LockTime::ZERO, input: vec![], output: vec![] };\n    assert_eq!(tx.version, 2);\n}\n```\n\n```python\ndef test_transaction_construction():\n    outpoint = COutPoint(bytes(32), 0)\n    txin = CTxIn(prevout=outpoint)\n    tx = CTransaction([txin], [])\n    \n    assert len(tx.vin) == 1\n    assert len(tx.vout) == 0\n```\n\n```cpp\nBOOST_AUTO_TEST_CASE(test_transaction) {\n    bc::chain::transaction tx;\n    tx.set_version(2);\n    BOOST_CHECK_EQUAL(tx.version(), 2u);\n}\n```\n\n```javascript\ntest('creates valid transaction structure', () => {\n  const psbt = new bitcoin.Psbt();\n  psbt.addInput({ hash: Buffer.alloc(32), index: 0, witnessUtxo: { script: Buffer.alloc(22), value: 100000 } });\n  expect(psbt.inputCount).toBe(1);\n});\n```\n:::\n\n## Integration Testing\n\n### Testing with Regtest\n\n**Complete Test Flow:**\n\n```python\nimport subprocess\nimport time\nimport json\n\nclass RegtestTestCase:\n    def setUp(self):\n        # Start bitcoind in regtest mode\n        subprocess.run(['bitcoind', '-regtest', '-daemon'])\n        time.sleep(2)  # Wait for startup\n        \n        # Create wallet and generate coins\n        self.cli('createwallet', 'test')\n        self.cli('-generate', '101')\n    \n    def tearDown(self):\n        # Stop bitcoind\n        self.cli('stop')\n    \n    def cli(self, *args):\n        result = subprocess.run(\n            ['bitcoin-cli', '-regtest'] + list(args),\n            capture_output=True,\n            text=True\n        )\n        if result.stdout:\n            try:\n                return json.loads(result.stdout)\n            except json.JSONDecodeError:\n                return result.stdout.strip()\n        return None\n    \n    def test_send_transaction(self):\n        # Get a new address\n        addr = self.cli('getnewaddress')\n        \n        # Send coins\n        txid = self.cli('sendtoaddress', addr, '1.0')\n        \n        # Verify transaction exists\n        tx = self.cli('gettransaction', txid)\n        assert tx is not None\n        assert tx['amount'] == 1.0\n```\n\n### Testing Fee Estimation\n\n```python\ndef test_fee_estimation(self):\n    # Generate some blocks with transactions\n    for _ in range(10):\n        addr = self.cli('getnewaddress')\n        self.cli('sendtoaddress', addr, '0.1')\n        self.cli('-generate', '1')\n    \n    # Test fee estimation\n    fee_rate = self.cli('estimatesmartfee', '6')\n    \n    # Should return a valid fee rate\n    assert 'feerate' in fee_rate\n    assert fee_rate['feerate'] > 0\n```\n\n## Debugging Techniques\n\n### Using bitcoin-cli for Debugging\n\n**Inspect Transaction:**\n\n```bash\n# Decode raw transaction\nbitcoin-cli decoderawtransaction <hex>\n\n# Get transaction details\nbitcoin-cli getrawtransaction <txid> true\n\n# Check mempool\nbitcoin-cli getmempoolentry <txid>\n```\n\n**Debug Scripts:**\n\n```bash\n# Test script execution (if using btcdeb)\nbtcdeb '[OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG]'\n```\n\n### Analyzing Debug Logs\n\nBitcoin Core writes detailed logs to `debug.log`.\n\n**Location:**\n- Linux: `~/.bitcoin/debug.log`\n- macOS: `~/Library/Application Support/Bitcoin/debug.log`\n- Windows: `%APPDATA%\\Bitcoin\\debug.log`\n\n**Useful Log Categories:**\n\n```bash\n# Enable specific debug categories\nbitcoind -debug=net -debug=mempool -debug=validation\n\n# Or in bitcoin.conf\ndebug=net\ndebug=mempool\ndebug=validation\n```\n\n**Common Debug Categories:**\n- `net`: Network messages\n- `mempool`: Mempool operations\n- `validation`: Block validation\n- `rpc`: RPC calls\n- `estimatefee`: Fee estimation\n- `selectcoins`: Coin selection\n\n### Common Debugging Patterns\n\n**Transaction Not Confirming:**\n\n```bash\n# Check if in mempool\nbitcoin-cli getmempoolentry <txid>\n\n# Check mempool info\nbitcoin-cli getmempoolinfo\n\n# Check fee rate\nbitcoin-cli getmempoolentry <txid> | jq '.fees.base / .vsize'\n```\n\n**Script Verification Failed:**\n\n```bash\n# Decode and inspect the transaction\nbitcoin-cli decoderawtransaction <raw_tx>\n\n# Check the referenced output\nbitcoin-cli gettxout <prev_txid> <vout>\n```\n\n## Testing Lightning Applications\n\n### Using Polar\n\nPolar provides a one-click Lightning Network for testing.\n\n**Setup:**\n1. Download from [lightningpolar.com](https://lightningpolar.com/)\n2. Create a new network\n3. Start nodes\n4. Open channels between nodes\n\n### LND Testing\n\n```python\nimport grpc\nimport lnrpc\n\nclass LightningTestCase:\n    def setUp(self):\n        # Connect to LND\n        self.channel = grpc.insecure_channel('localhost:10009')\n        self.stub = lnrpc.LightningStub(self.channel)\n    \n    def test_create_invoice(self):\n        # Create invoice\n        request = lnrpc.Invoice(value=1000, memo=\"test\")\n        response = self.stub.AddInvoice(request)\n        \n        # Verify invoice created\n        assert response.payment_request is not None\n        assert response.payment_request.startswith('ln')\n```\n\n### Core Lightning Testing\n\n```python\nfrom pyln.client import LightningRpc\n\nclass CLightningTestCase:\n    def setUp(self):\n        self.rpc = LightningRpc(\"/path/to/lightning-rpc\")\n    \n    def test_get_info(self):\n        info = self.rpc.getinfo()\n        assert 'id' in info\n        assert 'alias' in info\n```\n\n## Mocking and Stubbing\n\n### Mocking RPC Calls\n\n```python\nfrom unittest.mock import Mock, patch\n\nclass TestWithMocks:\n    @patch('bitcoinrpc.RawProxy')\n    def test_get_balance(self, mock_proxy):\n        # Setup mock\n        mock_proxy.return_value.getbalance.return_value = 10.5\n        \n        # Test code that uses RPC\n        rpc = mock_proxy()\n        balance = rpc.getbalance()\n        \n        assert balance == 10.5\n        mock_proxy.return_value.getbalance.assert_called_once()\n```\n\n### Mocking Network Responses\n\n```python\nimport responses\nimport requests\n\nclass TestAPIIntegration:\n    @responses.activate\n    def test_fetch_block(self):\n        # Mock the API response\n        responses.add(\n            responses.GET,\n            'https://blockstream.info/api/block/000000...',\n            json={'height': 100000, 'tx_count': 50},\n            status=200\n        )\n        \n        # Test code\n        response = requests.get('https://blockstream.info/api/block/000000...')\n        data = response.json()\n        \n        assert data['height'] == 100000\n```\n\n## Test Data Generation\n\n### Creating Test Transactions\n\n```python\ndef create_test_transaction(inputs, outputs):\n    \"\"\"Create a transaction for testing.\"\"\"\n    tx = CTransaction()\n    \n    for txid, vout in inputs:\n        outpoint = COutPoint(bytes.fromhex(txid)[::-1], vout)\n        tx.vin.append(CTxIn(outpoint))\n    \n    for address, amount in outputs:\n        script = address.to_scriptPubKey()\n        tx.vout.append(CTxOut(int(amount * 100000000), script))\n    \n    return tx\n```\n\n### Generating Test Keys\n\n```python\nimport secrets\nfrom bitcoin.wallet import CBitcoinSecret\n\ndef generate_test_keypair():\n    \"\"\"Generate a random keypair for testing.\"\"\"\n    # Generate random private key\n    private_key_bytes = secrets.token_bytes(32)\n    private_key = CBitcoinSecret.from_secret_bytes(private_key_bytes)\n    \n    # Derive public key\n    public_key = private_key.pub\n    \n    return private_key, public_key\n```\n\n## Continuous Integration\n\n### GitHub Actions Example\n\n```yaml\nname: Bitcoin Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.10'\n    \n    - name: Install dependencies\n      run: |\n        pip install python-bitcoinlib pytest\n    \n    - name: Install Bitcoin Core\n      run: |\n        wget https://bitcoincore.org/bin/bitcoin-core-25.0/bitcoin-25.0-x86_64-linux-gnu.tar.gz\n        tar xzf bitcoin-25.0-x86_64-linux-gnu.tar.gz\n        sudo mv bitcoin-25.0/bin/* /usr/local/bin/\n    \n    - name: Run unit tests\n      run: pytest tests/unit/\n    \n    - name: Run integration tests\n      run: |\n        bitcoind -regtest -daemon\n        sleep 5\n        pytest tests/integration/\n        bitcoin-cli -regtest stop\n```\n\n## Best Practices\n\n### Testing Checklist\n\n1. **Unit Tests**: Test individual functions in isolation\n2. **Integration Tests**: Test component interactions on regtest\n3. **End-to-End Tests**: Test full workflows on signet/testnet\n4. **Edge Cases**: Test boundary conditions and error handling\n5. **Security Tests**: Test for common vulnerabilities\n\n### Common Pitfalls\n\n**Don't:**\n- Test with real Bitcoin (mainnet)\n- Hardcode test data that could change\n- Skip error handling tests\n- Ignore race conditions in async code\n\n**Do:**\n- Use regtest for fast iteration\n- Test both success and failure paths\n- Mock external dependencies\n- Clean up test state between runs\n\n### Test Organization\n\n```\ntests/\nâ”œâ”€â”€ unit/\nâ”‚   â”œâ”€â”€ test_transactions.py\nâ”‚   â”œâ”€â”€ test_addresses.py\nâ”‚   â””â”€â”€ test_scripts.py\nâ”œâ”€â”€ integration/\nâ”‚   â”œâ”€â”€ test_wallet.py\nâ”‚   â”œâ”€â”€ test_mempool.py\nâ”‚   â””â”€â”€ test_mining.py\nâ”œâ”€â”€ fixtures/\nâ”‚   â”œâ”€â”€ transactions.json\nâ”‚   â””â”€â”€ blocks.json\nâ””â”€â”€ conftest.py\n```",
    "filename": "testing.md"
  },
  "/docs/development/psbt": {
    "content": "# Partially Signed Bitcoin Transactions (PSBT)\n\nPSBTs (BIP-174) provide a standardized format for passing unsigned or partially signed transactions between different software and hardware. They're essential for multi-party signing, hardware wallet integration, and air-gapped setups.\n\n## What is PSBT?\n\n### The Problem PSBTs Solve\n\nBefore PSBT, passing transactions between wallets was ad-hoc:\n- Each wallet had its own format\n- Hardware wallets needed custom integrations\n- Multi-signature coordination was complex\n- No standard way to include signing metadata\n\n### PSBT Solution\n\nPSBT provides:\n- **Standardized Format**: All wallets speak the same language\n- **Metadata Inclusion**: UTXOs, scripts, derivation paths\n- **Partial Signatures**: Multiple parties can sign independently\n- **Hardware Wallet Support**: Works with air-gapped devices\n\n## PSBT Structure\n\n### Components\n\n```\nPSBT\nâ”œâ”€â”€ Global Data\nâ”‚   â”œâ”€â”€ Unsigned Transaction\nâ”‚   â””â”€â”€ Extended Public Keys (optional)\nâ”œâ”€â”€ Input Data (per input)\nâ”‚   â”œâ”€â”€ Non-Witness UTXO\nâ”‚   â”œâ”€â”€ Witness UTXO\nâ”‚   â”œâ”€â”€ Partial Signatures\nâ”‚   â”œâ”€â”€ Sighash Type\nâ”‚   â”œâ”€â”€ Redeem Script\nâ”‚   â”œâ”€â”€ Witness Script\nâ”‚   â””â”€â”€ BIP32 Derivation Paths\nâ””â”€â”€ Output Data (per output)\n    â”œâ”€â”€ Redeem Script\n    â”œâ”€â”€ Witness Script\n    â””â”€â”€ BIP32 Derivation Paths\n```\n\n### Roles in PSBT Workflow\n\n1. **Creator**: Creates the unsigned transaction\n2. **Updater**: Adds UTXO information and scripts\n3. **Signer**: Adds signatures\n4. **Combiner**: Merges multiple PSBTs\n5. **Finalizer**: Completes the transaction\n6. **Extractor**: Extracts the final transaction\n\n## Creating PSBTs\n\n### Using Bitcoin Core\n\n```bash\n# Create a PSBT\nbitcoin-cli walletcreatefundedpsbt \\\n  '[]' \\\n  '[{\"bc1q...address...\": 0.5}]' \\\n  0 \\\n  '{\"includeWatching\": true}'\n\n# Result: {\"psbt\": \"cHNidP8BAH0CAAAA...\", \"fee\": 0.00001410, \"changepos\": 1}\n```\n\n### Creating PSBTs in Code\n\n:::code-group\n```rust\nuse bitcoin::psbt::Psbt;\nuse bitcoin::{Transaction, TxIn, TxOut, OutPoint, Sequence};\n\nlet tx = Transaction {\n    version: 2,\n    lock_time: bitcoin::absolute::LockTime::ZERO,\n    input: vec![TxIn {\n        previous_output: OutPoint::new(prev_txid, 0),\n        script_sig: bitcoin::ScriptBuf::new(),\n        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n        witness: bitcoin::Witness::default(),\n    }],\n    output: vec![TxOut { value: Amount::from_sat(50000), script_pubkey: recipient_script }],\n};\nlet mut psbt = Psbt::from_unsigned_tx(tx)?;\npsbt.inputs[0].witness_utxo = Some(TxOut { value: Amount::from_sat(100000), script_pubkey: input_script });\n```\n\n```python\nfrom bitcoin.psbt import PSBT\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\n\ntx = CTransaction([CTxIn(COutPoint(prev_txid, 0))], [CTxOut(50000, recipient_script)])\npsbt = PSBT(tx)\npsbt.inputs[0].witness_utxo = CTxOut(100000, input_script)\npsbt_bytes = psbt.serialize()\n```\n\n```cpp\n// libbitcoin has limited PSBT support\n// Consider using bitcoin-cli or implementing BIP-174 manually\n// See: https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\npsbt.addInput({\n  hash: 'previous_txid_here',\n  index: 0,\n  witnessUtxo: { script: Buffer.from('0014...', 'hex'), value: 100000 },\n});\npsbt.addOutput({ address: 'bc1q...', value: 50000 });\nconst psbtBase64 = psbt.toBase64();\n```\n:::\n\n## Signing PSBTs\n\n### Single Signature\n\n```typescript\n// Using bitcoinjs-lib\nimport ECPairFactory from 'ecpair';\nimport * as ecc from 'tiny-secp256k1';\n\nconst ECPair = ECPairFactory(ecc);\n\n// Parse PSBT\nconst psbt = Psbt.fromBase64(psbtBase64);\n\n// Create key pair\nconst keyPair = ECPair.fromWIF(privateKeyWIF);\n\n// Sign input 0\npsbt.signInput(0, keyPair);\n\n// Check if fully signed\nif (psbt.validateSignaturesOfInput(0, validator)) {\n  // Finalize the input\n  psbt.finalizeInput(0);\n}\n\n// Export signed PSBT\nconst signedPsbt = psbt.toBase64();\n```\n\n### Hardware Wallet Signing\n\n```typescript\n// Example with Ledger\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport AppBtc from '@ledgerhq/hw-app-btc';\n\nasync function signWithLedger(psbtBase64: string) {\n  // Connect to Ledger\n  const transport = await TransportWebUSB.create();\n  const btc = new AppBtc({ transport });\n  \n  // Parse PSBT\n  const psbt = Psbt.fromBase64(psbtBase64);\n  \n  // Get the serialized PSBT for Ledger\n  const psbtHex = psbt.toHex();\n  \n  // Sign with Ledger (simplified)\n  // Actual implementation depends on Ledger app version\n  const signature = await btc.signMessage(\n    \"84'/0'/0'/0/0\",\n    psbtHex\n  );\n  \n  return signature;\n}\n```\n\n### Multi-Signature Signing\n\n```typescript\n// Create PSBT for 2-of-3 multisig\nconst psbt = new Psbt();\n\npsbt.addInput({\n  hash: txid,\n  index: 0,\n  witnessUtxo: {\n    script: p2wshScript,\n    value: 100000,\n  },\n  witnessScript: multisigScript, // The actual multisig script\n});\n\npsbt.addOutput({\n  address: 'bc1q...',\n  value: 50000,\n});\n\n// First signer signs\npsbt.signInput(0, keyPair1);\n\n// Export partially signed PSBT\nconst partiallySignedPsbt = psbt.toBase64();\n\n// --- Send to second signer ---\n\n// Second signer imports and signs\nconst psbt2 = Psbt.fromBase64(partiallySignedPsbt);\npsbt2.signInput(0, keyPair2);\n\n// Now we have 2-of-3 signatures, can finalize\npsbt2.finalizeInput(0);\n\n// Extract final transaction\nconst finalTx = psbt2.extractTransaction();\nconsole.log(finalTx.toHex());\n```\n\n## Combining PSBTs\n\nWhen multiple parties sign the same PSBT independently:\n\n```typescript\n// Party A signs\nconst psbtA = Psbt.fromBase64(originalPsbt);\npsbtA.signInput(0, keyPairA);\nconst signedA = psbtA.toBase64();\n\n// Party B signs (independently)\nconst psbtB = Psbt.fromBase64(originalPsbt);\npsbtB.signInput(0, keyPairB);\nconst signedB = psbtB.toBase64();\n\n// Combine the PSBTs\nconst combined = Psbt.fromBase64(signedA);\nconst psbtBParsed = Psbt.fromBase64(signedB);\n\ncombined.combine(psbtBParsed);\n\n// Now combined has both signatures\ncombined.finalizeAllInputs();\nconst finalTx = combined.extractTransaction();\n```\n\n### Using Bitcoin Core\n\n```bash\n# Combine multiple PSBTs\nbitcoin-cli combinepsbt '[\"psbt1_base64\", \"psbt2_base64\"]'\n```\n\n## Finalizing PSBTs\n\n### Manual Finalization\n\n```typescript\nconst psbt = Psbt.fromBase64(signedPsbt);\n\n// Finalize each input\nfor (let i = 0; i < psbt.inputCount; i++) {\n  try {\n    psbt.finalizeInput(i);\n  } catch (e) {\n    console.error(`Failed to finalize input ${i}:`, e);\n  }\n}\n\n// Check if all inputs are finalized\nif (psbt.data.inputs.every(input => input.finalScriptSig || input.finalScriptWitness)) {\n  const tx = psbt.extractTransaction();\n  console.log('Final transaction:', tx.toHex());\n}\n```\n\n### Custom Finalizers\n\nFor complex scripts, you may need custom finalizers:\n\n```typescript\npsbt.finalizeInput(0, (inputIndex, input, script) => {\n  // Custom finalization logic for complex scripts\n  const payment = bitcoin.payments.p2wsh({\n    redeem: {\n      input: bitcoin.script.compile([\n        input.partialSig[0].signature,\n        input.partialSig[1].signature,\n        bitcoin.opcodes.OP_TRUE, // For example, a conditional branch\n      ]),\n      output: input.witnessScript,\n    },\n  });\n  \n  return {\n    finalScriptSig: Buffer.from([]),\n    finalScriptWitness: payment.witness,\n  };\n});\n```\n\n## PSBT Workflow Examples\n\n### Air-Gapped Signing\n\n```\n1. Online Computer (Creator/Updater)\n   â””â”€â”€ Creates PSBT with all UTXO data\n   â””â”€â”€ Exports to QR code or file\n   \n2. Air-Gapped Computer (Signer)\n   â””â”€â”€ Imports PSBT\n   â””â”€â”€ Reviews transaction details\n   â””â”€â”€ Signs with private key\n   â””â”€â”€ Exports signed PSBT\n   \n3. Online Computer (Finalizer/Extractor)\n   â””â”€â”€ Imports signed PSBT\n   â””â”€â”€ Finalizes transaction\n   â””â”€â”€ Broadcasts to network\n```\n\n### CoinJoin with PSBT\n\n```typescript\n// Coordinator creates base transaction\nconst psbt = new Psbt();\n\n// Add inputs from multiple participants\nparticipants.forEach(participant => {\n  psbt.addInput({\n    hash: participant.utxo.txid,\n    index: participant.utxo.vout,\n    witnessUtxo: participant.utxo.witnessUtxo,\n    bip32Derivation: participant.derivation,\n  });\n});\n\n// Add outputs (equal amounts for anonymity)\nparticipants.forEach(participant => {\n  psbt.addOutput({\n    address: participant.outputAddress,\n    value: COINJOIN_AMOUNT,\n  });\n});\n\n// Shuffle outputs for privacy\n// ... shuffle logic ...\n\n// Distribute to participants for signing\nconst psbtBase64 = psbt.toBase64();\n\n// Each participant signs their input\n// Coordinator combines and broadcasts\n```\n\n## PSBT Version 2 (BIP-370)\n\nPSBT v2 introduces improvements for interactive protocols:\n\n### Key Differences\n\n| Feature | PSBT v0 | PSBT v2 |\n|---------|---------|---------|\n| Transaction Storage | Global | Reconstructed from fields |\n| Modifiable | No | Yes (with restrictions) |\n| Lock Time | Fixed | Per-input |\n| Use Case | Simple signing | Interactive protocols |\n\n### When to Use PSBT v2\n\n- CoinJoin protocols\n- Payjoin\n- Multi-round signing protocols\n- Interactive transaction construction\n\n## Error Handling\n\n### Common PSBT Errors\n\n```typescript\ntry {\n  const psbt = Psbt.fromBase64(psbtString);\n} catch (e) {\n  if (e.message.includes('Invalid PSBT magic')) {\n    console.error('Not a valid PSBT');\n  } else if (e.message.includes('Duplicate key')) {\n    console.error('PSBT contains duplicate data');\n  }\n}\n\n// Validation before signing\ntry {\n  psbt.signInput(0, keyPair);\n} catch (e) {\n  if (e.message.includes('No inputs found')) {\n    console.error('PSBT has no inputs');\n  } else if (e.message.includes('Need UTXO')) {\n    console.error('Missing UTXO data for input');\n  }\n}\n```\n\n### Validation Checks\n\n```typescript\nfunction validatePsbt(psbt: Psbt): boolean {\n  // Check all inputs have required data\n  for (let i = 0; i < psbt.inputCount; i++) {\n    const input = psbt.data.inputs[i];\n    \n    // Need either witness UTXO or non-witness UTXO\n    if (!input.witnessUtxo && !input.nonWitnessUtxo) {\n      console.error(`Input ${i} missing UTXO data`);\n      return false;\n    }\n    \n    // For non-SegWit, need full previous transaction\n    if (input.nonWitnessUtxo && !input.witnessUtxo) {\n      // Verify the UTXO matches the referenced output\n      const prevTx = bitcoin.Transaction.fromBuffer(input.nonWitnessUtxo);\n      const prevOut = psbt.txInputs[i];\n      if (prevTx.getId() !== prevOut.hash.reverse().toString('hex')) {\n        console.error(`Input ${i} UTXO doesn't match`);\n        return false;\n      }\n    }\n  }\n  \n  return true;\n}\n```\n\n## Best Practices\n\n### For PSBT Creators\n\n1. **Include All Metadata**: Add derivation paths, scripts, and UTXOs\n2. **Use Deterministic Inputs**: Order inputs consistently\n3. **Set Appropriate Sighash**: Default to SIGHASH_ALL\n4. **Validate Before Export**: Check PSBT is well-formed\n\n### For PSBT Signers\n\n1. **Verify Outputs**: Always review destination and amounts\n2. **Check Change Address**: Verify change goes to your wallet\n3. **Inspect Fee**: Ensure fee is reasonable\n4. **Validate Scripts**: For complex scripts, verify the spending conditions\n\n### For Hardware Wallet Integration\n\n1. **Include BIP32 Paths**: Hardware wallets need derivation info\n2. **Use Standard Paths**: Stick to BIP44/49/84/86 paths\n3. **Test on Testnet**: Always test the integration first\n4. **Handle Rejections**: User may reject on device\n\n## Summary\n\nPSBTs provide a standardized way to:\n\n- **Create** unsigned transactions with full metadata\n- **Update** with UTXO and script information\n- **Sign** with one or multiple parties\n- **Combine** signatures from different sources\n- **Finalize** and extract broadcast-ready transactions\n\nUnderstanding PSBTs is essential for modern Bitcoin development, especially when working with hardware wallets, multi-signature setups, or any multi-party transaction construction.\n",
    "filename": "psbt.md"
  },
  "/docs/development/addresses": {
    "content": "# Address Generation & Validation\n\nBitcoin addresses are human-readable encodings of output scripts. Understanding how to generate, validate, and work with different address types is fundamental to Bitcoin development.\n\n## Address Types Overview\n\n### Legacy Addresses (P2PKH)\n\n**Format**: Starts with `1` (mainnet) or `m`/`n` (testnet)\n\n```\n1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\n```\n\n**Script**: Pay-to-Public-Key-Hash\n```\nOP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG\n```\n\n### Script Hash Addresses (P2SH)\n\n**Format**: Starts with `3` (mainnet) or `2` (testnet)\n\n```\n3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\n```\n\n**Script**: Pay-to-Script-Hash (can contain any script)\n```\nOP_HASH160 <script_hash> OP_EQUAL\n```\n\n### Native SegWit (P2WPKH)\n\n**Format**: Starts with `bc1q` (mainnet) or `tb1q` (testnet)\n\n```\nbc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq\n```\n\n**Script**: Pay-to-Witness-Public-Key-Hash\n```\nOP_0 <20-byte-pubkey-hash>\n```\n\n### Native SegWit Script (P2WSH)\n\n**Format**: Starts with `bc1q` but longer (mainnet)\n\n```\nbc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\n```\n\n**Script**: Pay-to-Witness-Script-Hash\n```\nOP_0 <32-byte-script-hash>\n```\n\n### Taproot (P2TR)\n\n**Format**: Starts with `bc1p` (mainnet) or `tb1p` (testnet)\n\n```\nbc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297\n```\n\n**Script**: Pay-to-Taproot\n```\nOP_1 <32-byte-x-only-pubkey>\n```\n\n## Address Comparison\n\n| Type | Prefix | Size | Encoding | Fee Efficiency |\n|------|--------|------|----------|----------------|\n| P2PKH | 1 | 25 bytes | Base58Check | Lowest |\n| P2SH | 3 | 23 bytes | Base58Check | Low |\n| P2WPKH | bc1q | 22 bytes | Bech32 | High |\n| P2WSH | bc1q | 34 bytes | Bech32 | Medium |\n| P2TR | bc1p | 34 bytes | Bech32m | Highest |\n\n## Generating Addresses\n\n### From Public Key to P2WPKH (Native SegWit)\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network, PublicKey, CompressedPublicKey};\nuse bitcoin::secp256k1::{Secp256k1, SecretKey};\n\nfn generate_address(secret_key: &SecretKey) -> Address {\n    let secp = Secp256k1::new();\n    let public_key = PublicKey::from_private_key(&secp, &secret_key.into());\n    let compressed = CompressedPublicKey::try_from(public_key).unwrap();\n    Address::p2wpkh(&compressed, Network::Bitcoin)\n}\n```\n\n```python\nimport hashlib\nimport bech32\n\ndef pubkey_to_p2wpkh(pubkey_bytes, mainnet=True):\n    sha256_hash = hashlib.sha256(pubkey_bytes).digest()\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    pubkey_hash = ripemd160.digest()\n    \n    hrp = 'bc' if mainnet else 'tb'\n    converted = bech32.convertbits(pubkey_hash, 8, 5)\n    return bech32.bech32_encode(hrp, [0] + converted)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::wallet::payment_address generate_address(const bc::ec_secret& secret) {\n    bc::ec_compressed pubkey;\n    bc::secret_to_public(pubkey, secret);\n    return bc::wallet::payment_address(\n        bc::wallet::ec_public(pubkey), \n        bc::wallet::payment_address::mainnet_p2wpkh\n    );\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst p2wpkh = bitcoin.payments.p2wpkh({ \n  pubkey: publicKey,\n  network: bitcoin.networks.bitcoin \n});\nconsole.log(p2wpkh.address); // bc1q...\n```\n:::\n\n## Validating Addresses\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network};\nuse std::str::FromStr;\n\nfn validate_address(addr_str: &str) -> Result<String, String> {\n    match Address::from_str(addr_str) {\n        Ok(addr) => Ok(match addr.address_type() {\n            Some(bitcoin::AddressType::P2pkh) => \"P2PKH\",\n            Some(bitcoin::AddressType::P2wpkh) => \"P2WPKH\",\n            Some(bitcoin::AddressType::P2tr) => \"P2TR\",\n            _ => \"Other\",\n        }.to_string()),\n        Err(e) => Err(format!(\"Invalid: {}\", e))\n    }\n}\n```\n\n```python\nimport hashlib, base58, bech32\n\ndef validate_address(address):\n    if address.startswith('bc1') or address.startswith('tb1'):\n        hrp, data = bech32.bech32_decode(address)\n        if hrp: return True, \"P2WPKH\" if len(data) == 21 else \"P2WSH\"\n        hrp, data = bech32.bech32m_decode(address)\n        if hrp: return True, \"P2TR\"\n    else:\n        try:\n            decoded = base58.b58decode_check(address)\n            return True, \"P2PKH\" if decoded[0] == 0 else \"P2SH\"\n        except: pass\n    return False, \"Invalid\"\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbool validate_address(const std::string& address) {\n    bc::wallet::payment_address addr(address);\n    return addr.is_valid();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction validateAddress(address, network = bitcoin.networks.bitcoin) {\n  try {\n    bitcoin.address.toOutputScript(address, network);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n```\n:::\n\n## Bech32 Encoding Details\n\n### Bech32 vs Bech32m\n\n```\nBech32 (BIP-173):\n- Used for SegWit v0 (P2WPKH, P2WSH)\n- Checksum constant: 1\n\nBech32m (BIP-350):\n- Used for SegWit v1+ (Taproot)\n- Checksum constant: 0x2bc830a3\n```\n\n### Why Bech32m?\n\nBech32 had a weakness where certain error patterns could go undetected. Bech32m fixes this for future witness versions.\n\n## From Script to Address\n\n:::code-group\n```rust\nuse bitcoin::{Address, Script, Network};\n\nfn script_to_address(script: &Script) -> Option<Address> {\n    Address::from_script(script, Network::Bitcoin).ok()\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript\nfrom bitcoin.wallet import CBitcoinAddress\n\ndef script_to_address(script):\n    return str(CBitcoinAddress.from_scriptPubKey(script))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string script_to_address(const bc::chain::script& script) {\n    return bc::wallet::payment_address(script).encoded();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction scriptToAddress(script, network = bitcoin.networks.bitcoin) {\n  return bitcoin.address.fromOutputScript(script, network);\n}\n```\n:::\n\n## Address Derivation Paths\n\n### BIP Standards\n\n| BIP | Path | Address Type | Example |\n|-----|------|--------------|---------|\n| BIP44 | m/44'/0'/0' | P2PKH | 1... |\n| BIP49 | m/49'/0'/0' | P2SH-P2WPKH | 3... |\n| BIP84 | m/84'/0'/0' | P2WPKH | bc1q... |\n| BIP86 | m/86'/0'/0' | P2TR | bc1p... |\n\n### Deriving Addresses from Seed\n\n:::code-group\n```rust\nuse bdk::keys::bip39::Mnemonic;\nuse bitcoin::bip32::{Xpriv, DerivationPath};\n\nfn derive_address(mnemonic: &str) -> Address {\n    let mnemonic = Mnemonic::parse(mnemonic).unwrap();\n    let seed = mnemonic.to_seed(\"\");\n    let master = Xpriv::new_master(Network::Bitcoin, &seed).unwrap();\n    let path = DerivationPath::from_str(\"m/84'/0'/0'/0/0\").unwrap();\n    let derived = master.derive_priv(&secp, &path).unwrap();\n    // Convert to address...\n}\n```\n\n```python\nfrom mnemonic import Mnemonic\nfrom bip32utils import BIP32Key\n\ndef derive_address(words):\n    seed = Mnemonic(\"english\").to_seed(words)\n    master = BIP32Key.fromEntropy(seed)\n    # Derive m/84'/0'/0'/0/0\n    key = master.ChildKey(84 + 0x80000000).ChildKey(0x80000000).ChildKey(0x80000000).ChildKey(0).ChildKey(0)\n    return key.Address()\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string derive_address(const std::string& mnemonic) {\n    auto seed = bc::wallet::decode_mnemonic(bc::split(mnemonic));\n    bc::wallet::hd_private master(seed);\n    auto derived = master.derive_private(84 + bc::wallet::hd_first_hardened_key)\n                        .derive_private(bc::wallet::hd_first_hardened_key)\n                        .derive_private(bc::wallet::hd_first_hardened_key)\n                        .derive_private(0).derive_private(0);\n    return bc::wallet::payment_address(derived).encoded();\n}\n```\n\n```javascript\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nasync function deriveAddress(mnemonic) {\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const root = bip32.fromSeed(seed);\n  const child = root.derivePath(\"m/84'/0'/0'/0/0\");\n  return bitcoin.payments.p2wpkh({ pubkey: child.publicKey }).address;\n}\n```\n:::\n\n## Multi-Signature Addresses\n\n### Creating 2-of-3 Multisig\n\n:::code-group\n```rust\nuse bitcoin::{PublicKey, Script, Address};\nuse bitcoin::blockdata::script::Builder;\n\nfn create_multisig(m: usize, pubkeys: &[PublicKey]) -> Address {\n    let script = Builder::new()\n        .push_int(m as i64)\n        .push_keys(pubkeys)\n        .push_int(pubkeys.len() as i64)\n        .push_opcode(opcodes::all::OP_CHECKMULTISIG)\n        .into_script();\n    Address::p2wsh(&script, Network::Bitcoin)\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_2, OP_3, OP_CHECKMULTISIG\nfrom bitcoin.wallet import P2SHBitcoinAddress\n\ndef create_multisig(m, pubkeys):\n    script = CScript([m] + pubkeys + [len(pubkeys), OP_CHECKMULTISIG])\n    return str(P2SHBitcoinAddress.from_redeemScript(script))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string create_multisig(uint8_t m, const std::vector<bc::ec_compressed>& pubkeys) {\n    bc::chain::script script = bc::chain::script::to_pay_multisig_pattern(m, pubkeys);\n    return bc::wallet::payment_address(script).encoded();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction createMultisig(m, pubkeys) {\n  const multisig = bitcoin.payments.p2ms({ m, pubkeys });\n  const p2wsh = bitcoin.payments.p2wsh({ redeem: multisig });\n  return p2wsh.address; // bc1q... (P2WSH)\n}\n```\n:::\n\n## Common Mistakes\n\n### Address Validation Pitfalls\n\n- **BAD**: Only checking prefix (`address.startsWith('bc1')`)\n- **GOOD**: Full validation with checksum verification using library functions\n\n### Network Mismatch\n\nAlways use consistent network parameters. Never mix mainnet keys with testnet addresses.\n\n### Checksum Errors\n\nAlways validate checksums before using an address - all libraries provide validation functions.\n\n## Best Practices\n\n### Address Generation\n\n1. **Use Established Libraries**: Don't implement encoding yourself\n2. **Validate After Generation**: Always verify the generated address\n3. **Use Appropriate Types**: Prefer SegWit/Taproot for lower fees\n4. **Test on Testnet**: Verify address generation works correctly\n\n### Address Handling\n\n1. **Case Sensitivity**: Bech32 is case-insensitive, Base58 is case-sensitive\n2. **Display Formatting**: Consider QR codes for long addresses\n3. **Copy Protection**: Use checksums to detect copy errors\n4. **Network Verification**: Always verify mainnet vs testnet\n\n### Security\n\n1. **Never Reuse Addresses**: Generate new addresses for each transaction\n2. **Verify Derivation Paths**: Ensure consistent paths across wallet imports\n3. **Backup Seeds**: Addresses can be regenerated from seeds\n\n## Summary\n\nUnderstanding Bitcoin addresses requires knowledge of:\n\n- **Encoding Schemes**: Base58Check, Bech32, Bech32m\n- **Script Types**: P2PKH, P2SH, P2WPKH, P2WSH, P2TR\n- **Derivation**: BIP32/39/44/49/84/86 standards\n- **Validation**: Checksum verification and format checking\n\nModern applications should default to Bech32m (Taproot) addresses for the best fee efficiency and privacy features.\n",
    "filename": "addresses.md"
  },
  "/docs/development/transactions": {
    "content": "# Transaction Construction\n\nBuilding Bitcoin transactions from scratch requires understanding inputs, outputs, fees, and signing. This guide covers the complete process from UTXO selection to broadcasting.\n\n## Transaction Structure\n\n### Components\n\n```\nTransaction\nâ”œâ”€â”€ Version (4 bytes)\nâ”œâ”€â”€ Marker & Flag (SegWit only, 2 bytes)\nâ”œâ”€â”€ Input Count (varint)\nâ”œâ”€â”€ Inputs\nâ”‚   â”œâ”€â”€ Previous TXID (32 bytes)\nâ”‚   â”œâ”€â”€ Output Index (4 bytes)\nâ”‚   â”œâ”€â”€ Script Length (varint)\nâ”‚   â”œâ”€â”€ ScriptSig (variable)\nâ”‚   â””â”€â”€ Sequence (4 bytes)\nâ”œâ”€â”€ Output Count (varint)\nâ”œâ”€â”€ Outputs\nâ”‚   â”œâ”€â”€ Value (8 bytes)\nâ”‚   â”œâ”€â”€ Script Length (varint)\nâ”‚   â””â”€â”€ ScriptPubKey (variable)\nâ”œâ”€â”€ Witness (SegWit only)\nâ”‚   â””â”€â”€ Witness data per input\nâ””â”€â”€ Locktime (4 bytes)\n```\n\n### Size Calculations\n\nVirtual size (vbytes) = (base_size Ã— 3 + total_size) / 4\n\n## Building Transactions\n\n:::code-group\n```rust\nuse bitcoin::{Transaction, TxIn, TxOut, OutPoint, Sequence, Amount, ScriptBuf};\nuse bitcoin::absolute::LockTime;\n\nfn create_transaction(prev_txid: Txid, recipient: ScriptBuf, change: ScriptBuf) -> Transaction {\n    Transaction {\n        version: 2,\n        lock_time: LockTime::ZERO,\n        input: vec![TxIn {\n            previous_output: OutPoint::new(prev_txid, 0),\n            script_sig: ScriptBuf::new(),\n            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n            witness: bitcoin::Witness::default(),\n        }],\n        output: vec![\n            TxOut { value: Amount::from_sat(50000), script_pubkey: recipient },\n            TxOut { value: Amount::from_sat(49000), script_pubkey: change },\n        ],\n    }\n}\n```\n\n```python\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\n\ndef create_transaction(prev_txid, recipient_script, change_script):\n    outpoint = COutPoint(bytes.fromhex(prev_txid)[::-1], 0)\n    txin = CTxIn(outpoint)\n    txout = CTxOut(50000, recipient_script)\n    change = CTxOut(49000, change_script)\n    return CTransaction([txin], [txout, change])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::chain::transaction create_transaction(const bc::hash_digest& prev_txid,\n                                          const bc::chain::script& recipient,\n                                          const bc::chain::script& change) {\n    bc::chain::input input;\n    input.set_previous_output({prev_txid, 0});\n    input.set_sequence(0xfffffffd); // RBF enabled\n    \n    bc::chain::transaction tx;\n    tx.set_version(2);\n    tx.inputs().push_back(input);\n    tx.outputs().push_back({50000, recipient});\n    tx.outputs().push_back({49000, change});\n    return tx;\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction createTransaction(prevTxid, recipientAddr, changeAddr) {\n  const psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\n  \n  psbt.addInput({\n    hash: prevTxid,\n    index: 0,\n    witnessUtxo: { script: Buffer.from('0014...', 'hex'), value: 100000 },\n  });\n  \n  psbt.addOutput({ address: recipientAddr, value: 50000 });\n  psbt.addOutput({ address: changeAddr, value: 49000 });\n  \n  // Sign and finalize...\n  return psbt;\n}\n```\n:::\n\n## Input Selection\n\n### Coin Selection Algorithms\n\n#### Largest First\n\n```typescript\nfunction largestFirst(utxos: UTXO[], target: number): UTXO[] {\n  // Sort by value descending\n  const sorted = [...utxos].sort((a, b) => b.value - a.value);\n  \n  const selected: UTXO[] = [];\n  let total = 0;\n  \n  for (const utxo of sorted) {\n    selected.push(utxo);\n    total += utxo.value;\n    if (total >= target) break;\n  }\n  \n  return total >= target ? selected : [];\n}\n```\n\n#### Branch and Bound (Exact Match)\n\n```typescript\nfunction branchAndBound(utxos: UTXO[], target: number, maxTries = 100000): UTXO[] | null {\n  let tries = 0;\n  let bestSelection: UTXO[] | null = null;\n  let bestWaste = Infinity;\n  \n  function search(index: number, selected: UTXO[], total: number): void {\n    if (tries++ > maxTries) return;\n    \n    // Found exact match\n    if (total === target) {\n      bestSelection = [...selected];\n      bestWaste = 0;\n      return;\n    }\n    \n    // Over target, calculate waste\n    if (total > target) {\n      const waste = total - target;\n      if (waste < bestWaste) {\n        bestSelection = [...selected];\n        bestWaste = waste;\n      }\n      return;\n    }\n    \n    // Try including next UTXO\n    if (index < utxos.length) {\n      // Include\n      selected.push(utxos[index]);\n      search(index + 1, selected, total + utxos[index].value);\n      selected.pop();\n      \n      // Exclude\n      search(index + 1, selected, total);\n    }\n  }\n  \n  search(0, [], 0);\n  return bestSelection;\n}\n```\n\n#### Knapsack\n\n```typescript\nfunction knapsack(utxos: UTXO[], target: number): UTXO[] {\n  const n = utxos.length;\n  const dp: boolean[][] = Array(n + 1).fill(null)\n    .map(() => Array(target + 1).fill(false));\n  \n  // Base case: sum of 0 is always achievable\n  for (let i = 0; i <= n; i++) dp[i][0] = true;\n  \n  // Fill the table\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= target; j++) {\n      dp[i][j] = dp[i - 1][j]; // Don't include\n      if (j >= utxos[i - 1].value) {\n        dp[i][j] = dp[i][j] || dp[i - 1][j - utxos[i - 1].value];\n      }\n    }\n  }\n  \n  // Backtrack to find solution\n  if (!dp[n][target]) return largestFirst(utxos, target); // Fallback\n  \n  const selected: UTXO[] = [];\n  let remaining = target;\n  for (let i = n; i > 0 && remaining > 0; i--) {\n    if (!dp[i - 1][remaining]) {\n      selected.push(utxos[i - 1]);\n      remaining -= utxos[i - 1].value;\n    }\n  }\n  \n  return selected;\n}\n```\n\n## Fee Estimation\n\n### Fee Rate Sources\n\n```typescript\nasync function getFeeRate(): Promise<number> {\n  // Option 1: mempool.space API\n  const response = await fetch('https://mempool.space/api/v1/fees/recommended');\n  const fees = await response.json();\n  \n  return {\n    fast: fees.fastestFee,      // Next block\n    medium: fees.halfHourFee,   // ~30 min\n    slow: fees.hourFee,         // ~1 hour\n    economy: fees.economyFee,   // Low priority\n  };\n}\n\n// Option 2: Bitcoin Core RPC\nasync function getFeeRateFromNode(rpc: BitcoinRPC, blocks: number): Promise<number> {\n  const result = await rpc.call('estimatesmartfee', [blocks]);\n  if (result.feerate) {\n    // Convert BTC/kB to sat/vB\n    return Math.ceil(result.feerate * 100000);\n  }\n  throw new Error('Fee estimation failed');\n}\n```\n\n### Calculating Transaction Fee\n\n```typescript\ninterface TransactionSizes {\n  P2PKH_INPUT: 148,\n  P2WPKH_INPUT: 68,\n  P2TR_INPUT: 57.5,\n  P2PKH_OUTPUT: 34,\n  P2WPKH_OUTPUT: 31,\n  P2TR_OUTPUT: 43,\n  OVERHEAD: 10.5,\n}\n\nfunction estimateFee(\n  inputs: { type: string }[],\n  outputs: { type: string }[],\n  feeRate: number\n): number {\n  let vSize = TransactionSizes.OVERHEAD;\n  \n  for (const input of inputs) {\n    switch (input.type) {\n      case 'P2PKH': vSize += TransactionSizes.P2PKH_INPUT; break;\n      case 'P2WPKH': vSize += TransactionSizes.P2WPKH_INPUT; break;\n      case 'P2TR': vSize += TransactionSizes.P2TR_INPUT; break;\n    }\n  }\n  \n  for (const output of outputs) {\n    switch (output.type) {\n      case 'P2PKH': vSize += TransactionSizes.P2PKH_OUTPUT; break;\n      case 'P2WPKH': vSize += TransactionSizes.P2WPKH_OUTPUT; break;\n      case 'P2TR': vSize += TransactionSizes.P2TR_OUTPUT; break;\n    }\n  }\n  \n  return Math.ceil(vSize * feeRate);\n}\n```\n\n## Replace-By-Fee (RBF)\n\n### Enabling RBF\n\n```typescript\nfunction createRBFTransaction(psbt: Psbt) {\n  // Set sequence to enable RBF (< 0xFFFFFFFE)\n  psbt.setInputSequence(0, 0xFFFFFFFD);\n  \n  // Alternative: Use the constant\n  psbt.setInputSequence(0, bitcoin.Transaction.DEFAULT_SEQUENCE - 2);\n}\n```\n\n### Creating Replacement Transaction\n\n```typescript\nfunction bumpFee(originalTx: Transaction, newFeeRate: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Copy inputs from original transaction\n  for (const input of originalTx.ins) {\n    psbt.addInput({\n      hash: input.hash,\n      index: input.index,\n      sequence: 0xFFFFFFFD, // RBF enabled\n      // Add witness UTXO data...\n    });\n  }\n  \n  // Recalculate outputs with higher fee\n  const originalFee = calculateFee(originalTx);\n  const newVSize = originalTx.virtualSize();\n  const newFee = newVSize * newFeeRate;\n  const additionalFee = newFee - originalFee;\n  \n  // Reduce change output by additional fee\n  for (let i = 0; i < originalTx.outs.length; i++) {\n    const output = originalTx.outs[i];\n    if (isChangeOutput(output)) {\n      psbt.addOutput({\n        script: output.script,\n        value: output.value - additionalFee,\n      });\n    } else {\n      psbt.addOutput({\n        script: output.script,\n        value: output.value,\n      });\n    }\n  }\n  \n  return psbt;\n}\n```\n\n## Child-Pays-For-Parent (CPFP)\n\n### Creating CPFP Transaction\n\n```typescript\nfunction createCPFPTransaction(\n  stuckTx: Transaction,\n  stuckTxFee: number,\n  targetFeeRate: number\n): Psbt {\n  // Find our output in the stuck transaction\n  const ourOutput = findOurOutput(stuckTx);\n  \n  // Calculate required fee for both transactions\n  const stuckTxVSize = stuckTx.virtualSize();\n  const childVSize = 110; // Estimate for simple spend\n  const totalVSize = stuckTxVSize + childVSize;\n  const totalFeeNeeded = totalVSize * targetFeeRate;\n  const childFee = totalFeeNeeded - stuckTxFee;\n  \n  // Create child transaction\n  const psbt = new bitcoin.Psbt();\n  \n  psbt.addInput({\n    hash: stuckTx.getId(),\n    index: ourOutput.index,\n    witnessUtxo: {\n      script: ourOutput.script,\n      value: ourOutput.value,\n    },\n  });\n  \n  psbt.addOutput({\n    address: newAddress,\n    value: ourOutput.value - childFee,\n  });\n  \n  return psbt;\n}\n```\n\n## Transaction Batching\n\n### Batch Multiple Payments\n\n```typescript\ninterface Payment {\n  address: string;\n  amount: number;\n}\n\nfunction createBatchTransaction(\n  utxos: UTXO[],\n  payments: Payment[],\n  feeRate: number,\n  changeAddress: string\n): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Calculate total needed\n  const totalPayments = payments.reduce((sum, p) => sum + p.amount, 0);\n  \n  // Select inputs\n  const estimatedFee = estimateBatchFee(utxos.length, payments.length + 1, feeRate);\n  const target = totalPayments + estimatedFee;\n  const selectedUtxos = selectCoins(utxos, target);\n  \n  // Add inputs\n  let totalInput = 0;\n  for (const utxo of selectedUtxos) {\n    psbt.addInput({\n      hash: utxo.txid,\n      index: utxo.vout,\n      witnessUtxo: {\n        script: utxo.script,\n        value: utxo.value,\n      },\n    });\n    totalInput += utxo.value;\n  }\n  \n  // Add payment outputs\n  for (const payment of payments) {\n    psbt.addOutput({\n      address: payment.address,\n      value: payment.amount,\n    });\n  }\n  \n  // Add change output\n  const actualFee = estimateBatchFee(selectedUtxos.length, payments.length + 1, feeRate);\n  const change = totalInput - totalPayments - actualFee;\n  \n  if (change > 546) {\n    psbt.addOutput({\n      address: changeAddress,\n      value: change,\n    });\n  }\n  \n  return psbt;\n}\n```\n\n### Benefits of Batching\n\n```\nSingle transaction to 10 recipients:\n- 1 input, 11 outputs (including change)\n- ~380 vbytes\n- 1 fee payment\n\n10 separate transactions:\n- 10 inputs, 20 outputs total\n- ~1,100 vbytes total\n- 10 fee payments\n```\n\n## Time Locks\n\n### Absolute Time Lock (nLockTime)\n\n```typescript\nfunction createTimeLocked(lockTime: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Set locktime (block height or Unix timestamp)\n  psbt.setLocktime(lockTime);\n  \n  // Must set sequence < 0xFFFFFFFF to enable locktime\n  psbt.addInput({\n    hash: utxo.txid,\n    index: utxo.vout,\n    sequence: 0xFFFFFFFE,\n    witnessUtxo: {\n      script: utxo.script,\n      value: utxo.value,\n    },\n  });\n  \n  psbt.addOutput({\n    address: recipient,\n    value: amount,\n  });\n  \n  return psbt;\n}\n\n// Lock until specific block\ncreateTimeLocked(850000); // Block 850,000\n\n// Lock until specific time (Unix timestamp > 500,000,000)\ncreateTimeLocked(1735689600); // Jan 1, 2025\n```\n\n### Relative Time Lock (CSV)\n\n```typescript\nfunction createCSVLocked(blocks: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Set sequence for relative timelock\n  // Blocks: blocks (up to 65535)\n  // Time: blocks | 0x00400000 (in 512-second units)\n  psbt.addInput({\n    hash: utxo.txid,\n    index: utxo.vout,\n    sequence: blocks, // e.g., 144 for ~1 day\n    witnessUtxo: {\n      script: utxo.script,\n      value: utxo.value,\n    },\n  });\n  \n  return psbt;\n}\n```\n\n## Broadcasting Transactions\n\n:::code-group\n```rust\nuse reqwest;\n\nasync fn broadcast_transaction(tx_hex: &str) -> Result<String, Box<dyn std::error::Error>> {\n    let response = reqwest::Client::new()\n        .post(\"https://mempool.space/api/tx\")\n        .body(tx_hex.to_string())\n        .send().await?;\n    Ok(response.text().await?)\n}\n```\n\n```python\nimport requests\n\ndef broadcast_transaction(tx_hex):\n    response = requests.post('https://mempool.space/api/tx', data=tx_hex)\n    if response.status_code != 200:\n        raise Exception(f\"Broadcast failed: {response.text}\")\n    return response.text  # Returns txid\n```\n\n```cpp\n#include <curl/curl.h>\n\nstd::string broadcast_transaction(const std::string& tx_hex) {\n    CURL* curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://mempool.space/api/tx\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, tx_hex.c_str());\n    // ... handle response\n    curl_easy_cleanup(curl);\n    return txid;\n}\n```\n\n```javascript\nasync function broadcastTransaction(txHex) {\n  const response = await fetch('https://mempool.space/api/tx', {\n    method: 'POST',\n    body: txHex,\n  });\n  if (!response.ok) throw new Error(await response.text());\n  return await response.text(); // Returns txid\n}\n```\n:::\n\n## Error Handling\n\n### Common Errors\n\n```typescript\nasync function safebroadcast(txHex: string): Promise<string> {\n  try {\n    return await broadcastTransaction(txHex);\n  } catch (error) {\n    const message = error.message.toLowerCase();\n    \n    if (message.includes('insufficient fee')) {\n      throw new Error('Fee too low. Increase fee rate and retry.');\n    }\n    if (message.includes('dust')) {\n      throw new Error('Output amount too small (below dust limit).');\n    }\n    if (message.includes('missing inputs') || message.includes('bad-txns-inputs-missingorspent')) {\n      throw new Error('Input already spent or does not exist.');\n    }\n    if (message.includes('txn-mempool-conflict')) {\n      throw new Error('Conflicting transaction in mempool. May need RBF.');\n    }\n    if (message.includes('non-final')) {\n      throw new Error('Transaction timelock not yet satisfied.');\n    }\n    \n    throw error;\n  }\n}\n```\n\n## Best Practices\n\n### Transaction Construction\n\n1. **Validate All Inputs**: Verify UTXOs exist and are unspent\n2. **Calculate Fees Carefully**: Use appropriate fee rate for urgency\n3. **Handle Dust**: Don't create outputs below dust limit (~546 sats)\n4. **Use RBF**: Enable RBF for flexibility (unless specific reason not to)\n5. **Verify Before Signing**: Double-check amounts and addresses\n\n### Security\n\n1. **Test on Testnet**: Always test transaction logic on testnet first\n2. **Validate Addresses**: Verify recipient addresses are valid\n3. **Check Change Amounts**: Ensure change is calculated correctly\n4. **Review Before Broadcast**: Final review of all transaction details\n\n### Optimization\n\n1. **Batch When Possible**: Combine multiple payments into one transaction\n2. **Use SegWit/Taproot**: Lower fees for SegWit and Taproot inputs/outputs\n3. **Consolidate UTXOs**: During low-fee periods, consolidate small UTXOs\n4. **Avoid Unnecessary Outputs**: Minimize output count when possible\n\n## Summary\n\nTransaction construction involves:\n\n- **Building**: Creating inputs, outputs, and metadata\n- **Coin Selection**: Choosing optimal UTXOs to spend\n- **Fee Estimation**: Calculating appropriate fees\n- **Signing**: Adding valid signatures\n- **Broadcasting**: Submitting to the network\n\nUnderstanding these fundamentals enables building robust Bitcoin applications that handle funds safely and efficiently.\n",
    "filename": "transactions.md"
  },
  "/docs/development/keys": {
    "content": "# Key Management & Security\n\nSecure key management is the foundation of Bitcoin security. This guide covers HD wallets, seed phrases, derivation paths, and best practices for handling private keys.\n\n## HD Wallets (BIP32)\n\n### What is an HD Wallet?\n\nHierarchical Deterministic (HD) wallets generate an entire tree of keys from a single seed. This enables:\n\n- **Backup Simplicity**: One seed backs up all keys\n- **Key Organization**: Structured derivation paths\n- **Privacy**: Fresh addresses without new backups\n- **Watch-Only Wallets**: Share xpubs without exposing keys\n\n### Key Derivation\n\n```\nMaster Seed\n    â””â”€â”€ Master Key (m)\n        â”œâ”€â”€ Account 0 (m/44'/0'/0')\n        â”‚   â”œâ”€â”€ External Chain (m/44'/0'/0'/0)\n        â”‚   â”‚   â”œâ”€â”€ Address 0 (m/44'/0'/0'/0/0)\n        â”‚   â”‚   â”œâ”€â”€ Address 1 (m/44'/0'/0'/0/1)\n        â”‚   â”‚   â””â”€â”€ ...\n        â”‚   â””â”€â”€ Internal Chain (m/44'/0'/0'/1)\n        â”‚       â”œâ”€â”€ Change 0 (m/44'/0'/0'/1/0)\n        â”‚       â””â”€â”€ ...\n        â””â”€â”€ Account 1 (m/44'/0'/1')\n            â””â”€â”€ ...\n```\n\n### HD Wallet Implementation\n\n:::code-group\n```rust\nuse bitcoin::bip32::{Xpriv, DerivationPath};\nuse bitcoin::secp256k1::Secp256k1;\n\nfn derive_key(seed: &[u8]) -> Xpriv {\n    let secp = Secp256k1::new();\n    let master = Xpriv::new_master(bitcoin::Network::Bitcoin, seed).unwrap();\n    let path = DerivationPath::from_str(\"m/84'/0'/0'/0/0\").unwrap();\n    master.derive_priv(&secp, &path).unwrap()\n}\n```\n\n```python\nfrom mnemonic import Mnemonic\nfrom bip32utils import BIP32Key\n\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)\nseed = mnemo.to_seed(words)\nmaster = BIP32Key.fromEntropy(seed)\n# Derive m/84'/0'/0'/0/0\nkey = master.ChildKey(84 + 0x80000000).ChildKey(0x80000000).ChildKey(0x80000000).ChildKey(0).ChildKey(0)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::wallet::hd_private derive_key(const bc::data_chunk& seed) {\n    bc::wallet::hd_private master(seed);\n    return master.derive_private(84 + bc::wallet::hd_first_hardened_key)\n                 .derive_private(bc::wallet::hd_first_hardened_key)\n                 .derive_private(bc::wallet::hd_first_hardened_key)\n                 .derive_private(0).derive_private(0);\n}\n```\n\n```javascript\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nconst mnemonic = bip39.generateMnemonic(256);\nconst seed = await bip39.mnemonicToSeed(mnemonic);\nconst root = bip32.fromSeed(seed);\nconst child = root.derivePath(\"m/84'/0'/0'/0/0\");\n```\n:::\n\n## Seed Phrases (BIP39)\n\n### Mnemonic Generation and Validation\n\n:::code-group\n```rust\nuse bip39::{Mnemonic, Language};\n\nlet mnemonic = Mnemonic::generate_in(Language::English, 24);\nlet is_valid = Mnemonic::parse(&mnemonic.to_string()).is_ok();\nlet seed = mnemonic.to_seed(\"optional_passphrase\");\n```\n\n```python\nfrom mnemonic import Mnemonic\n\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)  # 24 words\nis_valid = mnemo.check(words)\nseed = mnemo.to_seed(words, passphrase=\"optional\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nauto entropy = bc::data_chunk(32);\nbc::pseudo_random_fill(entropy);\nauto words = bc::wallet::create_mnemonic(entropy);\nbool is_valid = bc::wallet::validate_mnemonic(words);\nauto seed = bc::wallet::decode_mnemonic(words);\n```\n\n```javascript\nimport * as bip39 from 'bip39';\n\nconst mnemonic = bip39.generateMnemonic(256);\nconst isValid = bip39.validateMnemonic(mnemonic);\nconst seed = await bip39.mnemonicToSeed(mnemonic, 'optional_passphrase');\n```\n:::\n\n### Security Considerations\n\n```typescript\n// NEVER do this\nconst badMnemonic = \"abandon \".repeat(12).trim(); // Predictable!\n\n// ALWAYS use cryptographically secure random\nimport { randomBytes } from 'crypto';\nconst entropy = randomBytes(32); // 256 bits\nconst secureMnemonic = bip39.entropyToMnemonic(entropy);\n```\n\n## Derivation Paths\n\n### Standard Paths (BIPs)\n\n| BIP | Path | Purpose | Address Type |\n|-----|------|---------|--------------|\n| BIP44 | m/44'/0'/0' | Legacy | P2PKH (1...) |\n| BIP49 | m/49'/0'/0' | Nested SegWit | P2SH-P2WPKH (3...) |\n| BIP84 | m/84'/0'/0' | Native SegWit | P2WPKH (bc1q...) |\n| BIP86 | m/86'/0'/0' | Taproot | P2TR (bc1p...) |\n\n### Path Components\n\n```\nm / purpose' / coin_type' / account' / change / address_index\n\nm           - Master key\npurpose'    - BIP number (44, 49, 84, 86)\ncoin_type'  - 0 for Bitcoin, 1 for testnet\naccount'    - Account number (0, 1, 2...)\nchange      - 0 for receiving, 1 for change\naddress_index - Sequential index (0, 1, 2...)\n\n' = hardened derivation\n```\n\n### Deriving Multiple Address Types\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction deriveAllAddressTypes(root: BIP32Interface) {\n  const network = bitcoin.networks.bitcoin;\n  \n  // BIP44 - Legacy\n  const bip44 = root.derivePath(\"m/44'/0'/0'/0/0\");\n  const p2pkh = bitcoin.payments.p2pkh({ \n    pubkey: bip44.publicKey, \n    network \n  });\n  \n  // BIP49 - Nested SegWit\n  const bip49 = root.derivePath(\"m/49'/0'/0'/0/0\");\n  const p2shp2wpkh = bitcoin.payments.p2sh({\n    redeem: bitcoin.payments.p2wpkh({ \n      pubkey: bip49.publicKey, \n      network \n    }),\n    network\n  });\n  \n  // BIP84 - Native SegWit\n  const bip84 = root.derivePath(\"m/84'/0'/0'/0/0\");\n  const p2wpkh = bitcoin.payments.p2wpkh({ \n    pubkey: bip84.publicKey, \n    network \n  });\n  \n  // BIP86 - Taproot\n  const bip86 = root.derivePath(\"m/86'/0'/0'/0/0\");\n  const p2tr = bitcoin.payments.p2tr({\n    internalPubkey: bip86.publicKey.slice(1, 33),\n    network\n  });\n  \n  return {\n    legacy: p2pkh.address,\n    nestedSegwit: p2shp2wpkh.address,\n    nativeSegwit: p2wpkh.address,\n    taproot: p2tr.address\n  };\n}\n```\n\n## Extended Keys (xpub/xprv)\n\n### Exporting Extended Keys\n\n```typescript\n// Export extended private key (KEEP SECRET!)\nconst xprv = root.toBase58();\n// xprv9s21ZrQH143K...\n\n// Export extended public key (safe to share for watch-only)\nconst xpub = root.neutered().toBase58();\n// xpub661MyMwAqRbc...\n```\n\n### Version Bytes\n\n| Prefix | Network | Key Type | Address Type |\n|--------|---------|----------|--------------|\n| xpub/xprv | Mainnet | Standard | P2PKH |\n| ypub/yprv | Mainnet | BIP49 | P2SH-P2WPKH |\n| zpub/zprv | Mainnet | BIP84 | P2WPKH |\n| tpub/tprv | Testnet | Standard | Any |\n\n### Converting Between Formats\n\n```typescript\nimport bs58check from 'bs58check';\n\nfunction convertXpubToZpub(xpub: string): string {\n  const data = bs58check.decode(xpub);\n  // Replace version bytes (first 4 bytes)\n  // xpub: 0x0488B21E -> zpub: 0x04B24746\n  const zpubVersion = Buffer.from([0x04, 0xB2, 0x47, 0x46]);\n  const converted = Buffer.concat([zpubVersion, data.slice(4)]);\n  return bs58check.encode(converted);\n}\n```\n\n## Secure Key Storage\n\n### In-Memory Security\n\n```typescript\nimport { randomBytes } from 'crypto';\n\nclass SecureKeyStore {\n  private encryptedKey: Buffer | null = null;\n  private iv: Buffer | null = null;\n  \n  async store(privateKey: Buffer, password: string): Promise<void> {\n    const crypto = await import('crypto');\n    \n    // Derive encryption key from password\n    const salt = randomBytes(16);\n    const key = crypto.scryptSync(password, salt, 32);\n    \n    // Encrypt private key\n    this.iv = randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, this.iv);\n    \n    this.encryptedKey = Buffer.concat([\n      salt,\n      cipher.update(privateKey),\n      cipher.final(),\n      cipher.getAuthTag()\n    ]);\n    \n    // Clear original from memory\n    privateKey.fill(0);\n  }\n  \n  async retrieve(password: string): Promise<Buffer> {\n    if (!this.encryptedKey || !this.iv) {\n      throw new Error('No key stored');\n    }\n    \n    const crypto = await import('crypto');\n    const salt = this.encryptedKey.slice(0, 16);\n    const key = crypto.scryptSync(password, salt, 32);\n    \n    const authTag = this.encryptedKey.slice(-16);\n    const encrypted = this.encryptedKey.slice(16, -16);\n    \n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, this.iv);\n    decipher.setAuthTag(authTag);\n    \n    return Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final()\n    ]);\n  }\n  \n  clear(): void {\n    if (this.encryptedKey) {\n      this.encryptedKey.fill(0);\n      this.encryptedKey = null;\n    }\n    if (this.iv) {\n      this.iv.fill(0);\n      this.iv = null;\n    }\n  }\n}\n```\n\n### Hardware Wallet Integration\n\n```typescript\n// Example: Ledger integration concept\ninterface HardwareWallet {\n  getPublicKey(path: string): Promise<Buffer>;\n  signTransaction(path: string, txHash: Buffer): Promise<Buffer>;\n}\n\nclass LedgerWallet implements HardwareWallet {\n  async getPublicKey(path: string): Promise<Buffer> {\n    // Connect to Ledger and get public key\n    // Private key never leaves device\n    const transport = await TransportWebUSB.create();\n    const btc = new AppBtc({ transport });\n    const result = await btc.getWalletPublicKey(path);\n    return Buffer.from(result.publicKey, 'hex');\n  }\n  \n  async signTransaction(path: string, txHash: Buffer): Promise<Buffer> {\n    // Sign on device - private key stays secure\n    const transport = await TransportWebUSB.create();\n    const btc = new AppBtc({ transport });\n    // ... signing logic\n    return signature;\n  }\n}\n```\n\n## Multi-Signature Setup\n\n### Creating Multisig Wallet\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\n\ninterface MultisigConfig {\n  m: number;  // Required signatures\n  n: number;  // Total keys\n  pubkeys: Buffer[];\n}\n\nfunction createMultisigWallet(config: MultisigConfig) {\n  const { m, pubkeys } = config;\n  \n  // Sort pubkeys (BIP67)\n  const sortedPubkeys = [...pubkeys].sort((a, b) => a.compare(b));\n  \n  // Create P2WSH multisig\n  const multisig = bitcoin.payments.p2ms({\n    m: m,\n    pubkeys: sortedPubkeys,\n  });\n  \n  const p2wsh = bitcoin.payments.p2wsh({\n    redeem: multisig,\n  });\n  \n  return {\n    address: p2wsh.address,\n    redeemScript: multisig.output,\n    witnessScript: p2wsh.redeem?.output,\n  };\n}\n\n// Example: 2-of-3 multisig\nconst wallet = createMultisigWallet({\n  m: 2,\n  n: 3,\n  pubkeys: [pubkey1, pubkey2, pubkey3],\n});\n```\n\n### Multisig Key Distribution\n\n```\nRecommended 2-of-3 Setup:\n\nKey 1: Personal device (phone/computer)\nKey 2: Hardware wallet (Coldcard, Ledger, etc.)\nKey 3: Secure backup (safety deposit box, trusted party)\n\nBenefits:\n- Lose one key? Still have access\n- One key compromised? Funds still safe\n- No single point of failure\n```\n\n## Backup Strategies\n\n### Seed Phrase Backup\n\n```\nDO:\nâœ“ Write on paper/metal (fire/water resistant)\nâœ“ Store in multiple secure locations\nâœ“ Consider splitting (e.g., 2-of-3 Shamir)\nâœ“ Test recovery before storing funds\n\nDON'T:\nâœ— Store digitally (photos, cloud, email)\nâœ— Share with anyone\nâœ— Store all copies in one location\nâœ— Use brain wallet (memorized passphrase only)\n```\n\n### Shamir's Secret Sharing\n\n```typescript\nimport * as secrets from 'secrets.js-grempe';\n\nfunction splitSeed(seed: string, shares: number, threshold: number): string[] {\n  // Convert seed to hex\n  const seedHex = Buffer.from(seed).toString('hex');\n  \n  // Split into shares\n  const shareArray = secrets.share(seedHex, shares, threshold);\n  \n  return shareArray;\n}\n\nfunction recoverSeed(shares: string[]): string {\n  // Combine shares\n  const seedHex = secrets.combine(shares);\n  \n  return Buffer.from(seedHex, 'hex').toString();\n}\n\n// Example: 2-of-3 split\nconst shares = splitSeed(mnemonic, 3, 2);\n// Give shares[0] to location A\n// Give shares[1] to location B  \n// Give shares[2] to location C\n// Any 2 shares can recover the seed\n```\n\n## Security Best Practices\n\n### Key Generation\n\n```typescript\n// SECURE: Use crypto.getRandomValues or crypto.randomBytes\nimport { randomBytes } from 'crypto';\nconst entropy = randomBytes(32);\n\n// INSECURE: Never use Math.random()\nconst badEntropy = Math.random(); // NEVER DO THIS\n\n// INSECURE: Never use predictable data\nconst predictable = Date.now(); // NEVER DO THIS\n```\n\n### Memory Handling\n\n```typescript\nfunction secureSign(privateKey: Buffer, message: Buffer): Buffer {\n  try {\n    // Sign the message\n    const signature = secp256k1.sign(message, privateKey);\n    return signature;\n  } finally {\n    // Always clear sensitive data\n    privateKey.fill(0);\n  }\n}\n```\n\n### Environment Security\n\n```typescript\n// Check for common security issues\nfunction securityCheck(): string[] {\n  const warnings: string[] = [];\n  \n  // Check if running in browser\n  if (typeof window !== 'undefined') {\n    warnings.push('Browser environment - keys may be exposed to extensions');\n  }\n  \n  // Check for debugger\n  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {\n    warnings.push('Development mode - ensure production security');\n  }\n  \n  return warnings;\n}\n```\n\n## Recovery Procedures\n\n### From Mnemonic\n\n```typescript\nasync function recoverWallet(mnemonic: string, passphrase = ''): Promise<WalletData> {\n  // Validate mnemonic\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic');\n  }\n  \n  // Generate seed\n  const seed = await bip39.mnemonicToSeed(mnemonic, passphrase);\n  const root = bip32.fromSeed(seed);\n  \n  // Derive standard paths\n  const addresses = {\n    bip44: deriveAddresses(root, \"m/44'/0'/0'\"),\n    bip49: deriveAddresses(root, \"m/49'/0'/0'\"),\n    bip84: deriveAddresses(root, \"m/84'/0'/0'\"),\n    bip86: deriveAddresses(root, \"m/86'/0'/0'\"),\n  };\n  \n  return { root, addresses };\n}\n\nfunction deriveAddresses(root: BIP32Interface, basePath: string, count = 20) {\n  const addresses = [];\n  for (let i = 0; i < count; i++) {\n    const child = root.derivePath(`${basePath}/0/${i}`);\n    addresses.push(deriveAddress(child));\n  }\n  return addresses;\n}\n```\n\n### Gap Limit Scanning\n\n```typescript\nasync function scanForUsedAddresses(\n  xpub: string,\n  gapLimit = 20\n): Promise<string[]> {\n  const root = bip32.fromBase58(xpub);\n  const usedAddresses: string[] = [];\n  let consecutiveUnused = 0;\n  let index = 0;\n  \n  while (consecutiveUnused < gapLimit) {\n    const child = root.derivePath(`0/${index}`);\n    const address = deriveAddress(child);\n    \n    const hasHistory = await checkAddressHistory(address);\n    \n    if (hasHistory) {\n      usedAddresses.push(address);\n      consecutiveUnused = 0;\n    } else {\n      consecutiveUnused++;\n    }\n    \n    index++;\n  }\n  \n  return usedAddresses;\n}\n```\n\n## Summary\n\nSecure key management requires:\n\n- **HD Wallets**: Use BIP32/39/44/49/84/86 standards\n- **Secure Generation**: Cryptographically secure randomness\n- **Proper Storage**: Encrypted storage, hardware wallets\n- **Backup Strategy**: Multiple secure backups\n- **Recovery Testing**: Test recovery before storing significant funds\n\nNever expose private keys, use hardware wallets for significant amounts, and always have tested backup procedures.\n",
    "filename": "keys.md"
  },
  "/docs/development/testnets": {
    "content": "# Signet & Testnet Deep Dive\n\nTest networks are essential for Bitcoin development. This guide covers the differences between testnet, signet, and regtest, along with setup instructions and best practices.\n\n## Network Comparison\n\n| Feature | Mainnet | Testnet | Signet | Regtest |\n|---------|---------|---------|--------|---------|\n| Real Value | Yes | No | No | No |\n| Block Time | ~10 min | Variable | ~10 min | Instant |\n| Difficulty | Dynamic | Dynamic | Fixed | Minimal |\n| Public | Yes | Yes | Yes | Local |\n| Controlled | No | No | Yes | Yes |\n| Best For | Production | Integration | Testing | Unit tests |\n\n## Testnet (Testnet3)\n\n### Overview\n\nTestnet is the original Bitcoin test network. It mirrors mainnet but with worthless coins.\n\n### Configuration\n\n```ini\n# bitcoin.conf\ntestnet=1\n[test]\nrpcuser=user\nrpcpassword=password\nrpcport=18332\n```\n\n### Starting Testnet\n\n```bash\n# Start testnet node\nbitcoind -testnet -daemon\n\n# Use bitcoin-cli with testnet\nbitcoin-cli -testnet getblockchaininfo\n\n# Check sync status\nbitcoin-cli -testnet getblockcount\n```\n\n### Testnet Faucets\n\nGet free testnet coins:\n\n- [coinfaucet.eu](https://coinfaucet.eu/en/btc-testnet/)\n- [testnet-faucet.com](https://testnet-faucet.com/btc-testnet/)\n- [bitcoinfaucet.uo1.net](https://bitcoinfaucet.uo1.net/)\n\n### Testnet Explorers\n\n- [mempool.space/testnet](https://mempool.space/testnet)\n- [blockstream.info/testnet](https://blockstream.info/testnet)\n\n### Testnet Challenges\n\n```\nIssues with Testnet:\n- Block times can be erratic (difficulty resets)\n- Occasional \"block storms\" (many blocks quickly)\n- May have long periods with no blocks\n- Reorgs more common than mainnet\n```\n\n## Signet\n\n### Overview\n\nSignet (BIP-325) provides a more controlled test environment. Blocks are signed by specific keys, ensuring predictable block production.\n\n### Benefits Over Testnet\n\n- **Predictable Blocks**: Consistent ~10 minute block times\n- **No Difficulty Resets**: Stable mining simulation\n- **Controlled Environment**: No surprise reorgs\n- **Better for Testing**: More mainnet-like behavior\n\n### Default Signet Configuration\n\n```ini\n# bitcoin.conf\nsignet=1\n[signet]\nrpcuser=user\nrpcpassword=password\nrpcport=38332\n```\n\n### Starting Signet\n\n```bash\n# Start signet node\nbitcoind -signet -daemon\n\n# Check status\nbitcoin-cli -signet getblockchaininfo\n\n# Get network info\nbitcoin-cli -signet getnetworkinfo\n```\n\n### Signet Faucets\n\n- [signet.bc-2.jp](https://signet.bc-2.jp/)\n- [alt.signetfaucet.com](https://alt.signetfaucet.com/)\n- [signetfaucet.bublina.eu.org](https://signetfaucet.bublina.eu.org/)\n\n### Signet Explorer\n\n- [mempool.space/signet](https://mempool.space/signet)\n\n### Custom Signet\n\nYou can create your own signet for private testing:\n\n```bash\n# Generate signing key\nbitcoin-cli -regtest createwallet \"signet_signer\"\nSIGNET_ADDR=$(bitcoin-cli -regtest getnewaddress)\nSIGNET_PUBKEY=$(bitcoin-cli -regtest getaddressinfo $SIGNET_ADDR | jq -r '.pubkey')\n\n# Create signet challenge script\n# OP_1 <pubkey> OP_1 OP_CHECKMULTISIG\nCHALLENGE=\"5121${SIGNET_PUBKEY}51ae\"\n```\n\n```ini\n# Custom signet bitcoin.conf\nsignet=1\nsignetchallenge=5121...your_challenge...51ae\n[signet]\nrpcport=38332\n```\n\n## Regtest (Regression Test)\n\n### Overview\n\nRegtest is a local, private blockchain perfect for development and automated testing.\n\n### Configuration\n\n```ini\n# bitcoin.conf\nregtest=1\n[regtest]\nrpcuser=user\nrpcpassword=password\nrpcport=18443\n```\n\n### Starting Regtest\n\n```bash\n# Start regtest node\nbitcoind -regtest -daemon\n\n# Create wallet\nbitcoin-cli -regtest createwallet \"dev\"\n\n# Generate initial coins (need 100+ blocks for maturity)\nbitcoin-cli -regtest -generate 101\n\n# Check balance\nbitcoin-cli -regtest getbalance\n```\n\n### Instant Block Generation\n\n```bash\n# Generate blocks on demand\nbitcoin-cli -regtest -generate 1\n\n# Generate to specific address\nbitcoin-cli -regtest generatetoaddress 1 \"bcrt1q...\"\n\n# Generate multiple blocks\nbitcoin-cli -regtest -generate 10\n```\n\n### Regtest for Testing\n\n```python\nimport subprocess\nimport json\nimport time\n\nclass RegtestNode:\n    def __init__(self, datadir=None):\n        self.datadir = datadir or '/tmp/regtest'\n        \n    def start(self):\n        subprocess.run([\n            'bitcoind', '-regtest', '-daemon',\n            f'-datadir={self.datadir}',\n            '-rpcuser=test', '-rpcpassword=test'\n        ])\n        time.sleep(2)\n        \n    def stop(self):\n        self.cli('stop')\n        \n    def cli(self, *args):\n        result = subprocess.run(\n            ['bitcoin-cli', '-regtest', \n             f'-datadir={self.datadir}',\n             '-rpcuser=test', '-rpcpassword=test'] + list(args),\n            capture_output=True, text=True\n        )\n        if result.stdout:\n            try:\n                return json.loads(result.stdout)\n            except:\n                return result.stdout.strip()\n        return None\n    \n    def generate(self, blocks=1):\n        return self.cli('-generate', str(blocks))\n    \n    def get_new_address(self):\n        return self.cli('getnewaddress')\n    \n    def send(self, address, amount):\n        return self.cli('sendtoaddress', address, str(amount))\n\n# Usage\nnode = RegtestNode()\nnode.start()\nnode.cli('createwallet', 'test')\nnode.generate(101)  # Mine initial coins\naddr = node.get_new_address()\ntxid = node.send(addr, 1.0)\nnode.generate(1)  # Confirm transaction\nnode.stop()\n```\n\n## Lightning Network Testing\n\n### Polar (Recommended)\n\nPolar provides a GUI for managing Lightning test networks.\n\n```bash\n# Download from https://lightningpolar.com/\n# Create network with:\n# - Bitcoin Core (regtest)\n# - LND / Core Lightning / Eclair nodes\n# - Automatic channel opening\n```\n\n### Manual LND Setup on Regtest\n\n```bash\n# Start Bitcoin Core regtest\nbitcoind -regtest -daemon -zmqpubrawblock=tcp://127.0.0.1:28332 -zmqpubrawtx=tcp://127.0.0.1:28333\n\n# Generate initial blocks\nbitcoin-cli -regtest -generate 101\n\n# Start LND\nlnd --bitcoin.active --bitcoin.regtest \\\n    --bitcoin.node=bitcoind \\\n    --bitcoind.rpcuser=user --bitcoind.rpcpass=password \\\n    --bitcoind.zmqpubrawblock=tcp://127.0.0.1:28332 \\\n    --bitcoind.zmqpubrawtx=tcp://127.0.0.1:28333\n\n# Create wallet and get address\nlncli --network=regtest create\nlncli --network=regtest newaddress p2wkh\n\n# Fund the wallet (from Bitcoin Core)\nbitcoin-cli -regtest sendtoaddress <lnd_address> 1\nbitcoin-cli -regtest -generate 6\n```\n\n### Core Lightning on Regtest\n\n```bash\n# Start lightningd\nlightningd --network=regtest \\\n    --bitcoin-rpcuser=user \\\n    --bitcoin-rpcpassword=password \\\n    --bitcoin-rpcport=18443\n\n# Get new address\nlightning-cli --network=regtest newaddr\n\n# Fund and open channel\nlightning-cli --network=regtest connect <node_id>@localhost:9735\nlightning-cli --network=regtest fundchannel <node_id> 100000\n```\n\n## Automated Testing Setup\n\n### Docker Compose Example\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  bitcoind:\n    image: ruimarinho/bitcoin-core:latest\n    command:\n      - -regtest\n      - -rpcuser=test\n      - -rpcpassword=test\n      - -rpcallowip=0.0.0.0/0\n      - -rpcbind=0.0.0.0\n      - -zmqpubrawblock=tcp://0.0.0.0:28332\n      - -zmqpubrawtx=tcp://0.0.0.0:28333\n    ports:\n      - \"18443:18443\"\n      - \"28332:28332\"\n      - \"28333:28333\"\n    volumes:\n      - bitcoin_data:/home/bitcoin/.bitcoin\n\n  lnd:\n    image: lightninglabs/lnd:latest\n    depends_on:\n      - bitcoind\n    command:\n      - --bitcoin.active\n      - --bitcoin.regtest\n      - --bitcoin.node=bitcoind\n      - --bitcoind.rpchost=bitcoind\n      - --bitcoind.rpcuser=test\n      - --bitcoind.rpcpass=test\n      - --bitcoind.zmqpubrawblock=tcp://bitcoind:28332\n      - --bitcoind.zmqpubrawtx=tcp://bitcoind:28333\n    ports:\n      - \"10009:10009\"\n    volumes:\n      - lnd_data:/root/.lnd\n\nvolumes:\n  bitcoin_data:\n  lnd_data:\n```\n\n### CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Bitcoin Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      bitcoind:\n        image: ruimarinho/bitcoin-core:latest\n        options: >-\n          -regtest\n          -rpcuser=test\n          -rpcpassword=test\n          -rpcallowip=0.0.0.0/0\n        ports:\n          - 18443:18443\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Wait for Bitcoin Core\n        run: |\n          for i in {1..30}; do\n            if bitcoin-cli -regtest -rpcuser=test -rpcpassword=test getblockchaininfo; then\n              break\n            fi\n            sleep 1\n          done\n      \n      - name: Setup test environment\n        run: |\n          bitcoin-cli -regtest -rpcuser=test -rpcpassword=test createwallet test\n          bitcoin-cli -regtest -rpcuser=test -rpcpassword=test -generate 101\n      \n      - name: Run tests\n        run: npm test\n```\n\n## Network-Specific Code\n\n### Selecting Network\n\n:::code-group\n```rust\nuse bitcoin::Network;\n\nfn get_network(network_type: &str) -> Network {\n    match network_type {\n        \"mainnet\" => Network::Bitcoin,\n        \"testnet\" | \"signet\" => Network::Testnet,\n        \"regtest\" => Network::Regtest,\n        _ => panic!(\"Unknown network\"),\n    }\n}\n```\n\n```python\nfrom bitcoin import SelectParams\n\ndef select_network(network_type):\n    networks = {'mainnet': 'mainnet', 'testnet': 'testnet', 'regtest': 'regtest'}\n    SelectParams(networks.get(network_type, 'testnet'))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::config::network get_network(const std::string& type) {\n    if (type == \"mainnet\") return bc::config::network::mainnet;\n    if (type == \"testnet\") return bc::config::network::testnet;\n    return bc::config::network::regtest;\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction getNetwork(type) {\n  const networks = {\n    mainnet: bitcoin.networks.bitcoin,\n    testnet: bitcoin.networks.testnet,\n    regtest: bitcoin.networks.regtest,\n  };\n  return networks[type];\n}\n```\n:::\n\n### RPC Port Configuration\n\n| Network | RPC Port |\n|---------|----------|\n| Mainnet | 8332 |\n| Testnet | 18332 |\n| Signet | 38332 |\n| Regtest | 18443 |\n\n## Testing Scenarios\n\n### Testing RBF (Replace-By-Fee)\n\n```bash\n# On regtest\n# 1. Create transaction with RBF enabled\nbitcoin-cli -regtest sendtoaddress <addr> 0.1 \"\" \"\" false true  # replaceable=true\n\n# 2. Get the txid\nTXID=$(bitcoin-cli -regtest listtransactions | jq -r '.[0].txid')\n\n# 3. Bump the fee\nbitcoin-cli -regtest bumpfee $TXID\n\n# 4. Mine block to confirm\nbitcoin-cli -regtest -generate 1\n```\n\n### Testing Time Locks\n\n```bash\n# Test CLTV (absolute timelock)\n# Create transaction locked until block 150\nbitcoin-cli -regtest createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '[{\"<addr>\": 0.1}]' \\\n  150  # locktime\n\n# Won't be valid until block 150\nbitcoin-cli -regtest -generate 50  # Advance to block 150+\n```\n\n### Testing Mempool Behavior\n\n```python\ndef test_mempool_eviction(node):\n    # Fill mempool with low-fee transactions\n    low_fee_txs = []\n    for i in range(100):\n        addr = node.cli('getnewaddress')\n        txid = node.cli('sendtoaddress', addr, '0.001', '', '', False, False, 1)  # 1 sat/vB\n        low_fee_txs.append(txid)\n    \n    # Create high-fee transaction\n    addr = node.cli('getnewaddress')\n    high_fee_tx = node.cli('sendtoaddress', addr, '0.001', '', '', False, False, 100)  # 100 sat/vB\n    \n    # Verify high-fee tx is in mempool\n    mempool = node.cli('getrawmempool')\n    assert high_fee_tx in mempool\n    \n    # Some low-fee txs may be evicted if mempool is full\n```\n\n## Best Practices\n\n### Development Workflow\n\n```\n1. Unit Tests â†’ Regtest\n   - Fast iteration\n   - Complete control\n   - Automated testing\n\n2. Integration Tests â†’ Signet\n   - More realistic environment\n   - Predictable timing\n   - Public network testing\n\n3. Final Testing â†’ Testnet\n   - Closest to mainnet\n   - Real network conditions\n   - Edge case discovery\n\n4. Production â†’ Mainnet\n   - Start with small amounts\n   - Monitor closely\n   - Gradual rollout\n```\n\n### Common Mistakes\n\n```\nDON'T:\nâœ— Test with mainnet funds\nâœ— Assume testnet behavior matches mainnet exactly\nâœ— Ignore network-specific address formats\nâœ— Hardcode RPC ports\n\nDO:\nâœ“ Use appropriate network for each test stage\nâœ“ Handle network differences in code\nâœ“ Validate addresses for correct network\nâœ“ Configure networks via environment variables\n```\n\n## Summary\n\nEach test network serves a purpose:\n\n- **Regtest**: Local development and unit testing\n- **Signet**: Predictable integration testing\n- **Testnet**: Real-world simulation before mainnet\n\nStart with regtest for fast iteration, move to signet for integration testing, and use testnet for final validation before deploying to mainnet.\n",
    "filename": "testnets.md"
  },
  "/docs/development/libraries": {
    "content": "# Libraries & SDKs Reference\n\nThis guide compares major Bitcoin libraries across languages and provides practical examples for common development tasks.\n\n## Library Overview\n\n### By Language\n\n| Language | Library | Best For | Maintenance |\n|----------|---------|----------|-------------|\n| JavaScript | bitcoinjs-lib | Web apps, general use | Active |\n| Rust | rust-bitcoin | Core development | Active |\n| Rust | BDK | Wallet development | Active |\n| Python | python-bitcoinlib | Scripts, learning | Moderate |\n| Go | btcd/btcutil | Infrastructure | Active |\n| C++ | libbitcoin | Performance-critical | Active |\n\n### Feature Comparison\n\n| Feature | bitcoinjs-lib | rust-bitcoin | BDK | python-bitcoinlib |\n|---------|--------------|--------------|-----|-------------------|\n| Transaction Building | âœ“ | âœ“ | âœ“ | âœ“ |\n| PSBT Support | âœ“ | âœ“ | âœ“ | Partial |\n| Taproot | âœ“ | âœ“ | âœ“ | Limited |\n| HD Wallets | Via bip32/bip39 | Via bip32 | âœ“ | Via bip32utils |\n| Coin Selection | Manual | Manual | âœ“ | Manual |\n| Blockchain Sync | No | No | âœ“ | No |\n\n## JavaScript/TypeScript\n\n### bitcoinjs-lib\n\nThe most popular JavaScript Bitcoin library.\n\n**Installation:**\n\n```bash\nnpm install bitcoinjs-lib\nnpm install ecpair tiny-secp256k1  # For signing\nnpm install bip32 bip39           # For HD wallets\n```\n\n**Basic Usage:**\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\nimport ECPairFactory from 'ecpair';\nimport * as ecc from 'tiny-secp256k1';\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nconst ECPair = ECPairFactory(ecc);\nconst bip32 = BIP32Factory(ecc);\n\n// Generate mnemonic and derive keys\nconst mnemonic = bip39.generateMnemonic(256);\nconst seed = await bip39.mnemonicToSeed(mnemonic);\nconst root = bip32.fromSeed(seed);\n\n// BIP84 derivation (Native SegWit)\nconst child = root.derivePath(\"m/84'/0'/0'/0/0\");\n\n// Create address\nconst { address } = bitcoin.payments.p2wpkh({\n  pubkey: child.publicKey,\n  network: bitcoin.networks.bitcoin,\n});\nconsole.log('Address:', address);\n```\n\n**Transaction Building:**\n\n```typescript\nconst psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\n\n// Add input\npsbt.addInput({\n  hash: 'txid_hex',\n  index: 0,\n  witnessUtxo: {\n    script: Buffer.from('0014...', 'hex'),\n    value: 100000,\n  },\n});\n\n// Add output\npsbt.addOutput({\n  address: 'bc1q...',\n  value: 50000,\n});\n\n// Sign\npsbt.signInput(0, ECPair.fromPrivateKey(child.privateKey!));\npsbt.finalizeAllInputs();\n\n// Get raw transaction\nconst tx = psbt.extractTransaction();\nconsole.log('Raw TX:', tx.toHex());\n```\n\n### noble-secp256k1\n\nLightweight cryptographic library for schnorr/ECDSA.\n\n```typescript\nimport * as secp from '@noble/secp256k1';\n\n// Generate key pair\nconst privateKey = secp.utils.randomPrivateKey();\nconst publicKey = secp.getPublicKey(privateKey);\n\n// Sign message (Schnorr for Taproot)\nconst message = new Uint8Array(32); // Your message hash\nconst signature = await secp.schnorr.sign(message, privateKey);\n\n// Verify\nconst isValid = await secp.schnorr.verify(signature, message, publicKey);\n```\n\n## Rust\n\n### rust-bitcoin\n\nLow-level Bitcoin library for Rust.\n\n**Cargo.toml:**\n\n```toml\n[dependencies]\nbitcoin = \"0.31\"\nsecp256k1 = { version = \"0.28\", features = [\"global-context\"] }\n```\n\n**Basic Usage:**\n\n```rust\nuse bitcoin::{\n    Address, Network, PrivateKey, PublicKey,\n    secp256k1::{Secp256k1, SecretKey},\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate key pair\n    let secret_key = SecretKey::new(&mut rand::thread_rng());\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    let public_key = PublicKey::from_private_key(&secp, &private_key);\n    \n    // Create addresses\n    let p2wpkh = Address::p2wpkh(&public_key, Network::Bitcoin).unwrap();\n    println!(\"P2WPKH: {}\", p2wpkh);\n}\n```\n\n**Transaction Building:**\n\n```rust\nuse bitcoin::{\n    Transaction, TxIn, TxOut, OutPoint, Sequence,\n    absolute::LockTime, Amount, ScriptBuf,\n    sighash::{SighashCache, EcdsaSighashType},\n};\n\nfn create_transaction(\n    prev_txid: Txid,\n    prev_vout: u32,\n    recipient: Address,\n    amount: Amount,\n) -> Transaction {\n    let tx = Transaction {\n        version: 2,\n        lock_time: LockTime::ZERO,\n        input: vec![TxIn {\n            previous_output: OutPoint::new(prev_txid, prev_vout),\n            script_sig: ScriptBuf::new(),\n            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n            witness: bitcoin::Witness::default(),\n        }],\n        output: vec![TxOut {\n            value: amount,\n            script_pubkey: recipient.script_pubkey(),\n        }],\n    };\n    \n    tx\n}\n```\n\n### BDK (Bitcoin Dev Kit)\n\nHigh-level wallet library built on rust-bitcoin.\n\n**Cargo.toml:**\n\n```toml\n[dependencies]\nbdk = \"0.29\"\n```\n\n**Wallet Creation:**\n\n```rust\nuse bdk::{\n    Wallet, SignOptions,\n    database::MemoryDatabase,\n    bitcoin::Network,\n    keys::{DerivableKey, GeneratableKey, bip39::{Mnemonic, Language}},\n    template::Bip84,\n};\n\nfn create_wallet() -> Result<Wallet<MemoryDatabase>, Box<dyn std::error::Error>> {\n    // Generate mnemonic\n    let mnemonic = Mnemonic::generate((bdk::keys::bip39::WordCount::Words24, Language::English))?;\n    \n    // Create wallet with BIP84 descriptors\n    let wallet = Wallet::new(\n        Bip84(mnemonic.clone(), None),\n        Some(Bip84(mnemonic, None)),\n        Network::Bitcoin,\n        MemoryDatabase::default(),\n    )?;\n    \n    Ok(wallet)\n}\n```\n\n**Transaction Building with BDK:**\n\n```rust\nuse bdk::{FeeRate, wallet::AddressIndex};\n\nfn send_transaction(\n    wallet: &Wallet<MemoryDatabase>,\n    recipient: &str,\n    amount: u64,\n) -> Result<Transaction, Box<dyn std::error::Error>> {\n    let recipient = Address::from_str(recipient)?;\n    \n    // Build transaction\n    let mut builder = wallet.build_tx();\n    builder\n        .add_recipient(recipient.script_pubkey(), amount)\n        .fee_rate(FeeRate::from_sat_per_vb(5.0))\n        .enable_rbf();\n    \n    let (mut psbt, _details) = builder.finish()?;\n    \n    // Sign\n    wallet.sign(&mut psbt, SignOptions::default())?;\n    \n    // Extract final transaction\n    let tx = psbt.extract_tx();\n    Ok(tx)\n}\n```\n\n### LDK (Lightning Dev Kit)\n\nEmbed Lightning in your Rust application.\n\n```rust\nuse lightning::chain::keysinterface::KeysManager;\nuse lightning::ln::channelmanager::ChannelManager;\n\n// LDK requires more setup - see lightning.dev for full examples\n// Key components:\n// - ChannelManager: Manages channels\n// - PeerManager: Handles peer connections  \n// - ChainMonitor: Monitors on-chain events\n```\n\n## Python\n\n### python-bitcoinlib\n\n```bash\npip install python-bitcoinlib\n```\n\n**Basic Usage:**\n\n```python\nfrom bitcoin import SelectParams\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint, COIN\nfrom bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG\nfrom bitcoin.wallet import CBitcoinAddress, CBitcoinSecret\n\n# Select network\nSelectParams('mainnet')  # or 'testnet', 'regtest'\n\n# Create address from private key\nsecret = CBitcoinSecret.from_secret_bytes(bytes(32))  # Use real entropy!\naddress = CBitcoinAddress.from_pubkey(secret.pub)\nprint(f\"Address: {address}\")\n```\n\n**Transaction Building:**\n\n```python\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\nfrom bitcoin.core.script import SignatureHash, SIGHASH_ALL\n\ndef create_transaction(prev_txid, prev_vout, recipient, amount, private_key):\n    # Create input\n    outpoint = COutPoint(bytes.fromhex(prev_txid)[::-1], prev_vout)\n    txin = CTxIn(outpoint)\n    \n    # Create output\n    recipient_addr = CBitcoinAddress(recipient)\n    txout = CTxOut(amount, recipient_addr.to_scriptPubKey())\n    \n    # Create unsigned transaction\n    tx = CTransaction([txin], [txout])\n    \n    # Sign\n    sighash = SignatureHash(\n        recipient_addr.to_scriptPubKey(),\n        tx, 0, SIGHASH_ALL\n    )\n    sig = private_key.sign(sighash) + bytes([SIGHASH_ALL])\n    \n    # Add signature to input\n    txin.scriptSig = CScript([sig, private_key.pub])\n    \n    return CTransaction([txin], [txout])\n```\n\n### bip32utils\n\nFor HD wallet derivation in Python.\n\n```python\nfrom bip32utils import BIP32Key\nfrom mnemonic import Mnemonic\n\n# Generate mnemonic\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)\nseed = mnemo.to_seed(words)\n\n# Create master key\nmaster = BIP32Key.fromEntropy(seed)\n\n# Derive BIP84 path\naccount = master.ChildKey(84 + 0x80000000)  # purpose (hardened)\naccount = account.ChildKey(0 + 0x80000000)   # coin_type (hardened)\naccount = account.ChildKey(0 + 0x80000000)   # account (hardened)\nexternal = account.ChildKey(0)                # change\naddress_key = external.ChildKey(0)            # address_index\n\nprint(f\"Address: {address_key.Address()}\")\n```\n\n## Go\n\n### btcd/btcutil\n\n```go\nimport (\n    \"github.com/btcsuite/btcd/btcec/v2\"\n    \"github.com/btcsuite/btcd/btcutil\"\n    \"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc generateAddress() {\n    // Generate private key\n    privateKey, _ := btcec.NewPrivateKey()\n    \n    // Get public key\n    publicKey := privateKey.PubKey()\n    \n    // Create P2WPKH address\n    pubKeyHash := btcutil.Hash160(publicKey.SerializeCompressed())\n    addr, _ := btcutil.NewAddressWitnessPubKeyHash(\n        pubKeyHash,\n        &chaincfg.MainNetParams,\n    )\n    \n    fmt.Println(\"Address:\", addr.String())\n}\n```\n\n### lnd/lnrpc\n\nFor Lightning Network in Go.\n\n```go\nimport (\n    \"github.com/lightningnetwork/lnd/lnrpc\"\n    \"google.golang.org/grpc\"\n)\n\nfunc connectToLND() {\n    // Connect to LND\n    conn, _ := grpc.Dial(\"localhost:10009\", grpc.WithInsecure())\n    client := lnrpc.NewLightningClient(conn)\n    \n    // Get node info\n    info, _ := client.GetInfo(context.Background(), &lnrpc.GetInfoRequest{})\n    fmt.Println(\"Node pubkey:\", info.IdentityPubkey)\n    \n    // Create invoice\n    invoice, _ := client.AddInvoice(context.Background(), &lnrpc.Invoice{\n        Value: 1000,\n        Memo:  \"Test payment\",\n    })\n    fmt.Println(\"Payment request:\", invoice.PaymentRequest)\n}\n```\n\n## Common Tasks\n\n### Generate Address (All Languages)\n\n```typescript\n// JavaScript\nconst { address } = bitcoin.payments.p2wpkh({ pubkey: publicKey });\n```\n\n```rust\n// Rust\nlet address = Address::p2wpkh(&public_key, Network::Bitcoin)?;\n```\n\n```python\n# Python\naddress = CBitcoinAddress.from_pubkey(public_key)\n```\n\n```go\n// Go\naddr, _ := btcutil.NewAddressWitnessPubKeyHash(pubKeyHash, &chaincfg.MainNetParams)\n```\n\n### Parse Transaction\n\n```typescript\n// JavaScript\nconst tx = bitcoin.Transaction.fromHex(rawTxHex);\nconsole.log('TXID:', tx.getId());\nconsole.log('Inputs:', tx.ins.length);\nconsole.log('Outputs:', tx.outs.length);\n```\n\n```rust\n// Rust\nlet tx: Transaction = deserialize(&hex::decode(raw_tx_hex)?)?;\nprintln!(\"TXID: {}\", tx.txid());\n```\n\n```python\n# Python\ntx = CTransaction.deserialize(bytes.fromhex(raw_tx_hex))\nprint(f\"TXID: {tx.GetTxid().hex()}\")\n```\n\n### Validate Address\n\n```typescript\n// JavaScript\nfunction isValidAddress(address: string): boolean {\n  try {\n    bitcoin.address.toOutputScript(address, bitcoin.networks.bitcoin);\n    return true;\n  } catch {\n    return false;\n  }\n}\n```\n\n```rust\n// Rust\nfn is_valid_address(addr_str: &str) -> bool {\n    Address::from_str(addr_str)\n        .map(|a| a.is_valid_for_network(Network::Bitcoin))\n        .unwrap_or(false)\n}\n```\n\n```python\n# Python\ndef is_valid_address(address):\n    try:\n        CBitcoinAddress(address)\n        return True\n    except:\n        return False\n```\n\n## Choosing a Library\n\n### Decision Matrix\n\n| Use Case | Recommended |\n|----------|-------------|\n| Web wallet | bitcoinjs-lib |\n| Mobile app (React Native) | bitcoinjs-lib |\n| Backend service | rust-bitcoin or btcd |\n| Wallet application | BDK |\n| Lightning integration | LDK (Rust) or lnd (Go) |\n| Scripting/automation | python-bitcoinlib |\n| Learning/education | python-bitcoinlib |\n| High-performance | rust-bitcoin or libbitcoin |\n\n### Considerations\n\n**bitcoinjs-lib:**\n- Pros: Wide adoption, good docs, browser support\n- Cons: JavaScript ecosystem complexity\n\n**rust-bitcoin:**\n- Pros: Type safety, performance, active development\n- Cons: Steeper learning curve\n\n**BDK:**\n- Pros: Full wallet features, handles complexity\n- Cons: Rust knowledge required\n\n**python-bitcoinlib:**\n- Pros: Easy to learn, great for scripts\n- Cons: Slower, less complete Taproot support\n\n## Summary\n\nEach library has its strengths:\n\n- **bitcoinjs-lib**: Best for web and cross-platform\n- **rust-bitcoin/BDK**: Best for production applications\n- **python-bitcoinlib**: Best for learning and scripting\n- **btcd**: Best for Go infrastructure\n\nChoose based on your language preference, use case, and required features. For production wallets, consider BDK for its completeness; for web apps, bitcoinjs-lib remains the standard choice.\n",
    "filename": "libraries.md"
  },
  "/docs/development/monitoring": {
    "content": "# Blockchain Monitoring\n\nReal-time blockchain monitoring allows you to detect new blocks instantly, track mining pools, analyze transactions, and monitor network activity.\n\n> **Explore the blockchain live!** Try RPC commands like `getblockchaininfo` and `getmempoolinfo` in the [Bitcoin CLI Terminal](/terminal).\n\n## ZMQ Notifications\n\n### What is ZMQ?\n\nZeroMQ (ZMQ) provides real-time notifications for blockchain events without polling. It's much more efficient than repeatedly calling RPC commands.\n\n### Benefits\n\n- **Instant notifications**: No polling delays\n- **Lower resource usage**: No constant RPC calls\n- **Better reliability**: Catches blocks even after node restarts\n- **Real-time monitoring**: Perfect for applications\n\n### Configuration\n\nAdd to your `bitcoin.conf`:\n\n```ini\n# ZMQ Notifications\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28333\nzmqpubrawblock=tcp://127.0.0.1:28334\nzmqpubrawtx=tcp://127.0.0.1:28335\n```\n\n**Important**: Bitcoin Core must be built **with ZMQ enabled**.\n\n### Verification\n\n```bash\n# Check if ZMQ is enabled in Bitcoin logs\ngrep -i zmq ~/.bitcoin/debug.log\n\n# Check Bitcoin help for ZMQ options\nbitcoind -h | grep zmq\n```\n\n## Block Detection\n\n### Real-Time Block Monitoring\n\n**Using ZMQ (Recommended):**\n\n```python\nimport zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://127.0.0.1:28332\")\nsocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n\nwhile True:\n    message = socket.recv()\n    block_hash = message[1:].hex()\n    print(f\"New block: {block_hash}\")\n```\n\n**Using Polling (Fallback):**\n\n```python\nimport time\nfrom bitcoinrpc import BitcoinRPC\n\nrpc = BitcoinRPC(...)\nlast_block = rpc.getblockcount()\n\nwhile True:\n    current_block = rpc.getblockcount()\n    if current_block > last_block:\n        print(f\"New block: {current_block}\")\n        last_block = current_block\n    time.sleep(10)  # Poll every 10 seconds\n```\n\n### Block Information\n\n**Get Block Details:**\n\n```python\n# Get block by hash\nblock = rpc.getblock(block_hash)\n\n# Get block by height\nblock_hash = rpc.getblockhash(height)\nblock = rpc.getblock(block_hash)\n```\n\n**Key Information:**\n- Block height\n- Block hash\n- Previous block hash\n- Merkle root\n- Timestamp\n- Transaction count\n- Block size\n\n## Mining Pool Identification\n\n### Coinbase Transaction Analysis\n\nMining pools often embed their name or identifier in the coinbase transaction.\n\n**Extract Pool Information:**\n\n```python\ndef identify_pool(block):\n    coinbase_tx = block['tx'][0]\n    coinbase_hex = rpc.getrawtransaction(coinbase_tx)\n    \n    # Parse coinbase script\n    # Look for pool identifiers\n    # Common patterns:\n    # - Pool names in ASCII\n    # - Pool URLs\n    # - Pool signatures\n    \n    return pool_name\n```\n\n## OP_RETURN Analysis\n\n### Extracting OP_RETURN Data\n\n**Find OP_RETURN Outputs:**\n\n```python\ndef extract_op_return(tx):\n    op_returns = []\n    for output in tx['vout']:\n        asm = output['scriptPubKey']['asm']\n        if asm.startswith('OP_RETURN'):\n            # Extract data\n            data = asm.split(' ')[1]\n            op_returns.append(data)\n    return op_returns\n```\n\n### Use Cases\n\n- **Timestamping**: Document timestamps\n- **Asset Protocols**: Counterparty, Omni Layer\n- **Messages**: Encoded messages\n- **Metadata**: Transaction metadata\n\n## Transaction Monitoring\n\n### Mempool Monitoring\n\n**Watch Mempool:**\n\n```python\n# Using ZMQ\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://127.0.0.1:28333\")\nsocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n\nwhile True:\n    message = socket.recv()\n    tx_hash = message[1:].hex()\n    print(f\"New transaction: {tx_hash}\")\n```\n\n### Transaction Analysis\n\n**Analyze Transaction:**\n\n```python\ntx = rpc.getrawtransaction(tx_hash, True)\n\n# Key information:\n# - Inputs and outputs\n# - Fees\n# - Script types\n# - OP_RETURN data\n# - Transaction size\n```\n\n## Statistics and Logging\n\n### Block Statistics\n\n**Track Block Metrics:**\n\n```python\ndef log_block_stats(block):\n    stats = {\n        'height': block['height'],\n        'hash': block['hash'],\n        'tx_count': len(block['tx']),\n        'size': block['size'],\n        'pool': identify_pool(block),\n        'timestamp': block['time']\n    }\n    \n    # Log to CSV or database\n    log_to_csv(stats)\n```\n\n### CSV Logging\n\n**Log to CSV:**\n\n```python\nimport csv\n\ndef log_to_csv(stats):\n    with open('blocks.csv', 'a') as f:\n        writer = csv.DictWriter(f, fieldnames=stats.keys())\n        writer.writerow(stats)\n```\n\n## Error Handling\n\n### ZMQ Connection Failures\n\n**Handle ZMQ Errors:**\n\n```python\ntry:\n    socket = context.socket(zmq.SUB)\n    socket.connect(\"tcp://127.0.0.1:28332\")\nexcept zmq.ZMQError as e:\n    print(f\"ZMQ connection failed: {e}\")\n    # Fall back to polling\n    use_polling_fallback()\n```\n\n### RPC Failures\n\n**Handle RPC Errors:**\n\n```python\ntry:\n    block = rpc.getblock(block_hash)\nexcept Exception as e:\n    print(f\"RPC error: {e}\")\n    # Retry or log error\n```\n\n## Best Practices\n\n### For Monitoring Applications\n\n1. **Use ZMQ First**: Try ZMQ, fall back to polling\n2. **Error Handling**: Handle all error cases\n3. **Logging**: Log important events\n4. **Rate Limiting**: Don't overwhelm RPC\n5. **Caching**: Cache frequently accessed data\n\n### For Performance\n\n1. **Async Operations**: Use async/await for I/O\n2. **Batch Operations**: Batch RPC calls when possible\n3. **Connection Pooling**: Reuse connections\n4. **Efficient Parsing**: Parse only needed data\n",
    "filename": "blockchain.md"
  },
  "/docs/development/mining": {
    "content": "# Pool Mining Setup and Monitoring\n\nPool mining allows you to contribute hash power to a mining pool and receive proportional rewards. This guide covers setup, monitoring, and optimization.\n\n## Mining Architecture\n\n### Components\n\n1. **Bitcoin Node**: Provides blockchain data via RPC\n2. **Mining Software**: CPU/GPU/ASIC miner\n3. **Mining Pool**: Coordinates mining efforts\n4. **Wallet**: Receives mining rewards\n\n### Data Flow\n\n```\nBitcoin Node â†’ Mining Software â†’ Mining Pool â†’ Rewards\n```\n\n## Mining Software Setup\n\n### CPU Mining (cpuminer-opt)\n\n**Installation:**\n\n```bash\n# Install dependencies\nbrew install automake autoconf libtool curl gmp jansson\n\n# Clone and build\ngit clone https://github.com/JayDDee/cpuminer-opt.git\ncd cpuminer-opt\n./build.sh\n```\n\n**Configuration:**\n\n```bash\n# Start mining (replace with your pool URL and credentials)\n./cpuminer -a sha256d \\\n  -o stratum+tcp://<pool_url>:<port> \\\n  -u <your_bitcoin_address>.worker \\\n  -p <password> \\\n  -t <thread_count>\n```\n\n### Configuration Parameters\n\n- **Algorithm**: `sha256d` (Bitcoin)\n- **Pool URL**: Your chosen mining pool's Stratum URL\n- **Username**: Your Bitcoin address + worker name\n- **Password**: Pool password (often `x` for default)\n- **Threads**: Number of CPU threads to use\n\n## Pool Configuration\n\n### Choosing a Pool\n\n**Considerations:**\n- **Payout method**: PPS, PPLNS, SOLO\n- **Fee structure**: Pool fees\n- **Minimum payout**: Minimum withdrawal amount\n- **Reliability**: Uptime and stability\n- **Location**: Geographic proximity\n\n### Pool Types\n\n**Pay Per Share (PPS):**\n- Fixed payment per share\n- Predictable income\n- Higher pool fees\n\n**Pay Per Last N Shares (PPLNS):**\n- Payment based on recent shares\n- Variable income\n- Lower pool fees\n\n**Solo Mining:**\n- Mine independently\n- Keep full block reward\n- Very low probability\n\n## Monitoring Hash Rate\n\n### Real-Time Monitoring\n\n**Mining Software Output:**\n\n```\n[2024-01-15 10:30:45] accepted: 1/1 (100.00%), 85.23 kH/s\n[2024-01-15 10:30:50] accepted: 2/2 (100.00%), 85.45 kH/s\n```\n\n**Key Metrics:**\n- **Hash Rate**: Hashes per second (H/s, kH/s, MH/s)\n- **Accepted Shares**: Shares accepted by pool\n- **Rejected Shares**: Shares rejected (stale/invalid)\n- **Efficiency**: Accepted / Total shares\n\n### Hash Rate Calculation\n\n```\nHash Rate = Total Hashes / Time\n```\n\n**Example:**\n```\n85,230 hashes in 1 second = 85.23 kH/s\n```\n\n## Share Submission\n\n### What is a Share?\n\nA share is a proof-of-work submission that:\n- Meets pool difficulty (lower than network difficulty)\n- Proves mining work was done\n- Entitles miner to proportional reward\n\n### Share Difficulty\n\n**Pool Difficulty:**\n- Lower than network difficulty\n- Allows more frequent shares\n- Enables proportional rewards\n\n**Network Difficulty:**\n- Actual Bitcoin network difficulty\n- Must be met to find block\n- Very high (currently ~80T)\n\n### Share Acceptance\n\n**Accepted Share:**\n- Meets pool difficulty\n- Valid proof-of-work\n- Counts toward rewards\n\n**Rejected Share:**\n- Stale (block already found)\n- Invalid proof-of-work\n- Doesn't count toward rewards\n\n## Reward Calculation\n\n### Proportional Rewards\n\n**PPLNS Example:**\n```\nTotal pool hash rate: 100 PH/s\nYour hash rate: 100 kH/s\nYour contribution: 0.000001%\n\nBlock reward: 3.125 BTC + fees\nYour share: 3.125 BTC Ã— 0.000001% = 0.00003125 BTC\n```\n\n### Payout Schedule\n\n**Factors:**\n- Pool payout method\n- Minimum payout threshold\n- Pool fees\n- Network confirmation requirements\n\n**Typical Schedule:**\n- Daily or weekly payouts\n- Minimum 0.001 BTC\n- After 100+ confirmations\n\n## Performance Optimization\n\n### CPU Mining\n\n**Thread Optimization:**\n- Use all CPU cores\n- Monitor temperature\n- Balance performance vs. heat\n\n**Example:**\n```\n10-core CPU: Use 8-10 threads\nLeave 1-2 cores for system\n```\n\n### System Load\n\n**Monitor:**\n- CPU usage: 80-100%\n- Temperature: 60-80Â°C (varies by hardware)\n- Power consumption: Varies by CPU and system\n- Fan noise: May increase with load\n\n### Thermal Management\n\n**Best Practices:**\n- Monitor temperature\n- Reduce threads if overheating\n- Improve ventilation\n- Consider stopping if too hot\n\n## Troubleshooting\n\n### Low Hash Rate\n\n**Causes:**\n- Too few threads\n- CPU throttling\n- System load\n- Mining software issues\n\n**Solutions:**\n- Increase thread count\n- Check CPU temperature\n- Reduce other system load\n- Update mining software\n\n### High Rejection Rate\n\n**Causes:**\n- Network latency\n- Stale shares\n- Pool issues\n- Clock synchronization\n\n**Solutions:**\n- Check network connection\n- Use closer pool server\n- Sync system clock\n- Contact pool support\n\n### No Shares Accepted\n\n**Causes:**\n- Wrong pool configuration\n- Invalid credentials\n- Network issues\n- Pool downtime\n\n**Solutions:**\n- Verify pool URL\n- Check username/password\n- Test network connection\n- Check pool status\n\n## Security Considerations\n\n### Wallet Security\n\n**Best Practices:**\n- Use dedicated receiving address\n- Don't use main wallet\n- Monitor for payouts\n- Secure private keys\n\n### Pool Security\n\n**Considerations:**\n- Choose reputable pools\n- Verify pool website\n- Use secure connections (SSL/TLS)\n- Monitor payouts\n\n## Educational Value\n\n### What You Learn\n\n1. **Proof-of-Work**: How mining works\n2. **Hash Functions**: SHA256D algorithm\n3. **Network Difficulty**: How difficulty adjusts\n4. **Pool Coordination**: How pools work\n5. **Economic Incentives**: Mining economics\n\n### Technical Concepts\n\n- **Block Headers**: 80-byte mining target\n- **Nonce Space**: 4.3 billion possible values\n- **Merkle Trees**: Transaction organization\n- **Difficulty Target**: Network-wide target\n- **Block Rewards**: Miner compensation\n\n## Expected Results\n\n### Realistic Expectations\n\n**CPU Mining:**\n- Hash Rate: Varies by CPU (typically kH/s range)\n- Network Hash Rate: ~700 EH/s\n- Your Contribution: Negligible percentage\n- Probability of Finding Block: Essentially zero\n- Pool Rewards: Very small but consistent\n\n**Reality Check:**\n- CPU mining is educational\n- Real mining requires ASICs\n- Pool rewards are minimal\n- Focus on learning, not profit\n\n## Summary\n\nPool mining provides:\n\n- **Educational Value**: Learn how mining works\n- **Network Support**: Contribute to network security\n- **Small Rewards**: Proportional pool payouts\n- **Real-Time Monitoring**: Track hash rate and shares\n- **Technical Understanding**: Deep dive into proof-of-work\n\nUnderstanding pool mining helps explain Bitcoin's security model and economic incentives.\n",
    "filename": "pool-mining.md"
  },
  "/docs/development/tools": {
    "content": "# Bitcoin Price Tracking\n\nIntegrating Bitcoin price data into applications requires API integration, caching strategies, and handling rate limits. This guide covers best practices.\n\n## API Providers\n\n### CoinGecko\n\n**Advantages:**\n- Free tier available\n- Good rate limits\n- Historical data\n- Multiple currencies\n\n**Example:**\n\n```python\nimport requests\n\ndef get_price_coingecko():\n    url = \"https://api.coingecko.com/api/v3/simple/price\"\n    params = {\n        \"ids\": \"bitcoin\",\n        \"vs_currencies\": \"usd,eur\"\n    }\n    response = requests.get(url, params=params)\n    return response.json()\n```\n\n### Yahoo Finance\n\n**Advantages:**\n- Free\n- Real-time data\n- Historical data\n- Multiple currencies\n\n**Example:**\n\n```python\nimport yfinance as yf\n\ndef get_price_yahoo():\n    btc = yf.Ticker(\"BTC-USD\")\n    data = btc.history(period=\"1d\")\n    return data['Close'].iloc[-1]\n```\n\n## Centralized Price Service\n\n### Service Architecture\n\n**Benefits:**\n- Single source of truth\n- Caching reduces API calls\n- Fallback mechanisms\n- Rate limit management\n\n**Implementation:**\n\n```python\nclass BitcoinPriceService:\n    def __init__(self):\n        self.cache = {}\n        self.cache_duration = 60  # seconds\n        self.rate_limiter = RateLimiter()\n    \n    def get_price(self, currency='USD'):\n        # Check cache first\n        cache_key = f\"price_{currency}\"\n        if cache_key in self.cache:\n            cached_price, timestamp = self.cache[cache_key]\n            if time.time() - timestamp < self.cache_duration:\n                return cached_price\n        \n        # Try CoinGecko first\n        try:\n            price = self._get_price_coingecko(currency)\n            self.cache[cache_key] = (price, time.time())\n            return price\n        except Exception:\n            # Fallback to Yahoo Finance\n            price = self._get_price_yahoo(currency)\n            self.cache[cache_key] = (price, time.time())\n            return price\n```\n\n## Caching Strategies\n\n### In-Memory Caching\n\n**Simple Cache:**\n\n```python\nimport time\n\ncache = {}\nCACHE_DURATION = 60  # seconds\n\ndef get_cached_price(currency):\n    key = f\"price_{currency}\"\n    if key in cache:\n        price, timestamp = cache[key]\n        if time.time() - timestamp < CACHE_DURATION:\n            return price\n    return None\n```\n\n### Cache Invalidation\n\n**Time-Based:**\n\n```python\ndef is_cache_valid(timestamp, duration):\n    return time.time() - timestamp < duration\n```\n\n**Event-Based:**\n\n```python\ndef invalidate_cache():\n    cache.clear()\n```\n\n## Rate Limiting\n\n### Implementing Rate Limits\n\n**Simple Rate Limiter:**\n\n```python\nimport time\nfrom collections import deque\n\nclass RateLimiter:\n    def __init__(self, max_calls=10, period=60):\n        self.max_calls = max_calls\n        self.period = period\n        self.calls = deque()\n    \n    def can_call(self):\n        now = time.time()\n        # Remove old calls\n        while self.calls and self.calls[0] < now - self.period:\n            self.calls.popleft()\n        \n        if len(self.calls) < self.max_calls:\n            self.calls.append(now)\n            return True\n        return False\n```\n\n### Respecting API Limits\n\n**Best Practices:**\n- Check rate limits before calling\n- Implement exponential backoff\n- Use caching to reduce calls\n- Monitor API usage\n\n## Multi-Source Fallbacks\n\n### Fallback Chain\n\n**Priority Order:**\n\n1. **Primary**: CoinGecko (best rate limits)\n2. **Secondary**: Yahoo Finance (backup)\n3. **Tertiary**: Local cache (if available)\n\n**Implementation:**\n\n```python\ndef get_price_with_fallback(currency='USD'):\n    # Try primary source\n    try:\n        return get_price_coingecko(currency)\n    except Exception as e:\n        print(f\"CoinGecko failed: {e}\")\n    \n    # Try secondary source\n    try:\n        return get_price_yahoo(currency)\n    except Exception as e:\n        print(f\"Yahoo Finance failed: {e}\")\n    \n    # Try cache\n    cached = get_cached_price(currency)\n    if cached:\n        return cached\n    \n    # All failed\n    raise Exception(\"All price sources failed\")\n```\n\n## Error Handling\n\n### API Errors\n\n**Handle Common Errors:**\n\n```python\ndef get_price_safe(currency='USD'):\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout:\n        # Handle timeout\n        return get_cached_price(currency)\n    except requests.exceptions.HTTPError as e:\n        # Handle HTTP errors\n        if e.response.status_code == 429:\n            # Rate limited, use cache\n            return get_cached_price(currency)\n        raise\n    except Exception as e:\n        # Handle other errors\n        return get_cached_price(currency)\n```\n\n## Thread Safety\n\n### Concurrent Access\n\n**Thread-Safe Cache:**\n\n```python\nimport threading\n\nclass ThreadSafePriceService:\n    def __init__(self):\n        self.cache = {}\n        self.lock = threading.Lock()\n    \n    def get_price(self, currency='USD'):\n        with self.lock:\n            # Check cache\n            if currency in self.cache:\n                price, timestamp = self.cache[currency]\n                if time.time() - timestamp < 60:\n                    return price\n            \n            # Fetch new price\n            price = self._fetch_price(currency)\n            self.cache[currency] = (price, time.time())\n            return price\n```\n\n## Best Practices\n\n### For Developers\n\n1. **Use Caching**: Reduce API calls\n2. **Implement Fallbacks**: Multiple data sources\n3. **Rate Limiting**: Respect API limits\n4. **Error Handling**: Handle all error cases\n5. **Thread Safety**: Support concurrent access\n\n### For Performance\n\n1. **Cache Duration**: Balance freshness vs. API calls\n2. **Batch Requests**: Request multiple currencies at once\n3. **Connection Pooling**: Reuse HTTP connections\n4. **Async Operations**: Use async/await for I/O\n\n## Common Issues\n\n### Rate Limit Exceeded\n\n**Problem**: API rate limit reached\n\n**Solutions:**\n- Implement caching\n- Use multiple API sources\n- Reduce request frequency\n- Upgrade API tier (if available)\n\n### Stale Data\n\n**Problem**: Cached data too old\n\n**Solutions:**\n- Reduce cache duration\n- Implement cache invalidation\n- Add timestamp checks\n- Force refresh option\n\n### API Downtime\n\n**Problem**: API service unavailable\n\n**Solutions:**\n- Implement fallback sources\n- Use cached data\n- Retry with exponential backoff\n- Monitor API status\n\n## Summary\n\nPrice tracking requires:\n\n- **API Integration**: Multiple data sources\n- **Caching**: Reduce API calls and improve performance\n- **Rate Limiting**: Respect API limits\n- **Fallbacks**: Multiple sources for reliability\n- **Error Handling**: Handle all error cases\n- **Thread Safety**: Support concurrent access\n\nUnderstanding price tracking helps build robust applications that integrate Bitcoin price data efficiently.\n",
    "filename": "price-tracking.md"
  },
  "/docs/controversies/op-return": {
    "content": "# The OP_RETURN Debate: Bitcoin as Database vs. Financial Network\n\nAn analysis of the ongoing debate about OP_RETURN, carrier size limits, and Bitcoin's fundamental purpose.\n\n---\n\n## What is OP_RETURN?\n\n### Basic Function\n\n`OP_RETURN` is a Bitcoin Script opcode that creates **provably unspendable outputs**. When executed, it immediately terminates script execution and marks the transaction as invalid.\n\n**Script Pattern:**\n```\nOP_RETURN <data>\n```\n\n**Key Characteristics:**\n- Outputs are **unspendable** - they cannot be used as inputs in future transactions\n- Data is **permanently stored** on the blockchain (immutable)\n- Data does **not contribute to UTXO set** - can be pruned by nodes\n- Originally limited to **80 bytes** of data per output\n\n### How It Works Technically\n\n1. **Script Execution:**\n   - When `OP_RETURN` is encountered, script execution immediately fails\n   - Transaction is marked as invalid (cannot be spent)\n   - But the transaction itself is still valid and included in blocks\n\n2. **Data Storage:**\n   - Data follows `OP_RETURN` in the script\n   - Stored in the transaction output's `scriptPubKey`\n   - Permanently recorded in blockchain history\n\n3. **UTXO Set Impact:**\n   - Since outputs are unspendable, they don't add to UTXO set\n   - Nodes can prune OP_RETURN data after validation\n   - Reduces long-term storage burden compared to regular outputs\n\n**Example:**\n```\nOP_RETURN 48656c6c6f20576f726c64  (hex for \"Hello World\")\n```\n\n---\n\n## The Technical Reality\n\n### Current Implementation (Bitcoin Core v30+)\n\n#### Default Limits\n\n**Before v30 (Historical):**\n- Default limit: **80 bytes** per OP_RETURN output\n- Configurable via `-datacarriersize` parameter\n- Multiple OP_RETURN outputs allowed, but total size limited\n\n**After v30 (Current):**\n- Default limit: **~1 MB** (MAX_STANDARD_TX_WEIGHT / WITNESS_SCALE_FACTOR)\n- Effectively: Up to **~4 MB** per transaction (block size limit)\n- Configurable via `-datacarriersize` parameter\n- Can be disabled entirely with `-datacarrier=0`\n\n#### Key Technical Points\n\n1. **Policy, Not Consensus:** OP_RETURN limits are **relay policy**, not consensus rules\n   - Nodes can reject transactions as \"non-standard\"\n   - But if included in a block, they're still valid\n   - Miners can include non-standard transactions if they choose\n\n2. **Cumulative Limit:** The limit applies to **total size** across all OP_RETURN outputs in a transaction\n   - Not per-output, but total across all outputs\n   - Multiple OP_RETURN outputs are allowed\n\n3. **Configurable:** Node operators can set their own limits\n   - `-datacarrier=0` disables OP_RETURN entirely\n   - `-datacarriersize=<bytes>` sets custom limit\n   - Default changed from 80 bytes to ~1 MB in v30\n\n### Script Size Limits\n\n**Consensus Limits (Hard):**\n- Maximum script size: **10,000 bytes** (consensus rule)\n- Maximum script element size: **520 bytes** (for most opcodes)\n- Maximum transaction size: **4 MB** (block size limit)\n\n**Policy Limits (Soft):**\n- Standard transaction weight: **400,000 weight units** (~100 KB virtual size)\n- OP_RETURN data carrier size: Configurable (default ~1 MB in v30)\n\n---\n\n## The Historical Context\n\n### 2009-2013: Early Days\n\n- **No OP_RETURN:** Initially, people used other methods to store data\n  - Encoding data in addresses (P2PKH outputs)\n  - Using fake addresses with embedded data\n  - These methods bloated the UTXO set\n\n### 2014: OP_RETURN Introduced\n\n- **BIP Proposal:** Introduced to provide a clean way to store data\n- **Purpose:** Enable timestamping, asset protocols, messages\n- **Initial Limit:** 40 bytes (very restrictive)\n- **Rationale:** Prevent blockchain bloat while allowing legitimate use cases\n\n### 2015: Limit Increased to 80 Bytes\n\n- **Community Consensus:** Increased to 80 bytes\n- **Use Cases:** \n  - Timestamping documents\n  - Proof of existence\n  - Small metadata\n  - Early token protocols\n\n### 2017-2024: Status Quo\n\n- **80-byte limit maintained** in Bitcoin Core\n- **Alternative implementations:** Some forks/alternatives had different limits\n- **Growing tension:** Between data storage advocates and financial purists\n\n### 2024-2025: The v30 Controversy\n\n- **Bitcoin Core v30:** Removed default 80-byte limit\n- **New default:** ~1 MB (effectively up to block size limit)\n- **Community split:** Major controversy and debate\n- **Alternative implementations:** Bitcoin Knots maintains stricter limits\n\n---\n\n## The Recent Controversy\n\n### Bitcoin Core v30 Changes\n\n**What Changed:**\n- Default `-datacarriersize` increased from 80 bytes to ~1 MB\n- Effectively allows up to 4 MB of data per transaction (block size limit)\n- Can still be configured by node operators\n\n**Why the Change:**\n- Proponents argued 80 bytes was arbitrary and limiting\n- Modern use cases need more data (NFTs, complex protocols, etc.)\n- Users pay fees, so they should decide how to use block space\n\n### Community Reaction\n\n**Supporters:**\n- Innovation advocates\n- Protocol developers building on Bitcoin\n- Those who see Bitcoin as a platform, not just money\n\n**Opponents:**\n- Bitcoin maximalists focused on \"sound money\"\n- Node operators concerned about costs\n- Those who see this as mission creep\n\n**Result:**\n- **Bitcoin Core:** Implemented the change\n- **Bitcoin Knots:** Maintained stricter 80-byte default\n- **Community:** Deeply divided, ongoing debate\n\n---\n\n## Arguments For Increasing Limits\n\n### 1. \"Users Pay Fees\"\n\n**Argument:**\n- If users are willing to pay transaction fees, they should be able to use block space as they see fit\n- Market forces (fees) will naturally limit abuse\n- No one is forced to store the data - nodes can prune\n\n**Technical Support:**\n- OP_RETURN outputs don't bloat UTXO set (unspendable)\n- Data can be pruned after validation\n- Fees compensate miners for including data\n\n### 2. Innovation and Utility\n\n**Argument:**\n- Enables new use cases:\n  - Document timestamping\n  - Proof of existence\n  - Decentralized identity\n  - Asset protocols\n  - NFT metadata\n- Bitcoin should evolve and support innovation\n\n**Examples:**\n- Counterparty protocol (built on Bitcoin)\n- Omni Layer (USDT originally on Bitcoin)\n- Various timestamping services\n\n### 3. Technical Feasibility\n\n**Argument:**\n- Modern hardware can handle larger blockchains\n- Storage is cheap and getting cheaper\n- Bandwidth has improved significantly\n- Pruning makes it manageable\n\n**Data:**\n- Full node storage: ~500 GB (2024)\n- Pruned node: ~10 GB\n- Storage costs: ~$10-50/year\n\n### 4. Consistency with Block Size\n\n**Argument:**\n- If blocks can be 4 MB, why limit OP_RETURN to 80 bytes?\n- Inconsistent policy\n- Should align with actual block capacity\n\n### 5. Censorship Resistance\n\n**Argument:**\n- Limiting data storage is a form of censorship\n- Bitcoin should be permissionless\n- Who decides what's \"legitimate\" use?\n\n---\n\n## Arguments Against Increasing Limits\n\n### 1. Mission Creep\n\n**Argument:**\n- Bitcoin's purpose is to be \"sound money\"\n- Adding data storage dilutes the mission\n- Should focus on financial transactions, not general data storage\n\n### 2. Blockchain Bloat\n\n**Argument:**\n- Larger blockchain = higher costs for node operators\n- Slower initial sync times\n- More bandwidth required\n- Centralization risk (fewer people can run nodes)\n\n**Technical Reality:**\n- Full blockchain: ~500 GB and growing\n- Each 1 MB of data = permanent storage cost\n- Sync time already takes days/weeks for new nodes\n\n### 3. Spam and Abuse\n\n**Argument:**\n- Larger limits enable spam attacks\n- Malicious actors could fill blocks with garbage data\n- Legal risks (illegal content stored permanently)\n- No way to remove bad data\n\n**Examples of Potential Abuse:**\n- Storing illegal content (child abuse material, etc.)\n- Spam attacks filling blocks\n- Protest messages\n- Corporate advertising\n\n### 4. Node Operator Costs\n\n**Argument:**\n- Node operators bear the cost\n- Not just storage, but bandwidth, CPU, electricity\n- Could lead to centralization\n- Fewer nodes = less decentralization\n\n**Cost Breakdown:**\n- Storage: ~$10-50/year (cheap)\n- Bandwidth: Variable, can be significant\n- CPU: Minimal for validation\n- Electricity: ~$50-200/year\n\n### 5. Legal and Regulatory Risks\n\n**Argument:**\n- Storing illegal content creates legal liability\n- Node operators might be legally responsible\n- Could lead to Bitcoin being banned in some jurisdictions\n- Regulatory scrutiny increases\n\n### 6. Fee Market Distortion\n\n**Argument:**\n- Large data transactions compete with financial transactions\n- Could drive up fees for regular users\n- Distorts the fee market\n- Financial transactions should have priority\n\n---\n\n## Technical Implications\n\n### Storage Impact\n\n**Current Blockchain Size:**\n- ~500 GB (2024)\n- Growing ~50-100 GB per year\n- With increased OP_RETURN: Could grow faster\n\n**Pruning:**\n- OP_RETURN data can be pruned\n- But initial download still requires full chain\n- Historical data still stored by archival nodes\n\n### Network Impact\n\n**Bandwidth:**\n- Larger transactions = more bandwidth\n- Affects initial sync time\n- Ongoing bandwidth for new blocks\n- Could slow down network propagation\n\n**UTXO Set Impact:**\n- **Good News:** OP_RETURN outputs don't add to UTXO set\n- **Bad News:** Still stored in blockchain, still needs validation, still consumes block space\n\n### Fee Market Impact\n\n**Competition for Block Space:**\n- OP_RETURN transactions compete with financial transactions\n- If fees are high, data storage becomes expensive\n- If fees are low, could enable spam\n\n---\n\n## The Philosophical Divide\n\n### Two Competing Visions\n\n#### Vision 1: Bitcoin as \"Sound Money\"\n\n**Core Belief:**\n- Bitcoin should be focused solely on being digital gold\n- Financial transactions are the priority\n- Data storage is a distraction\n- \"Do one thing well\"\n\n**Key Principles:**\n- Minimalism\n- Focus on core function\n- Avoid mission creep\n- Preserve decentralization\n\n#### Vision 2: Bitcoin as a Platform\n\n**Core Belief:**\n- Bitcoin should be a versatile platform\n- Enable innovation and new use cases\n- Data storage is a feature, not a bug\n- \"Build on Bitcoin\"\n\n**Key Principles:**\n- Flexibility\n- Innovation-friendly\n- Permissionless\n- User choice\n\n### The Fundamental Question\n\n**\"What is Bitcoin for?\"**\n\nThis is the core question that divides the community:\n\n1. **Is Bitcoin money?** (Sound money vision)\n2. **Is Bitcoin a platform?** (Innovation vision)\n3. **Can it be both?** (Compromise position)\n\n---\n\n## Current Status and Alternatives\n\n### Bitcoin Core (v30+)\n\n**Status:**\n- Default limit: ~1 MB (effectively up to block size)\n- Configurable by node operators\n- Change implemented in v30\n\n**Configuration:**\n```bash\n# Disable OP_RETURN entirely\n-datacarrier=0\n\n# Set custom limit (in bytes)\n-datacarriersize=80\n\n# Use default (~1 MB)\n# (no configuration needed)\n```\n\n### Bitcoin Knots\n\n**Status:**\n- Maintains 80-byte default limit\n- Stricter policy\n- Alternative implementation for those who disagree with Core\n\n### Other Alternatives\n\n**1. Sidechains:**\n- Store data on separate chains\n- Pegged to Bitcoin\n- Examples: Liquid, Rootstock\n\n**2. Layer 2 Solutions:**\n- Lightning Network (for payments)\n- Other L2s for data storage\n\n**3. Separate Protocols:**\n- Build data storage on separate blockchains\n- Reference Bitcoin for security\n- Examples: IPFS, Arweave\n\n**4. Off-Chain Solutions:**\n- Store data outside blockchain\n- Hash references on-chain\n- Best of both worlds\n\n---\n\n## Conclusion\n\nThe OP_RETURN debate represents a fundamental philosophical divide in the Bitcoin community:\n\n**Technical Reality:**\n- OP_RETURN limits are **policy, not consensus**\n- Can be configured by node operators\n- Data can be pruned (doesn't bloat UTXO set)\n- But still consumes block space and bandwidth\n\n**Philosophical Divide:**\n- **Sound Money:** Bitcoin should focus on financial transactions\n- **Platform:** Bitcoin should enable innovation and data storage\n- **Compromise:** Some data storage is OK, but with limits\n\n**Current Status:**\n- Bitcoin Core v30: Larger default limits (~1 MB)\n- Bitcoin Knots: Maintains 80-byte default\n- Community: Deeply divided\n- Future: Unclear, likely ongoing debate\n\n**The Core Question:**\nWhat is Bitcoin's fundamental purpose? The answer to this question determines where you stand on OP_RETURN limits, and this debate will likely continue as long as Bitcoin exists.\n",
    "filename": "debate.md"
  },
  "/docs/controversies/blocksize-wars": {
    "content": "# The Blocksize Wars\n\nThe Blocksize Wars (2015-2017) were a period of intense debate and conflict within the Bitcoin community over whether to increase Bitcoin's block size limit. This controversy ultimately led to the hard fork that created Bitcoin Cash and fundamentally shaped Bitcoin's development philosophy.\n\n## The Core Issue\n\n### The Problem\n\nBitcoin's block size was limited to **1 MB** (set by Satoshi Nakamoto in 2010). As Bitcoin adoption grew, this limit became a bottleneck:\n\n- **Transaction Backlog**: Transactions waiting hours or days for confirmation\n- **Rising Fees**: Fees increased as users competed for limited block space\n- **Scalability Concerns**: Could Bitcoin handle global adoption with 1 MB blocks?\n\n### The Question\n\n**Should Bitcoin increase its block size limit?**\n\nThis seemingly simple question divided the community into two camps with fundamentally different visions for Bitcoin's future.\n\n## The Two Sides\n\n### Big Blockers\n\n**Core Belief:**\n- Bitcoin should scale on-chain\n- Increase block size to handle more transactions\n- Keep all transactions on the main chain\n- Lower fees through increased capacity\n\n**Proposed Solutions:**\n- Increase to 2 MB, 8 MB, or even 32 MB blocks\n- Remove block size limit entirely\n- Let the market decide optimal block size\n\n**Key Advocates:**\n- Bitcoin XT (2 MB proposal)\n- Bitcoin Classic (2 MB proposal)\n- Bitcoin Unlimited (removable limit)\n- Bitcoin Cash (8 MB, later increased)\n\n### Small Blockers\n\n**Core Belief:**\n- Bitcoin should scale off-chain\n- Keep blocks small to preserve decentralization\n- Use Layer 2 solutions (Lightning Network)\n- Maintain low node operation costs\n\n**Proposed Solutions:**\n- Keep 1 MB limit\n- Implement Segregated Witness (SegWit)\n- Build Lightning Network for scaling\n- Optimize transaction efficiency\n\n**Key Advocates:**\n- Bitcoin Core developers\n- Most node operators\n- Decentralization-focused community\n\n## Timeline of Events\n\n### 2010: The 1 MB Limit\n\n- **Satoshi Nakamoto** sets 1 MB block size limit\n- Initially a spam protection measure\n- Blocks were mostly empty at the time\n- Limit was meant to be temporary\n\n### 2015: Early Proposals\n\n**Bitcoin XT (August 2015)**\n- Proposed increasing to 2 MB, then 8 MB\n- Required 75% miner support\n- Controversial hard fork proposal\n- Rejected by community\n\n**Bitcoin Classic (January 2016)**\n- Proposed 2 MB block size increase\n- Simpler proposal than XT\n- Gained some miner support\n- Eventually abandoned\n\n### 2016: Bitcoin Unlimited\n\n**Bitcoin Unlimited (March 2016)**\n- Proposed removing block size limit entirely\n- Let miners vote on block size\n- \"Emergent consensus\" mechanism\n- Gained significant miner support (~30-40%)\n\n### 2017: The Resolution\n\n**SegWit Activation (August 2017)**\n- Segregated Witness soft fork activated\n- Increased effective block capacity to ~2 MB\n- Fixed transaction malleability\n- Enabled Lightning Network\n\n**Bitcoin Cash Hard Fork (August 1, 2017)**\n- Big blockers created Bitcoin Cash (BCH)\n- 8 MB block size limit\n- Separate blockchain from Bitcoin\n- Permanent chain split\n\n## Key Arguments\n\n### Arguments for Bigger Blocks\n\n1. **On-Chain Scaling**\n   - More transactions per block = lower fees\n   - Simpler solution (no complex Layer 2)\n   - Users want on-chain transactions\n\n2. **User Experience**\n   - Faster confirmations\n   - Lower fees\n   - Better for everyday payments\n\n3. **Technical Feasibility**\n   - Storage is cheap\n   - Bandwidth has improved\n   - Modern hardware can handle larger blocks\n\n4. **Satoshi's Vision**\n   - Satoshi mentioned increasing block size\n   - Was meant to be temporary limit\n   - Should adapt to demand\n\n### Arguments for Small Blocks\n\n1. **Decentralization**\n   - Larger blocks = higher node operation costs\n   - Fewer people can run full nodes\n   - Centralization risk\n\n2. **Network Security**\n   - Slower block propagation with larger blocks\n   - More orphan blocks\n   - Weaker network security\n\n3. **Off-Chain Scaling**\n   - Lightning Network can handle millions of transactions\n   - On-chain for settlement, off-chain for payments\n   - Better long-term solution\n\n4. **Economic Security**\n   - Higher fees = better security\n   - Miners need fees after halvings\n   - Fee market is important\n\n## Technical Details\n\n### Block Size Limits\n\n**Bitcoin (BTC):**\n- Base block size: 1 MB\n- With SegWit: ~2-4 MB effective capacity\n- Weight limit: 4,000,000 weight units\n\n**Bitcoin Cash (BCH):**\n- Started: 8 MB\n- Current: 32 MB\n- Plans for even larger blocks\n\n### SegWit Solution\n\nSegregated Witness (SegWit) was the compromise solution:\n\n- **Soft Fork**: Backward compatible\n- **Witness Data**: Moved outside base block\n- **Effective Capacity**: ~2 MB (up to 4 MB with witness)\n- **Transaction Malleability**: Fixed\n- **Lightning Network**: Enabled\n\n### Network Metrics\n\n**Bitcoin (BTC) - 2024:**\n- Average block size: ~1.5-2 MB (with SegWit)\n- Transactions per block: ~2,000-3,000\n- Average fee: Variable ($1-50+)\n- Full node count: ~15,000-20,000\n\n**Bitcoin Cash (BCH) - 2024:**\n- Average block size: ~100-500 KB\n- Transactions per block: ~500-2,000\n- Average fee: Very low (<$0.01)\n- Full node count: ~1,000-2,000\n\n## The Outcome\n\n### Bitcoin (BTC) Won\n\n**Results:**\n- Maintained 1 MB base block size\n- Implemented SegWit for scaling\n- Lightning Network developed\n- Focus on decentralization preserved\n\n**Current Status:**\n- ~80% of transactions use SegWit\n- Lightning Network growing\n- Fees remain variable but manageable\n- Strong decentralization\n\n### Bitcoin Cash (BCH) Split\n\n**Results:**\n- Created separate blockchain\n- 8 MB blocks (later increased to 32 MB)\n- Lower fees but less decentralization\n- Smaller network and ecosystem\n\n**Current Status:**\n- Separate cryptocurrency\n- Lower market cap than Bitcoin\n- Different development path\n- Still active but smaller community\n\n## Lessons Learned\n\n### 1. Hard Forks Are Risky\n- Created permanent chain split\n- Divided community and resources\n- Both chains continue separately\n\n### 2. Soft Forks Preferred\n- SegWit was a soft fork (backward compatible)\n- No chain split\n- Gradual adoption\n\n### 3. Decentralization Matters\n- Small block supporters prioritized decentralization\n- This has proven important for Bitcoin's security\n- Node count remains high\n\n### 4. Scaling Solutions Evolve\n- Lightning Network emerged as solution\n- Multiple approaches can coexist\n- Innovation continues\n\n## Impact on Bitcoin\n\n### Positive Outcomes\n\n1. **Clarified Vision**: Bitcoin's focus on decentralization was reinforced\n2. **SegWit Activation**: Enabled Lightning Network and other innovations\n3. **Community Cohesion**: Core developers and community aligned\n4. **Innovation**: Led to development of Layer 2 solutions\n\n### Negative Outcomes\n\n1. **Community Division**: Deep split that still exists\n2. **Resources Split**: Development resources divided\n3. **Confusion**: Users confused about different Bitcoin versions\n4. **Delayed Scaling**: Took years to resolve\n\n## Current Status\n\n### Bitcoin (BTC)\n- **Block Size**: 1 MB base, ~2-4 MB with SegWit\n- **Scaling**: Lightning Network + SegWit\n- **Philosophy**: Decentralization first\n- **Status**: Dominant Bitcoin implementation\n\n### Bitcoin Cash (BCH)\n- **Block Size**: 32 MB\n- **Scaling**: On-chain only\n- **Philosophy**: Big blocks, low fees\n- **Status**: Separate cryptocurrency\n\n## Related Topics\n\n- [OP_RETURN Debate](/docs/controversies/op-return) - Another major Bitcoin controversy\n- [History: Forks](/docs/history/forks) - Complete fork history including Bitcoin Cash\n- [Lightning Network](/docs/lightning) - The scaling solution that emerged\n",
    "filename": "blocksize-wars.md"
  },
  "/docs/controversies/energy-consumption": {
    "content": "# Energy Consumption\n\nBitcoin's energy consumption is one of the most debated topics in the cryptocurrency space. Critics argue that Bitcoin uses too much energy, while supporters point out that energy use is a security feature and that Bitcoin's consumption should be viewed in context with other global energy uses.\n\n## The Energy Debate\n\n### Energy Use Is Not Inherently Bad\n\nUsing energy is not a moral failing. It is the signature of civilization.\n\nThe Kardashev scale measures a civilization's advancement by its energy consumption. A Type I civilization harnesses all energy available on its planet. A Type II harnesses its star. A Type III harnesses its galaxy. By this measure, using *more* energy is not regression. It is evolution.\n\nEvery advancement in human history has required more energy: fire, agriculture, industry, computing, space exploration. The question has never been \"are we using too much energy?\" but rather \"are we using energy for things that matter?\"\n\n### The \"Too Much Energy\" Argument\n\nWhen someone says \"Bitcoin uses too much energy,\" they are not making a technical argument. They are making a **moral argument**: \"I don't think Bitcoin is valuable enough to justify its energy use.\"\n\nThis is an opinion about Bitcoin's worth, not a statement about physics or economics. Energy is neutral. It flows to wherever humans direct it.\n\nConsider what humanity chooses to spend energy on:\n\n- **Holiday lights**: ~200 TWh annually (more than Bitcoin)\n- **US military**: Trillions of dollars and immense energy to project force globally\n- **Air conditioning in the US alone**: ~6,500 TWh (50x Bitcoin's consumption)\n- **The global financial system**: ~5,000 TWh maintaining the infrastructure of fiat money\n\nIf Bitcoin's energy use is \"wasteful,\" then we must also ask: Is air conditioning wasteful? Are holiday lights? Is the military? These are not questions with objective answers, they are value judgments.\n\n### What Bitcoin's Energy Actually Does\n\nBitcoin's energy consumption is not waste. It performs a specific, irreplaceable function:\n\n- **Secures a global, permissionless monetary network**\n- **Provides financial sovereignty to billions of people**\n- **Creates a store of value immune to inflation and seizure**\n- **Enables instant, borderless value transfer**\n\nThe energy expenditure is the cost of removing trust from money. It replaces armies, banks, courts, and governments with mathematics and thermodynamics.\n\n### The Real Question\n\nThe debate is not about energy, it's about whether you believe Bitcoin is valuable.\n\nIf you believe a decentralized, censorship-resistant, inflation-proof monetary system is valuable, then Bitcoin's energy consumption is a bargain. If you don't believe Bitcoin is valuable, no amount of energy would be acceptable.\n\nThis is why the energy debate is ultimately unproductive. It disguises a subjective value judgment as an objective technical criticism. Those who oppose Bitcoin will always say it uses \"too much\" energy. Those who understand it will recognize that the energy is precisely what makes it work.\n\n## Energy Use as a Security Feature\n\nBitcoin's proof-of-work mechanism requires significant computational resources, which translates to energy consumption. This is by design:\n\n- **Attack Cost**: To attack Bitcoin, an attacker would need to control more than 50% of the network's hash rate, requiring enormous energy investment\n- **Economic Security**: The cost of energy creates a real economic barrier to attacks\n- **Decentralization**: High energy costs prevent any single entity from controlling the network\n\n## Renewable Energy Usage\n\nBitcoin mining has increasingly moved toward renewable energy sources:\n\n- **Hydroelectric Power**: Many mining operations use excess hydroelectric power\n- **Solar and Wind**: Mining operations located near renewable energy sources\n- **Flared Gas**: Some miners use otherwise-wasted natural gas from oil production\n- **Grid Balancing**: Mining can help balance renewable energy grids by consuming excess power\n\nAccording to the Bitcoin Mining Council (Q4 2021), Bitcoin mining used approximately 58.5% renewable energy.\n\n## Energy Consumption in Context\n\nTo understand Bitcoin's energy consumption, it's helpful to compare it with other global energy uses. The following data is from 2021:\n\n### Global Energy Consumption Comparison\n\n| Sector | Annual Energy Consumption (TWh) | Notes |\n|--------|----------------------------------|-------|\n| **Total Global Energy** | ~165,000 TWh | All energy uses worldwide |\n| **Residential Buildings** | ~26,000 TWh | Global residential energy use |\n| **Air Conditioning (US alone)** | ~6,500 TWh | US air conditioning energy use (350 million people in America use more electricity for cooling than 1.1 billion people in Africa for everything) |\n| **Construction** | ~6,000 TWh | Global construction industry |\n| **Finance & Insurance** | ~5,000 TWh | Global financial services sector |\n| **Aviation** | ~4,000 TWh | Global aviation industry |\n| **Banking** | ~750 TWh | Global banking sector |\n| **Gold Mining** | ~500 TWh | Global gold mining industry |\n| **Holiday Lights (US alone)** | ~200 TWh | US holiday lighting energy use |\n| **Bitcoin** | ~100-150 TWh | Bitcoin network (2021 estimate) |\n| **US Military** | ~30 TWh | US military energy consumption (30,000 GWh) |\n\n### Key Observations\n\n1. **Bitcoin's Relative Size**: Bitcoin's energy consumption (~100-150 TWh) is a small fraction of global energy use (~165,000 TWh), representing approximately 0.06-0.09% of total global energy consumption.\n\n2. **Comparison to Other Industries**: Bitcoin uses less energy than:\n   - Residential buildings (26,000 TWh)\n   - US air conditioning alone (6,500 TWh)\n   - Construction industry (6,000 TWh)\n   - Finance & Insurance (5,000 TWh)\n   - Aviation (4,000 TWh)\n   - Banking (750 TWh)\n   - Gold mining (500 TWh)\n\n3. **Perspective**: US holiday lights alone consume more energy (~200 TWh) than Bitcoin's entire network (~100-150 TWh).\n\n## Energy Efficiency Trends\n\nBitcoin mining has become more energy-efficient over time:\n\n- **Hardware Improvements**: ASIC miners have become more efficient\n- **Renewable Energy Adoption**: Increasing use of renewable energy sources\n- **Hash Rate Efficiency**: More hash power per unit of energy consumed\n- **Mining Pool Optimization**: Better coordination reduces wasted computation\n\n## The Value Proposition\n\nSupporters argue that Bitcoin's energy consumption is justified by the value it provides:\n\n- **Financial Sovereignty**: Enables censorship-resistant, borderless transactions\n- **Store of Value**: Provides a decentralized alternative to traditional monetary systems\n- **Network Security**: Energy consumption directly translates to network security\n- **Global Access**: Provides financial services to unbanked populations\n\n## Environmental Concerns\n\n### Carbon Emissions\n\nThe environmental impact depends on the energy sources used:\n\n- **Renewable Energy**: Minimal carbon footprint\n- **Fossil Fuels**: Higher carbon emissions\n- **Mixed Sources**: Impact varies by region and energy mix\n\n### Mitigation Strategies\n\n- **Renewable Energy**: Increasing adoption of renewable energy sources\n- **Carbon Offsets**: Some mining operations purchase carbon offsets\n- **Efficiency Improvements**: Ongoing hardware and operational efficiency gains\n- **Location Optimization**: Mining operations moving to areas with excess renewable energy\n\n## Future Outlook\n\n### Potential Changes\n\n- **Renewable Energy Growth**: As renewable energy becomes cheaper, mining will likely use more renewables\n- **Efficiency Gains**: Continued hardware improvements will increase efficiency\n- **Regulation**: Some jurisdictions may regulate mining energy use\n- **Technology**: Potential improvements in mining efficiency\n\n### Sustainability\n\nThe long-term sustainability of Bitcoin's energy consumption depends on:\n\n- **Renewable Energy Adoption**: How quickly mining moves to renewable sources\n- **Efficiency Improvements**: Rate of hardware and operational efficiency gains\n- **Network Growth**: How Bitcoin's energy consumption scales with adoption\n- **Regulatory Environment**: How governments regulate mining energy use\n\n## Conclusion\n\nBitcoin's energy consumption is a complex topic with valid arguments on both sides. While Bitcoin does consume significant energy, it's important to view this consumption in context:\n\n- Bitcoin uses a relatively small fraction of global energy\n- Energy consumption is a security feature, not a bug\n- Mining increasingly uses renewable energy sources\n- The value provided by Bitcoin may justify its energy use\n\nThe debate over Bitcoin's energy consumption will likely continue as the network grows and evolves. Understanding both the criticisms and defenses helps form a balanced perspective on this controversial topic.\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - How Bitcoin's consensus mechanism works\n- [Mining Economics](/docs/mining/economics) - Economic incentives in Bitcoin mining\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - Another major Bitcoin controversy\n\n## Resources\n\n- [Bitcoin Mining Council](https://bitcoinminingcouncil.com/) - Industry group tracking Bitcoin mining energy use\n- [Cambridge Bitcoin Electricity Consumption Index](https://ccaf.io/cbeci/index) - Real-time Bitcoin energy consumption estimates\n- [Bitcoin Energy Consumption](https://digiconomist.net/bitcoin-energy-consumption) - Alternative energy consumption estimates\n",
    "filename": "energy-consumption.md"
  },
  "/docs/controversies/mt-gox": {
    "content": "# Mt. Gox Collapse\n\nMt. Gox was once the world's largest Bitcoin exchange, handling over 70% of all Bitcoin transactions at its peak. In February 2014, it collapsed spectacularly, losing approximately 850,000 BTC (worth ~$450 million at the time, and tens of billions at later prices). The Mt. Gox disaster became Bitcoin's defining cautionary tale and permanently shaped how the community thinks about custody, exchange security, and the principle of \"not your keys, not your coins.\"\n\n## The Rise of Mt. Gox\n\n### Origins\n\nMt. Gox began as a trading platform for Magic: The Gathering cards (the name stands for \"Magic: The Gathering Online eXchange\"). In 2010, programmer Jed McCaleb repurposed it as a Bitcoin exchange when Bitcoin was still worth pennies.\n\nIn 2011, McCaleb sold Mt. Gox to Mark KarpelÃ¨s, a French developer living in Japan. Under KarpelÃ¨s, the exchange grew rapidly alongside Bitcoin's rising price and popularity.\n\n### Dominance\n\nBy 2013, Mt. Gox was:\n- Handling 70%+ of global Bitcoin trading volume\n- The primary price discovery mechanism for Bitcoin\n- The de facto \"Bitcoin exchange\" for most users worldwide\n\nThis concentration of power in a single exchange was a ticking time bomb.\n\n## The Collapse\n\n### Warning Signs\n\nProblems had been brewing for years:\n\n- **2011 Hack**: Mt. Gox was hacked, losing 25,000 BTC. This was kept quiet.\n- **Withdrawal Delays**: Users increasingly reported slow or failed withdrawals throughout 2013.\n- **Banking Issues**: Traditional banks were reluctant to work with Mt. Gox, causing fiat withdrawal problems.\n- **Technical Incompetence**: The codebase was reportedly a mess, with poor security practices.\n\n### The Final Days\n\nIn February 2014, events accelerated:\n\n1. **February 7**: Mt. Gox halted all Bitcoin withdrawals, citing \"transaction malleability\" issues.\n2. **February 10**: Other exchanges issued a joint statement distancing themselves from Mt. Gox.\n3. **February 24**: The website went completely offline.\n4. **February 25**: A leaked document revealed Mt. Gox had lost 744,408 BTC from customer deposits plus 100,000 of its own BTC.\n5. **February 28**: Mt. Gox filed for bankruptcy protection in Tokyo.\n\n### The Missing Bitcoin\n\nThe total loss was approximately:\n- **744,408 BTC** from customer accounts\n- **100,000 BTC** owned by Mt. Gox\n- **~$28 million** in fiat currency\n\nAt 2014 prices (~$450/BTC), this was about $450 million. At Bitcoin's 2021 peak (~$69,000/BTC), the lost coins would have been worth over $58 billion.\n\n## What Happened?\n\n### The Official Story\n\nMt. Gox blamed \"transaction malleability\", a known Bitcoin quirk where transaction IDs could be changed before confirmation without invalidating the transaction. The exchange claimed hackers exploited this to steal Bitcoin over time.\n\n### The Reality\n\nInvestigations revealed a more damning picture:\n\n- **Theft Over Years**: The Bitcoin had been draining from Mt. Gox wallets since at least 2011.\n- **Poor Security**: Private keys were stored insecurely. The codebase was amateurish.\n- **No Audits**: Mt. Gox never conducted proper audits that would have revealed the missing funds.\n- **Possible Inside Job**: Some investigators believe insiders were involved in the theft.\n\nIn 2015, Mark KarpelÃ¨s was arrested in Japan on charges of embezzlement and data manipulation (though not directly for the Bitcoin theft). He was eventually convicted of data manipulation but acquitted of embezzlement.\n\n## The Aftermath\n\n### Victims\n\nApproximately 24,000 creditors lost funds. Many were early Bitcoin adopters who had their entire holdings on the exchange. The bankruptcy proceedings have dragged on for nearly a decade.\n\n### Bitcoin Price Impact\n\nBitcoin's price crashed from ~$850 to under $400 in the months following the collapse. The broader cryptocurrency market was shaken.\n\n### Recovery Efforts\n\nIn a twist of fate, 200,000 BTC were later \"found\" in old Mt. Gox wallets. Combined with Bitcoin's price appreciation, the bankruptcy estate eventually had enough to potentially repay creditors in full, though the legal process has taken years.\n\nCreditor repayments finally began in 2024, over a decade after the collapse.\n\n## Lessons Learned\n\n### \"Not Your Keys, Not Your Coins\"\n\nThe Mt. Gox collapse became the defining argument for self-custody. When you leave Bitcoin on an exchange:\n- You don't own Bitcoin; you own an IOU\n- You trust the exchange's security, competence, and honesty\n- You have no recourse if they fail\n\nThis mantra became foundational to Bitcoin culture.\n\n### Exchange Security Standards\n\nThe industry responded with:\n- **Proof of Reserves**: Cryptographic audits showing exchanges hold customer funds\n- **Cold Storage**: Keeping most funds offline\n- **Multi-signature Wallets**: Requiring multiple keys to move funds\n- **Regular Audits**: Independent verification of holdings\n\n### Regulatory Awareness\n\nMt. Gox operated in a regulatory gray zone. Its collapse prompted:\n- Increased regulatory scrutiny of exchanges\n- Licensing requirements in many jurisdictions\n- Debates about consumer protection vs. Bitcoin's permissionless ethos\n\n## The Ongoing Saga\n\n### Bankruptcy Proceedings\n\nThe Mt. Gox bankruptcy has been one of the longest and most complex in cryptocurrency history:\n\n- **Civil Rehabilitation**: In 2018, proceedings converted from bankruptcy to civil rehabilitation, allowing creditors to receive Bitcoin rather than the (much lower) 2014 fiat value.\n- **Creditor Claims**: Complex legal battles over who is owed what.\n- **Distribution**: Final distribution began in 2024.\n\n### Market Impact\n\nEven a decade later, Mt. Gox affects markets:\n- Large creditor payouts create selling pressure fears\n- The \"Mt. Gox Bitcoin\" is tracked as a potential market-moving event\n- Each distribution milestone makes headlines\n\n## Historical Significance\n\nMt. Gox represents a pivotal moment in Bitcoin history:\n\n1. **End of Innocence**: Bitcoin's early, naive era ended. The community learned that enthusiasm wasn't enough; security and proper engineering mattered.\n\n2. **Decentralization Validated**: The collapse showed the danger of centralized points of failure, reinforcing Bitcoin's core philosophy.\n\n3. **Culture Defined**: \"Not your keys, not your coins\" became more than a slogan. It became a core principle of Bitcoin culture.\n\n4. **Industry Matured**: Surviving exchanges implemented better practices. New exchanges learned from Mt. Gox's failures.\n\n5. **Bitcoin Survived**: Despite losing the dominant exchange, Bitcoin itself continued. The network was unaffected. Only the centralized exchange failed; the decentralized protocol kept running.\n\n## Conclusion\n\nMt. Gox is the ghost that haunts every Bitcoin exchange. Its collapse cost early adopters billions of dollars and years of legal limbo. But it also taught the Bitcoin community invaluable lessons about the importance of self-custody, the dangers of centralization, and the difference between trusting Bitcoin the protocol and trusting businesses built on top of it.\n\nWhen you hear Bitcoiners say \"not your keys, not your coins,\" they're speaking the language of Mt. Gox survivors.\n\n## Related Topics\n\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - Another major Bitcoin controversy\n- [Energy Consumption](/docs/controversies/energy-consumption) - The energy debate\n- [OP_RETURN Debate](/docs/controversies/op-return) - Data storage on Bitcoin\n\n## Resources\n\n- [Mt. Gox Legal](https://www.mtgox.com/) - Official bankruptcy proceedings\n- [Wizsec Research](https://blog.wizsec.jp/) - Detailed investigation into the Mt. Gox hack\n",
    "filename": "mt-gox.md"
  },
  "/docs/controversies/craig-wright": {
    "content": "# Craig Wright / \"Faketoshi\"\n\nCraig Steven Wright is an Australian computer scientist who has claimed since 2016 to be Satoshi Nakamoto, the pseudonymous creator of Bitcoin. Despite years of assertions, lawsuits, and media appearances, Wright has never provided cryptographic proof of his claim. This is something the real Satoshi could trivially do by signing a message with Satoshi's known private keys.\n\nThe Bitcoin community overwhelmingly rejects Wright's claims, derisively calling him \"Faketoshi.\" His saga has become one of Bitcoin's strangest and most persistent controversies, involving forged documents, failed proofs, billion-dollar lawsuits, and the creation of Bitcoin SV (BSV).\n\n## The Claim\n\n### What Would Prove It\n\nThe real Satoshi Nakamoto has access to:\n- Private keys that mined the earliest Bitcoin blocks\n- The private key behind the genesis block\n- Keys controlling approximately 1 million unmoved BTC\n\nTo prove identity, Satoshi need only **sign a message** with one of these keys. This is trivial to do and impossible to fake. Every legitimate Bitcoiner would accept this as proof.\n\nCraig Wright has never done this.\n\n### What Wright Has Provided\n\nInstead of cryptographic proof, Wright has offered:\n- **Personal testimony**: \"Trust me, I'm Satoshi\"\n- **Documents**: Later shown to be backdated or forged\n- **Vague technical claims**: Often containing errors\n- **Private demonstrations**: To a few individuals, later disputed\n- **Legal threats**: Against anyone who publicly denies his claim\n\n## Timeline of Events\n\n### 2015: Initial Leaks\n\nIn December 2015, Wired and Gizmodo published articles suggesting Craig Wright might be Satoshi, based on leaked documents and emails. Within days, Australian police raided Wright's home (related to tax issues, not Bitcoin).\n\nInitial excitement quickly faded as researchers found problems with the \"evidence.\"\n\n### 2016: The Failed Proof\n\nIn May 2016, Wright came forward publicly, claiming to be Satoshi in interviews with the BBC and The Economist. He demonstrated a signature verification to several prominent Bitcoin figures, including [Gavin Andresen](/docs/history/people#gavin-andresen) (an early Bitcoin developer).\n\n**The problem**: Wright's \"proof\" was quickly debunked. He had used a signature that was already publicly available on the blockchain, not a new signature proving key access. It was a sleight of hand, not cryptographic proof.\n\nWhen challenged to provide real proof, Wright wrote a blog post promising to move coins from a known Satoshi address. The post was deleted and replaced with an apology, claiming he didn't have the \"courage\" to continue. He never provided the proof.\n\nGavin Andresen later said he was \"bamboozled\" and regretted supporting Wright's claim.\n\n### 2017: Bitcoin Cash and Drama\n\nWright became involved in the Bitcoin Cash (BCH) community after the August 2017 fork. He positioned himself as a thought leader, claiming his Satoshi status gave him authority.\n\n### 2018: Bitcoin SV Fork\n\nIn November 2018, Wright led a contentious hard fork of Bitcoin Cash, creating Bitcoin Satoshi Vision (BSV). The fork was accompanied by threats of a \"hash war\" to destroy the original BCH chain.\n\nBSV was explicitly designed around Wright's interpretation of Satoshi's \"vision\", primarily larger blocks and removing protocol changes. The fork was backed by Calvin Ayre, an online gambling billionaire who has been Wright's primary financial supporter.\n\n### 2019â€“2023: The Lawsuit Era\n\nWright launched an aggressive legal campaign:\n\n- **Kleiman v. Wright (2021)**: The estate of Dave Kleiman, a deceased computer forensics expert, sued Wright for half of Satoshi's Bitcoin (~1.1 million BTC). Wright claimed he and Kleiman mined early Bitcoin together. A Florida jury found Wright liable for $100 million related to a joint venture, but the verdict didn't confirm or deny Wright was Satoshi.\n\n- **COPA v. Wright (2024)**: The Crypto Open Patent Alliance (backed by companies including Square, Coinbase, and others) sued Wright seeking a declaration that he is not Satoshi. In February 2024, a UK judge ruled definitively that **Craig Wright is not Satoshi Nakamoto** and that he had forged documents to support his claims.\n\n- **Defamation Threats**: Wright has threatened or sued numerous individuals and organizations for calling him a fraud, including Bitcoin developers, podcasters, and Twitter users.\n\n### 2024: The Verdict\n\nIn the COPA v. Wright trial, UK High Court Justice Mellor delivered a comprehensive ruling:\n\n- Craig Wright is **not Satoshi Nakamoto**\n- Wright **forged documents** on a \"grand scale\"\n- His evidence was \"deliberately false\"\n- The ruling was \"emphatic\"\n\nThe judge didn't mince words, describing Wright's claims as \"a lie\" and his evidence as fabricated.\n\n## Evidence of Fraud\n\n### Forged Documents\n\nMultiple documents Wright presented as evidence have been proven to be backdated or fabricated:\n\n- **PGP keys**: Keys allegedly created in 2008 were shown to use cryptographic parameters that didn't exist until years later\n- **Blog posts**: Allegedly early writings about Bitcoin contained metadata showing they were created or modified much later\n- **Emails**: Headers and formatting inconsistent with claimed dates\n- **Academic papers**: Submitted to support his claims but containing anachronistic references\n\n### Failed Proofs\n\nEvery time Wright has been cornered into providing cryptographic proof, he has failed:\n\n- **May 2016**: Recycled a public signature instead of creating a new one\n- **Bonded Courier**: Claimed a bonded courier would deliver keys that would prove his identity; the courier never materialized\n- **Tulip Trust**: Claimed his Bitcoin was locked in a trust until 2020; when 2020 arrived, new excuses appeared\n\n### Technical Errors\n\nWright has made statements about Bitcoin that reveal misunderstandings a creator couldn't have:\n\n- Confused technical details about how Bitcoin works\n- Made claims about the protocol that are demonstrably false\n- Shown unfamiliarity with aspects of Bitcoin's design that Satoshi would know intimately\n\n## Community Response\n\n### Bitcoin Community\n\nThe Bitcoin community overwhelmingly rejects Wright's claims:\n\n- **\"Faketoshi\"**: The derisive nickname is universally used\n- **Developers**: Bitcoin Core developers have been vocal in their rejection\n- **Researchers**: Cryptographers and security researchers have debunked his \"proofs\"\n- **Humor**: Wright has become a meme, with his claims treated as a running joke\n\n### BSV Community\n\nA small community of BSV supporters continues to believe Wright is Satoshi. BSV has experienced:\n- Declining market cap and relevance\n- Delistings from major exchanges (citing fraud concerns around Wright)\n- Isolation from the broader cryptocurrency ecosystem\n\n## Why Does It Matter?\n\n### Protocol Control\n\nIf Wright were accepted as Satoshi, he could claim authority over Bitcoin's direction. His vision involves:\n- Massive block sizes (128MB+)\n- Removing privacy features\n- Making Bitcoin more amenable to government oversight\n- Aggressive patent enforcement\n\nThe community's rejection of Wright is partly about protecting Bitcoin from capture.\n\n### Legal Precedent\n\nWright's lawsuits have targeted:\n- Bitcoin developers (for alleged copyright infringement)\n- Anyone who publicly calls him a fraud\n- The Bitcoin whitepaper's distribution\n\nA successful Wright legal campaign could have chilling effects on Bitcoin development and free speech.\n\n### Reputation\n\nWright's saga damages Bitcoin's reputation with mainstream audiences who don't understand the nuances. Headlines about \"Satoshi suing developers\" or \"Bitcoin founder\" create confusion.\n\n## The Real Satoshi\n\nWhile Wright is not Satoshi, the real Satoshi's identity remains unknown. Key facts:\n\n- **Satoshi's coins haven't moved**: The ~1 million BTC from early mining remain untouched since 2010\n- **No public appearances**: Satoshi stopped communicating in 2011 and has never returned\n- **Cryptographic proof pending**: Anyone with access to Satoshi's keys could prove it instantly\n\nThe contrast is stark: the real Satoshi has remained silent for 15+ years, while Wright can't stop claiming the title without ever providing proof.\n\n## Conclusion\n\nThe Craig Wright saga is a bizarre footnote in Bitcoin history: a man who claims to be the creator but cannot prove it, who has forged documents and lost lawsuits, yet continues to assert his identity backed by a wealthy patron.\n\nFor the Bitcoin community, Wright serves as a useful reminder:\n\n- **Proof of work matters**: Claims require evidence. In Bitcoin, cryptographic proof is king.\n- **Decentralization protects**: Bitcoin has no CEO or founder who can be captured. Even if someone credibly claimed to be Satoshi, they couldn't control the protocol.\n- **The community decides**: Consensus (whether about code or identity) emerges from the network, not from proclamations.\n\nCraig Wright is not Satoshi Nakamoto. A UK High Court has ruled it. The cryptographic evidence (or lack thereof) proves it. And the Bitcoin community has always known it.\n\n## Related Topics\n\n- [Mt. Gox Collapse](/docs/controversies/mt-gox) - Exchange disaster that shaped Bitcoin culture\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - The scaling debate that led to Bitcoin Cash\n- [OP_RETURN Debate](/docs/controversies/op-return) - Data storage controversy\n\n## Resources\n\n- [COPA v. Wright Judgment](https://www.judiciary.uk/judgments/copa-v-wright/) - The full UK court ruling\n- [Wizsec: Wright's Fake Documents](https://blog.wizsec.jp/2018/02/kleiman-v-craig-wright-bitcoins.html) - Detailed forensic analysis\n- [stopcraigwright.com](https://stopcraigwright.com/) - Community documentation of Wright's claims\n",
    "filename": "craig-wright.md"
  },
  "/docs/glossary": {
    "content": "## 0-9\n\n### 51% Attack\nA theoretical attack where an entity controlling more than 50% of the network's hash rate could potentially double-spend transactions or prevent confirmations. The attacker could rewrite recent blockchain history by mining an alternative chain faster than the honest network. However, this attack becomes exponentially more expensive as the network grows, currently requiring billions of dollars in specialized hardware and ongoing electricity costs. Even with majority hash power, an attacker cannot steal coins, change consensus rules, or alter transactions that have many confirmations.\n\n### 2-of-3 Multisig\nA common multisignature configuration requiring 2 signatures from 3 possible signers to spend funds. This setup provides a balance between security and convenience: if one key is lost or compromised, funds remain accessible and secure. Often used for personal security (user key + hardware wallet + backup), business treasury management, or escrow services where a neutral third party can resolve disputes. The three keys are typically stored in different locations or controlled by different parties to minimize single points of failure.\n\n### 21 Million\nThe maximum supply of Bitcoin that will ever exist, making it one of the scarcest assets ever created. This hard cap is enforced by the protocol's consensus rules and achieved through the halving schedule, with the last satoshi expected to be mined around the year 2140. The fixed supply creates a deflationary monetary policy that contrasts sharply with traditional fiat currencies, which can be printed without limit. This scarcity is often cited as a key driver of Bitcoin's value proposition as \"digital gold\" or a store of value.\n\n## A\n\n### Absolute Time Lock\nA time lock that prevents a transaction from being spent until a specific block height or Unix timestamp is reached. Implemented using the OP_CHECKLOCKTIMEVERIFY (CLTV) opcode, which causes script execution to fail if the specified time hasn't passed. This is useful for creating vesting schedules, inheritance mechanisms, or ensuring funds cannot be moved before a certain date. Unlike relative time locks, absolute locks reference a fixed point in time rather than being relative to when the UTXO was created.\n\n### Address\nA public identifier where Bitcoin can be received, analogous to an email address for money. Generated from a public key through hash functions, addresses provide a shorter, checksummed format that's easier to share and helps detect typos. Different address types exist reflecting Bitcoin's evolution: P2PKH (starts with 1) for legacy, P2SH (starts with 3) for script hashes, P2WPKH/P2WSH (starts with bc1q) for native SegWit, and P2TR (starts with bc1p) for Taproot. Newer address types generally offer lower fees and better privacy.\n\n### Address Reuse\nUsing the same Bitcoin address for multiple transactions, which is generally discouraged for both privacy and security reasons. Reusing addresses links transactions together on the public blockchain, making it easier to trace your financial activity and spending patterns. Additionally, once you spend from an address, your public key is revealed, which theoretically weakens security against future quantum computing attacks. Best practice is to generate a fresh address for each transaction, which HD wallets handle automatically.\n\n### Anchor Outputs\nA mechanism in Lightning Network that allows payment channels to be closed reliably even when on-chain fee rates have increased significantly since the channel was opened. Each commitment transaction includes small \"anchor\" outputs that either party can use to attach a child transaction with higher fees via CPFP (Child Pays for Parent). This solves the problem of pre-signed commitment transactions becoming stuck if network fees spike, ensuring channels can always be closed in a timely manner. Anchor outputs are a key improvement for Lightning Network reliability and security.\n\n### ASIC (Application-Specific Integrated Circuit)\nSpecialized hardware designed and manufactured specifically for Bitcoin mining, optimized to perform SHA-256 hash calculations as efficiently as possible. ASICs are orders of magnitude more efficient than general-purpose CPUs or GPUs, making other hardware economically unviable for mining. Modern Bitcoin ASICs achieve hash rates measured in hundreds of terahashes per second while consuming several kilowatts of power. The development of ASICs has led to significant centralization concerns in mining hardware manufacturing, with a small number of companies dominating production.\n\n### Atomic Swap\nA peer-to-peer exchange of cryptocurrencies between two parties without the need for a trusted third party or centralized exchange. Atomic swaps use hash time-locked contracts (HTLCs) to ensure that either both parties receive their funds or neither does. The swap is \"atomic\" in the sense that it cannot be partially completed. This enables trustless trading across different blockchains, such as exchanging Bitcoin for Litecoin directly. The technology requires both blockchains to support compatible scripting capabilities and hash functions.\n\n### API (Application Programming Interface)\nA set of protocols and tools that allow applications to communicate with Bitcoin nodes, typically via JSON-RPC. The Bitcoin Core RPC API provides methods to query blockchain data, create and broadcast transactions, manage wallets, and monitor network status. Developers use these APIs to build wallets, block explorers, payment processors, and other Bitcoin applications. Third-party services also offer REST APIs that provide similar functionality without requiring users to run their own nodes.\n\n## B\n\n### Batching\nCombining multiple payments into a single transaction to reduce fees by sharing the fixed overhead costs across many recipients. Instead of creating separate transactions (each with its own inputs and overhead), multiple outputs are included in one transaction, significantly reducing the total bytes and thus fees paid. Exchanges and payment processors commonly use batching to process withdrawals efficiently, sometimes saving 75% or more on transaction fees. The tradeoff is that recipients may need to wait until enough payments accumulate before the batch is broadcast.\n\n### Base58\nAn encoding scheme used in legacy Bitcoin addresses that provides a human-readable format while minimizing transcription errors. It's similar to Base64 but excludes visually ambiguous characters (0, O, I, l) that could be confused when reading or typing addresses. Base58Check extends this with a 4-byte checksum appended to detect typos before funds are sent to an invalid address. While still used for legacy addresses, newer address formats use Bech32 encoding instead.\n\n### Bech32\nA checksummed base32 encoding format introduced with SegWit (BIP 173) that provides better error detection than Base58Check. Addresses start with `bc1` for mainnet or `tb1` for testnet, followed by a human-readable separator and the encoded data. Bech32 uses only lowercase letters and numbers, eliminating case-sensitivity issues and making addresses easier to read aloud or type on mobile devices. An updated version called Bech32m (BIP 350) is used for Taproot addresses to fix a minor issue with error detection.\n\n### Block\nA collection of transactions grouped together and permanently added to the blockchain approximately every 10 minutes. Each block contains a header with proof-of-work, a coinbase transaction that creates new Bitcoin, and typically thousands of user transactions. Blocks are limited in size (measured in weight units), creating competition for space that drives the fee market. Once a block is mined and accepted by the network, the transactions it contains are considered confirmed.\n\n### Blockchain\nA distributed, append-only ledger of all Bitcoin transactions maintained by thousands of independent nodes worldwide. Blocks are cryptographically linked in chronological order (each block header contains a hash of the previous block), making historical data tamper-evident and immutable. This chain structure means that altering any past transaction would require re-mining all subsequent blocks, which becomes computationally infeasible as more blocks are added. The blockchain serves as the single source of truth for Bitcoin ownership without requiring a central authority.\n\n### Block Header\nThe 80-byte metadata at the start of each block that miners hash repeatedly during proof-of-work. It contains six fields: version number, previous block hash (linking to the chain), merkle root (summarizing all transactions), timestamp, difficulty target (the hash threshold to beat), and nonce (the value miners increment). Because the header is only 80 bytes, SPV clients can verify the chain's proof-of-work without downloading full blocks. The compact size also enables efficient verification of the longest chain.\n\n### Block Height\nThe number of blocks in the chain before a given block, serving as a sequential identifier for blocks. The genesis block has height 0, and each subsequent block increments the height by one. Block height is used to reference specific points in Bitcoin's history, trigger protocol changes (like halvings at heights divisible by 210,000), and calculate confirmation depth. As of 2024, Bitcoin's block height exceeds 800,000.\n\n### Block Reward\nThe amount of new Bitcoin created and awarded to miners for successfully mining a block, also called the block subsidy. Currently 3.125 BTC after the 2024 halving, this reward halves approximately every four years (210,000 blocks) until all 21 million Bitcoin are mined around 2140. The block reward, combined with transaction fees, provides the economic incentive for miners to secure the network. As the subsidy decreases over time, transaction fees are expected to become the primary source of miner revenue.\n\n### Block Size\nThe size of a block measured in bytes or weight units, which is limited by consensus rules to prevent blockchain bloat. Bitcoin has a 1 MB base block size limit, but the SegWit upgrade introduced weight units that allow blocks to effectively reach ~4 MB when containing mostly SegWit transactions. This limit creates scarcity of block space, driving fee competition during high-demand periods. The block size debate was one of Bitcoin's most contentious controversies, ultimately leading to the creation of Bitcoin Cash in 2017.\n\n### Block Time\nThe average time between consecutive blocks, which Bitcoin targets at 10 minutes through automatic difficulty adjustment. This target represents a tradeoff between confirmation speed and security; faster blocks would increase orphan rates and potentially centralize mining. The actual time between blocks varies due to the random nature of mining; individual blocks can take seconds or over an hour. The 10-minute average is maintained by adjusting difficulty every 2016 blocks based on actual block production rate.\n\n### Block Template\nA data structure containing selected transactions and partially-filled block header fields that miners use to construct candidate blocks. Mining pools generate block templates by selecting transactions from the mempool (typically prioritizing by fee rate), computing the merkle root, and providing all header fields except the nonce. Miners then repeatedly hash variations of this template, trying different nonces and extranonces, until finding a valid block. The getblocktemplate RPC allows miners to customize transaction selection rather than relying entirely on the pool.\n\n### BOLT (Basis of Lightning Technology)\nThe technical specifications that define the Lightning Network protocol, similar to how RFCs define internet protocols. BOLT documents specify everything from the peer-to-peer message format to channel construction, payment routing, and invoice encoding. There are currently 11 main BOLT specifications (BOLT 1-11) covering different aspects of the protocol. Multiple independent implementations (LND, c-lightning, Eclair, LDK) follow these specs to ensure interoperability across the Lightning Network.\n\n### BIP (Bitcoin Improvement Proposal)\nA design document that proposes changes, additions, or informational content for the Bitcoin ecosystem, following a structured process for community review. BIPs are categorized as Standards Track (protocol changes), Informational, or Process documents. Notable examples include BIP 16 (P2SH), BIP 32 (HD wallets), BIP 39 (mnemonic seeds), BIP 141 (SegWit), and BIP 341 (Taproot). The BIP process provides a transparent, community-driven approach to Bitcoin development without requiring a central authority to approve changes.\n\n## C\n\n### CLTV (CheckLockTimeVerify)\nAn opcode (OP_CHECKLOCKTIMEVERIFY) that enforces absolute time locks by making a transaction invalid if spent before a specified block height or Unix timestamp. Introduced in BIP 65, CLTV enables time-locked contracts where funds cannot be moved until a future date regardless of who holds the keys. This is essential for Lightning Network HTLCs, which require time-locked refund paths, as well as inheritance planning and vesting schedules. CLTV checks the transaction's locktime field against the script's specified value and fails if the locktime hasn't been reached.\n\n### Coinbase Transaction\nThe first transaction in every block, which has no inputs and creates new Bitcoin out of thin air as the block reward plus collected transaction fees. Miners construct the coinbase transaction to pay themselves, and it's the only transaction type that can create new coins. The coinbase includes an arbitrary data field (up to 100 bytes) where miners often include pool identifiers, political messages, or other data. Satoshi famously embedded a newspaper headline in the genesis block. Coinbase outputs cannot be spent until 100 blocks have passed, preventing issues if the block is orphaned.\n\n### Coin Selection\nThe process of choosing which UTXOs to spend when creating a transaction, which significantly impacts fees, privacy, and future UTXO management. Various algorithms exist: largest-first minimizes input count but creates large change outputs; smallest-first consolidates dust but increases fees; branch-and-bound tries to find exact matches avoiding change entirely. Good coin selection balances immediate fee costs against long-term UTXO set health and privacy considerations. Wallet software typically handles this automatically, but advanced users may want manual control for privacy-sensitive transactions.\n\n### CoinJoin\nA privacy technique where multiple users combine their transactions into a single transaction, making it difficult for blockchain analysts to determine which inputs correspond to which outputs. Each participant signs only their own inputs, so no one can steal funds, and the coordinator (if any) never has custody. Implementations include Wasabi Wallet's WabiSabi protocol and JoinMarket's maker-taker model. CoinJoin breaks the common-input-ownership heuristic that chain analysis relies on, significantly improving transaction privacy when done correctly.\n\n### Commitment Transaction\nIn Lightning Network, a pre-signed transaction that represents the current state of a payment channel and can be broadcast to close the channel unilaterally. Both channel parties hold their own version of the commitment transaction, which pays out the current balance distribution. These transactions are updated off-chain every time a payment flows through the channel, with old states being invalidated through revocation keys. The penalty mechanism ensures that broadcasting an outdated commitment transaction results in losing all channel funds to the counterparty.\n\n### Confirmation\nWhen a transaction is included in a block that is added to the blockchain, it receives its first confirmation; each subsequent block adds another confirmation. More confirmations increase certainty that the transaction is final because reversing it would require re-mining all those blocks. For small amounts, 1-3 confirmations are typically sufficient, while 6 confirmations (about 1 hour) is widely considered secure for large amounts. Zero-confirmation transactions are risky because they can be double-spent until mined, though they may be acceptable for small, in-person transactions.\n\n### Consensus\nAgreement among network participants about the current state of the blockchain, including which transactions are valid and which chain of blocks is authoritative. Bitcoin achieves consensus through proof-of-work and the longest chain rule: nodes accept the valid chain with the most accumulated work. This allows thousands of independent nodes to agree on a single transaction history without any central coordinator. Consensus is Bitcoin's core innovation, solving the double-spend problem in a decentralized way for the first time.\n\n### Consensus Rules\nThe set of rules that all Bitcoin nodes must follow to validate transactions and blocks, forming the foundation of network agreement. These include rules about block structure, transaction format, signature validity, coin supply, and timing. Any transaction or block that violates consensus rules is rejected by honest nodes, regardless of how much hash power supports it. Changing consensus rules requires either a soft fork (tightening rules) or hard fork (loosening rules), both of which need broad network agreement to succeed.\n\n### Censorship Resistance\nThe ability to make transactions that cannot be blocked, reversed, or seized by any central authority, government, or corporation. Bitcoin achieves this through decentralization: thousands of independent miners and nodes mean no single entity controls which transactions are included in blocks. Even if some miners refuse to include certain transactions, others will mine them for the fees. This property makes Bitcoin particularly valuable for people in authoritarian regimes, those facing financial censorship, or anyone needing to transact without permission.\n\n### Change Output\nA transaction output that sends excess funds back to the sender, created because Bitcoin's UTXO model requires spending entire outputs. When input value exceeds the payment amount plus fees, the difference must be explicitly sent somewhere, typically a new address controlled by the sender. For example, spending a 1 BTC UTXO to pay 0.3 BTC (plus 0.0001 BTC fee) requires a 0.6999 BTC change output. Wallets handle change automatically, but understanding it is important for privacy (change outputs can link transactions) and fee estimation.\n\n### CPFP (Child Pays For Parent)\nA fee bumping technique where a new transaction (the child) spends an unconfirmed output from a stuck transaction (the parent) with a high enough fee to make mining both transactions profitable. Miners evaluate transaction packages together, so a high-fee child incentivizes them to include the low-fee parent to collect both fees. This is useful when you're the recipient of a stuck transaction and can't use RBF because you didn't create the original. CPFP requires spending an output from the stuck transaction, which the receiver can do with their change or payment output.\n\n### CSV (CheckSequenceVerify)\nAn opcode (OP_CHECKSEQUENCEVERIFY) that enforces relative time locks, preventing a UTXO from being spent until a specified number of blocks or time has passed since it was confirmed. Unlike CLTV's absolute locks, CSV's relative locks start counting from when the UTXO was created, making them ideal for protocols that need \"wait N blocks after X happens\" logic. Essential for Lightning Network, where CSV ensures that a party has time to respond to a fraudulent channel close. Introduced in BIP 112, CSV uses the transaction's sequence field to enforce the delay.\n\n### Compact Block\nA block relay protocol (BIP 152) that dramatically reduces bandwidth by sending only block headers and short transaction IDs instead of full transaction data. Since most transactions in a new block are already in a node's mempool, the node can reconstruct the full block locally using these short IDs. This optimization reduces block propagation time and bandwidth by roughly 90%, which improves network efficiency and reduces orphan rates. High-bandwidth mode pushes compact blocks immediately upon mining, while low-bandwidth mode uses a request-response pattern.\n\n### Channel\nA payment channel between two Lightning Network nodes that enables instant, low-cost payments without broadcasting each transaction to the blockchain. Channels are created by locking Bitcoin in a 2-of-2 multisig address on-chain, then updating balance distributions off-chain through signed commitment transactions. Payments can flow in either direction up to the channel's capacity, and channels can remain open indefinitely. When parties want to settle, they close the channel and the final balance is recorded on the Bitcoin blockchain.\n\n### Channel Capacity\nThe total amount of Bitcoin locked in a Lightning payment channel, representing the maximum value that can flow through it at any moment. Capacity is set when the channel is opened and equals the sum of both parties' contributions (though single-funded channels are common). Importantly, capacity doesn't mean both parties can send that amount; each can only send up to their current balance in the channel. Large channels provide more routing flexibility but require more capital lockup; this liquidity tradeoff is a key consideration in Lightning Network economics.\n\n### Channel Closing\nThe process of finalizing a Lightning payment channel by broadcasting the final state to the Bitcoin blockchain, which settles the channel balance and unlocks funds. Cooperative closes are preferred: both parties agree on the final balance and sign a closing transaction with minimal fees and no time locks. Force closes occur when one party is unresponsive or disputes arise: the initiator broadcasts their latest commitment transaction and must wait for a timelock before accessing funds. Breach closes happen when someone broadcasts an old state and loses all funds to the penalty mechanism.\n\n### Channel Funding\nThe process of opening a Lightning payment channel by creating an on-chain transaction that locks Bitcoin in a 2-of-2 multisig address controlled by both channel parties. The funding transaction must be confirmed on the blockchain before the channel becomes usable, which typically takes 3-6 confirmations (30-60 minutes). Originally only one party funded channels, but dual-funded channels (where both contribute) are now supported, providing initial liquidity in both directions. The funding transaction output becomes the channel's capacity and anchor point on the blockchain.\n\n### Channel State\nThe current balance distribution in a Lightning payment channel, representing how much each party would receive if the channel were closed immediately. State is updated off-chain through signed commitment transactions every time a payment flows through the channel. These updates are instant and free. Old states are invalidated through revocation keys, creating a penalty mechanism if anyone tries to broadcast an outdated state. The channel state is essentially a running tab that's only settled to the blockchain when the channel closes.\n\n### Cooperative Close\nThe preferred method of closing a Lightning payment channel where both parties agree on the final balance and sign a single closing transaction. Unlike force closes, cooperative closes have no time delays, lower fees (no anchor outputs or penalty mechanisms needed), and settle immediately once confirmed on-chain. Both parties benefit from cooperative closes, so they're used in the vast majority of channel closures. A cooperative close is only impossible when one party is offline, unresponsive, or actively disputing the channel state.\n\n## D\n\n### Decentralization\nThe distribution of control, decision-making, and infrastructure across many independent participants rather than a single central authority. Bitcoin achieves this through open-source code that anyone can audit, distributed mining across thousands of operations worldwide, and permissionless node operation that lets anyone verify the blockchain. This architecture means no government, company, or individual can unilaterally change the rules, censor transactions, or shut down the network. Decentralization is often considered Bitcoin's most important property, as it underpins censorship resistance, trustlessness, and long-term resilience.\n\n### Derivation Path\nA sequence of indices that specifies how to derive a specific key from a master seed in an HD (hierarchical deterministic) wallet, enabling organized key management. The format `m/purpose'/coin'/account'/change/index` creates a tree structure where the apostrophe indicates hardened derivation (more secure but can't derive child public keys from parent public keys). Common paths include m/44'/0'/0' for legacy addresses, m/84'/0'/0' for native SegWit, and m/86'/0'/0' for Taproot. Understanding derivation paths is crucial for wallet recovery and interoperability between different wallet software.\n\n### Descriptors\nA standardized format (BIP 380-386) for describing how to derive addresses and spending conditions from keys, providing more complete wallet backup information than keys alone. Descriptors specify not just which keys to use but how to use them: the script type, derivation paths, and any multi-party arrangements. For example, `wpkh([fingerprint/84'/0'/0']xpub.../0/*)` describes a native SegWit wallet with a specific derivation. This enables wallet software to correctly reconstruct addresses and sign transactions without ambiguity, improving interoperability and backup reliability.\n\n### DATUM\nA decentralized mining protocol that allows individual miners to construct their own block templates rather than accepting whatever the pool provides. This gives miners control over which transactions to include, addressing concerns about pool-level transaction censorship and centralization of block construction. DATUM represents a shift toward \"solo mining with pool payout variance smoothing,\" where miners maintain sovereignty over block content while still benefiting from pooled rewards. This protocol is part of a broader movement (including Stratum V2) toward more decentralized mining infrastructure.\n\n### Difficulty\nA measure of how computationally hard it is to find a valid block hash, automatically adjusted every 2016 blocks (roughly two weeks) to maintain approximately 10-minute block intervals. When blocks are found faster than target, difficulty increases; when slower, it decreases. This self-adjusting mechanism ensures consistent block times regardless of how much hash power joins or leaves the network. Difficulty has increased astronomically since Bitcoin's early days. Finding a block today requires roughly 10^23 times more computation than when the network launched.\n\n### Difficulty Target\nThe maximum hash value that is considered valid for a block, expressed as a 256-bit number that miners must beat. Miners repeatedly hash block headers with different nonces until finding a hash numerically below this target. Lower targets are harder to hit and represent higher difficulty. The target is stored compactly in each block header as \"nBits\" and decoded into the full 256-bit threshold for validation. When you see a block hash starting with many zeros, those zeros represent the successful search for a value below the current target.\n\n### Double Spend\nAn attempt to spend the same Bitcoin twice by creating two conflicting transactions that both reference the same UTXO. Bitcoin's blockchain consensus mechanism prevents this by establishing a single authoritative transaction history. Once one transaction is confirmed in a block, conflicting transactions become invalid. Before confirmation, double spends are possible (which is why merchants wait for confirmations), but after even one confirmation, reversing the transaction requires mining a longer alternative chain. This is why double-spend prevention is considered Bitcoin's fundamental innovation.\n\n### Dust\nA transaction output so small that the fee required to spend it would exceed or approach its value, making it economically irrational to use. The dust threshold depends on fee rates but is typically around 546 satoshis for standard outputs and 294 satoshis for SegWit outputs. Dust outputs bloat the UTXO set without providing useful value, so Bitcoin Core rejects transactions that create dust by default. Wallets should avoid creating dust through careful coin selection, and users accumulating many small outputs may need to consolidate during low-fee periods.\n\n## E\n\n### ECDSA (Elliptic Curve Digital Signature Algorithm)\nThe original cryptographic signature algorithm used in Bitcoin, based on the secp256k1 elliptic curve (chosen for its efficiency and lack of suspicious constants). ECDSA signatures prove ownership of private keys without revealing them, enabling secure authorization of transactions. Each signature is approximately 71-72 bytes and is mathematically tied to both the private key and the specific transaction data being signed. While still widely used, ECDSA is being supplemented by Schnorr signatures (introduced with Taproot), which offer better efficiency and enable signature aggregation.\n\n### ECDH (Elliptic Curve Diffie-Hellman)\nA key exchange protocol that allows two parties to establish a shared secret over an insecure channel using elliptic curve cryptography. In Lightning Network, ECDH is used in onion routing (Sphinx protocol) to derive shared secrets between each hop without revealing them to other nodes in the path. The sender uses each routing node's public key to create encrypted layers, and each node uses its private key to decrypt only its layer and learn the next hop. This enables private, trustless payment routing where no single node learns the full payment path.\n\n## F\n\n### Fee Bumping\nTechniques to increase the effective fee of an unconfirmed transaction to speed up confirmation when the original fee is too low for current network conditions. The two main methods are RBF (Replace-by-Fee), which replaces the stuck transaction with a higher-fee version, and CPFP (Child Pays for Parent), which spends an output from the stuck transaction with enough fee to make mining both worthwhile. Fee bumping is essential for time-sensitive transactions during fee spikes and for Lightning channel management. Modern wallets increasingly support fee bumping by default, signaling RBF on all transactions.\n\n### Fee Rate\nThe fee paid per virtual byte (vByte) of transaction size, expressed in satoshis per vByte (sat/vB), which determines a transaction's priority for inclusion in blocks. Miners typically sort transactions by fee rate and fill blocks from highest to lowest, so higher rates mean faster confirmation. Fee rates fluctuate based on network demand; they might be 1-5 sat/vB during quiet periods but spike to 100+ sat/vB during high activity. Fee estimation services and mempool visualizers help users choose appropriate rates for their urgency level.\n\n### Force Close\nUnilaterally closing a Lightning payment channel by broadcasting your latest commitment transaction to the Bitcoin blockchain without the counterparty's cooperation. Force closes are necessary when the other party is offline, unresponsive, or attempting fraud, but they're more expensive and slower than cooperative closes. The initiator must wait for a timelock (typically 1-2 weeks) before accessing their funds, giving the counterparty time to dispute with a penalty transaction if an old state was broadcast. Force closes should be a last resort due to higher fees and locked funds.\n\n### Finality\nThe assurance that a confirmed transaction cannot be reversed or altered, which in Bitcoin is probabilistic rather than absolute. Each additional confirmation makes reversal exponentially more difficult and expensive. After 6 confirmations, reversing a transaction would require an attacker to re-mine those 6 blocks plus stay ahead of the honest network. While never mathematically impossible, deep confirmations provide practical finality that approaches certainty for any realistic attacker. This probabilistic model differs from traditional payment systems where finality is instant but dependent on trusted intermediaries.\n\n### Fork\nA divergence in the blockchain where two or more competing chains temporarily or permanently coexist, which can occur naturally or through protocol changes. Temporary forks happen when two miners find valid blocks simultaneously; the network resolves this by eventually building on one chain, orphaning the other. Hard forks create permanent splits when protocol changes make new blocks incompatible with old software (like Bitcoin Cash in 2017). Soft forks tighten rules in a backward-compatible way, where old nodes still accept new blocks but may not understand new features.\n\n### Full Node\nA Bitcoin node that independently validates every transaction and block against consensus rules, maintaining a complete copy of the blockchain without trusting any external source. Full nodes download and verify ~600GB+ of historical data during initial sync, then validate new blocks as they arrive. Running a full node provides the highest level of security and privacy, as you verify your own transactions rather than trusting third parties. Full nodes also contribute to network decentralization by rejecting invalid blocks and relaying valid transactions to peers.\n\n## G\n\n### Genesis Block\nThe first block in the Bitcoin blockchain (block height 0), created by Satoshi Nakamoto on January 3, 2009, with a timestamp reflecting that date. The coinbase transaction famously includes the text \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks,\" both proving the block wasn't pre-mined before that date and commenting on the financial system Bitcoin aimed to provide an alternative to. The genesis block is hardcoded into Bitcoin software as the starting point of the chain. Interestingly, its 50 BTC reward is unspendable due to a quirk in the original code.\n\n### Gossip Protocol\nThe peer-to-peer mechanism by which Bitcoin nodes share information about new blocks, transactions, and network addresses with their connected peers. When a node receives valid new data, it announces it to peers who haven't seen it yet (avoiding re-broadcasting to the sender). This creates a flooding pattern where information propagates across the network in seconds without any central coordinator. The gossip protocol includes mechanisms to prevent spam and denial-of-service attacks, such as validating data before relay and limiting bandwidth per peer.\n\n## H\n\n### Halving\nAn event that occurs every 210,000 blocks (approximately every four years) where the block reward paid to miners is cut in half, reducing Bitcoin's inflation rate. This mechanism is central to Bitcoin's monetary policy, creating a predictable and diminishing supply schedule that asymptotically approaches the 21 million cap. Halvings have historically been significant market events as they directly reduce the rate of new Bitcoin entering circulation, affecting miner economics and supply-demand dynamics. The most recent halving in April 2024 reduced the block reward from 6.25 to 3.125 BTC.\n\n### Hash\nA cryptographic function that takes any input and produces a fixed-size output (digest) that appears random but is deterministic: the same input always produces the same output. Bitcoin uses SHA-256 for proof-of-work and transaction IDs, and RIPEMD-160 combined with SHA-256 for address generation. Hash functions are one-way (you can't reverse them to find the input), collision-resistant (finding two inputs with the same output is computationally infeasible), and avalanche-sensitive (small input changes completely change the output). These properties make hashes essential for blockchain integrity and mining.\n\n### Hash Rate\nThe total computational power dedicated to Bitcoin mining, measured in hashes per second, representing the network's security level. The network currently operates at approximately 500-700 EH/s (exahashes per second, or 10^18 hashes per second), requiring massive amounts of specialized hardware and electricity. Higher hash rate means the network is more secure against 51% attacks, as an attacker would need proportionally more resources. Hash rate has grown exponentially over Bitcoin's history as mining technology advanced from CPUs to GPUs to ASICs.\n\n### Hard Fork\nA protocol change that loosens consensus rules, making previously invalid blocks or transactions valid, which is not backward-compatible. Nodes that don't upgrade will reject new blocks as invalid, potentially creating a permanent chain split where two incompatible networks exist. Bitcoin Cash (2017) and Bitcoin SV (2018) resulted from contentious hard forks over block size. Hard forks are controversial in Bitcoin because they risk splitting the network and are generally avoided in favor of soft forks, which maintain backward compatibility.\n\n### HD Wallet (Hierarchical Deterministic Wallet)\nA wallet architecture (BIP 32) that generates all keys from a single master seed, typically represented as a 12-24 word mnemonic phrase for backup. The hierarchical structure allows deriving billions of addresses in an organized tree, with branches for different accounts, purposes (receiving vs. change), and address types. HD wallets revolutionized Bitcoin usability by making backups simple (one seed phrase backs up all past and future addresses) while also improving privacy by making fresh address generation trivial. Most modern wallets use HD architecture with BIP 39 mnemonics and BIP 44/84/86 derivation paths.\n\n### HTLC (Hash Time-Locked Contract)\nA conditional payment contract that forms the foundation of Lightning Network and atomic swaps, combining a hash lock with a time lock. The payment can only be claimed by revealing a secret (preimage) that hashes to a known value, and it automatically refunds to the sender if not claimed before the timeout expires. In Lightning, HTLCs chain across multiple channels to enable multi-hop payments. Each node only releases payment upon receiving the preimage from the next hop. This creates trustless routing where either the entire payment succeeds or it fails and refunds atomically.\n\n## I\n\n### IBD (Initial Block Download)\nThe process of downloading and validating the entire blockchain history when first starting a Bitcoin full node, which can take hours to days depending on hardware and bandwidth. During IBD, the node downloads all ~600GB+ of block data, verifies every signature, checks all consensus rules, and builds the UTXO set from scratch. This process is intentionally thorough; it's how full nodes achieve trustless verification without relying on any external source. Modern optimizations like assumevalid and assumeutxo can speed up IBD by skipping some signature verification for deeply buried blocks while maintaining security guarantees.\n\n### Input\nA reference to a previous transaction output (UTXO) that is being consumed in a new transaction, essentially pointing to where the funds came from. Each input contains the previous transaction's ID, the output index being spent, and a script (or witness data) proving authorization to spend those funds. A transaction can have multiple inputs to combine UTXOs when the payment amount exceeds any single available output. The total value of all inputs minus the total value of all outputs equals the transaction fee paid to miners.\n\n### Invoice\nA payment request in Lightning Network encoded as a BOLT11 string that contains all information needed to make a payment. Invoices typically start with `lnbc` for mainnet (or `lntb` for testnet), followed by an amount, and include the payment hash, recipient's node public key, expiry time, routing hints, and a signature. They're usually displayed as QR codes for easy mobile scanning. BOLT12 \"offers\" are a newer standard that enables reusable payment requests and other advanced features not possible with one-time BOLT11 invoices.\n\n## K\n\n### Key Pair\nA cryptographic pair consisting of a private key (a 256-bit secret number) and its corresponding public key (derived through elliptic curve multiplication). The private key signs transactions to prove ownership, while the public key allows anyone to verify those signatures without learning the private key. From the public key, Bitcoin addresses are generated through hashing, creating a one-way chain: private key â†’ public key â†’ address. Keeping private keys secret is paramount, as anyone with access can spend the associated funds. Public keys and addresses can be freely shared.\n\n## L\n\n### Lightning Network\nA second-layer payment protocol built on top of Bitcoin that enables instant, high-volume, low-cost transactions through a network of payment channels. Instead of recording every payment on the blockchain, Lightning users open channels by locking Bitcoin in 2-of-2 multisig addresses, then exchange signed transactions off-chain to update balances. Payments can route through multiple channels, enabling payments to anyone on the network without direct channel connections. Settlement to the Bitcoin blockchain only occurs when channels are opened or closed, dramatically reducing fees and enabling micropayments as small as 1 satoshi.\n\n### Locktime\nA transaction-level field (nLockTime) that prevents the transaction from being valid until a specified block height or Unix timestamp is reached. When set to a block height (values < 500,000,000) or timestamp (values >= 500,000,000), nodes will not relay or mine the transaction until that condition is met. Locktime enables use cases like post-dated checks, where a transaction is signed now but can't be spent until later. It's also foundational to Lightning Network, where pre-signed transactions with future locktimes serve as backup recovery mechanisms.\n\n## M\n\n### Mainnet\nThe production Bitcoin network where real Bitcoin with actual monetary value is transacted, as opposed to test networks used for development. Mainnet addresses start with \"1\" (legacy), \"3\" (P2SH), or \"bc1\" (SegWit/Taproot), distinguishing them from testnet addresses. All consensus rules are fully enforced on mainnet, and transactions are irreversible. When people refer to \"Bitcoin\" without qualification, they mean mainnet, the network that launched on January 3, 2009, and has operated continuously since.\n\n### Mempool (Memory Pool)\nThe collection of valid, unconfirmed transactions that a node has received and is holding in memory, waiting to be included in a block. Each node maintains its own mempool, and they may differ slightly based on when transactions were received and node-specific policies. Miners select transactions from their mempool when constructing blocks, typically prioritizing by fee rate. Mempool size fluctuates with network demand; during busy periods it can grow to hundreds of thousands of transactions, while during quiet times it may nearly empty. Mempool visualization tools help users choose appropriate fee rates.\n\n### Merkle Root\nA single hash that cryptographically summarizes all transactions in a block, created by repeatedly hashing pairs of transaction hashes in a tree structure until one root remains. The merkle root is included in the 80-byte block header, allowing the entire block's transactions to be verified from this single value. This enables Simplified Payment Verification (SPV), where light clients can verify transaction inclusion using only the merkle root and a small proof path, without downloading the full block. Changing any transaction would change the merkle root, making tampering detectable.\n\n### Merkle Tree\nA binary tree structure where each leaf node is a hash of a transaction, and each parent node is the hash of its two children combined, ultimately producing a single root hash. This structure enables efficient proofs of inclusion: proving a transaction is in a block only requires logâ‚‚(n) hashes rather than all n transactions. Bitcoin uses Merkle trees for transaction summarization in block headers, and Taproot uses them for organizing spending conditions (MAST). The ability to prove membership with logarithmic-sized proofs is crucial for light clients and scalability.\n\n### MAST (Merkle Abstract Syntax Tree)\nA technique implemented in Taproot that represents multiple spending conditions as leaves in a Merkle tree, with only the executed path revealed when spending. This dramatically improves privacy because unused conditions remain hidden. A complex contract with many possible outcomes looks identical to a simple payment when only one path is used. MAST also reduces transaction size and fees by only requiring proof of the executed branch. Complex smart contracts like inheritance schemes, timelocked escrows, or multi-party arrangements benefit significantly from MAST's privacy and efficiency gains.\n\n### MuSig\nA multi-signature scheme using Schnorr signatures that allows multiple parties to create a single aggregated signature indistinguishable from a regular single-key signature. Unlike traditional multisig (which requires listing all public keys and signatures), MuSig combines keys and signatures off-chain, producing an output that looks like a normal Taproot key-path spend on the blockchain. This provides significant privacy improvements (observers can't tell a transaction was multi-party) and fee savings from the smaller signature size. MuSig2 is the production-ready version that requires only two communication rounds between signers.\n\n### MPP (Multi-Part Payment)\nA Lightning Network feature that allows splitting a large payment into multiple smaller parts that route independently through different paths, then recombine at the destination. This improves payment success rates by utilizing multiple channels' liquidity simultaneously and enables payments larger than any single channel's capacity. The receiver waits until all parts arrive before revealing the preimage, ensuring atomicity: either the entire payment completes or none of it does. MPP (also called AMP for atomic multi-path payments) significantly improved Lightning's reliability for larger transactions.\n\n### Miniscript\nA structured language for writing Bitcoin Scripts that is easier to analyze, compose, and reason about than raw Script. Miniscript maps to a subset of valid Bitcoin Script but provides guarantees about spending conditions, costs, and required signatures that would be difficult to determine from raw opcodes. Wallets can automatically analyze Miniscript policies to determine all possible spending paths, compute worst-case transaction sizes for fee estimation, and verify that scripts behave as intended. This makes complex multi-party contracts and time-locked conditions safer to implement and use.\n\n### Mining Pool\nA collective of miners who combine their computational power and share block rewards proportionally to each member's contributed work. Pools reduce payout variance: instead of rarely winning large rewards, miners receive frequent smaller payments based on submitted shares. The pool operator constructs blocks and distributes work to members, paying out when blocks are found. While pools provide economic benefits to small miners, their concentration has raised centralization concerns, as large pools could theoretically influence which transactions get mined.\n\n### Multisig (Multi-Signature)\nA Bitcoin script pattern requiring multiple cryptographic signatures to authorize spending, providing enhanced security and enabling shared custody arrangements. Common configurations include 2-of-3 (any two of three keyholders can spend), 3-of-5 (majority required), or 2-of-2 (both parties must agree, as used in Lightning channels). Multisig protects against single points of failure: losing one key doesn't lose funds, and compromising one key doesn't enable theft. Pre-Taproot multisig visibly reveals the m-of-n structure on-chain, while Taproot with MuSig can make multisig indistinguishable from single-sig.\n\n## N\n\n### Node\nA computer running Bitcoin software that participates in the network by validating transactions and blocks, relaying data to peers, and maintaining its own view of the blockchain. Full nodes verify everything independently against consensus rules, while lightweight (SPV) nodes trust others for some validation. Running a node provides trustless verification of your own transactions and contributes to network decentralization. Nodes communicate using a peer-to-peer protocol, typically maintaining 8-10 outbound connections and accepting inbound connections from other nodes.\n\n### Node (Lightning)\nA computer running Lightning Network software (such as LND, Core Lightning, Eclair, or LDK) that participates in the payment network by opening channels, routing payments, and managing liquidity. Lightning nodes maintain connections to the Bitcoin network to monitor channel funding transactions and handle on-chain settlements. Each node has a unique public key identity and advertises its channels and fee policies to the network. Well-connected nodes with good liquidity and uptime earn routing fees by forwarding payments between other participants in the network.\n\n### Nonce\nA 32-bit number in the block header that miners increment while searching for a valid proof-of-work hash. When combined with other header fields and hashed, different nonce values produce different hashes. Miners try billions of nonces looking for one that produces a hash below the difficulty target. Since the nonce provides only 4 billion possibilities (2^32), modern miners also vary the extranonce in the coinbase transaction to expand the search space. Finding the right nonce is essentially a lottery where more hash power buys more tickets per second.\n\n## O\n\n### OP_RETURN\nAn opcode that marks a transaction output as provably unspendable, allowing data to be embedded in transactions without bloating the UTXO set. Since OP_RETURN outputs can never be spent, nodes can safely discard them rather than tracking them forever. This provides a \"legitimate\" way to store small amounts of data (up to 80 bytes per output) on the blockchain for timestamping, asset protocols, or other applications. While controversial due to non-financial blockchain use, OP_RETURN is preferred over alternative methods that create spendable dust outputs that must be tracked indefinitely.\n\n### OPCODE\nA single operation in Bitcoin's stack-based scripting language, used to define spending conditions for transaction outputs. Each opcode performs a specific function: OP_DUP duplicates the top stack item, OP_HASH160 hashes it, OP_CHECKSIG verifies a signature, OP_IF enables conditional execution, and so on. Standard transactions use well-known opcode patterns (like P2PKH or P2WPKH), while more complex contracts combine opcodes to create multisig, time locks, or hash locks. Bitcoin Script is intentionally limited (not Turing-complete) to ensure all scripts terminate and can be analyzed for validity.\n\n### Onion Routing\nA privacy technique used in Lightning Network (via the Sphinx protocol) where payment information is encrypted in multiple layers, like an onion, with each routing node only able to decrypt its layer. Each node learns only the previous hop (where the payment came from) and the next hop (where to forward it), never the full payment path or final amount. The sender constructs all encryption layers using each routing node's public key, so intermediate nodes can't determine their position in the path or who the original sender is. This provides strong privacy for payment routing.\n\n### Orphan Block\nA valid block that was mined but is not part of the main chain because another block at the same height was adopted by the network instead. Orphans occur naturally when two miners find blocks nearly simultaneously; the network temporarily has two competing chain tips until one gets extended and becomes the longest chain. The \"losing\" block becomes orphaned, and its transactions return to the mempool to be included in future blocks. Orphan rates increase with larger blocks or slower propagation, which is why block size limits and efficient relay protocols matter.\n\n### Output\nA component of a Bitcoin transaction that specifies an amount of Bitcoin and the conditions (locking script or scriptPubKey) required to spend it. Each output represents a new UTXO that can later be used as an input in a future transaction. The locking script typically specifies a public key hash (address) that must provide a valid signature to spend, though more complex conditions are possible. A transaction can have multiple outputs, commonly one for the payment recipient and another returning change to the sender.\n\n## P\n\n### Payjoin\nA privacy technique where both the sender and receiver contribute inputs to a transaction, breaking the common-input-ownership heuristic that blockchain analysis relies on. Normally, analysts assume all inputs to a transaction belong to the same entity. Payjoin defeats this by mixing ownership. The transaction looks like a normal payment on-chain, but the true amounts are obscured because inputs from both parties are combined. Also known as P2EP (Pay-to-Endpoint), Payjoin requires coordination between sender and receiver but provides significant privacy benefits without the coordination overhead of CoinJoin.\n\n### Peer\nAnother Bitcoin node that your node maintains a direct TCP connection with for exchanging blocks, transactions, and network information. Nodes typically maintain 8-10 outbound connections (ones they initiated) and accept inbound connections (up to 125 total by default) from other nodes. Peer selection uses various heuristics to achieve diversity, connecting to nodes in different IP ranges, different parts of the world, and different ASNs to reduce the risk of eclipse attacks. The peer-to-peer nature of these connections means no central server controls the network.\n\n### P2PKH (Pay-to-Pubkey-Hash)\nThe original and most common legacy Bitcoin script pattern, where funds are locked to the hash of a public key. Addresses start with \"1\" and spending requires providing the full public key and a valid signature. The hash provides an extra layer of protection: until funds are spent, only the hash is public, so even a (theoretical) public key crack couldn't steal unspent coins. P2PKH was the dominant address type for Bitcoin's first years but is being superseded by more efficient SegWit formats.\n\n### P2SH (Pay-to-Script-Hash)\nA script pattern (BIP 16) that locks funds to the hash of an arbitrary script, with the actual script only revealed when spending. Addresses start with \"3\" and can encapsulate any valid script, most commonly multisig arrangements or wrapped SegWit. The sender only needs to know the script hash (address); the complexity of the actual spending conditions is hidden until redemption. P2SH shifted the storage burden for complex scripts from the sender to the recipient and enabled more sophisticated Bitcoin contracts.\n\n### P2TR (Pay-to-Taproot)\nThe modern Bitcoin address type introduced with the Taproot upgrade (BIP 341), providing the best combination of privacy, efficiency, and flexibility. Addresses start with \"bc1p\" and can be spent either with a simple key signature (key path) or by revealing one of potentially many script conditions (script path via MAST). Crucially, key path spends look identical regardless of whether the underlying setup was single-sig or complex multisig, dramatically improving privacy. P2TR also benefits from Schnorr signature efficiencies and should be the default choice for new applications.\n\n### P2WPKH (Pay-to-Witness-Pubkey-Hash)\nA native SegWit address type (BIP 141/173) that provides the same security as P2PKH but with lower fees by moving signature data to the witness section. Addresses start with \"bc1q\" followed by 42 characters and use Bech32 encoding for better error detection. P2WPKH transactions are approximately 38% cheaper than equivalent P2PKH transactions because witness data is discounted in the weight calculation. This is currently the most common address type in use, offering a good balance of compatibility, efficiency, and wallet support.\n\n### P2WSH (Pay-to-Witness-Script-Hash)\nA native SegWit address type for complex scripts (like multisig), providing the same capabilities as P2SH but with SegWit's fee discount on witness data. Addresses start with \"bc1q\" but are longer than P2WPKH (62 characters) due to the larger script hash. Like P2SH, the actual script is only revealed when spending, but the witness discount makes complex redemptions significantly cheaper. P2WSH is commonly used for multisig wallets and Lightning channel funding transactions, though P2TR is increasingly preferred for new deployments.\n\n### Payment Channel\nA mechanism that enables multiple Bitcoin transactions between two parties without broadcasting each one to the blockchain, using a 2-of-2 multisig address as the foundation. Funds are locked in the multisig through an on-chain funding transaction, then balance updates happen off-chain through exchanging signed transactions. Only the final state needs to be published to the blockchain, dramatically reducing fees and enabling instant transfers. Payment channels are the building block of the Lightning Network, which connects many channels into a routable payment network.\n\n### Payment Hash\nA cryptographic hash of the payment preimage, used in Lightning Network HTLCs to cryptographically link payment attempts across the network. The receiver generates a random preimage and provides its hash to the sender; the payment can only be claimed by revealing the preimage that produces this hash. As the preimage propagates backward through the payment path, each hop can verify they received the correct secret by hashing it themselves. This creates an atomic payment mechanism where either the entire path succeeds (preimage revealed) or fails (preimage never revealed).\n\n### Payment Preimage\nA random 32-byte secret generated by the payment recipient that, when hashed, produces the payment hash included in Lightning invoices. The preimage is the \"key\" that unlocks payment. The receiver reveals it to claim funds, and this revelation cascades back through all routing nodes to settle the HTLCs. Knowledge of the preimage serves as proof of payment, since only the original recipient could have revealed it. This mechanism enables trustless multi-hop payments where no routing node can steal funds or deny payment.\n\n### Preimage\nThe original input data that produces a specific hash output through a cryptographic hash function. In general cryptography, finding a preimage from a hash should be computationally infeasible (preimage resistance). In Lightning Network specifically, the payment preimage is the secret whose hash is the payment hash; revealing it proves payment receipt. The preimage/hash relationship is fundamental to HTLCs, enabling conditional payments where funds are released only when the secret is revealed.\n\n### Propagation\nThe process by which new blocks and transactions spread across the Bitcoin network from node to node through the gossip protocol. Fast propagation is critical for network security; slow block propagation increases orphan rates and gives advantages to miners with better connectivity. Bitcoin Core includes optimizations like compact blocks (sending only transaction IDs for blocks) and transaction relay improvements to minimize propagation delay. A new block typically reaches most of the network within seconds, while transactions propagate even faster.\n\n### Private Key\nA 256-bit secret number that cryptographically proves ownership of associated Bitcoin addresses, enabling the creation of valid signatures to spend funds. Private keys must be generated with sufficient randomness and kept absolutely secure. Anyone who obtains a private key can irreversibly steal all funds it controls. Modern wallets generate private keys from seed phrases using deterministic derivation, so users typically only need to secure the seed phrase. Private keys should never be shared, stored unencrypted on connected devices, or entered into websites.\n\n### Proof-of-Work (PoW)\nThe consensus mechanism securing Bitcoin, requiring miners to expend computational resources to find a block hash below a target difficulty threshold. This work is easy to verify but expensive to produce, creating a cost to create blocks that prevents spam and makes chain reorganization economically infeasible. PoW also provides a fair mechanism for distributing new coins and achieves consensus without requiring identity or permission. The energy expenditure, often criticized, is the fundamental source of Bitcoin's security. Attacking the network requires matching or exceeding this ongoing investment.\n\n### PSBT (Partially Signed Bitcoin Transaction)\nA standardized format (BIP 174) for creating, transferring, and signing Bitcoin transactions that require multiple steps or multiple signers. PSBTs contain all necessary information (UTXOs, derivation paths, scripts) for signers to validate and sign, then can be combined into a final transaction. This enables workflows like hardware wallet signing (computer creates PSBT, hardware wallet signs it), multisig coordination (multiple parties each add their signatures), and air-gapped signing (moving unsigned transactions via QR codes or USB). PSBTs are essential for secure, multi-party Bitcoin operations.\n\n### Public Key\nA cryptographic key derived from a private key through one-way elliptic curve multiplication (on the secp256k1 curve), used to verify signatures and generate addresses. Public keys can be safely shared since the mathematical relationship to the private key cannot be reversed. Bitcoin uses two forms: uncompressed (65 bytes, starting with 04) and compressed (33 bytes, starting with 02 or 03), with compressed now standard for efficiency. In Taproot, public keys are further tweaked with 32-byte x-only representation, saving additional space.\n\n## R\n\n### RBF (Replace-by-Fee)\nA feature (BIP 125) that allows replacing an unconfirmed transaction with a new version paying higher fees, useful when the original fee was too low for timely confirmation. For RBF to work, the original transaction must signal replaceability (by setting a sequence number below 0xfffffffe), and the replacement must pay strictly higher fees. Full RBF (allowing replacement of any unconfirmed transaction regardless of signaling) is gaining support and is available in Bitcoin Core 24.0+. RBF is safer and more flexible than CPFP for fee bumping when you created the original transaction.\n\n### Regtest\nA local regression testing network mode where you can mine blocks instantly with minimal difficulty, creating a private blockchain for development and testing. Unlike testnet or signet, regtest runs entirely on your local machine with no connection to other nodes, giving complete control over block production and timing. This makes it ideal for automated testing, debugging, and developing applications that need predictable block times. Regtest coins have no value and the chain can be reset at any time.\n\n### Relative Time Lock\nA time lock that prevents a UTXO from being spent until a certain number of blocks or time units have passed since the UTXO itself was confirmed, implemented using OP_CHECKSEQUENCEVERIFY (CSV) and the sequence field. Unlike absolute time locks (CLTV), relative locks count from when the spending UTXO was created, enabling \"wait N blocks after X happens\" logic. This is essential for Lightning Network, where CSV ensures parties have time to respond to channel disputes. Relative time locks enable complex protocols that depend on ordering of events rather than calendar dates.\n\n### Relay\nThe act of receiving valid blocks or transactions from peers and forwarding them to other connected nodes, which is how information propagates across the decentralized Bitcoin network. Nodes validate data before relaying to prevent spam and invalid data from spreading. Relay policies can differ between nodes (some may reject transactions below certain fee rates or with specific characteristics), but blocks that meet consensus rules are always relayed. Efficient relay is critical for network health, and improvements like compact blocks and Erlay reduce bandwidth requirements.\n\n### RIPEMD-160\nA cryptographic hash function that produces a 160-bit (20-byte) output, used in Bitcoin address generation to create shorter addresses while maintaining security. The standard address derivation applies SHA-256 to the public key first, then RIPEMD-160 to that result, producing the 20-byte \"pubkey hash\" that forms the core of an address. This HASH160 operation (SHA256 + RIPEMD160) provides 160-bit security while keeping addresses reasonably short. RIPEMD-160 was chosen for its output size; the double-hash construction provides defense in depth against potential weaknesses in either algorithm.\n\n### RPC (Remote Procedure Call)\nThe JSON-RPC protocol interface that Bitcoin Core exposes for programmatic interaction, allowing applications to query blockchain data, manage wallets, and create transactions. Common RPC commands include getblockchaininfo, getblock, getrawtransaction, sendrawtransaction, and wallet management functions. The RPC interface is how block explorers, payment processors, and other applications integrate with Bitcoin nodes. Access is controlled by authentication credentials in bitcoin.conf, and the interface listens only on localhost by default for security.\n\n### Routing\nThe process of finding a path through the Lightning Network's channel graph from the payment sender to the recipient. Senders query the network gossip data to build a local graph of channels, then use pathfinding algorithms to find routes with sufficient liquidity and acceptable fees. Routes must have enough capacity at each hop, and the sender typically tries multiple paths if the first fails. Good routing considers fees, channel reliability, and privacy (avoiding routes through potentially malicious nodes). Routing remains one of Lightning's active research areas.\n\n### Routing Fee\nThe fee charged by Lightning nodes for forwarding payments through their channels, compensating them for providing liquidity and taking on channel management costs. Fees consist of two components: a base fee (fixed amount per forwarded payment, often 0-1000 millisatoshis) and a proportional fee (percentage of the payment amount, often 0.0001% to 0.1%). Routing nodes set their own fee policies, and senders choose routes partly based on total fees. Well-connected nodes with good liquidity can earn meaningful income from routing fees, incentivizing network connectivity.\n\n## S\n\n### Satoshi\nThe smallest unit of Bitcoin, representing 0.00000001 BTC (one hundred millionth of a Bitcoin). Named after Bitcoin's pseudonymous creator, [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto), this denomination enables Bitcoin to be used for micropayments despite any future price appreciation. Lightning Network even uses millisatoshis (1/1000 of a satoshi) for routing fee calculations, though on-chain transactions are limited to whole satoshi precision. As Bitcoin's value has increased, satoshis (often abbreviated \"sats\") have become the more practical unit for everyday discussion of prices and payments.\n\n### Seed Phrase\nA human-readable backup of a wallet's master secret, typically consisting of 12-24 words from a standardized BIP39 wordlist of 2048 words. This mnemonic phrase encodes the entropy used to derive all wallet keys through hierarchical deterministic (HD) derivation, allowing complete wallet recovery from just these words. Seed phrases should be stored securely offline (metal backups are popular) and never entered into computers except during recovery. Compromising a seed phrase means losing all funds across all addresses and chains derived from it, as it's effectively the master key to everything.\n\n### Share\nA proof-of-work submission from a miner to a mining pool that meets the pool's difficulty target (lower than the actual network difficulty). Shares prove the miner is doing work without requiring them to find actual blocks, enabling fair reward distribution. A pool might require shares at 1/1000th of network difficulty, so miners submit approximately 1000 shares for every block the pool finds. Share counting allows pools to distribute block rewards proportionally to contributed hash power, dramatically reducing individual miner variance.\n\n### Script\nBitcoin's stack-based programming language used to define spending conditions for transaction outputs and provide proofs to satisfy them. Script is intentionally limited (not Turing complete) to ensure all programs terminate and can be analyzed for validity and resource consumption. Scripts execute by pushing data and running opcodes that manipulate a stack; a successful spend results in a non-empty stack with a true value on top. While most transactions use standard script templates (P2PKH, P2WPKH, P2TR), Script enables sophisticated smart contracts including multisig, time locks, and hash locks.\n\n### ScriptPubKey\nThe locking script embedded in a transaction output that defines what conditions must be met to spend those funds. Named because it typically involves a public key or its hash, the scriptPubKey is essentially a puzzle that the spender must solve. Common patterns include requiring a signature matching a specific public key hash (P2PKH), satisfying a hashed script (P2SH), or meeting SegWit witness requirements (P2WPKH, P2WSH, P2TR). The scriptPubKey is created by the sender when making a payment and determines the address format used.\n\n### ScriptSig\nThe unlocking script in a transaction input that provides the data needed to satisfy the referenced output's scriptPubKey conditions. For P2PKH outputs, the scriptSig contains the signature and public key; for P2SH, it contains the serialized redeem script and any necessary signatures. The scriptSig is concatenated with the scriptPubKey during validation, and the combined script must execute successfully to validate the spend. With SegWit, much of this data moved to the separate witness field, but legacy transactions still use scriptSig.\n\n### SegWit (Segregated Witness)\nA major protocol upgrade activated in August 2017 (BIP 141) that moves signature data (\"witness\") outside the base transaction structure, fixing several important issues. SegWit resolved transaction malleability (which had blocked Lightning Network development), increased effective block capacity through a new weight-based limit, and enabled future upgrades like Taproot. By segregating witness data and applying a discount factor, SegWit transactions pay lower fees, typically 30-40% less than equivalent legacy transactions. SegWit also created a cleaner upgrade path through witness versioning.\n\n### SHA-256\nA cryptographic hash function from the SHA-2 family that produces a 256-bit (32-byte) output, used extensively in Bitcoin for proof-of-work, transaction IDs, and block hashing. SHA-256 provides strong security properties: it's computationally infeasible to find an input that produces a specific hash (preimage resistance), to find two different inputs with the same hash (collision resistance), and small input changes completely change the output (avalanche effect). Bitcoin's proof-of-work specifically uses double SHA-256, hashing the block header twice.\n\n### SHA256D\nDouble SHA-256 hashing used throughout Bitcoin, where data is hashed twice in succession: `SHA256(SHA256(data))`. Block headers, transaction IDs, and merkle tree nodes all use SHA256D. This construction provides defense in depth: even if vulnerabilities were discovered in single SHA-256, attacking double-hashed values would remain difficult. When miners perform proof-of-work, they're computing SHA256D of 80-byte block headers billions of times per second, searching for results below the difficulty target.\n\n### Schnorr Signature\nA digital signature scheme (BIP 340) introduced with Taproot that offers several advantages over the previously-used ECDSA. Schnorr signatures are mathematically simpler, provably secure under standard assumptions, and enable powerful features like signature aggregation (combining multiple signatures into one) and batch verification (verifying many signatures faster than individually). With Schnorr, a transaction from a multisig wallet can look identical to a single-sig transaction on-chain, significantly improving privacy. Schnorr also reduces signature size and enables MuSig protocols for collaborative signing.\n\n### Selfish Mining\nAn attack strategy where a miner with significant hash power secretly mines blocks without broadcasting them, then strategically releases them to orphan honest miners' blocks. By withholding blocks and timing releases, an attacker can potentially earn more than their proportional share of hash power would suggest. Research shows selfish mining becomes profitable above roughly 25-33% of hash power (depending on network connectivity). While concerning theoretically, no sustained selfish mining attacks have been documented on Bitcoin, partly due to the capital costs and detection risks.\n\n### Silent Payments\nA privacy protocol (BIP 352) enabling recipients to publish a static identifier from which senders can derive unique, unlinkable addresses for each payment. This solves the address reuse problem without requiring interaction, as the recipient doesn't need to generate and share new addresses for each payment. Senders use ECDH with their transaction inputs and the recipient's public key to derive a unique one-time address. Recipients scan the blockchain using their private key to detect payments. Silent Payments provide stealth address-like privacy while being simpler and more compatible with the existing ecosystem.\n\n### Signet\nA test network (BIP 325) that adds a signature requirement to block validity, enabling more controlled and realistic testing than regtest while avoiding testnet's issues with griefing and worthless coins. Signet blocks must be signed by specific keys, so only authorized parties can mine blocks, preventing the spam and instability that plagued testnet. The default signet is maintained by Bitcoin developers and operates similarly to mainnet in terms of transaction competition and fee markets. Custom signets can be created for private testing networks.\n\n### Soft Fork\nA backward-compatible protocol change that tightens consensus rules, making some previously valid transactions or blocks now invalid. Non-upgraded nodes continue accepting new blocks but may not understand new features (they see transactions as \"anyone can spend\" but observe miners not spending them). Examples include SegWit (BIP 141) and Taproot (BIP 341). Soft forks can be activated through various methods including flag-day activation, miner signaling, or speedy trial. Because soft forks don't force the network to split, they're Bitcoin's preferred upgrade mechanism.\n\n### Sphinx Protocol\nThe onion routing protocol used in Lightning Network to provide payment privacy, where route information is encrypted in layers like an onion. The sender constructs the entire encrypted packet, with each routing node only able to decrypt their layer to learn the next hop. Sphinx ensures that no intermediate node learns the payment origin, destination, or their position in the route. The protocol also provides a return path for error messages without revealing route information. Sphinx is specified in BOLT 4 and is fundamental to Lightning's privacy guarantees.\n\n### SPV (Simplified Payment Verification)\nA method described in the Bitcoin whitepaper for lightweight clients to verify transactions without downloading the full blockchain, relying on merkle proofs and block headers. SPV clients download only block headers (~80 bytes each vs. megabytes of full blocks), then request merkle proofs for transactions affecting their addresses. By verifying the proof against the merkle root in the header and checking that header is part of the longest chain, SPV clients can confirm transaction inclusion with reasonable security. The tradeoff is trusting that miners are not mining invalid blocks.\n\n### Stratum\nThe de facto standard protocol for communication between Bitcoin miners and mining pools, enabling work distribution and share submission. Stratum v1 has pools send work (block header template and target) to miners, who submit shares (valid proofs of work). Stratum V2 is a next-generation protocol that adds encryption, enables miners to select their own transactions (improving decentralization), and reduces bandwidth usage. Most mining operations use Stratum to connect to pools, with the pool handling block construction and broadcasting.\n\n### Sybil Attack\nAn attack where a malicious actor creates many fake identities (nodes) to gain disproportionate influence over the network, potentially to eclipse victims from honest nodes or manipulate peer discovery. Bitcoin mitigates Sybil attacks through several mechanisms: proof-of-work means mining power can't be faked, nodes limit connections per IP range, and the economic cost of running many nodes provides some resistance. However, well-resourced attackers can still attempt Sybil attacks, which is why users running their own full nodes and having diverse peer connections matters for security.\n\n## T\n\n### Taproot\nA major Bitcoin protocol upgrade activated in November 2021 (BIPs 340, 341, 342) that significantly improves privacy, efficiency, and smart contract capabilities. Taproot combines Schnorr signatures, MAST (Merkle Abstract Syntax Trees), and a new script version to make complex transactions indistinguishable from simple payments when using the key path. This means multisig wallets, Lightning channels, and sophisticated contracts all look like normal single-signature transactions on-chain, dramatically improving privacy for everyone. Taproot also enables more efficient complex scripts and paves the way for future innovations like cross-input signature aggregation.\n\n### Testnet\nA public Bitcoin network using worthless test coins, designed for development and testing without risking real money. Testnet uses different address prefixes (starting with \"m\", \"n\", \"2\", or \"tb1\") and different genesis block, ensuring testnet and mainnet transactions can never be confused. Testnet has had issues with griefing (malicious difficulty spikes) and coins sometimes acquiring value despite being meant to be free. For more controlled testing, many developers prefer signet (more stable) or regtest (fully local). Testnet4 was introduced in 2024 to address some of testnet3's accumulated issues.\n\n### Time Lock\nA mechanism built into Bitcoin transactions that prevents funds from being spent until specified conditions are met, enabling time-based smart contracts. Absolute time locks (CLTV) prevent spending until a specific block height or Unix timestamp. Relative time locks (CSV) prevent spending until a certain time has passed since the UTXO was created. Time locks are fundamental to Lightning Network (for HTLC refunds), inheritance planning, vesting schedules, and various escrow arrangements. Both transaction-level (nLockTime, nSequence) and script-level (OP_CLTV, OP_CSV) time locks exist.\n\n### TLV (Type-Length-Value)\nA flexible encoding format used extensively in Lightning Network protocol messages (BOLT specifications) that allows for extensible and forward-compatible data structures. Each TLV record contains a type identifier (what kind of data), a length (how many bytes), and the value itself. Nodes can safely ignore TLV types they don't understand while processing ones they do, enabling smooth protocol upgrades where new features can be added without breaking older implementations. TLV encoding is used for onion payloads, channel announcements, and various other Lightning message types.\n\n### Transaction\nThe fundamental unit of value transfer in Bitcoin, consisting of inputs (references to previously unspent outputs being consumed), outputs (new UTXOs being created with specified amounts and spending conditions), and metadata. Every Bitcoin transaction must consume at least one existing UTXO and create at least one new one. The sum of input values must equal or exceed the sum of output values, with any difference becoming the miner fee. Transactions are validated by nodes, broadcast through the network, and eventually included in blocks by miners.\n\n### Transaction Fee\nThe amount paid to miners as incentive for including a transaction in a block, calculated as the difference between total input value and total output value. Fees are paid in satoshis and typically expressed as a fee rate (satoshis per virtual byte) to account for transaction size. During periods of high demand, users compete by offering higher fee rates to get faster confirmation. Transaction fees represent an increasingly important component of miner revenue as block subsidies halve every four years, and they're essential to Bitcoin's long-term security model.\n\n### Transaction ID (TXID)\nA unique 256-bit identifier for a transaction, calculated as the SHA256D hash of the serialized transaction data. TXIDs are used to reference transactions in inputs (specifying which output to spend), in block merkle trees, and throughout the ecosystem for tracking and identification. Before SegWit, TXIDs could be changed by third parties through malleability attacks by altering signatures without invalidating them. SegWit introduced the WTXID (witness transaction ID) that includes witness data, while the TXID excludes it, fixing malleability for SegWit transactions.\n\n### Transaction Malleability\nA historical vulnerability where transaction signatures could be modified by third parties without invalidating them, causing the transaction ID to change even though the transaction itself remained valid. This was problematic for protocols that needed to reference unconfirmed transactions by TXID, like Lightning Network channels that reference funding transactions before they confirm. SegWit (BIP 141) fixed malleability by moving signature data to a separate witness structure not included in the TXID calculation. This fix was a prerequisite for Lightning Network's development and security.\n\n## U\n\n### UTXO (Unspent Transaction Output)\nA transaction output that hasn't been spent yet, representing the actual \"coins\" in Bitcoin's accounting model. Unlike account-based systems (like bank accounts), Bitcoin tracks ownership through discrete UTXOs. Each is either entirely unspent or entirely consumed when used as an input. When you \"have 1 BTC\", you actually possess one or more UTXOs that sum to that amount. Spending requires consuming entire UTXOs and creating new ones, including change outputs when the input exceeds the payment. Understanding the UTXO model is fundamental to grasping Bitcoin's transaction structure and privacy characteristics.\n\n### UTXO Set\nThe complete database of all unspent transaction outputs at a given point in time, representing the current state of Bitcoin ownership. Full nodes maintain the UTXO set in memory or fast storage for quick transaction validation, checking that referenced inputs exist and aren't already spent. The UTXO set currently contains around 70-100 million entries requiring several gigabytes to store. Keeping the UTXO set manageable is important for node performance, which is why creating dust outputs and unnecessary UTXOs is discouraged. AssumeUTXO allows new nodes to bootstrap quickly with a trusted UTXO set snapshot.\n\n## V\n\n### vByte (Virtual Byte)\nA unit of transaction size measurement introduced with SegWit, calculated as weight units divided by 4, used for fee calculation and block space accounting. Virtual bytes provide backward compatibility with legacy fee estimation while incorporating SegWit's discount for witness data. A legacy transaction has equal vBytes and actual bytes, while SegWit transactions have fewer vBytes than actual bytes due to the witness discount. Fee rates are typically expressed in satoshis per vByte (sat/vB), and the block limit of 4 million weight units translates to 1 million vBytes maximum per block.\n\n## W\n\n### Wallet\nSoftware (or hardware) that manages Bitcoin private keys, tracks balances, and creates transactions on behalf of the user. Wallets can be full node (run their own node for verification), SPV (trust others for block validation), or custodial (third party holds keys). Hardware wallets store keys on secure devices that never expose private keys to potentially compromised computers. Modern wallets typically use HD (hierarchical deterministic) architecture, deriving all keys from a single seed phrase for easy backup. Wallet selection involves tradeoffs between security, convenience, privacy, and self-custody.\n\n### Watchtower\nA service that monitors the Bitcoin blockchain on behalf of Lightning Network users, watching for attempts to close channels with outdated (fraudulent) states. When a channel counterparty broadcasts a revoked commitment transaction while you're offline, the watchtower detects it and broadcasts a penalty transaction to claim all channel funds on your behalf. Watchtowers solve the \"always online\" problem in Lightning, allowing users to go offline safely knowing their channels are monitored. Some watchtowers operate as paid services, while users can also run their own or use free community services.\n\n### Weight Units\nThe measurement system introduced by SegWit for calculating transaction size and block capacity, where base transaction data counts as 4 weight units per byte and witness data counts as 1 weight unit per byte. This 4:1 discount for witness data incentivizes SegWit adoption and reduces the fee cost of signatures. The block limit is 4 million weight units, which translates to approximately 1 MB of base data plus additional witness data, enabling effective block sizes of around 2-4 MB for blocks full of SegWit transactions. Weight units divided by 4 gives virtual bytes (vBytes), used for fee calculation.\n\n### Witness\nThe segregated data structure in SegWit transactions containing signatures, public keys, and other unlocking data that proves authorization to spend inputs. By moving witness data outside the base transaction (and thus outside the TXID calculation), SegWit fixed transaction malleability and enabled the witness discount for fee calculation. The witness is committed to through a separate witness root in the coinbase transaction rather than affecting the main merkle tree. For Taproot (witness version 1), the witness structure includes Schnorr signatures and, for script path spends, the revealed script and merkle proof.\n\n## Z\n\n### ZMQ (ZeroMQ)\nA high-performance messaging library integrated into Bitcoin Core that provides real-time publish-subscribe notifications for new blocks, transactions, and other events. Applications can subscribe to ZMQ topics (like \"rawtx\" for new transactions or \"hashblock\" for new blocks) and receive instant notifications without polling the RPC interface. This is essential for building responsive applications that need to react immediately to blockchain events. Block explorers, payment processors, and Lightning nodes commonly use ZMQ for event-driven architectures. ZMQ must be explicitly enabled in Bitcoin Core configuration and typically binds to a TCP port for local connections.\n",
    "filename": "terms.md"
  }
}