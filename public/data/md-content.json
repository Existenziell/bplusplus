{
  "/docs/fundamentals": {
    "content": "# What is Bitcoin?\n\nBitcoin is a decentralized digital currency and payment system that operates without a central authority or intermediary. It was created in 2009 by an anonymous person or group using the pseudonym [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto), who first described the system in the [Bitcoin whitepaper](/whitepaper) published on October 31, 2008.\n\nWhile this definition captures Bitcoin's technical foundation, Bitcoin is multifaceted. As you go down the Bitcoin rabbit hole, you'll discover that Bitcoin represents something unprecedented in human history. Bitcoin has a way of enticing you to learn more about related topics: economics, game theory, cryptography, monetary history, and the nature of trust itself.\n\nStay curious and keep learning ðŸ§¡\n\n---\n\n**Bitcoin** (capitalized) refers to the protocol, network, and system.  \n**bitcoin** (lowercase) or **BTC** refers to the currency unit.\n\n\n> **Note:** Throughout this documentation, \"Bitcoin\" refers specifically to **BTC (Bitcoin Core)**, the original and longest-running Bitcoin network. While other networks like Bitcoin Cash (BCH) and Bitcoin SV (BSV) share Bitcoin's history up to their respective fork points, they are separate networks with different consensus rules. This documentation focuses exclusively on Bitcoin (BTC).  \n>   \n> **Be aware:** The website bitcoin.com promotes Bitcoin Cash (BCH), not Bitcoin (BTC). Despite its name, it is not the official Bitcoin website and does not represent the Bitcoin (BTC) network.\n\n---\n\n## Core Components\n\nBitcoin consists of several key components that work together to create a decentralized monetary system:\n\n**Blockchain:** The [distributed ledger](/docs/fundamentals/blockchain) that records all transactions in cryptographically linked blocks, creating an immutable history that all network participants can verify.\n\n**Cryptography:** The mathematical foundation of Bitcoin. [Elliptic curve cryptography](/docs/bitcoin/cryptography) enables unforgeable digital signatures, while hash functions provide data integrity and mining security.\n\n**Consensus Mechanism:** Bitcoin's [consensus mechanism](/docs/bitcoin/consensus) allows thousands of nodes worldwide to agree on a single transaction history without central coordination, using proof-of-work and economic incentives.\n\n**Script:** [Bitcoin Script](/docs/bitcoin/script) is a simple programming language that defines spending conditions, enabling features like multi-signature wallets and time-locked transactions.\n\n**OP Codes:** The [instruction set](/docs/bitcoin/op-codes) that powers Bitcoin Script, with each opcode performing specific operations for transaction validation and program execution.\n\n**Block Structure:** [Blocks](/docs/bitcoin/blocks) are the fundamental units of Bitcoin's ledger, organizing transactions and enabling efficient verification through Merkle trees.\n\n**Economic Rules:** The [subsidy equation](/docs/bitcoin/subsidy) mathematically guarantees Bitcoin's fixed supply, creating a predictable monetary policy that approaches 21 million coins.\n\n---\n\n## Technical Innovation\n\n### Proof-of-Work\n- Secures the network through computational work\n- Prevents [double-spending](/docs/glossary#double-spend)\n- Reaches [consensus](/docs/glossary#consensus) without central authority\n- Requires significant computational resources\n\n### UTXO Model\n- [Unspent Transaction Outputs](/docs/fundamentals/utxos) - The fundamental accounting model of Bitcoin\n- Each transaction consumes and creates UTXOs\n- Enables parallel transaction processing\n- Clear ownership model\n\n### Merkle Trees\n- Efficient transaction verification\n- Compact block structure\n- Enables [SPV](/docs/glossary#spv-simplified-payment-verification) (Simplified Payment Verification)\n- Cryptographic integrity\n\n---\n\n## The Many Faces of Bitcoin\n\n### The New Element\n\nBitcoin represents something unprecedented: **Element Zero**, consisting only of energy.\n\n**Proof of Work** is the bridge between the physical and digital worlds. Real energy (electricity, computational power, thermodynamic work) is consumed to maintain the digital scarcity of bitcoin. This is not a bug, but a feature. The energy expenditure is what gives bitcoin its unforgeable costliness, anchoring digital value to physical reality in a way no other digital asset can claim.\n\n### The Currency\n\nBitcoin is **deflationary money with absolute scarcity**. Only 21 million bitcoin will ever exist, a fixed supply that cannot be inflated, diluted, or manipulated.\n\nThis scarcity will produce conditions of human interaction never before seen in monetary history:\n- **Abundance through deflation**: As productivity increases, the value of saved bitcoin grows\n- **Long-term thinking**: Sound money encourages saving and investment over consumption\n- **True price discovery**: Without monetary manipulation, markets can function honestly\n\n### The Commodity\n\nBitcoin can **store value across time**. Like gold, but better:\n- Infinitely divisible\n- Perfectly portable\n- Easily verifiable\n- Impossible to counterfeit\n- Resistant to confiscation\n\n### The Protocol\n\nBitcoin is a protocol that allows for **free and instant transfers of value** across the entire planet.\n\n- **Trustless**: No need to trust any third party\n- **Permissionless**: Anyone can participate without asking permission\n- **Borderless**: Works the same everywhere on Earth\n\n**Bitcoin is a trust machine.** It replaces trust in institutions with mathematical verification.\n\n### The Network\n\n**Miners**: Transform energy into bitcoin. They compete to solve cryptographic puzzles, securing the network and processing transactions. In doing so, they convert raw energy into the most secure monetary network ever created.\n\n**Nodes**: Verify that the network rules were followed. Every node is a server on the Bitcoin network, independently validating every transaction and block. This distributed verification is what makes Bitcoin truly decentralized.\n\n### The Idea\n\nAt its core, Bitcoin is nothing but a **meme**, an idea that replicates itself through human minds.\n\nBitcoin embodies the idea that a **fixed set of rules can exist** around which entire societies can be built, rules that no government, corporation, or individual can change.\n\nIt unlocks the **true power of human cooperation**: voluntary exchange based on mutually agreed rules that cannot be violated.\n\nOnce the concept of sound, digital, decentralized money enters someone's mind, it cannot be unseen. It spreads from person to person, generation to generation, border to border.\n\nSee [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) for how these ideas spread and the cultural memes that have emerged.\n\n### The Threat\n\nBitcoin is under **constant attack** from the most sophisticated entities on this planet:\n- Intelligence agencies (NSA, KGB, Mossad, and countless others)\n- Central banks protecting their monopoly on money\n- Governments seeking to maintain financial control\n- Hackers seeking the largest bug bounty in history\n\n**And it has never been hacked.**\n\nThe network has operated continuously since January 3, 2009, securing hundreds of billions of dollars in value. The only theoretical attack (a 51% attack) would require controlling more computational power than all other miners combined, a feat that grows more impossible as the network expands.\n\nBitcoin cannot be hacked. It can only be adopted.\n\n---\n\n## Explore Bitcoin Fundamentals\n\nDive deeper into the core concepts that make Bitcoin work:\n\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - The fundamental challenges Bitcoin addresses\n- [Cypherpunk Philosophy](/docs/fundamentals/cypherpunk-philosophy) - The philosophical foundation behind Bitcoin's design\n- [The Blockchain](/docs/fundamentals/blockchain) - How blocks are cryptographically linked to create an immutable chain\n- [Bitcoin as Timechain](/docs/fundamentals/timechain) - How Bitcoin solves timing in decentralized networks\n- [UTXO Model](/docs/fundamentals/utxos) - How Bitcoin tracks ownership through unspent transaction outputs\n- [Decentralization](/docs/fundamentals/decentralization) - Distribution of control across the network\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin minimizes trust requirements\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - The economic characteristics of Bitcoin\n- [Denominations](/docs/fundamentals/denominations) - Bitcoin units from satoshis to BTC and how to convert between them\n- [Incentive Structure](/docs/fundamentals/incentives) - How economic incentives shape Bitcoin's security\n- [Game Theory](/docs/fundamentals/game-theory) - How strategic decision-making secures the Bitcoin network\n- [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) - How Bitcoin functions as a powerful idea that spreads through culture\n",
    "filename": "overview.md"
  },
  "/docs/fundamentals/problems": {
    "content": "# What Problems Did Bitcoin Solve?\n\nBitcoin addresses fundamental challenges in digital currency and distributed systems that had prevented previous attempts at decentralized money.\n\n## The Core Challenges\n\nBefore Bitcoin, decentralized digital currency faced seemingly insurmountable problems:\n\n- **No central authority:** Traditional systems rely on banks/servers to coordinate\n- **Network unreliability:** Nodes fail, messages get lost, partitions occur\n- **Byzantine failures:** Some participants may be malicious or send conflicting information\n- **Timing:** No synchronized clocks or central time source to order events (see [Bitcoin as Timechain](/docs/fundamentals/timechain) for how this is solved)\n\n---\n\n## The Double-Spending Problem\n\nDouble-spending occurs when the same digital currency unit is spent more than once. Unlike physical cash, digital information can be perfectly copied; without protection, the same coin could be sent to multiple recipients simultaneously, destroying the currency's value.\n\n**Traditional solution:** A central authority (bank) maintains the ledger and verifies each transaction. Problem: requires trust in that authority.\n\n**Bitcoin's solution:** A public blockchain where all transactions are visible, ordered into blocks, and secured by [proof-of-work](/docs/glossary#proof-of-work-pow). Nodes independently verify that inputs haven't been spent. The longest chain determines valid transactions, so only the first spend succeeds.\n\n```\nAlice has 1 BTC, attempts to send it to both Bob and Charlie:\nâ†’ Network includes first transaction in block N\nâ†’ Second transaction rejected (input already spent)\nâ†’ Result: Only one transaction succeeds\n```\n\n:::video-group\n[How Satoshi Nakamoto Solved The Double Spending Problem](https://www.youtube.com/watch?v=yBwDGby1yZA)\n[Double-Spending Problem Explained by a Developer](https://www.youtube.com/watch?v=jtc3_Gw39Ps?t=39)\n:::\n\n---\n\n## The Two Generals Problem\n\nA classic distributed systems problem that demonstrates the impossibility of achieving perfect agreement over an unreliable communication channel.\n\n### The Scenario\n\nTwo armies, led by two generals, are positioned on opposite sides of an enemy city. They must coordinate a simultaneous attack to succeed. The only way to communicate is by sending messengers through enemy territory, where they may be captured or killed.\n\n**The dilemma:**\n- General A sends a message: \"Attack at dawn\"\n- General B receives it and sends back: \"Acknowledged, attacking at dawn\"\n- General A receives the acknowledgment, but thinks: \"How do I know General B received my acknowledgment of their acknowledgment?\"\n- This creates infinite regress: each confirmation requires its own confirmation\n\n### Why It's Theoretically Unsolvable\n\nIn a system with unreliable communication, perfect certainty is mathematically impossible. No matter how many confirmations are exchanged, there's always a non-zero probability that the last message was lost, leaving one general uncertain about whether coordination was achieved.\n\n### Bitcoin's Solution\n\nBitcoin sidesteps the impossibility by accepting **probabilistic finality** instead of perfect certainty:\n\n1. **Proof-of-work creates objective ordering:** Blocks are ordered by computational work, not by message acknowledgments\n2. **The longest chain rule:** The network naturally converges on a single history through economic incentives\n3. **Increasing certainty over time:** Each block added makes the previous blocks exponentially harder to reverse\n4. **Practical finality:** While theoretically reversible, 6 confirmations (about 1 hour) is considered effectively irreversible due to the enormous computational cost required\n\nThis is fundamentally different from trying to achieve perfect certainty through message acknowledgments; Bitcoin uses economic and cryptographic mechanisms to create convergence without requiring perfect communication.\n\n### Two Generals vs. Byzantine Generals\n\nThese are often confused but address different problems:\n\n| Aspect | Two Generals Problem | Byzantine Generals Problem |\n|--------|---------------------|---------------------------|\n| **Core Issue** | Unreliable communication (messages may be lost) | Malicious actors (messages may be corrupted or conflicting) |\n| **Assumption** | All parties are honest but communication is unreliable | Some parties may be malicious and send false information |\n| **Focus** | Achieving agreement despite message loss | Achieving agreement despite malicious behavior |\n| **Bitcoin's Approach** | Probabilistic finality through proof-of-work | Economic security (assumes <50% malicious hash rate) |\n\n**In summary:** The Two Generals Problem is about **unreliable channels**, while the Byzantine Generals Problem is about **unreliable participants**. Bitcoin addresses both: proof-of-work handles unreliable communication through probabilistic finality, while the longest-chain rule and economic incentives handle potentially malicious miners.\n\n:::video-group\n[The Byzantine Generals problem, and why it matters for Bitcoin](https://www.youtube.com/watch?v=Bvj72wN0OVk)\n[The Byzantine Generals Problem](https://www.youtube.com/watch?v=fyf-MCz0Qoo)\n:::\n\n---\n\n## Other Problems Solved\n\n| Problem | Traditional Issue | Bitcoin's Solution |\n|---------|------------------|-------------------|\n| **Byzantine Generals** | Malicious nodes send conflicting information | Proof-of-work makes attacks expensive; assumes <50% malicious hash rate |\n| **Trust in Third Parties** | Must trust banks, payment processors, governments | Cryptographic proof replaces institutional trust; no intermediaries |\n| **Inflation** | Central banks can print unlimited money | Fixed 21M supply; predictable issuance; no authority can inflate |\n| **Cross-Border Payments** | Slow (days), expensive, requires intermediaries | Minutes to hours, lower fees, works 24/7, same currency globally |\n| **Financial Inclusion** | Billions unbanked, high barriers, geographic restrictions | Anyone with internet access can participate; no account required |\n\n---\n\n## The Innovation\n\nBitcoin didn't invent new primitives; it combined existing techniques in a novel way:\n\n- **Cryptography:** Digital signatures, hash functions\n- **Distributed systems:** Peer-to-peer network\n- **Economics:** Incentive alignment\n- **Game theory:** Nash equilibrium makes honest behavior profitable\n\nPrevious digital currency attempts required central authority and couldn't prevent double-spending. Bitcoin achieves decentralized consensus through this combination, proving that trustless digital money is possible.\n\n---\n\n## The Philosophical Foundation\n\nThe problems Bitcoin solved were precisely the problems that [cypherpunk philosophy](/docs/fundamentals/cypherpunk-philosophy) had been trying to address for decades. Cypherpunks believed that cryptography could enable individual freedom by eliminating the need to trust institutions. Bitcoin was the first system to successfully implement these cypherpunk ideals, creating a practical solution to problems that had been identified but not solved for over 20 years.\n",
    "filename": "problems.md"
  },
  "/docs/fundamentals/cypherpunk-philosophy": {
    "content": "# Cypherpunk Philosophy\n\nBitcoin didn't emerge from a vacuum. It was born from a decades-long movement of cryptographers, privacy advocates, and technologists who believed that cryptography could be a tool for individual freedom and liberation. This movement, known as **cypherpunk**, provided the philosophical foundation that shaped Bitcoin's core design principles. Cypherpunk is a philosophy and movement that advocates for **privacy and freedom through cryptography**. The term combines \"cypher\" (encryption) and \"punk\" (rebellious counterculture). Cypherpunks believe that:\n\n- **Privacy is a fundamental right** that must be protected through technology, not granted by institutions\n- **Cryptography enables individual sovereignty** by allowing people to communicate and transact without surveillance\n- **Code is law**: mathematical proof is more reliable than trust in institutions\n- **Decentralization prevents control** by removing single points of failure and authority\n\nThe cypherpunk movement emerged in the late 1980s and early 1990s, as the internet was becoming mainstream and governments began discussing encryption regulations. Cypherpunks saw cryptography as a tool for protecting individual rights in the digital age.\n\n---\n\n## Core Principles\n\n### Privacy Through Cryptography\n\n![Cypherpunk Manifesto](/images/docs/cypherpunk.webp)\n\nCypherpunks believe that privacy is essential for an open society, but it cannot be granted by governments or corporations; it must be **enforced through mathematics**. As [Eric Hughes](/docs/history/people#eric-hughes) wrote in \"A Cypherpunk's Manifesto\" (1993):\n\n> \"Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn't want the whole world to know, but a secret matter is something one doesn't want anybody to know. Privacy is the power to selectively reveal oneself to the world.\"\n\nBitcoin embodies this principle through:\n- **Pseudonymity**: Addresses don't require identity verification\n- **Public-key cryptography**: Transactions are verifiable without revealing identity\n- **No mandatory KYC**: Users can participate without revealing personal information\n- **Blockchain analysis resistance**: Techniques like coin mixing and address reuse avoidance\n\n### Trust in Code, Not Institutions\n\nCypherpunks advocate for **trusting mathematics and code** rather than people or institutions. This principle is captured in the phrase \"code is law\": the rules are enforced by cryptographic proof, not by human interpretation or enforcement.\n\nBitcoin implements this through:\n- **Cryptographic proof**: Digital signatures prove ownership mathematically\n- **Open-source code**: Anyone can audit the protocol\n- **Consensus rules**: Enforced by code, not by vote or decree\n- **No trusted third parties**: The protocol itself provides security\n\nThis connects directly to Bitcoin's [trust model](/docs/fundamentals/trust-model), which minimizes trust in institutions and maximizes trust in cryptographic proof.\n\n### Decentralization and Avoiding Central Control\n\nCypherpunks recognized that **centralized systems create single points of failure and control**. Any system with a central authority can be:\n- Censored\n- Shut down\n- Manipulated\n- Surveilled\n\nBitcoin's [decentralization](/docs/fundamentals/decentralization) directly addresses this concern:\n- **No central authority**: No company, government, or individual controls Bitcoin\n- **Distributed network**: Thousands of nodes worldwide\n- **Permissionless**: Anyone can participate without approval\n- **Censorship-resistant**: No one can prevent valid transactions\n\n### Permissionless Participation\n\nCypherpunks believe that **participation in digital systems should not require permission**. Traditional financial systems require:\n- Identity verification (KYC)\n- Account approval\n- Geographic restrictions\n- Regulatory compliance\n\nBitcoin enables permissionless participation:\n- **No account required**: Just generate a key pair\n- **No identity verification**: Pseudonymous addresses\n- **Global access**: Works the same everywhere\n- **No gatekeepers**: No one can prevent you from using Bitcoin\n\n### Censorship Resistance\n\nCypherpunks saw censorship as a fundamental threat to freedom. Bitcoin's design makes censorship extremely difficult:\n- **No central authority** to block transactions\n- **Distributed network** prevents shutdown\n- **Cryptographic proof** prevents false claims of invalidity\n- **Economic incentives** align miners toward including all valid transactions\n\n---\n\n## Historical Context\n\n### The Cypherpunk Mailing List\n\nIn 1992, three mathematicians ([Eric Hughes](/docs/history/people#eric-hughes), [Timothy C. May](/docs/history/people#timothy-c-may), and John Gilmore) founded the **cypherpunk mailing list**. This became the central forum for discussing cryptography, privacy, and digital cash. The mailing list included:\n- Cryptographers working on privacy technologies\n- Activists concerned about government surveillance\n- Entrepreneurs building digital cash systems\n- Academics researching cryptographic protocols\n\nThe mailing list was where many foundational ideas were discussed, including:\n- Digital signatures and public-key cryptography\n- Anonymous remailers\n- Digital cash proposals\n- Privacy-preserving protocols\n\n### The Crypto Anarchist Manifesto\n\nIn 1992, [Timothy C. May](/docs/history/people#timothy-c-may) published \"The Crypto Anarchist Manifesto,\" which outlined a vision of cryptography enabling:\n- Anonymous transactions\n- Untraceable digital cash\n- Private communication\n- Freedom from government surveillance\n\nThe manifesto predicted that cryptography would enable new forms of social organization that couldn't be controlled by governments.\n\n### Early Digital Cash Attempts\n\nSeveral cypherpunks attempted to create digital cash systems:\n\n- **eCash (David Chaum, 1982)**: Used blind signatures for anonymous payments\n- **DigiCash (1990s)**: Commercial implementation of eCash\n- **b-money (Wei Dai, 1998)**: Proposed distributed digital cash\n- **Bit Gold (Nick Szabo, 1998)**: Proposed proof-of-work based digital currency\n\nWhile these early attempts failed commercially or technically, they established the intellectual foundation that Bitcoin would build upon.\n\n---\n\n## Key Figures\n\n### Timothy May\n\nTimothy May was a physicist and one of the founders of the cypherpunk movement. He wrote \"The Crypto Anarchist Manifesto\" (1992), which predicted that cryptography would enable new forms of social organization free from government control. May was a vocal advocate for privacy and individual sovereignty.\n\n### Eric Hughes\n\nEric Hughes co-founded the cypherpunk mailing list and wrote \"A Cypherpunk's Manifesto\" (1993), which articulated the core principles of the movement. The manifesto's most famous line: **\"Cypherpunks write code\"**, emphasizing that action through code is more powerful than political advocacy.\n\n### David Chaum\n\n[David Chaum](/docs/history/people#david-chaum) is often called the \"godfather of cryptocurrency.\" In 1982, he published \"Blind Signatures for Untraceable Payments,\" introducing the concept of anonymous digital cash. His work directly inspired the cypherpunk movement and later cryptocurrency development.\n\n### Adam Back\n\n[Adam Back](/docs/history/people#adam-back) invented Hashcash (1997), a proof-of-work system that became a critical component of Bitcoin. Satoshi Nakamoto cited Hashcash in the [Bitcoin whitepaper](/whitepaper), and Bitcoin's mining algorithm is essentially Hashcash applied to transaction validation.\n\n### Nick Szabo\n\n[Nick Szabo](/docs/history/people#nick-szabo) designed Bit Gold (1998), often called the direct precursor to Bitcoin. He also coined the term \"smart contracts\" in 1994. His intellectual contributions to the conceptual foundations of cryptocurrency are undeniable.\n\n### Wei Dai\n\n[Wei Dai](/docs/history/people#wei-dai) proposed b-money (1998), a theoretical system for anonymous, distributed electronic cash. Satoshi Nakamoto cited b-money in the Bitcoin whitepaper and personally emailed Wei Dai before Bitcoin's launch.\n\n---\n\n## How Cypherpunk Philosophy Influenced Bitcoin\n\n### Why Satoshi Posted to the Cypherpunk Mailing List\n\nOn October 31, 2008, Satoshi Nakamoto announced Bitcoin on the cypherpunk mailing list. This was intentional: Bitcoin was designed for people who shared cypherpunk values. The announcement was met with skepticism from some cypherpunks, but it represented the culmination of decades of cypherpunk research and experimentation.\n\n### Design Decisions Reflecting Cypherpunk Values\n\nBitcoin's design embodies cypherpunk principles:\n\n| Cypherpunk Principle | Bitcoin Implementation |\n|---------------------|----------------------|\n| **Privacy through cryptography** | Pseudonymous addresses, public-key cryptography |\n| **Trust in code, not institutions** | Cryptographic proof, open-source, consensus rules |\n| **Decentralization** | No central authority, distributed network |\n| **Permissionless participation** | No KYC, no account approval, global access |\n| **Censorship resistance** | No one can block valid transactions |\n| **Open-source transparency** | Code is publicly auditable |\n\n### Pseudonymity vs. Anonymity\n\nBitcoin provides **pseudonymity** rather than full anonymity. This reflects a cypherpunk balance:\n- **Privacy**: Addresses don't require identity\n- **Transparency**: All transactions are public (enables verification)\n- **Selective disclosure**: Users can reveal their identity when beneficial\n\nThis design allows Bitcoin to be both private and verifiable, a key cypherpunk insight.\n\n### Open-Source Code\n\nBitcoin is open-source, allowing anyone to:\n- Audit the code for security\n- Verify that it works as claimed\n- Propose improvements\n- Create alternative implementations\n\nThis transparency is essential for trust in code rather than trust in institutions.\n\n---\n\n## Connection to Bitcoin Fundamentals\n\n### Trust Model\n\nBitcoin's [trust model](/docs/fundamentals/trust-model) directly implements the cypherpunk principle of \"trust code, not people.\" Instead of trusting banks or governments, Bitcoin users trust:\n- Cryptographic proof (mathematics)\n- Open-source code (transparency)\n- Economic incentives (game theory)\n\nThis minimizes trust in institutions and maximizes trust in verifiable systems.\n\n### Decentralization\n\nBitcoin's [decentralization](/docs/fundamentals/decentralization) addresses the cypherpunk concern about central control. By distributing control across thousands of nodes, Bitcoin prevents:\n- Single points of failure\n- Censorship\n- Manipulation\n- Shutdown\n\n### Problems Bitcoin Solved\n\nThe [problems Bitcoin solved](/docs/fundamentals/problems) were precisely the problems that cypherpunks had been trying to solve for decades:\n- **Trust in third parties**: Cypherpunks wanted to eliminate intermediaries\n- **Censorship**: Cypherpunks wanted uncensorable transactions\n- **Privacy**: Cypherpunks wanted private but verifiable payments\n- **Central control**: Cypherpunks wanted decentralized systems\n\nBitcoin was the first system to solve all these problems simultaneously.\n\n---\n\n## The Cypherpunk Legacy\n\n### \"Cypherpunks Write Code\"\n\nThe most famous cypherpunk principle is: **\"Cypherpunks write code.\"** This means:\n- Action through technology is more powerful than political advocacy\n- Code can enforce rights that laws cannot guarantee\n- Building systems is more effective than asking for permission\n\nBitcoin embodies this principle: it doesn't ask for permission or approval. It exists as code running on a distributed network, and no one can stop it.\n\n### Privacy vs. Secrecy\n\nCypherpunks distinguish between:\n- **Privacy**: The power to selectively reveal information\n- **Secrecy**: Hiding information completely\n\nBitcoin provides privacy (you choose what to reveal) while maintaining transparency (all transactions are public). This balance enables both privacy and verification.\n\n### Individual Sovereignty\n\nCypherpunks believe in **individual sovereignty**: the right to control your own:\n- Money (without banks)\n- Identity (without governments)\n- Communication (without surveillance)\n- Data (without corporations)\n\nBitcoin enables financial sovereignty by giving individuals direct control over their money through private keys.\n\n---\n\n## Modern Relevance\n\n### Why These Principles Still Matter\n\nCypherpunk principles are more relevant than ever:\n- **Government surveillance**: Mass surveillance programs continue to expand\n- **Financial censorship**: Banks can freeze accounts, governments can seize funds\n- **Corporate control**: Tech companies control access to digital services\n- **Privacy erosion**: Personal data is collected and monetized\n\nBitcoin provides a practical implementation of cypherpunk values that addresses these concerns.\n\n### Bitcoin as Cypherpunk Success\n\nBitcoin represents the most successful implementation of cypherpunk philosophy:\n- **Privacy**: Pseudonymous transactions\n- **Decentralization**: No central control\n- **Censorship resistance**: Cannot be shut down\n- **Trust in code**: Cryptographic proof\n- **Permissionless**: Anyone can participate\n\nWhile early digital cash attempts failed, Bitcoin succeeded because it combined cypherpunk principles with economic incentives and game theory.\n\n---\n\n## Conclusion\n\nCypherpunk philosophy provided the intellectual and philosophical foundation for Bitcoin. The movement's core principles (privacy through cryptography, trust in code, decentralization, permissionless participation, and censorship resistance) are all embodied in Bitcoin's design.\n\nUnderstanding cypherpunk philosophy helps explain:\n- **Why Bitcoin was created**: To solve problems cypherpunks had identified for decades\n- **Why it's designed this way**: To embody cypherpunk values\n- **Why it matters**: It enables individual sovereignty and freedom\n\nBitcoin is not just a technology; it's the practical implementation of a decades-long philosophical movement that believed cryptography could be a tool for individual liberation. As Eric Hughes wrote: \"Cypherpunks write code.\" Bitcoin is that code, running on a global network, providing financial freedom to anyone who chooses to use it.\n\n---\n\n## Further Reading\n\n- [People in Bitcoin](/docs/history/people) - Learn about the cypherpunk figures who influenced Bitcoin\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin implements \"trust code, not people\"\n- [Decentralization](/docs/fundamentals/decentralization) - How Bitcoin avoids central control\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - The problems cypherpunks wanted to solve\n",
    "filename": "cypherpunk-philosophy.md"
  },
  "/docs/fundamentals/blockchain": {
    "content": "# The Blockchain\n\nThe blockchain is Bitcoin's foundational data structure: a cryptographically linked chain of blocks that creates an immutable, verifiable record of all transactions. Each block contains a hash of the previous block's header, creating an unbreakable chain where altering any block invalidates all subsequent blocks. This structure enables trustless verification, prevents tampering, and forms the backbone of Bitcoin's security model. A blockchain is a sequence of blocks, where each block is cryptographically linked to the previous one through a hash reference. This creates a chain structure where:\n\n- **Each block references the previous block** via its hash\n- **The chain is immutable**: changing any block breaks the chain\n- **The entire history is verifiable**: nodes can verify the chain's integrity\n- **No central authority is needed**: the structure itself provides security\n\nUnlike a traditional database where records can be modified or deleted, the blockchain creates a permanent, append-only ledger. Once a block is added to the chain, it becomes part of an unalterable historical record.\n\n---\n\n## Block Structure and Hash Linking\n\nEach block in Bitcoin contains a header with several fields, including a critical reference to the previous block:\n\n```\nBlock Header Structure:\nâ”œâ”€â”€ Version (4 bytes)\nâ”œâ”€â”€ Previous Block Hash (32 bytes) â† Links to previous block\nâ”œâ”€â”€ Merkle Root (32 bytes)\nâ”œâ”€â”€ Timestamp (4 bytes)\nâ”œâ”€â”€ Difficulty Target (4 bytes)\nâ””â”€â”€ Nonce (4 bytes)\n```\n\nThe **Previous Block Hash** field is what creates the chain. Each block contains the hash of the previous block's header, creating an unbreakable link:\n\n```\nBlock 0 (Genesis)\n    â†“ (hash: 000000000019d6...)\nBlock 1\n    â†“ (hash: 00000000839a8e...)\nBlock 2\n    â†“ (hash: 000000006a625f...)\nBlock 3\n    â†“\n...\n```\n\n### How Hash Linking Works\n\nWhen a miner creates a new block:\n\n1. **Takes the hash of the previous block's header** (80 bytes)\n2. **Places this hash in the new block's \"Previous Block Hash\" field**\n3. **Mines the new block** by finding a valid proof-of-work\n4. **The new block's hash** becomes the reference for the next block\n\nThis creates a one-way chain: you can verify that Block N+1 follows Block N by checking that Block N+1's \"Previous Block Hash\" matches Block N's actual hash. But you cannot go backwards: the hash function is one-way.\n\n### Cryptographic Security\n\nThe security of the blockchain comes from cryptographic hash functions (specifically SHA-256 in Bitcoin):\n\n| Property | Why It Matters |\n|----------|----------------|\n| **One-way function** | Cannot reverse-engineer the input from the hash |\n| **Deterministic** | Same input always produces same hash |\n| **Avalanche effect** | Tiny change in input completely changes hash |\n| **Collision-resistant** | Practically impossible to find two inputs with same hash |\n\nIf an attacker tries to change a transaction in Block N:\n1. The block's hash changes (avalanche effect)\n2. Block N+1's \"Previous Block Hash\" no longer matches\n3. Block N+1 becomes invalid\n4. Block N+2 becomes invalid (it references invalid Block N+1)\n5. The entire chain from Block N onward breaks\n\n---\n\n## Immutability Through Chain Structure\n\nThe blockchain's immutability comes from the combination of hash linking and proof-of-work:\n\n### Why Changing History Is Prohibitively Expensive\n\nTo change a block in the chain, an attacker must:\n\n1. **Modify the target block** (change a transaction, for example)\n2. **Recalculate that block's hash** (easy, but...)\n3. **Find new proof-of-work for that block** (requires significant computational work)\n4. **Recalculate Block N+1's hash** (because its \"Previous Block Hash\" changed)\n5. **Find new proof-of-work for Block N+1** (more work)\n6. **Repeat for every subsequent block** (exponentially more work)\n7. **Outpace the honest network** (must mine faster than all honest miners combined)\n\nAs more blocks are added after the target block, the work required grows exponentially. Changing a block from 100 blocks ago requires redoing 100 blocks of proof-of-work. Changing a block from 1000 blocks ago requires redoing 1000 blocks of proof-of-work.\n\n### The Longest Chain Rule\n\nBitcoin nodes follow the **longest valid chain rule**: they accept the chain with the most cumulative proof-of-work. This means:\n\n- An attacker's modified chain must have more work than the honest chain\n- With each new honest block, the attacker falls further behind\n- The honest chain grows faster, making the attack increasingly impossible\n\n```\nHonest Chain:     Block 100 â†’ Block 101 â†’ Block 102 â†’ Block 103\n                                    â†“\nAttacker's Chain: Block 100 â†’ Block 101' (modified)\n                                    â†“\n                            Must mine faster than entire network\n                            to catch up and overtake\n```\n\n---\n\n## Chain Verification\n\nNodes verify the blockchain's integrity by checking:\n\n### Header Chain Verification\n\n1. **Previous hash links**: Each block's \"Previous Block Hash\" matches the actual hash of the previous block\n2. **Proof-of-work validity**: Each block's hash meets the difficulty target\n3. **Chain continuity**: No gaps or breaks in the sequence\n4. **Genesis block**: The chain starts with the known genesis block\n\n### Full Block Verification\n\nBeyond the header chain, nodes also verify:\n\n1. **Transaction validity**: All transactions follow consensus rules\n2. **Merkle root**: The Merkle root in the header matches the transactions\n3. **UTXO references**: All transaction inputs reference valid, unspent UTXOs\n4. **No double-spends**: No UTXO is spent twice in the chain\n\n### Efficient Verification\n\nThe chain structure enables efficient verification:\n\n- **Headers-first sync**: Nodes can download and verify all block headers (~60 MB) before downloading full blocks\n- **Incremental verification**: Nodes only need to verify new blocks, not re-verify the entire chain\n- **Checkpoint verification**: Nodes can trust known good blocks (checkpoints) and verify from there\n\n---\n\n## Relationship to Other Bitcoin Concepts\n\nThe blockchain structure is fundamental to many other Bitcoin concepts:\n\n### Consensus\n\nThe blockchain enables consensus without a central authority:\n- All nodes independently verify the same chain structure\n- The longest valid chain naturally emerges as the consensus chain\n- No voting or coordination needed: the structure itself creates agreement\n\n### Security\n\nThe chain structure provides security through:\n- **Immutability**: History cannot be rewritten without enormous cost\n- **Verifiability**: Anyone can verify the chain's integrity\n- **Decentralization**: No single point of failure or control\n\n### Timechain\n\nThe blockchain structure enables Bitcoin's [timechain](/docs/fundamentals/timechain) property:\n- Blocks form an ordered sequence (temporal ordering)\n- The chain structure ensures this ordering is immutable\n- Block height provides a reliable time reference\n\n### Proof-of-Work\n\nProof-of-work secures the blockchain:\n- Each block requires computational work to create\n- The chain with the most work is the valid chain\n- Changing history requires redoing all subsequent work\n\n---\n\n## Practical Implications\n\nUnderstanding the blockchain structure explains several important aspects of Bitcoin:\n\n### Why Confirmations Matter\n\nEach block added after your transaction makes it more secure:\n- Block 1: Your transaction is in the chain\n- Block 2: One confirmation: attacker must redo 1 block of work\n- Block 6: Six confirmations: attacker must redo 6 blocks of work\n- Block 100: One hundred confirmations: attacker must redo 100 blocks of work\n\nMore confirmations = more blocks built on top = more work required to reverse = more security.\n\n### Why Reorganizations Are Rare\n\nA chain reorganization (reorg) occurs when the network switches to a different chain. This is rare because:\n- The honest chain typically has the most work\n- Reorgs only happen when two blocks are found nearly simultaneously\n- The network quickly converges on the longest chain\n- Deep reorgs (many blocks) are extremely rare and require massive hash rate\n\n### Why Full Nodes Are Important\n\nFull nodes verify the entire blockchain:\n- They independently verify every block and transaction\n- They reject invalid blocks, protecting the network\n- They don't trust other nodes; they verify the chain structure themselves\n- More full nodes = more decentralized verification = stronger security\n\n### Why Blockchain Size Matters\n\nThe blockchain grows continuously:\n- Each block adds ~1-2 MB of data (with SegWit, up to ~4 MB)\n- The full blockchain is ~500+ GB and growing\n- This creates a trade-off: larger blocks = more transactions but larger blockchain\n- Bitcoin's block size limit balances throughput with node requirements\n\n---\n\n## Comparison to Traditional Systems\n\n| Aspect | Traditional Database | Bitcoin Blockchain |\n|--------|---------------------|-------------------|\n| **Modification** | Records can be updated or deleted | Append-only: history cannot be changed |\n| **Verification** | Trust the database administrator | Anyone can verify the entire chain |\n| **Authority** | Central authority controls the database | No central authority: structure provides security |\n| **Tampering** | Administrator can modify records | Changing history requires redoing all subsequent work |\n| **Backup** | Need to trust backup integrity | Every node has a complete, verifiable copy |\n| **Audit** | Requires trusting audit logs | The chain itself is the audit trail |\n\n---\n\n## The Elegance of the Solution\n\nThe blockchain structure is elegant because it:\n\n1. **Solves multiple problems simultaneously**: Immutability, verification, consensus, and security\n2. **Requires no trust**: The structure itself provides security through cryptography\n3. **Is self-verifying**: Anyone can verify the chain's integrity independently\n4. **Creates natural convergence**: The longest chain rule causes the network to naturally agree\n5. **Scales verification**: Efficient to verify incrementally as new blocks arrive\n6. **Prevents tampering**: The cost of changing history grows exponentially\n\nThe blockchain isn't just a data structure: it's a mechanism that creates trust through mathematics rather than authority.\n\n---\n\n## Common Misconceptions\n\n### \"Blockchain is just a database\"\n\nWhile the blockchain stores data, it's fundamentally different from a traditional database:\n- **Immutable**: Cannot modify or delete records\n- **Decentralized**: No central administrator\n- **Cryptographically secured**: Hash linking prevents tampering\n- **Verifiable**: Anyone can verify the entire chain\n\n### \"You can change the blockchain if you have enough computing power\"\n\nWhile a 51% attack could theoretically create an alternative chain, it cannot:\n- Change blocks that are already deeply confirmed (too much work required)\n- Modify transactions that are already spent (UTXOs already consumed)\n- Break the cryptographic links (hash function security is mathematical)\n- Succeed long-term (honest network will eventually outpace attacker)\n\n### \"The blockchain is stored in one place\"\n\nThe blockchain is distributed:\n- Every full node stores a complete copy\n- Thousands of nodes worldwide maintain the chain\n- No single point of failure\n- Network redundancy ensures availability\n\n---\n\n## Conclusion\n\nThe blockchain is Bitcoin's foundational innovation: a cryptographically linked chain of blocks that creates an immutable, verifiable record. By linking each block to the previous one through cryptographic hashes, Bitcoin creates a structure where:\n\n- **History cannot be rewritten** without redoing all subsequent proof-of-work\n- **Anyone can verify** the chain's integrity independently\n- **No central authority** is needed: the structure itself provides security\n- **Consensus emerges naturally** through the longest chain rule\n\nThis elegant structure enables Bitcoin's core properties: decentralization, immutability, and trustlessness. The blockchain isn't just how Bitcoin stores data: it's the mechanism that makes Bitcoin possible.\n",
    "filename": "blockchain.md"
  },
  "/docs/fundamentals/timechain": {
    "content": "# Bitcoin as Timechain\n\n> As Leslie Lamport once said: Special Relativity teaches us, that two different observers can have different notions of what ***at the same time*** means.\n\nBitcoin solves one of the most fundamental problems in distributed systems: **how to order events in time without a central time source**. In a decentralized network where nodes may have different clocks, network delays are unpredictable, and there's no trusted authority, determining the sequence of events is essential yet seemingly impossible. Bitcoin's solution is elegant: it creates a **timechain**, a cryptographically secured, decentralized ordering mechanism that enables trustless temporal coordination.\n\n## Why Timing Matters\n\nIn any distributed system, especially one handling financial transactions, the order of events is critical:\n\n- **Preventing double-spending:** If Alice sends 1 BTC to both Bob and Charlie, which transaction happened first?\n- **Enforcing time-locks:** A contract requires funds to be locked until a specific time. How do we verify when that time has passed?\n- **Establishing causality:** Transaction B depends on transaction A. How do we ensure A happened before B?\n- **Consensus on history:** All nodes must agree on the same sequence of events to maintain a consistent ledger\n\nTraditional systems solve this with **centralized time sources**: banks use synchronized clocks, databases use timestamps from authoritative servers, and payment processors rely on trusted time services. But in a decentralized system, there is no central authority to provide trusted time.\n\n---\n\n## The Problem: No Synchronized Clocks\n\nIn a distributed network without central coordination, nodes face several timing challenges:\n\n### Clock Drift\nEach node's local clock may run at slightly different speeds. Over time, clocks drift apart, making it impossible to rely on local timestamps for ordering.\n\n### Network Delays\nMessages between nodes take unpredictable amounts of time. A transaction sent \"first\" might arrive \"second\" due to network routing, making message arrival time unreliable for ordering.\n\n### Malicious Actors\nA dishonest node could manipulate its clock to create timestamps that favor its own transactions or attack the network.\n\n### No Authority\nThere's no trusted time server that all nodes can query. Even if there were, trusting a single source would violate Bitcoin's decentralized design.\n\n---\n\n## Bitcoin's Solution: Proof-of-Work as Time\n\nBitcoin solves the timing problem by using **[proof-of-work](/docs/glossary#proof-of-work-pow)** to create an objective, verifiable ordering mechanism. Instead of relying on clocks, Bitcoin uses **computational work** as a proxy for time.\n\n### Blocks as Temporal Units\n\nEach block in the blockchain represents a discrete unit of time. Blocks are discovered approximately every 10 minutes through proof-of-work mining. The sequence of blocks creates a **temporal ordering** of all transactions:\n\n```\nBlock 1 (10:00) â†’ Block 2 (10:10) â†’ Block 3 (10:20) â†’ Block 4 (10:30)\n```\n\nEven though blocks aren't perfectly spaced at 10-minute intervals, the blockchain creates an unambiguous ordering: Block 2 always comes after Block 1, regardless of when any individual node's clock says it is.\n\n### Block Timestamps\n\nEach block contains a timestamp field, but this timestamp is **not authoritative**. Instead, it's validated against a **consensus window**:\n\n- A block's timestamp must be **greater than the median of the previous 11 blocks**\n- A block's timestamp must be **less than 2 hours in the future** (from the node's perspective)\n\nThis prevents miners from manipulating timestamps while allowing for reasonable clock drift. The timestamp is a **suggestion**, not a command: the network accepts it if it's reasonable, but the actual ordering comes from the block sequence, not the timestamp value.\n\n### Proof-of-Work Creates Ordering\n\nThe key insight is that **proof-of-work makes ordering expensive to manipulate**. To change the order of events, an attacker would need to:\n\n1. Redo all the proof-of-work for the block they want to reorder\n2. Redo all the proof-of-work for every subsequent block\n3. Outpace the honest network's hash rate\n\nThis becomes exponentially more difficult as more blocks are added. The computational work **anchors** the ordering in physical reality: you can't fake the work that was done.\n\n### Difficulty Adjustment: Maintaining Stable Block Time\n\nFor the timechain to function reliably, blocks must be created at a **predictable rate**. If blocks came too fast, the network couldn't propagate them efficiently. If blocks came too slow, the system would be unusable. Bitcoin solves this with difficulty adjustment.\n\nEvery 2016 blocks (~2 weeks), the network automatically adjusts mining difficulty based on how long it actually took to mine the previous 2016 blocks:\n\n- **If blocks were mined too fast** (less than 2 weeks): Difficulty increases, making future blocks harder to find\n- **If blocks were mined too slow** (more than 2 weeks): Difficulty decreases, making future blocks easier to find\n- **Target**: Maintain ~10 minutes per block on average\n\nThis creates a **self-regulating system** that maintains stable block times despite:\n- Changes in network hash rate (miners joining/leaving)\n- Hardware improvements (new ASICs increasing mining power)\n- Geographic distribution of miners\n- Network conditions affecting propagation\n\n**Why this matters for the timechain:**\n\nWithout difficulty adjustment, the timechain would be unreliable. If hash rate suddenly doubled, blocks would come every 5 minutes instead of 10, making the temporal ordering unpredictable. If hash rate dropped, blocks might take 20+ minutes, making the system too slow to use. Difficulty adjustment ensures that regardless of network conditions, the timechain maintains its ~10 minute cadence, providing a stable temporal reference for the entire network.\n\nThe difficulty adjustment is what makes \"approximately every 10 minutes\" actually work in practice. It's the mechanism that keeps the timechain's temporal units consistent over time, enabling reliable time-locked contracts, predictable confirmation times, and stable network operation.\n\nFor technical details on how difficulty adjustment works, see the [Difficulty Adjustment](/docs/mining/difficulty) page.\n\n---\n\n## The Blockchain as Timechain\n\nThe blockchain is fundamentally a **timechain**: a cryptographically secured sequence of events ordered by proof-of-work. This temporal structure enables several critical functions:\n\n### Transaction Ordering\n\nAll transactions are ordered by the block they appear in. If two transactions conflict (e.g., double-spending), the one in the earlier block wins. The network doesn't need to know \"when\" each transaction occurred in absolute time; it only needs to know which came first in the chain.\n\n### Time-Locked Contracts\n\nBitcoin supports [time locks](/docs/glossary#time-lock) that prevent spending until a certain time:\n- **Absolute time locks (CLTV):** \"Cannot spend until block height 800,000\" or \"Cannot spend until Unix timestamp 1700000000\"\n- **Relative time locks (CSV):** \"Cannot spend until 1000 blocks after this UTXO was created\"\n\nThese locks work because the blockchain provides a reliable ordering mechanism. Even if your local clock is wrong, you can verify the block height or check the block's timestamp against the consensus window.\n\n### Preventing Double-Spending\n\nThe timechain ensures that if Alice tries to spend the same UTXO twice, only the transaction that appears first in the chain is valid. Nodes reject the second transaction because its input has already been spent. The ordering is objective and verifiable: no need to trust timestamps or coordinate clocks.\n\n### Consensus on History\n\nAll nodes agree on the same sequence of blocks (the longest valid chain), which means they agree on the same ordering of all transactions. This creates a **shared temporal reality** across the entire network without any central coordination.\n\n---\n\n## Why This Is Essential\n\nThe timechain property is fundamental to Bitcoin's operation:\n\n| Function | Why Timechain Matters |\n|----------|----------------------|\n| **Consensus** | Nodes agree on transaction order without central authority |\n| **Security** | Prevents double-spending through objective ordering |\n| **Smart Contracts** | Enables time-based conditions (vesting, inheritance, etc.) |\n| **Finality** | More blocks = more work = more secure ordering |\n| **Decentralization** | No need for trusted time servers or synchronized clocks |\n\nWithout the timechain, Bitcoin couldn't function as a decentralized payment system. The ability to order events trustlessly is what makes everything else possible.\n\n---\n\n## Comparison to Traditional Systems\n\n| Aspect | Traditional Systems | Bitcoin (Timechain) |\n|--------|-------------------|---------------------|\n| **Time Source** | Central time server (NTP, atomic clocks) | Proof-of-work creates ordering |\n| **Trust Required** | Must trust time authority | No trust required: work is verifiable |\n| **Manipulation** | Time server can be compromised | Requires >50% hash rate to manipulate |\n| **Synchronization** | All nodes sync to central source | Nodes independently verify block sequence |\n| **Failure Mode** | Single point of failure | Distributed: no single point of failure |\n\n---\n\n## The Elegance of the Solution\n\nBitcoin's timechain solution is elegant because it:\n\n1. **Uses existing mechanism:** Proof-of-work already secures the network; it also provides ordering\n2. **No additional trust:** Doesn't require trusting time servers or clock synchronization\n3. **Self-correcting:** Network naturally converges on longest chain (most work)\n4. **Self-regulating:** Difficulty adjustment maintains stable block times automatically\n5. **Verifiable:** Anyone can verify the ordering by checking proof-of-work\n6. **Resistant to manipulation:** Changing order requires redoing all subsequent work\n\nThe timechain isn't a separate feature; it's an emergent property of how Bitcoin achieves consensus. By solving the consensus problem, Bitcoin also solved the timing problem.\n\n---\n\n## Practical Implications\n\nUnderstanding Bitcoin as a timechain helps explain:\n\n- **Why confirmations matter:** Each block adds more work, making the ordering more secure\n- **Why block time matters:** ~10 minutes balances security (enough time for propagation) with usability (not too slow)\n- **Why difficulty adjustment is essential:** It maintains the stable block time that makes the timechain reliable\n- **Why timestamps are flexible:** They're hints, not commands: the real ordering comes from proof-of-work\n- **Why time-locks work:** Block height and consensus timestamps provide reliable temporal reference\n- **Why reorganization is rare:** Changing order requires redoing massive amounts of work\n\n---\n\n## Conclusion\n\nBitcoin's timechain is a fundamental innovation that enables trustless ordering of events in a decentralized network. By using proof-of-work to create an objective sequence of blocks, Bitcoin solves the timing problem without requiring synchronized clocks or trusted time sources. This temporal structure is essential for consensus, security, and the network's ability to function as a decentralized payment system.\n\nThe timechain demonstrates Bitcoin's elegance: a single mechanism (proof-of-work) solves multiple problems simultaneously (security, consensus, and timing). This is why Bitcoin is often described not just as a blockchain, but as a **timechain**: a cryptographically secured sequence of events that creates shared temporal reality across a global, decentralized network.\n",
    "filename": "timechain.md"
  },
  "/docs/fundamentals/utxos": {
    "content": "# The UTXO Model\n\nThe UTXO (Unspent Transaction Output) model is one of Bitcoin's most fundamental and elegant design choices. Unlike traditional account-based systems where balances are stored in accounts, Bitcoin tracks ownership through discrete, spendable transaction outputs. Understanding UTXOs is essential to understanding how Bitcoin actually works. A **UTXO** is a transaction output that hasn't been spent yet. It represents the actual \"coins\" in Bitcoin's accounting model. When you \"have 1 BTC,\" you don't have a balance in an account. You actually possess one or more UTXOs that sum to that amount. Key characteristics:\n\n- **Discrete units**: Each UTXO is a separate, indivisible unit\n- **All-or-nothing spending**: You must spend an entire UTXO; partial spending isn't possible\n- **Consumption**: When a UTXO is spent, it's completely consumed and removed from the [UTXO set](/docs/glossary#utxo-set)\n- **Creation**: Every transaction creates new UTXOs as outputs\n\n---\n\n## UTXO vs Account-Based Systems\n\nBitcoin's UTXO model differs fundamentally from traditional account-based systems:\n\n| Aspect | UTXO Model (Bitcoin) | Account-Based (Traditional) |\n|--------|---------------------|----------------------------|\n| **Storage** | Discrete outputs | Account balances |\n| **Spending** | Consume entire UTXO | Debit from account balance |\n| **Privacy** | Each UTXO is separate | All transactions linked to account |\n| **Verification** | Check if output exists and unspent | Check if account has sufficient balance |\n| **Parallel Processing** | Multiple UTXOs can be processed simultaneously | Account updates must be sequential |\n| **State** | UTXO set represents current state | Account balances represent state |\n\n**Why the UTXO Model?**\n\n- **Simpler verification**: Nodes only need to check if a UTXO exists and hasn't been spent\n- **Better privacy**: Each UTXO is independent; transactions don't automatically link\n- **Parallel processing**: Multiple transactions can be validated simultaneously\n- **Clear ownership**: No ambiguity about what can be spent\n\n---\n\n## The UTXO Lifecycle\n\nUnderstanding the lifecycle is crucial:\n\nThe UTXO lifecycle follows this flow:\n\n```\nTransaction Output (in a block)\n  â†“\nUTXO (unspent, available to spend)\n  â†“\nReferenced by Transaction Input\n  â†“\nConsumed (removed from UTXO set)\n  â†“\nNew Outputs Created (become new UTXOs)\n```\n\n### Step-by-Step Lifecycle\n\n1. **Output Creation**: A transaction creates outputs with specific amounts and spending conditions (scriptPubKeys)\n2. **UTXO Status**: If an output hasn't been spent, it's a UTXO\n3. **Spending**: A transaction input references a UTXO (by transaction ID and output index)\n4. **Consumption**: The UTXO is consumed: it can never be spent again\n5. **New UTXOs**: The transaction creates new outputs, which become new UTXOs\n\n---\n\n## Understanding the Relationships\n\n### Addresses â†’ Outputs â†’ UTXOs\n\n**Addresses are not accounts.** They're human-readable encodings of spending conditions that get embedded in transaction outputs.\n\n```\nAddress (bc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq)\n  â†“ (encoded as)\nOutput ScriptPubKey (OP_0 <20-byte-hash>)\n  â†“ (when unspent)\nUTXO\n```\n\nWhen someone sends bitcoin to your address:\n1. Your address is converted to a scriptPubKey\n2. This scriptPubKey is placed in a transaction output\n3. That output becomes a UTXO you can spend (if you control the private key)\n\n**Important**: An address doesn't \"hold\" bitcoin. Bitcoin is held in UTXOs that have scriptPubKeys matching your address's spending conditions.\n\n### UTXOs â†’ Inputs\n\nWhen you want to spend bitcoin, you reference existing UTXOs as inputs:\n\n```\nInput Structure:\nâ”œâ”€â”€ Previous TXID (which transaction created the UTXO)\nâ”œâ”€â”€ Output Index (which output in that transaction)\nâ”œâ”€â”€ ScriptSig (proof you can spend it)\nâ””â”€â”€ Sequence (optional timelock/Replace-by-Fee)\n```\n\nEach input references exactly one UTXO. The input must provide proof (via ScriptSig and witness data) that it satisfies the spending conditions encoded in that UTXO's scriptPubKey.\n\n### Inputs â†’ Outputs\n\nEvery transaction must create at least one output. When you spend UTXOs:\n\n```\nTransaction:\nâ”œâ”€â”€ Inputs (consuming UTXOs)\nâ”‚   â”œâ”€â”€ Input 1: 0.5 BTC UTXO\nâ”‚   â””â”€â”€ Input 2: 0.3 BTC UTXO\nâ””â”€â”€ Outputs (creating new UTXOs)\n    â”œâ”€â”€ Output 1: 0.7 BTC to recipient\n    â””â”€â”€ Output 2: 0.1 BTC change (back to you)\n```\n\n**Key Rule**: `Sum of Input Values â‰¥ Sum of Output Values`\n\nThe difference becomes the transaction fee paid to miners.\n\n### Transaction Structure\n\nA transaction is the bridge between consuming old UTXOs and creating new ones:\n\n```\nTransaction\nâ”œâ”€â”€ Version\nâ”œâ”€â”€ Inputs (references to UTXOs being consumed)\nâ”‚   â””â”€â”€ Each input: (TXID, output_index, scriptSig, sequence)\nâ”œâ”€â”€ Outputs (new UTXOs being created)\nâ”‚   â””â”€â”€ Each output: (value, scriptPubKey)\nâ””â”€â”€ Locktime\n```\n\n---\n\n## Practical Examples\n\n### Simple Transaction Flow\n\n**Scenario**: Alice wants to send 0.1 BTC to Bob. She has a UTXO worth 0.5 BTC.\n\n```\nBefore:\n- Alice's UTXO: 0.5 BTC (unspent)\n\nTransaction:\n- Input: Alice's 0.5 BTC UTXO\n- Output 1: 0.1 BTC to Bob's address\n- Output 2: 0.4 BTC change back to Alice\n- Fee: 0.0 BTC (for simplicity)\n\nAfter:\n- Alice's old UTXO: CONSUMED (no longer exists)\n- Bob's new UTXO: 0.1 BTC (can now spend)\n- Alice's new UTXO: 0.4 BTC (change, can spend)\n```\n\n**Key Points**:\n- The entire 0.5 BTC UTXO was consumed\n- Two new UTXOs were created\n- Alice's \"balance\" is now a different UTXO (the change)\n\n### Multiple UTXO Spending\n\n**Scenario**: Alice wants to send 0.8 BTC but has multiple smaller UTXOs.\n\n```\nAlice's UTXOs:\n- UTXO 1: 0.3 BTC\n- UTXO 2: 0.4 BTC\n- UTXO 3: 0.2 BTC\nTotal: 0.9 BTC\n\nTransaction:\n- Input 1: UTXO 1 (0.3 BTC)\n- Input 2: UTXO 2 (0.4 BTC)\n- Input 3: UTXO 3 (0.2 BTC)\n- Output 1: 0.8 BTC to Bob\n- Output 2: 0.09 BTC change to Alice\n- Fee: 0.01 BTC\n\nResult:\n- All three UTXOs consumed\n- Two new UTXOs created (payment + change)\n```\n\nThis demonstrates **coin selection**: the process of choosing which UTXOs to spend. Wallets must select UTXOs that sum to at least the payment amount plus fees.\n\n### Change Outputs Explained\n\nChange outputs are crucial to understand:\n\n**Why Change?**\n- You must spend entire UTXOs\n- If your UTXO (0.5 BTC) is larger than your payment (0.1 BTC), you need change\n- Change creates a new UTXO back to an address you control\n\n**Privacy Consideration**: Change outputs can reveal that you're the sender, as they typically go back to addresses you control. Advanced wallets use techniques to make change less obvious.\n\n---\n\n## The UTXO Set\n\nThe **UTXO Set** is the complete database of all unspent transaction outputs at any given point in time. It represents the current state of Bitcoin ownership.\n\n### What It Is\n\nThe UTXO set is essentially Bitcoin's \"ledger state.\" Instead of storing account balances, Bitcoin stores the set of all spendable outputs.\n\n**Current Size**: Approximately 70-100 million UTXOs, requiring several gigabytes of storage.\n\n### Why Nodes Maintain It\n\nFull nodes maintain the UTXO set for fast transaction validation:\n\n1. **Existence Check**: When validating a transaction input, nodes check if the referenced UTXO exists\n2. **Double-Spend Prevention**: Nodes verify the UTXO hasn't already been spent\n3. **Efficiency**: Without the UTXO set, nodes would need to scan the entire blockchain for each validation\n\n**Without UTXO Set**: To validate a transaction, you'd need to:\n- Search through all blocks to find the output\n- Check if it was spent in any subsequent transaction\n- This would be extremely slow\n\n**With UTXO Set**: Validation is nearly instant:\n- Look up UTXO in the set (fast database query)\n- Verify it exists and is unspent\n- Remove it from the set when spent\n\n### How It's Maintained\n\nThe UTXO set is updated with each new block:\n\n```\nNew Block Arrives:\nâ”œâ”€â”€ For each transaction:\nâ”‚   â”œâ”€â”€ Remove consumed UTXOs from set (inputs)\nâ”‚   â””â”€â”€ Add new UTXOs to set (outputs)\nâ””â”€â”€ UTXO set updated\n```\n\n**Example**:\n```\nUTXO Set Before Block: 100,000,000 UTXOs\n\nBlock Contains:\n- 1,000 transactions\n- 2,500 inputs (consuming UTXOs)\n- 2,600 outputs (creating UTXOs)\n\nUTXO Set After Block: 100,000,100 UTXOs\n(100M - 2,500 + 2,600 = 100,000,100)\n```\n\n### Performance Implications\n\nKeeping the UTXO set manageable is critical for node performance:\n\n- **Storage**: Each UTXO requires storage (typically 50-100 bytes)\n- **Memory**: Active UTXOs are kept in fast storage (RAM or SSD)\n- **Validation Speed**: Larger sets mean slower lookups\n- **Sync Time**: New nodes must build the UTXO set from scratch\n\n**Why Dust Outputs Matter**: Creating many tiny UTXOs (dust) bloats the UTXO set without providing much value. This is why:\n- Wallets avoid creating dust outputs\n- Some nodes prune dust outputs\n- Fee rates make spending dust uneconomical\n\n### AssumeUTXO\n\n**AssumeUTXO** is a feature that allows new nodes to bootstrap faster by starting with a trusted UTXO set snapshot instead of building it from scratch.\n\n**Traditional Bootstrap**:\n1. Download all blocks\n2. Process each block sequentially\n3. Build UTXO set incrementally\n4. Takes days or weeks\n\n**With AssumeUTXO**:\n1. Download trusted UTXO set snapshot\n2. Verify snapshot matches a known block\n3. Continue from that point\n4. Much faster (hours instead of days)\n\nThis makes running a full node more accessible while maintaining security through cryptographic verification of the snapshot.\n\n### Querying the UTXO Set\n\nBitcoin nodes provide RPC commands to query UTXO set information:\n\n**`gettxoutsetinfo`**: Returns statistics about the UTXO set\n- Total number of UTXOs\n- Total amount of bitcoin in UTXOs\n- Size of the UTXO set\n- Block height of the set\n\n**`gettxout`**: Query a specific UTXO\n- Check if a specific output is unspent\n- Get the value and scriptPubKey\n- Useful for wallet balance checking\n\nSee the [RPC Commands](/docs/bitcoin/rpc#9-utxo-set-information) documentation for details.\n\n---\n\n## Privacy Implications\n\nThe UTXO model has important privacy characteristics:\n\n### Positive Aspects\n\n- **UTXO Independence**: Each UTXO is separate; spending one doesn't automatically reveal others\n- **No Account Linking**: Unlike account-based systems, there's no single \"account\" that links all your transactions\n- **Change Outputs**: While change can be identified, it's not always obvious\n\n### Privacy Challenges\n\n- **UTXO Linking**: If you spend multiple UTXOs together, they're likely yours\n- **Change Identification**: Change outputs often go back to the sender\n- **Address Reuse**: Using the same address links all UTXOs sent to it\n- **Blockchain Analysis**: Sophisticated analysis can cluster UTXOs by owner\n\n**Best Practices**:\n- Generate new addresses for each transaction\n- Use [coin selection](/docs/wallets/coin-selection) strategies that enhance privacy\n- Consider [CoinJoin](/docs/glossary#coinjoin) for better privacy\n- Avoid address reuse\n\n---\n\n## Common Misconceptions\n\n### \"I have a balance in my address\"\n\n**Reality**: Addresses don't hold balances. You control UTXOs whose scriptPubKeys match addresses derived from your keys. Your \"balance\" is the sum of UTXOs you can spend.\n\n### \"Bitcoin works like a bank account\"\n\n**Reality**: Bitcoin is fundamentally different. There are no accounts, only discrete UTXOs. Each transaction consumes entire UTXOs and creates new ones.\n\n### \"I can send part of a UTXO\"\n\n**Reality**: You must spend entire UTXOs. If you need to send less, you create a change output back to yourself.\n\n### \"UTXOs are stored in my wallet\"\n\n**Reality**: UTXOs exist on the blockchain. Your wallet tracks which UTXOs you can spend by monitoring addresses you control. The wallet doesn't \"store\" the UTXOs: they're on every full node.\n\n### \"The UTXO set is the blockchain\"\n\n**Reality**: The blockchain contains all historical transactions. The UTXO set is a derived database containing only unspent outputs. It's much smaller than the full blockchain.\n\n---\n\n## Why This Matters\n\nUnderstanding the UTXO model is essential because:\n\n1. **Transaction Construction**: You must understand UTXOs to build valid transactions\n2. **Fee Calculation**: Transaction size (and thus fees) depends on the number of inputs/outputs\n3. **Privacy**: UTXO management affects your privacy\n4. **Wallet Design**: Wallets must implement coin selection algorithms\n5. **Node Operation**: Running a node requires understanding UTXO set management\n\nThe UTXO model is not just a technical detail: it's fundamental to how Bitcoin works. Every transaction, every wallet, every node interacts with the UTXO model. Understanding it deeply will make you a better Bitcoin user, developer, or node operator.\n\n---\n\n## Related Topics\n\n- [Transaction Construction](/docs/bitcoin-development/transactions) - How to build transactions using UTXOs\n- [Coin Selection](/docs/wallets/coin-selection) - Algorithms for choosing which UTXOs to spend\n- [Address Types](/docs/wallets/address-types) - How addresses relate to UTXO scriptPubKeys\n- [RPC Commands](/docs/bitcoin/rpc#9-utxo-set-information) - Querying the UTXO set\n- [Blockchain Monitoring](/docs/bitcoin-development/blockchain-monitoring) - Tracking UTXOs programmatically\n",
    "filename": "utxos.md"
  },
  "/docs/fundamentals/decentralization": {
    "content": "# Decentralization\n\nDecentralization is the distribution of control across many independent participants rather than a single central authority. It's the foundation of Bitcoin's [censorship resistance](/docs/glossary#censorship-resistance), resilience, and trustlessness.\n\n## What Decentralization Means\n\nNo single entity controls Bitcoin. Control is distributed across thousands of nodes, multiple [mining pools](/docs/glossary#mining-pool), diverse developers, and a global user base. This means:\n\n- **No central authority:** No government, company, or person controls Bitcoin\n- **No single point of failure:** The network survives even if parts go offline\n- **Open participation:** Anyone can run a node, mine, or contribute to development\n- **Consensus-driven changes:** Protocol changes require broad agreement\n\n---\n\n## Why It Matters\n\nDecentralization enables Bitcoin's core properties:\n\n| Property | Centralized System | Decentralized (Bitcoin) |\n|----------|-------------------|------------------------|\n| **Censorship** | Authority can block transactions and freeze accounts | No one can block your transactions or freeze your funds |\n| **Resilience** | Single point of failure; can be shut down | Global network with redundant infrastructure |\n| **Trust** | Must trust the central authority | Trust the protocol and code, not people |\n| **Control** | Authority controls your money | You control your private keys |\n\n---\n\n## How Bitcoin Achieves Decentralization\n\n### Nodes\n\nBitcoin has ~15,000-20,000 reachable [full nodes](/docs/glossary#full-node) spread across 100+ countries. Each node independently validates every transaction and stores the complete blockchain. No single node is essential; if one goes offline, the network continues.\n\n### Mining\n\n[Hash rate](/docs/glossary#hash-rate) is distributed across multiple independent mining pools, with the largest typically controlling less than 20% of total hash power. Miners can switch pools freely, preventing any single pool from gaining too much control. Geographic distribution across many countries reduces regulatory risk.\n\n### Development\n\nBitcoin has multiple implementations (Bitcoin Core, Bitcoin Knots, etc.) and an open development process. Changes go through the [BIP](/docs/glossary#bip-bitcoin-improvement-proposal) (Bitcoin Improvement Proposal) process and require community [consensus](/docs/glossary#consensus). No single developer or team controls the protocol.\n\n---\n\n## The Bitcoin Trilemma\n\nThe Bitcoin Trilemma describes the challenge of balancing three critical blockchain properties: **Scalability**, **Security**, and **Decentralization**. Optimizing one typically comes at the cost of another.\n\n### The Three Pillars\n\n| Property | Definition | Bitcoin's Approach |\n|----------|------------|-------------------|\n| **Scalability** | Ability to process many transactions quickly | ~7 TPS, 1 MB blocks (up to ~4 MB with [SegWit](/docs/glossary#segwit-segregated-witness)), 10-min block time |\n| **Security** | Resistance to attacks and manipulation | 700+ EH/s hash rate, [proof-of-work](/docs/glossary#proof-of-work-pow), economic incentives |\n| **Decentralization** | Distribution of control across participants | Thousands of global nodes, open participation, multiple mining pools |\n\n### The Trade-offs\n\n| Trade-off | What Happens | Example |\n|-----------|--------------|---------|\n| **Scalability â†” Security** | Larger/faster blocks require more resources â†’ fewer nodes can participate â†’ weaker security | Bitcoin Cash's 32 MB blocks resulted in fewer nodes |\n| **Scalability â†” Decentralization** | Higher hardware requirements â†’ only well-funded entities can run nodes | 100+ MB blocks would exclude most participants |\n| **Security â†” Decentralization** | Higher hash rate requires expensive ASICs â†’ mining power concentrates | ASIC mining improved security but reduced miner diversity |\n\n### Bitcoin's Solution\n\n**Layer 1: Prioritize Security + Decentralization**\n\nBitcoin intentionally limits base-layer scalability to maintain security and decentralization. The philosophy: the settlement layer should be maximally secure and decentralized.\n\n**Layer 2: Scale on Top**\n\nScalability is addressed through Layer 2 solutions that inherit base-layer security:\n\n- **[Lightning Network](/docs/glossary#lightning-network):** Off-chain payment channels enabling millions of TPS with low fees\n- **Sidechains:** Liquid, Rootstock for specific use cases\n- **State/Payment channels:** Direct peer-to-peer transactions\n\n### Historical Examples\n\n| Change | Year | Scalability | Security | Decentralization |\n|--------|------|-------------|----------|------------------|\n| **Bitcoin Cash** (8â†’32 MB blocks) | 2017 | âœ… Higher TPS | âš ï¸ Lower hash rate | âŒ Fewer nodes |\n| **SegWit** (witness data separated) | 2017 | âœ… ~2x capacity | âœ… Maintained | âœ… Soft fork compatible |\n| **Lightning Network** | 2018+ | âœ… Millions TPS | âœ… Base layer intact | âœ… Base layer intact |\n\nBitcoin optimizes for **Security** and **Decentralization**, accepting limited base-layer **Scalability**. This is intentional:\n\n- **Base layer** = Settlement layer (high-value, infrequent transactions)\n- **Layer 2** = Payment layer (low-value, frequent transactions)\n\nThis separation of concerns provides the benefits of all three properties across the stack.\n\n---\n\n## Threats to Decentralization\n\n| Area | Risk | Mitigation |\n|------|------|------------|\n| **Mining** | Pool consolidation, geographic concentration, ASIC manufacturer influence | Miners can switch pools; competitive market; global distribution |\n| **Nodes** | Growing blockchain size, higher hardware requirements | Pruning, light clients, ongoing optimization |\n| **Development** | Single implementation dominance, few core developers | Multiple implementations, open BIP process, fork ability |\n\n---\n\n## Measuring Decentralization\n\n**Quantitative:** Node count, hash rate distribution across pools, geographic spread, implementation diversity.\n\n**Qualitative:** Can transactions be censored? Can the network survive targeted attacks? Can anyone participate without permission?\n",
    "filename": "decentralization.md"
  },
  "/docs/fundamentals/trust-model": {
    "content": "# Trust Model\n\nBitcoin's trust model differs fundamentally from traditional finance. Instead of trusting intermediaries (banks, payment processors, governments), Bitcoin uses cryptographic proof and economic incentives to create a **trustless** system: minimal trust, not zero trust.\n\n## Traditional vs Bitcoin Trust\n\n| Aspect | Traditional System | Bitcoin |\n|--------|-------------------|---------|\n| **Who to trust** | Banks, payment processors, governments | The protocol and cryptography |\n| **Single points of failure** | Bank/processor/government failure | None (distributed network) |\n| **Censorship** | Accounts can be frozen, transactions blocked | Resistant (no central authority) |\n| **Reversibility** | Chargebacks, reversals possible | Final after confirmation |\n| **Privacy** | Intermediaries see all transactions | Pseudonymous, no identity required |\n\n---\n\n## What \"Trustless\" Really Means\n\nYou trust **mathematics and code** rather than **people and institutions**. This principle comes directly from [cypherpunk philosophy](/docs/fundamentals/cypherpunk-philosophy), which advocates for \"trust code, not people\":\n\n- **Cryptographic proof:** Digital signatures prove ownership; hash functions secure the blockchain\n- **Economic incentives:** Miners profit from honest behavior; attacks are prohibitively expensive\n- **Open verification:** Anyone can run a node and independently verify every transaction\n\n---\n\n## Trust Assumptions\n\n### What You Must Trust\n\n- **Protocol correctness:** Bitcoin works as designed\n- **Cryptography:** [SHA-256](/docs/glossary#sha-256), [ECDSA](/docs/glossary#ecdsa-elliptic-curve-digital-signature-algorithm) remain secure\n- **Network honesty:** Majority of [hash rate](/docs/glossary#hash-rate) follows the rules\n- **Your own security:** You protect your [private keys](/docs/glossary#private-key)\n\n### What You Don't Need to Trust\n\nBanks, payment processors, governments, other users, miners (economically incentivized), or developers (code is open-source and auditable).\n\n#### The Immaculate Conception: Why Satoshi's Anonymity Matters\n\nBitcoin's creator, [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto), remains anonymous and disappeared from the project in 2010. This is not a bug; it's a feature. The \"immaculate conception\" refers to the idea that **not knowing who created Bitcoin is actually beneficial** for the network's trust model.\n\n**Why anonymity strengthens Bitcoin:**\n\n- **No founder worship:** There's no charismatic leader to follow blindly or whose opinions carry undue weight. Decisions are made through [consensus](/docs/glossary#consensus) and code, not authority.\n- **No single point of attack:** Governments or adversaries can't target, coerce, or influence the creator to change Bitcoin's rules or shut it down.\n- **No special privileges:** Satoshi cannot return to claim special rights, reverse transactions, or modify the protocol. The code speaks for itself.\n- **True decentralization:** With no known founder, Bitcoin truly belongs to no one and everyone. The protocol stands on its own merits, not the reputation of its creator.\n- **Focus on the code:** Attention stays on Bitcoin's technical properties and economic incentives, not on the personality or intentions of its creator.\n\nSatoshi's disappearance was the ultimate act of decentralization: they created the system, proved it worked, and then removed themselves from the equation entirely. Bitcoin doesn't need its creator; it only needs the protocol, the network, and the mathematics that make it work.\n\n---\n\n## Trust Minimization Techniques\n\n**Run a [full node](/docs/glossary#full-node):** Verify all transactions yourself instead of trusting others.\n\n**Use open-source software:** Code is publicly auditable with no hidden functionality.\n\n**Self-custody:** Control your own private keys; no third-party can freeze or seize your funds. See [wallets](/docs/glossary#wallet) for more.\n\n---\n\n## Trust vs Convenience Spectrum\n\n| Approach | Trust Level | Trade-off |\n|----------|-------------|-----------|\n| **Full node + self-custody** | Minimal | Maximum security; requires technical knowledge and resources |\n| **Light wallet** | Medium | Mobile-friendly, fast setup; trusts full nodes for verification |\n| **Custodial wallet/exchange** | High | Easy to use, password recovery; you trust the custodian completely |\n\nBitcoin's philosophy: prefer trust minimization, accept inconvenience for security, verify rather than trust.\n",
    "filename": "trust-model.md"
  },
  "/docs/fundamentals/monetary-properties": {
    "content": "# Monetary Properties\n\nBitcoin exhibits key monetary properties that make it suitable as both a medium of exchange and a store of value. These properties emerge from Bitcoin's technical design and economic model.\n\n## Core Monetary Properties\n\n| Property | Definition | Bitcoin Implementation |\n|----------|------------|----------------------|\n| **Scarcity** | Limited supply that cannot be arbitrarily increased | Fixed [21 million](/docs/glossary#21-million) cap, predictable issuance via [halving](/docs/glossary#halving) schedule |\n| **Divisibility** | Ability to divide into smaller units | 8 decimal places (1 BTC = 100,000,000 satoshis). See [Denominations](/docs/fundamentals/denominations) for the full unit table. |\n| **Portability** | Easy to transport and transfer | Digital, transferable globally via internet, 24/7 |\n| **Durability** | Resistance to wear or destruction | Digital (no degradation), distributed across thousands of nodes |\n| **Fungibility** | All units interchangeable | Technically fungible, though blockchain analysis can trace history |\n| **Acceptability** | Others willing to accept as payment | Growing adoption among millions of users and thousands of merchants |\n\n---\n\n## Additional Properties\n\n**Verifiability:** Digital signatures prove ownership cryptographically. Anyone can verify transactions on the public blockchain, and counterfeiting is mathematically impossible.\n\n**Programmability:** Bitcoin [Script](/docs/glossary#script) enables conditional transactions: [time locks](/docs/glossary#time-lock) ([CLTV](/docs/glossary#cltv-checklocktimeverify), [CSV](/docs/glossary#csv-checksequenceverify)), [multisignature](/docs/glossary#multisig-multi-signature) requirements, and basic smart contracts.\n\n**Censorship Resistance:** No central authority can block transactions. The global, permissionless network makes shutdown impractical.\n\n---\n\n## Comparison to Traditional Money\n\n| Property | Fiat Currency | Gold | Bitcoin |\n|----------|--------------|------|---------|\n| **Scarcity** | Can be printed indefinitely | Limited but unknown total | Fixed 21M cap |\n| **Divisibility** | Cents (2 decimals) | Difficult to divide | 8 decimal places |\n| **Portability** | Physical cash limited; digital requires banks | Heavy, expensive to move | Digital, instant global transfer |\n| **Durability** | Paper degrades; digital depends on banks | Excellent | Distributed across thousands of nodes |\n| **Verifiability** | Counterfeiting possible | Requires expertise | Cryptographic proof |\n| **Censorship** | Accounts can be frozen | Physical seizure possible | Resistant (no central control) |\n| **Volatility** | Low (developed countries) | Low | High (currently) |\n| **Acceptance** | Universal (within jurisdiction) | Limited | Growing |\n\n---\n\n## Economic Functions\n\n**Store of Value:** Scarcity and deflationary supply support long-term value preservation. High short-term volatility, but growing institutional adoption as a \"digital gold\" asset.\n\n**Medium of Exchange:** Base layer handles ~7 TPS with fees that vary by demand. [Lightning Network](/docs/glossary#lightning-network) enables fast, low-fee payments for everyday transactions.\n\n**Unit of Account:** Still developing. Prices are primarily quoted in fiat (USD), though some communities price goods in satoshis.\n",
    "filename": "monetary-properties.md"
  },
  "/docs/fundamentals/denominations": {
    "content": "# Denominations\n\nBitcoin is highly divisible: one bitcoin (BTC) equals 100 million of the smallest on-chain unit, the satoshi (sat). This design supports both large transfers and tiny amounts, and it scales as the nominal value of each unit changes over time. Common units include satoshis for small amounts, bits (ÂµBTC, or one millionth of a BTC) for everyday thinking, and millibits (mBTC) or whole BTC for larger sums. Understanding how these units relate helps when reading [fees](/docs/glossary#fee-rate), [block rewards](/docs/glossary#block-reward), and prices across wallets and Lightning apps. Below you can convert between units and see the full reference table.\n\n## Calculator\n\n:::denomination-calculator\n\n:::\n\n## Conversion Table\n\n| Denomination | Symbol | Value in BTC |\n|-------------|--------|--------------|\n| Satoshi | SAT | 0.00000001 |\n| Microbit | ÂµBTC (uBTC) | 0.000001 |\n| Millibit | mBTC | 0.001 |\n| Centibit | cBTC | 0.01 |\n| Decibit | dBTC | 0.1 |\n| Bitcoin | BTC | 1 |\n| DecaBit | daBTC | 10 |\n| Hectobit | hBTC | 100 |\n| Kilobit | kBTC | 1,000 |\n| Megabit | MBTC | 1,000,000 |\n\nThe [Lightning Network](/docs/glossary#lightning-network) uses **millisatoshis** (1/1000 of a satoshi) for routing and invoice amounts.\n",
    "filename": "denominations.md"
  },
  "/docs/fundamentals/incentives": {
    "content": "# Incentive Structure\n\nBitcoin's security and functionality emerge from carefully designed economic incentives that align the interests of all network participants toward honest behavior. Unlike traditional systems that rely on legal enforcement or trusted authorities, Bitcoin uses game theory and economic incentives to create a system where **honesty is the most profitable strategy**.\n\n## Why Incentives Matter\n\nBitcoin operates in a hostile environment where participants may be anonymous, geographically distributed, and potentially malicious. Without a central authority to enforce rules, Bitcoin must rely on **incentive alignment**: making it more profitable to follow the rules than to break them.\n\nThe genius of Bitcoin's design is that it doesn't require participants to be altruistic or trustworthy. Instead, it assumes rational self-interest and structures the system so that **self-interest naturally leads to network security**.\n\n---\n\n## Core Principle: Honesty is Profitable\n\nBitcoin's incentive structure follows a simple principle: **honest behavior is more profitable than dishonest behavior**. This creates a Nash equilibrium where rational actors choose to follow the rules because doing so maximizes their expected value.\n\n| Participant | Honest Behavior | Dishonest Behavior | Result |\n|-------------|----------------|-------------------|---------|\n| **Miner** | Mine valid blocks, follow consensus rules | Attempt to double-spend or include invalid transactions | Honest mining earns block rewards; dishonest blocks are rejected |\n| **Node** | Validate all transactions and blocks | Accept invalid transactions | Invalid blocks are rejected by network; node loses credibility |\n| **User** | Pay appropriate fees, use valid addresses | Attempt double-spending | Double-spend fails; user loses transaction fees |\n\n---\n\n## Miner Incentives\n\nMiners are the primary security providers for the Bitcoin network. Their incentives are carefully designed to make securing the network more profitable than attacking it.\n\n### Block Rewards\n\nThe **block reward** consists of two components:\n\n1. **Block Subsidy**: New bitcoin created with each block (currently 3.125 BTC, halving every 210,000 blocks)\n2. **Transaction Fees**: Fees paid by users to have their transactions included\n\nMiners only receive rewards if:\n- The block follows all consensus rules\n- The block is accepted by the network\n- The block is built on the longest valid chain\n\n### Honest Mining Incentives\n\n**Why miners follow the rules:**\n\n- **Block acceptance**: Invalid blocks are rejected by nodes, wasting mining effort\n- **Longest chain rule**: Miners maximize profits by building on the longest chain\n- **Network participation**: Honest miners earn consistent rewards; attackers face high costs with uncertain outcomes\n- **Reputation**: Mining pools that include invalid transactions lose credibility\n\n**Economic calculation:**\n```\nExpected Value (Honest Mining) = Block Reward Ã— Probability of Finding Block\nExpected Value (Attack) = Attack Cost + (Low Probability of Success Ã— Potential Gain)\n```\n\nFor rational miners, honest mining has higher expected value than attacking.\n\n### Attack Costs\n\nAttacking Bitcoin requires:\n\n| Attack Type | Cost | Why It Fails |\n|-------------|------|--------------|\n| **51% Attack** | >50% of network hash rate (currently >350 EH/s) | Hardware costs billions; could earn more mining honestly |\n| **Double-Spend** | Must create longer chain than honest miners | Requires majority hash rate; transactions revert if attack fails |\n| **Invalid Transactions** | Blocks rejected by network | Wasted electricity, no reward |\n\nThe cost of attacking Bitcoin exceeds any potential gain, making attacks economically irrational.\n\n### Fee Market Evolution\n\nAs block subsidies decrease through [halvings](/docs/glossary#halving), transaction fees become increasingly important:\n\n- **Current**: Block subsidy (3.125 BTC) >> Transaction fees (~0.1-1 BTC)\n- **Future**: Transaction fees will become primary miner revenue\n- **Fee market**: Users compete by offering higher fees for faster confirmation\n\nThis transition ensures miners remain incentivized to secure the network even after all 21 million bitcoin are mined.\n\n---\n\n## Node Incentives\n\n[Full nodes](/docs/glossary#full-node) validate all transactions and blocks, maintaining network integrity. Unlike miners, nodes don't receive direct financial rewards, yet thousands of nodes operate worldwide.\n\n### Why Run a Node?\n\n**Direct benefits:**\n- **Self-verification**: Verify your own transactions without trusting others\n- **Privacy**: Don't reveal your addresses to third-party services\n- **Security**: Ensure you're following the real Bitcoin rules\n- **Censorship resistance**: Participate in network without intermediaries\n\n**Network benefits:**\n- **Decentralization**: More nodes = stronger network resilience\n- **Rule enforcement**: Nodes reject invalid blocks, maintaining consensus\n- **Propagation**: Help spread valid blocks and transactions\n\n### Economic Model\n\nRunning a node has costs (hardware, electricity, bandwidth) but provides value:\n- **Individual value**: Self-verification, privacy, security\n- **Collective value**: Network security and decentralization\n- **Altruistic value**: Supporting the Bitcoin network\n\nThe fact that thousands of individuals choose to run nodes demonstrates that the benefits (both personal and collective) outweigh the costs.\n\n---\n\n## User Incentives\n\nUsers are incentivized to use Bitcoin honestly through the fee market and security model.\n\n### Fee Market\n\nUsers compete for block space by offering transaction fees:\n\n- **Higher fees** = Faster confirmation (miners prioritize profitable transactions)\n- **Lower fees** = Slower confirmation (may wait during congestion)\n- **No fees** = Transaction may never confirm\n\nThis creates a **market-based allocation** of block space, ensuring:\n- Urgent transactions can pay for priority\n- Network resources are allocated efficiently\n- Miners are compensated for their work\n\n### Security Incentives\n\nUsers are incentivized to:\n- **Use proper security**: Protect private keys to avoid loss\n- **Wait for confirmations**: Higher-value transactions need more confirmations\n- **Pay appropriate fees**: Ensure transactions confirm in reasonable time\n\n### Double-Spending Deterrence\n\nAttempting to double-spend is economically irrational:\n- **Cost**: Must control >50% hash rate (billions of dollars)\n- **Risk**: Attack may fail, losing transaction fees\n- **Benefit**: Only succeeds if attack succeeds (low probability)\n\nFor typical users, the cost of double-spending far exceeds any potential gain.\n\n---\n\n## Developer Incentives\n\nBitcoin's open-source development model creates unique incentives for developers.\n\n### Open Source Benefits\n\n- **Transparency**: Code is auditable by anyone\n- **No single point of control**: Multiple implementations exist\n- **Merit-based**: Best ideas win through consensus\n- **Reputation**: Contributions build developer reputation\n\n### Consensus Process\n\nChanges to Bitcoin require broad consensus:\n- **BIP process**: Bitcoin Improvement Proposals are publicly discussed\n- **Node adoption**: Changes only work if nodes adopt them\n- **Backward compatibility**: Soft forks maintain compatibility; hard forks create new chains\n\nThis process ensures that:\n- Changes benefit the network, not just developers\n- No single developer can force changes\n- The protocol evolves through community consensus\n\n### Economic Alignment\n\nDevelopers are incentivized to improve Bitcoin because:\n- **Network value**: Bitcoin's success increases the value of their contributions\n- **Reputation**: Successful contributions build professional reputation\n- **Ideology**: Many developers believe in Bitcoin's mission\n- **Career**: Bitcoin expertise is valuable in the industry\n\n---\n\n## Game Theory and Nash Equilibrium\n\nBitcoin's incentive structure creates a **Nash equilibrium**: a situation where no participant can improve their outcome by unilaterally changing their strategy.\n\n### The Mining Game\n\n**Players**: All miners  \n**Strategies**: Mine honestly vs. attack the network  \n**Payoffs**: Block rewards for honest mining; costs and low success probability for attacks\n\n**Equilibrium**: All miners choose to mine honestly because:\n- Honest mining has positive expected value\n- Attacking has negative expected value\n- No miner can improve their outcome by attacking\n\n### The Node Game\n\n**Players**: All nodes  \n**Strategies**: Validate honestly vs. accept invalid blocks  \n**Payoffs**: Network security and self-verification for honest validation; network degradation for accepting invalid blocks\n\n**Equilibrium**: Nodes validate honestly because:\n- Invalid blocks harm the network (which nodes depend on)\n- Self-verification provides direct value\n- No benefit to accepting invalid blocks\n\n### Attack Deterrence\n\nThe game-theoretic structure makes attacks economically irrational:\n\n```\nAttack Cost > Potential Gain Ã— Probability of Success\n```\n\nFor Bitcoin, this inequality holds because:\n- Attack costs are enormous (hardware, electricity, opportunity cost)\n- Success probability is low (requires >50% hash rate)\n- Potential gain is limited (can only reverse recent transactions)\n\n---\n\n## Incentive Alignment Across Participants\n\nBitcoin's incentives align all participants toward network security:\n\n| Participant | Primary Incentive | How It Secures Network |\n|-------------|------------------|----------------------|\n| **Miners** | Block rewards + fees | Secure network to earn rewards |\n| **Nodes** | Self-verification + network health | Enforce rules, reject invalid blocks |\n| **Users** | Reliable transactions | Pay fees, use network honestly |\n| **Developers** | Network success + reputation | Improve protocol, maintain security |\n\n### Positive Feedback Loops\n\nBitcoin's incentive structure creates positive feedback loops:\n\n1. **Security â†’ Value**: More security increases Bitcoin's value\n2. **Value â†’ Mining**: Higher value increases mining profitability\n3. **Mining â†’ Security**: More mining increases network security\n4. **Security â†’ Adoption**: Strong security attracts more users\n5. **Adoption â†’ Value**: More users increase Bitcoin's value\n\nThis creates a **virtuous cycle** where network security and value reinforce each other.\n\n---\n\n## Long-Term Incentive Sustainability\n\nBitcoin's incentive structure is designed to remain effective long-term:\n\n### Subsidy Transition\n\n- **Early years**: Block subsidies provide primary miner revenue\n- **Transition**: Transaction fees gradually become more important\n- **Long-term**: Fees provide sufficient revenue to secure network\n\nThe fee market ensures miners remain incentivized even after all bitcoin are mined.\n\n### Difficulty Adjustment\n\nThe [difficulty adjustment](/docs/mining/difficulty) mechanism ensures:\n- Block times remain ~10 minutes regardless of hash rate\n- Mining remains competitive\n- Network security scales with adoption\n\n### Protocol Immutability\n\nBitcoin's core rules are difficult to change, ensuring:\n- Incentive structure remains stable\n- Participants can rely on long-term incentives\n- No single entity can change the rules\n\n---\n\n## Comparison with Traditional Systems\n\n| Aspect | Traditional Systems | Bitcoin |\n|--------|-------------------|---------|\n| **Enforcement** | Legal, regulatory, institutional | Economic incentives |\n| **Trust** | Trust in authorities | Trust in mathematics and incentives |\n| **Attack prevention** | Legal penalties | Economic disincentives |\n| **Alignment** | Authorities enforce rules | Self-interest enforces rules |\n| **Failure mode** | Authority corruption/failure | Economic attack (prohibitively expensive) |\n\nBitcoin's incentive-based model is more resilient because it doesn't depend on:\n- Legal systems\n- Regulatory enforcement\n- Institutional trust\n- Geographic jurisdiction\n\n---\n\n## Conclusion\n\nBitcoin's incentive structure is the foundation of its security and functionality. By making honesty more profitable than dishonesty, Bitcoin creates a system where rational self-interest naturally leads to network security. This elegant design allows Bitcoin to operate without central authority, legal enforcement, or trusted intermediaries, relying instead on mathematics, cryptography, and economic incentives.\n\nUnderstanding incentives is essential for understanding Bitcoin because **incentives explain why Bitcoin works**, not just how it works. Every aspect of Bitcoin's design (from proof-of-work to the fee market to consensus rules) is shaped by the need to align participant incentives toward network security.\n\n---\n\n## Related Topics\n\n- [Game Theory](/docs/fundamentals/game-theory) - Deep dive into game-theoretic principles behind Bitcoin's incentive structure\n- [Trust Model](/docs/fundamentals/trust-model) - How incentives minimize trust requirements\n- [Consensus Mechanism](/docs/bitcoin/consensus) - How incentives enable decentralized consensus\n- [Mining Economics](/docs/mining/economics) - Detailed analysis of miner incentives\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - How incentive alignment solves coordination problems\n- [Decentralization](/docs/fundamentals/decentralization) - How incentives maintain decentralization\n",
    "filename": "incentives.md"
  },
  "/docs/fundamentals/game-theory": {
    "content": "# Game Theory\n\nGame theory is the mathematical study of strategic decision-making. In Bitcoin, game theory explains **why** the network remains secure even when participants are anonymous, potentially malicious, and have no reason to trust each other. Bitcoin's design creates a system where rational self-interest naturally leads to honest behavior and network security.\n\n## Why Game Theory Matters for Bitcoin\n\nTraditional financial systems rely on legal enforcement, trusted authorities, and institutional oversight. Bitcoin operates in a **trustless environment** where:\n\n- Participants may be anonymous\n- No central authority enforces rules\n- Attackers have strong incentives to break the system\n- Cooperation must emerge without coordination\n\nGame theory provides the framework to understand how Bitcoin achieves security and consensus in this hostile environment. By structuring incentives correctly, Bitcoin creates games where **honesty is the dominant strategy**: the most profitable choice for rational actors.\n\n---\n\n## Game Theory Basics\n\nA **game** in game theory consists of:\n\n- **Players**: Participants who make decisions (miners, nodes, users)\n- **Strategies**: Choices available to each player (mine honestly vs. attack, validate vs. accept invalid blocks)\n- **Payoffs**: Outcomes based on strategy choices (block rewards, network security, transaction fees)\n\n### Nash Equilibrium\n\nA **Nash equilibrium** occurs when no player can improve their outcome by unilaterally changing their strategy, given what other players are doing. In Bitcoin, the Nash equilibrium is: **all participants choose honest behavior** because:\n\n- Honest behavior has positive expected value\n- Dishonest behavior has negative expected value\n- No participant can improve their outcome by deviating\n\nThis creates a stable state where the network remains secure without requiring trust or enforcement.\n\n### Dominant Strategies\n\nA **dominant strategy** is one that yields the best outcome regardless of what other players do. Bitcoin's design makes honest behavior a dominant strategy:\n\n| Participant | Dominant Strategy | Why |\n|-------------|------------------|-----|\n| **Miner** | Mine honestly | Earns block rewards; attacks cost more than they gain |\n| **Node** | Validate honestly | Maintains network security; invalid blocks harm everyone |\n| **User** | Use network honestly | Transactions confirm; double-spends fail and waste fees |\n\n---\n\n## The Prisoner's Dilemma\n\nThe **Prisoner's Dilemma** is a classic game theory problem where two players must choose between cooperation and defection. The dilemma: each player's dominant strategy (defect) leads to a worse outcome for both than if they cooperated.\n\n### The Classic Problem\n\nTwo prisoners are interrogated separately:\n- If both **cooperate** (stay silent): Both get light sentences\n- If both **defect** (confess): Both get medium sentences\n- If one defects and one cooperates: Defector goes free, cooperator gets harsh sentence\n\nThe dominant strategy is to defect, but this leads to a worse outcome than mutual cooperation.\n\n### How Bitcoin Avoids the Prisoner's Dilemma\n\nBitcoin's incentive structure **reverses the payoffs** so that cooperation (honest behavior) becomes the dominant strategy:\n\n| Scenario | Traditional Prisoner's Dilemma | Bitcoin's Design |\n|----------|-------------------------------|------------------|\n| **Both cooperate** | Good outcome | Best outcome (both earn rewards) |\n| **Both defect** | Bad outcome | Worst outcome (both lose, network fails) |\n| **One defects** | Defector wins, cooperator loses | Defector loses (attack fails), cooperator wins (network secure) |\n\nBy making honest behavior more profitable than attacks, Bitcoin transforms a potential prisoner's dilemma into a **coordination game** where cooperation is the rational choice.\n\n---\n\n## Coordination Without Authority\n\nBitcoin achieves coordination among thousands of independent participants without a central authority. This is a **coordination game**: multiple players benefit from choosing the same strategy.\n\n### The Longest Chain Rule\n\nBitcoin's longest chain rule is a coordination mechanism:\n\n- **All miners** want to build on the same chain (the longest one)\n- **All nodes** accept the longest valid chain\n- **All users** recognize transactions in the longest chain\n\nThis creates a **focal point**: a natural choice that all participants converge on without communication or coordination.\n\n### Why Coordination Works\n\n| Challenge | Bitcoin's Solution |\n|-----------|-------------------|\n| **Which chain is valid?** | Longest chain (most proof-of-work) |\n| **Which transactions are confirmed?** | Transactions in the longest chain |\n| **What if chains conflict?** | Network converges on longest chain |\n| **How to prevent forks?** | Miners build on longest chain (most profitable) |\n\nThe longest chain rule creates a **self-enforcing coordination mechanism** where rational actors naturally converge on the same choice.\n\n---\n\n## Games in Bitcoin\n\nBitcoin contains multiple interconnected games, each with different players, strategies, and payoffs:\n\n### The Mining Game\n\n**Players**: All miners  \n**Strategies**: Mine honestly vs. attack the network  \n**Payoffs**: Block rewards for honest mining; costs and low success probability for attacks\n\n**Equilibrium**: All miners choose to mine honestly because honest mining has positive expected value, while attacking has negative expected value.\n\nSee [Incentive Structure](/docs/fundamentals/incentives#game-theory-and-nash-equilibrium) for detailed analysis of the mining game.\n\n### The Node Validation Game\n\n**Players**: All nodes  \n**Strategies**: Validate honestly vs. accept invalid blocks  \n**Payoffs**: Network security and self-verification for honest validation; network degradation for accepting invalid blocks\n\n**Equilibrium**: Nodes validate honestly because invalid blocks harm the network (which nodes depend on), and self-verification provides direct value.\n\nSee [Incentive Structure](/docs/fundamentals/incentives#game-theory-and-nash-equilibrium) for detailed analysis of the node game.\n\n### The Fee Market Game\n\n**Players**: Users competing for block space  \n**Strategies**: Pay higher fees vs. pay lower fees  \n**Payoffs**: Faster confirmation (higher fees) vs. slower confirmation (lower fees)\n\n**Equilibrium**: Users pay fees based on urgency. Miners prioritize higher-fee transactions, creating a market-based allocation of block space.\n\nThis creates a **competitive market** where:\n- Urgent transactions can pay for priority\n- Non-urgent transactions can wait\n- Block space is allocated efficiently\n\n### The Pool Coordination Game\n\n**Players**: Miners in a mining pool  \n**Strategies**: Contribute hash rate honestly vs. cheat the pool  \n**Payoffs**: Regular payouts for honest contribution; risk of detection and exclusion for cheating\n\n**Equilibrium**: Miners contribute honestly because:\n- Pool operators can detect cheating through share validation\n- Cheating risks exclusion from the pool\n- Honest contribution provides steady income\n\n---\n\n## Attack Deterrence\n\nGame theory explains why attacks on Bitcoin are economically irrational. The game-theoretic structure makes attacks unprofitable:\n\n```\nAttack Cost > Potential Gain Ã— Probability of Success\n```\n\n### Why Attacks Fail\n\n| Attack Type | Cost | Potential Gain | Success Probability | Result |\n|-------------|------|----------------|-------------------|---------|\n| **51% Attack** | Billions in hardware + electricity | Can only reverse recent transactions | Requires >50% hash rate | Cost exceeds gain |\n| **Double-Spend** | Must create longer chain | Value of reversed transaction | Low (requires majority hash rate) | Attack fails, fees lost |\n| **Invalid Blocks** | Mining effort wasted | None (blocks rejected) | 0% (blocks rejected) | Pure loss |\n\n### Economic Rationality\n\nFor a rational attacker:\n- **Expected value of attack** = (Potential Gain Ã— Success Probability) - Attack Cost\n- **Expected value of honest mining** = Block Reward Ã— Probability of Finding Block\n\nFor Bitcoin, honest mining has positive expected value, while attacks have negative expected value. Rational actors choose the profitable strategy: honest participation.\n\n### Long-Term vs Short-Term\n\nBitcoin's game theory works over **long time horizons**:\n\n- **Short-term**: An attacker might temporarily control hash rate\n- **Long-term**: Network adjusts, attacker's hardware becomes worthless, honest miners continue earning\n\nThis creates a **repeated game** where defection (attacking) is punished not just immediately, but through long-term network responses like changing the proof-of-work algorithm.\n\n---\n\n## Game Theory and Network Security\n\nGame theory provides the theoretical foundation for Bitcoin's security:\n\n1. **Incentive Alignment**: All participants benefit from network security\n2. **Attack Deterrence**: Attacks are economically irrational\n3. **Coordination**: Network converges on single valid chain\n4. **Stability**: Nash equilibrium ensures honest behavior persists\n\nThis is why Bitcoin can operate **without**:\n- Legal enforcement\n- Trusted authorities\n- Central coordination\n- Institutional oversight\n\nInstead, Bitcoin relies on **mathematical incentives** that make security the rational choice.\n\n---\n\n## Conclusion\n\nGame theory explains why Bitcoin works. By structuring incentives so that honest behavior is the most profitable strategy, Bitcoin creates a system where:\n\n- **Rational self-interest** leads to network security\n- **Cooperation emerges** without central coordination\n- **Attacks are deterred** through economic disincentives\n- **Consensus is achieved** through natural convergence\n\nUnderstanding game theory is essential for understanding Bitcoin because it explains **why** the network remains secure, not just **how** the protocol works. Every aspect of Bitcoin's design, from proof-of-work to the fee market to consensus rules, is shaped by game-theoretic principles that align participant incentives toward network security.\n\n---\n\n## Related Topics\n\n- [Incentive Structure](/docs/fundamentals/incentives) - Detailed analysis of economic incentives and Nash equilibrium\n- [Trust Model](/docs/fundamentals/trust-model) - How game theory minimizes trust requirements\n- [Consensus Mechanism](/docs/bitcoin/consensus) - How game theory enables decentralized consensus\n- [Mining Attacks](/docs/mining/attacks) - Game-theoretic analysis of attack scenarios\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - How game theory solves coordination problems\n- [Decentralization](/docs/fundamentals/decentralization) - How game theory maintains decentralization\n- [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) - How game theory and memetic spread interact to drive adoption\n",
    "filename": "game-theory.md"
  },
  "/docs/fundamentals/bitcoin-meme": {
    "content": "# Bitcoin, the Meme\n\nBitcoin is more than code and cryptography. It's a **meme** in the original sense: an idea that replicates itself through human minds, spreading from person to person, generation to generation, border to border.\n\nAs described in [Bitcoin Fundamentals](/docs/fundamentals#the-idea), Bitcoin embodies the idea that a fixed set of rules can exist around which entire societies can be built, rules that no government, corporation, or individual can change. Once the concept of sound, digital, decentralized money enters someone's mind, it cannot be unseen.\n\nBitcoin, where money meets math.\n\n---\n\n<img src=\"/images/docs/do-something.gif\" alt=\"C'mon, do something...\" width=\"300\" />\n\n### Simple Core Narratives\n\nBitcoin's fundamental concepts are easy to understand and share:\n\n- **21 million**: A fixed supply cap that anyone can verify\n- **Don't trust, verify**: The principle that you can independently verify everything\n- **Not your keys, not your coins**: The importance of self-custody\n- **Decentralization**: No single point of control or failure\n\nThese simple narratives compress complex technical concepts into shareable ideas. See [Monetary Properties](/docs/fundamentals/monetary-properties) for the economic foundation, and [Trust Model](/docs/fundamentals/trust-model) for how verification replaces trust.\n\n### Clear Villains\n\nMemes spread faster when they have clear antagonists. Bitcoin's memetic power is amplified by identifiable \"villains\":\n\n- **Inflation**: The silent tax that erodes purchasing power\n- **Censorship**: The ability of authorities to block or reverse transactions\n- **Centralization**: Single points of failure in traditional systems\n- **Counterfeiting**: The impossibility of creating fake bitcoin\n\nThese villains make Bitcoin's value proposition immediately understandable. See [Problems Bitcoin Solved](/docs/fundamentals/problems) for how Bitcoin addresses these issues.\n\n### Visible Success\n\nBitcoin's memetic strength is reinforced by observable success:\n\n- **Network uptime**: Over 15 years of continuous operation\n- **Price appreciation**: Long-term value growth despite volatility\n- **Adoption growth**: Millions of users, thousands of merchants, nation-state adoption\n- **Security record**: Never hacked, despite constant attacks\n\nThese visible metrics provide proof that the idea works. See [Bitcoin History](/docs/history) for the full story of Bitcoin's growth.\n\n### Philosophical Foundation\n\nBitcoin's memetic power is rooted in [Cypherpunk Philosophy](/docs/fundamentals/cypherpunk-philosophy): the belief that privacy and freedom can be achieved through cryptography and decentralized systems. This philosophical foundation gives Bitcoin meaning beyond mere technology.\n\n---\n\n## The Orange Pill\n\nThe **orange pill** refers to the process of someone \"waking up\" to Bitcoin's implications, a reference to *The Matrix*, where taking the red pill means seeing reality as it truly is.\n\n### The Journey\n\nThe orange pill journey typically follows a pattern:\n\n1. **Skepticism**: Initial dismissal (\"it's a scam,\" \"it has no value,\" \"it's just for criminals\")\n2. **Curiosity**: First exposure to Bitcoin's properties (fixed supply, decentralization, censorship resistance)\n3. **Investigation**: Deep dive into [Bitcoin Fundamentals](/docs/fundamentals), [The Bitcoin Protocol](/docs/bitcoin), and [Game Theory](/docs/fundamentals/game-theory)\n4. **Understanding**: Recognition of Bitcoin's unique properties and potential\n5. **Adoption**: Personal use, investment, or advocacy\n\nThis journey often begins with a meme, a conversation, or a moment of curiosity, then leads to deeper study of Bitcoin's technical and economic foundations.\n\n### From Meme to Understanding\n\nThe orange pill is powerful because it's a meme that leads to education. Someone might first encounter Bitcoin through a joke or meme, but the orange pill process encourages them to learn the fundamentals, understand the technology, and appreciate the economic and social implications.\n\nSee [Bitcoin Adoption](/docs/adoption) for real-world examples of people and communities who have taken the orange pill, and [Bitcoin as Investment](/docs/investment) for how understanding drives investment decisions.\n\n---\n\n## \"Magic Internet Money\" & Other Memes\n\nBitcoin culture has produced numerous memes that serve multiple functions: they're satirical, self-deprecating, educational, and defensive.\n\n### Magic Internet Money\n\n**\"Magic Internet Money\"** is a satirical term that acknowledges Bitcoin's seemingly impossible nature while hinting at its power. It's used both by Bitcoiners (self-deprecating humor) and critics (dismissal), but the meme has been embraced by the community.\n\nThe term highlights that Bitcoin *is* remarkable: digital scarcity without a central issuer, global transfers without intermediaries, and value storage without physical form. Behind the meme is serious technology: [cryptography](/docs/bitcoin/cryptography), [proof-of-work](/docs/mining/proof-of-work), and [game theory](/docs/fundamentals/game-theory).\n\n### Other Common Memes\n\n- **\"Number go up\"**: A satirical reference to Bitcoin's price appreciation, often used to mock both Bitcoin maximalists and critics\n- **\"Have fun staying poor\" (HFSP)**: A defensive meme used when critics dismiss Bitcoin\n- **\"HODL\"**: Originally a typo for \"hold,\" now a verb meaning to hold bitcoin through volatility\n- **\"WAGMI\"**: \"We're all gonna make it,\" a community encouragement meme\n- **\"NGMI\"**: \"Not gonna make it,\" used for those who don't understand Bitcoin\n\nThese memes serve multiple purposes:\n- **Defense**: Responding to criticism with humor\n- **Education**: Compressing complex ideas into shareable formats\n- **Community**: Creating shared language and identity\n- **Awareness**: Spreading Bitcoin concepts to new audiences\n\n### Memes vs. Reality\n\nIt's important to distinguish between useful memes and misleading hype. Memes can be entry points, but they're not substitutes for understanding. Behind every Bitcoin meme is serious technology, economic theory, and game-theoretic security.\n\nSee [The Bitcoin Protocol](/docs/bitcoin) for the technical foundation, and [Game Theory](/docs/fundamentals/game-theory) for why the system works.\n\n---\n\n## Memes, Education, and Adoption\n\nMemes function as **onboarding tools**: they compress complex ideas into shareable hooks that invite deeper learning.\n\n### Memes as Doorways\n\nA meme might introduce someone to Bitcoin, but education is what keeps them. The journey typically looks like:\n\n1. **Meme exposure**: Encounter Bitcoin through a meme, joke, or cultural reference\n2. **Initial curiosity**: \"What is this thing?\"\n3. **Basic learning**: Understanding fundamentals like fixed supply, decentralization, self-custody\n4. **Deep dive**: Studying [Bitcoin Script](/docs/bitcoin/script), [mining](/docs/mining), [Lightning Network](/docs/lightning), and advanced topics\n5. **Adoption**: Using Bitcoin, building on Bitcoin, or advocating for Bitcoin\n\nMemes are effective because they're:\n- **Shareable**: Easy to pass along\n- **Memorable**: Stick in the mind\n- **Accessible**: Don't require technical knowledge\n- **Inviting**: Encourage further exploration\n\n### From Memes to Study\n\nThe responsible approach to Bitcoin memes is to use them as doorways, not destinations. Memes can spark interest, but understanding requires study:\n\n- **Fundamentals**: Start with [Bitcoin Fundamentals](/docs/fundamentals) to understand core concepts\n- **Protocol**: Study [The Bitcoin Protocol](/docs/bitcoin) to understand how it works\n- **Economics**: Learn [Monetary Properties](/docs/fundamentals/monetary-properties) and [Incentive Structure](/docs/fundamentals/incentives)\n- **Security**: Understand [Trust Model](/docs/fundamentals/trust-model) and [Wallet Security](/docs/investment/wallet-security)\n- **Privacy**: Study [Privacy Techniques](/docs/wallets/privacy) and [Privacy](/docs/investment/privacy)\n\n### Memes and Responsible Adoption\n\nMemes can drive adoption, but responsible adoption requires education. See [Risk Management](/docs/investment/risk-management) for how to approach Bitcoin investment responsibly, and [Investment Strategy](/docs/investment-strategy) for long-term thinking.\n\nThe best memes lead to understanding. They're hooks that draw people in, but the real value comes from learning Bitcoin's technical, economic, and social foundations.\n\n---\n\n## Related Topics\n\n- [Bitcoin Fundamentals](/docs/fundamentals) - Core concepts that make Bitcoin memetic\n- [Cypherpunk Philosophy](/docs/fundamentals/cypherpunk-philosophy) - The philosophical foundation behind Bitcoin\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin has value\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin enables trustless transactions\n- [Game Theory](/docs/fundamentals/game-theory) - How strategic decision-making secures Bitcoin\n- [Bitcoin Adoption](/docs/adoption) - Real-world examples of Bitcoin adoption\n- [Problems Bitcoin Solved](/docs/fundamentals/problems) - The fundamental challenges Bitcoin addresses\n- [Decentralization](/docs/fundamentals/decentralization) - Why Bitcoin can't be stopped\n",
    "filename": "bitcoin-meme.md"
  },
  "/docs/history": {
    "content": "# Historical Milestones\n\nBitcoin's history spans from its creation in 2009 to its future supply schedule extending into the 22nd century.\n\n## 2008\n\n### Bitcoin Whitepaper Published\n\n- **Date**: October 31, 2008\n- **Author**: [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto)\n- **Title**: \"Bitcoin: A Peer-to-Peer Electronic Cash System\"\n\nSatoshi Nakamoto published the [Bitcoin whitepaper](/whitepaper), introducing the concept of a decentralized digital currency system. The whitepaper outlined the technical foundation for Bitcoin, including proof-of-work, the blockchain, and the peer-to-peer network architecture. Its release coincided with the 2008 financial crisisâ€”bank bailouts, failed institutions, and loss of trust in central banksâ€”which gave the idea of peer-to-peer electronic cash without intermediaries immediate relevance.\n\n---\n\n## 2009\n\n### Bitcoin Launch\n\n- **Date**: January 3, 2009\n- **Block**: 0 ([Genesis Block](/docs/glossary#genesis-block))\n- **Block Reward**: 50 BTC\n- **Creator**: Satoshi Nakamoto\n\nThe [Genesis Block](/docs/glossary#genesis-block) was mined by Satoshi Nakamoto, marking the birth of the Bitcoin network. The block contains a hidden message in its coinbase transaction: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\": a reference to a headline from The Times newspaper, highlighting Bitcoin's purpose as an alternative to the traditional financial system.\n\n### First Transaction\n\n- **Date**: January 12, 2009\n- **Details**: Satoshi Nakamoto sent 10 BTC to [Hal Finney](/docs/history/people#hal-finney)\n- **Block**: 170\n\nThis transaction marked the first time Bitcoin was sent from one person to another, demonstrating the peer-to-peer nature of the network.\n\n### First Exchange Rate\n\n- **Date**: October 5, 2009\n- **Rate**: $1 = 1,309.03 BTC\n\nThe first published exchange rate valued Bitcoin at less than $0.001 per coin.\n\n---\n\n## 2010\n\n### Satoshi's Handover\n\n- **Date**: Midâ€“late 2010\n\nSatoshi Nakamoto gradually handed over Bitcoin development and [repository](https://github.com/bitcoin/bitcoin) access to [Gavin Andresen](/docs/history/people) and others, then stopped appearing in forums and email. The last known public communications are from early 2011. Satoshiâ€™s identity remains unknown, and the [protocol](/docs/bitcoin) has since been maintained by the open-source community.\n\n### Pizza Day\n\n- **Date**: May 22, 2010\n- **Details**: Laszlo Hanyecz paid 10,000 BTC for two pizzas\n\nThe first real-world commercial transaction using Bitcoin. At 2024 prices, those pizzas would be worth hundreds of millions of dollars. May 22 is now celebrated annually as \"Bitcoin Pizza Day.\"\n\n### Mt. Gox Launches\n\n- **Date**: July 17, 2010\n\nMt. Gox launched as the first major Bitcoin exchange, eventually handling over 70% of all Bitcoin transactions before its collapse in 2014.\n\n### Value Overflow Bug\n\n- **Date**: August 15, 2010\n\nA critical [consensus](/docs/glossary#consensus) bug was discovered that allowed creation of 184 billion BTC from an integer overflow in [output](/docs/glossary#output) validation. The exploit was fixed with a [soft fork](/docs/glossary#soft-fork), and the invalid [transaction](/docs/bitcoin/transaction-lifecycle) was removed from the [blockchain](/docs/glossary#blockchain). It remains one of the most serious early [protocol](/docs/bitcoin) bugs; the response showed the network could coordinate a timely fix.\n\n---\n\n## 2011\n\n### Dollar Parity\n\n- **Date**: February 9, 2011\n- **Price**: $1/BTC\n\nBitcoin reached parity with the US dollar for the first time.\n\n### First Major Rally\n\n- **Date**: June 8, 2011\n- **Price**: $31/BTC\n\nBitcoin's first major price spike, followed by a crash to $2 by November.\n\n### Silk Road Launches\n\n- **Date**: February 2011\n\nSilk Road, an online marketplace that used Bitcoin for payments, launched. It became the best-known early use case for [Bitcoin](/docs/glossary#bitcoin-network) and drew attention (both positive and negative) to [censorship resistance](/docs/glossary#censorship-resistance) and [privacy](/docs/wallets/privacy). The site was shut down by law enforcement in October 2013; the episode highlighted that [Bitcoin](/docs/glossary#bitcoin-network) is neutral infrastructure and that adoption and regulation would continue to evolve.\n\n---\n\n## 2012\n\n### First Halving\n\n- **Date**: November 28, 2012\n- **Block**: 210,000\n- **New Reward**: 25 BTC\n\nThe first halving reduced the block reward from 50 BTC to 25 BTC.\n\n### Bitcoin Foundation\n\n- **Date**: September 27, 2012\n\nThe Bitcoin Foundation was established to promote Bitcoin development and adoption.\n\n---\n\n## 2013\n\n### Billion Dollar Market Cap\n\n- **Date**: March 28, 2013\n\nBitcoin's market capitalization exceeded $1 billion for the first time.\n\n### First $1,000\n\n- **Date**: November 29, 2013\n- **Price**: $1,000/BTC\n\nBitcoin crossed $1,000 for the first time during a rally driven by Chinese exchange activity.\n\n### Silk Road Shut Down\n\n- **Date**: October 2013\n\nU.S. law enforcement shut down Silk Road and arrested its operator. The event fueled debate over [Bitcoin](/docs/glossary#bitcoin-network)â€™s use in illicit markets and over [regulation](/docs/glossary#aml-anti-money-laundering). The [network](/docs/bitcoin/p2p-protocol) continued to operate; no [protocol](/docs/bitcoin) change was required.\n\n---\n\n## 2014\n\n### Mt. Gox Collapse\n\n- **Date**: February 2014\n\n[Mt. Gox](/docs/controversies/mt-gox), then the world's largest Bitcoin exchange, suspended trading and declared bankruptcy after losing approximately 850,000 BTC to theft and operational failures. The collapse entrenched \"not your keys, not your coins\" as a core lesson: custody matters, and trusting third parties with bitcoin carries serious risk.\n\n---\n\n## 2015\n\n### Scaling Debate and Lightning Whitepaper\n\n- **Date**: 2015\n\nThe [blocksize wars](/docs/controversies/blocksize-wars) intensified as Bitcoinâ€™s 1 MB block limit began to bite. Proposals to raise the limit (e.g. Bitcoin XT, larger blocks) clashed with efforts to scale via [Layer 2](/docs/glossary#layer-2) and [SegWit](/docs/glossary#segwit-segregated-witness). In the same year, Joseph Poon and Thaddeus Dryja published the [Lightning Network](/docs/glossary#lightning-network) whitepaper, outlining an off-chain payment-channel network that would later become Bitcoinâ€™s main scaling solution.\n\n---\n\n## 2016\n\n### Second Halving\n\n- **Date**: July 9, 2016\n- **Block**: 420,000\n- **New Reward**: 12.5 BTC\n\n---\n\n## 2017\n\n### Bitcoin Cash Fork\n\n- **Date**: August 1, 2017\n\nThe contentious hard fork created Bitcoin Cash (BCH), splitting the community over the block size debate.\n\n### First $20,000\n\n- **Date**: December 17, 2017\n- **Price**: ~$20,000/BTC\n\nBitcoin reached its then all-time high during the 2017 bull run, driven by retail FOMO and ICO speculation.\n\n---\n\n## 2020\n\n### Third Halving\n\n- **Date**: May 11, 2020\n- **Block**: 630,000\n- **New Reward**: 6.25 BTC\n\n---\n\n## 2021\n\n### El Salvador Adoption\n\n- **Date**: September 7, 2021\n\nEl Salvador became the first country to adopt Bitcoin as legal tender.\n\n---\n\n## 2024\n\n### Fourth Halving\n\n- **Date**: April 20, 2024\n- **Block**: 840,000\n- **New Reward**: 3.125 BTC\n\n### Spot Bitcoin ETFs\n\n- **Date**: January 10, 2024\n\nThe SEC approved the first spot Bitcoin ETFs in the United States, opening Bitcoin investment to traditional finance.\n\n---\n\n## Future\n\n### All Coins Issued\n\n- **Date**: ~2140 (estimated)\n- **Block**: ~6,930,000\n- **Significance**: Last new Bitcoin will be created\n\nAfter this date, no new Bitcoin will be created through block rewards. Miners will rely entirely on transaction fees for income.\n",
    "filename": "overview.md"
  },
  "/docs/history/people": {
    "content": "# People in Bitcoin\n\nBitcoin didn't emerge from a vacuum. It was built on decades of cryptographic research and the work of visionary cypherpunks who dreamed of digital cash. This page honors both the pioneers who laid the groundwork and the contributors who brought Bitcoin to life.\n\n**Pioneers (pre-Bitcoin):** [David Chaum](#david-chaum), [Eric Hughes](#eric-hughes), [Timothy C. May](#timothy-c-may), [John Gilmore](#john-gilmore), [Adam Back](#adam-back), [Nick Szabo](#nick-szabo), [Wei Dai](#wei-dai), [Ralph Merkle](#ralph-merkle), [Stuart Haber and Scott Stornetta](#stuart-haber-and-scott-stornetta)\n\n**Bitcoin builders:** [Satoshi Nakamoto](#satoshi-nakamoto), [Hal Finney](#hal-finney), [Len Sassaman](#len-sassaman), [Martti Malmi](#martti-malmi), [Gavin Andresen](#gavin-andresen), [Laszlo Hanyecz](#laszlo-hanyecz), [Wladimir van der Laan](#wladimir-van-der-laan), [Pieter Wuille](#pieter-wuille), [Gregory Maxwell](#gregory-maxwell), [Joseph Poon and Thaddeus Dryja](#joseph-poon-and-thaddeus-dryja)\n\n**Evangelists & beyond:** [Andreas M. Antonopoulos](#andreas-m-antonopoulos), [Roger Ver](#roger-ver), [You ?](#you)\n\n---\n\n## David Chaum\n\n![David Chaum](/images/people/David_Chaum.jpg)\n\n**Contribution:** eCash (1982) - The godfather of cryptocurrency\n\nDavid Chaum is widely regarded as the inventor of digital cash. In 1982, he published \"Blind Signatures for Untraceable Payments,\" introducing the concept of cryptographically secure anonymous payments. His company DigiCash launched eCash in the 1990s, which allowed users to withdraw digital tokens from a bank and spend them anonymously.\n\nWhile eCash ultimately failed commercially (DigiCash went bankrupt in 1998), Chaum's work established the fundamental cryptographic techniques for digital currency, including blind signatures that preserve privacy. His vision of electronic cash that could replicate the anonymity of physical cash directly inspired the cypherpunk movement and later cryptocurrency development.\n\n[More](https://en.wikipedia.org/wiki/David_Chaum)\n\n---\n\n## Eric Hughes\n\n![Eric Hughes](/images/people/Eric-Hughes.jpg)\n\n**Contribution:** \"A Cypherpunk's Manifesto\" (1993) - Privacy through cryptography\n\nEric Hughes is a mathematician and privacy advocate who wrote \"A Cypherpunk's Manifesto\" in 1993, which became one of the foundational documents of the cypherpunk movement. The manifesto articulated that privacy in an open society requires cryptography, not laws or the good intentions of institutions. Along with Timothy C. May and John Gilmore, Hughes co-founded the legendary cypherpunk mailing list where the ideas that would eventually produce Bitcoin were debated and refined.\n\nThe manifesto's principles, that we must defend our own privacy, that cryptography enables anonymous systems, and that we cannot expect governments or corporations to grant privacy, directly shaped the worldview behind Bitcoin. The cypherpunk culture of building tools rather than petitioning authorities found its fullest expression in Satoshi's creation of a peer-to-peer electronic cash system that required no one's permission.\n\n[More](https://en.wikipedia.org/wiki/Eric_Hughes)\n\n---\n\n## Timothy C. May\n\n![Timothy C. May](/images/people/Timothy_May.jpg)\n\n**Contribution:** \"The Crypto Anarchist Manifesto,\" cypherpunk mailing list co-founder\n\nTimothy C. May was an American physicist and writer who authored \"The Crypto Anarchist Manifesto\" (1988) and co-founded the cypherpunk mailing list with Eric Hughes and John Gilmore in 1992. His manifesto envisioned a future where cryptography would enable anonymous markets and transactions beyond the reach of governments, laying the ideological groundwork for digital cash and permissionless systems.\n\nMay's writings foresaw many developments: anonymous digital currencies, reputational systems beyond national borders, and the collision of technology with traditional notions of regulation. The cypherpunk mailing list he helped create became the incubator where Chaum's eCash, Back's Hashcash, and Szabo's Bit Gold were discussed; the same community where Satoshi Nakamoto would later announce Bitcoin. May passed away in 2018.\n\n[More](https://en.wikipedia.org/wiki/Timothy_C._May)\n\n---\n\n## John Gilmore\n\n![John Gilmore](/images/people/John_Gilmore.jpg)\n\n**Contribution:** Cypherpunk mailing list co-founder (1992)\n\nJohn Gilmore is a computer scientist, entrepreneur, and civil-liberties advocate who co-founded the cypherpunk mailing list with Eric Hughes and Timothy C. May in 1992. The list became the main forum where ideas that would eventually produce Bitcoin, including David Chaum's eCash, Adam Back's Hashcash, and Nick Szabo's Bit Gold, were debated. Gilmore also co-founded the Electronic Frontier Foundation (EFF) and Cygnus Solutions; his work on open systems and crypto advocacy helped create the culture in which Satoshi Nakamoto would later publish the Bitcoin whitepaper.\n\n[More](https://en.wikipedia.org/wiki/John_Gilmore_(activist))\n\n---\n\n## Adam Back\n\n![Adam Back](/images/people/Adam_Back.jpg)\n\n**Contribution:** Hashcash (1997) - [Proof-of-Work](/docs/glossary#proof-of-work-pow) for spam prevention\n\nAdam Back is a British cryptographer who invented Hashcash in 1997, a proof-of-work system designed to limit email spam and denial-of-service attacks. The core idea was elegant: require senders to perform computational work before sending an email, making mass spam economically infeasible.\n\nHashcash's proof-of-work mechanism became a critical component of Bitcoin. Satoshi Nakamoto cited Hashcash in the Bitcoin whitepaper, and Bitcoin's mining algorithm is essentially Hashcash applied to transaction validation. Back is one of only two people cited in the Bitcoin whitepaper who are still alive (the other being Wei Dai).\n\nBack is currently CEO of Blockstream, a Bitcoin infrastructure company he co-founded in 2014.\n\n[More](https://en.wikipedia.org/wiki/Adam_Back)\n\n---\n\n## Nick Szabo\n\n![Nick Szabo](/images/people/Nick_Szabo.jpg)\n\n**Contribution:** Bit Gold (1998) - Decentralized digital currency concept\n\nNick Szabo is a computer scientist, legal scholar, and cryptographer who designed Bit Gold in 1998, often called the direct precursor to Bitcoin. Bit Gold proposed a [decentralized](/docs/glossary#decentralization) digital currency where participants would use computational power to solve cryptographic puzzles, with solutions timestamped and published to a distributed registry.\n\nSzabo also coined the term \"smart contracts\" in 1994, describing self-executing contracts with terms written directly into code, a concept that would later become central to Ethereum and other blockchain platforms.\n\nThe similarities between Bit Gold and Bitcoin are so striking that many have speculated Szabo is Satoshi Nakamoto, which he has denied. Regardless, his intellectual contributions to the conceptual foundations of cryptocurrency are undeniable.\n\n[More](https://en.wikipedia.org/wiki/Nick_Szabo)\n\n---\n\n## Wei Dai\n\n![Wei Dai](/images/people/Wei_Dai.jpg)\n\n**Contribution:** b-money (1998) - Digital scarcity and distributed consensus\n\nWei Dai is a computer engineer and cryptographer who proposed b-money in 1998, a theoretical system for an anonymous, distributed electronic cash system. His proposal described two protocols: one where all participants maintain a database of account balances, and another using a subset of participants (similar to modern proof-of-stake).\n\nB-money introduced key concepts that would appear in Bitcoin, including:\n- The creation of money through computational work\n- Verification of work by the community\n- A distributed database of transactions\n- Transfer of money by signing messages\n\nSatoshi Nakamoto cited b-money in the Bitcoin whitepaper and personally emailed Wei Dai before Bitcoin's launch. Dai has noted that Bitcoin's implementation differs from b-money, particularly in how Nakamoto elegantly solved the double-spending problem with the blockchain.\n\nThe smallest subunit of Ether (Ethereum's currency) is called a \"wei\" in his honor.\n\n[More](https://en.wikipedia.org/wiki/Wei_Dai)\n\n---\n\n## Ralph Merkle\n\n![Ralph Merkle](/images/people/Ralph_Merkle.jpg)\n\n**Contribution:** Merkle trees (1979) - Efficient verification of block contents\n\nRalph Merkle is a computer scientist who invented Merkle trees (also called hash trees) in 1979. In this structure, leaf nodes contain hashes of data, and each parent node is the hash of its children, building up to a single root hash. The Bitcoin whitepaper uses this construction to enable compact proofs: [SPV](/docs/glossary#spv-simplified-payment-verification) clients can verify that a transaction is in a block by checking a path from the transaction to the [Merkle root](/docs/glossary#merkle-root) in the block header, without downloading the full block.\n\nMerkle trees are fundamental to Bitcoin's [block](/docs/glossary#block) structure. Every block header includes a Merkle root that commits to all transactions in the block; tampering with any transaction changes the root and breaks the chain. Merkle also contributed to public-key cryptography (Merkle's puzzles) and later to nanotechnology. His 1979 paper \"Protocols for Public Key Cryptosystems\" and the Merkle tree concept are among the cryptographic foundations Satoshi drew on.\n\n[More](https://en.wikipedia.org/wiki/Ralph_Merkle)\n\n---\n\n## Stuart Haber and Scott Stornetta\n\n![Stuart Haber and Scott Stornetta](/images/people/Scott_Stornetta_and_Stuart_Haber.jpg)\n\n**Contribution:** Secure timestamps (1990-91) - \"How to time-stamp a digital document\"\n\nStuart Haber and W. Scott Stornetta are cryptographers who, in a 1991 paper, solved the problem of timestamping digital documents so that they cannot be backdated or tampered with. Their scheme linked each new timestamp to the previous one in a chain, creating a cryptographically secured sequence that could prove the order and existence of records. Satoshi Nakamoto cited their work in the Bitcoin whitepaper as a direct precursor to the blockchain's design.\n\nTheir approach used hash pointers to create an append-only, tamper-evident log. This \"chain of timestamps\" is the conceptual ancestor of Bitcoin's [blockchain](/docs/glossary#blockchain): each block references the previous block's hash, and changing history would require redoing an exponentially growing amount of work. Haber and Stornetta's 1990 paper \"How to Time-Stamp a Digital Document\" and its 1991 follow-up established the core idea that Bitcoin would combine with proof-of-work and digital cash.\n\n[More](https://en.wikipedia.org/wiki/Stuart_Haber)\n\n---\n\n## Satoshi Nakamoto\n\n![Satoshi Nakamoto](/images/people/Satoshi_Nakamoto.jpg)\n\n**Contribution:** Bitcoin (2008-2010) - Creator of Bitcoin\n\nSatoshi Nakamoto is the pseudonymous person or group who created Bitcoin. On October 31, 2008, Nakamoto published the [Bitcoin whitepaper](/whitepaper), \"Bitcoin: A Peer-to-Peer Electronic Cash System.\" On January 3, 2009, they mined the [Genesis Block](/docs/glossary#genesis-block), embedding the message: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.\"\n\nSatoshi was active in developing Bitcoin and communicating on forums until December 2010, when they handed over control to Gavin Andresen and disappeared. Their last known communication was an email in April 2011.\n\nKey facts about Satoshi:\n- Mined an estimated 1 million BTC in early blocks (never moved)\n- True identity remains unknown\n- Communicated only through forums, emails, and code\n- Disappeared without cashing out or claiming credit\n\nThe mystery of Satoshi's identity has become part of Bitcoin's mythos. Various candidates have been proposed, including Nick Szabo, Hal Finney, and others, but none have been confirmed. In 2024, a UK court definitively ruled that Craig Wright is not Satoshi Nakamoto.\n\n[More](https://en.wikipedia.org/wiki/Satoshi_Nakamoto)\n\n---\n\n## Hal Finney\n\n![Hal Finney](/images/people/Hal_Finney.jpg)\n\n**Contribution:** RPOW, PGP 2.0, first Bitcoin transaction recipient\n\nHal Finney was a cryptographic pioneer and one of Bitcoin's most important early contributors. Before Bitcoin, he developed RPOW (Reusable Proofs of Work) in 2004, a system that allowed proof-of-work tokens to be reused as digital cash, building on Adam Back's Hashcash. He was also the lead developer of PGP 2.0 (Pretty Good Privacy), the first widely-used implementation of public key cryptography for email encryption.\n\nFinney was the first person other than Satoshi to run the Bitcoin software, and on January 12, 2009, he received the first Bitcoin transaction: 10 BTC from Satoshi Nakamoto. He immediately began contributing to the codebase, reporting bugs and suggesting improvements. He famously tweeted \"Running bitcoin\" on January 10, 2009.\n\nInterestingly, Finney lived just a few blocks from Dorian Satoshi Nakamoto in Temple City, California, a coincidence that fueled speculation when Dorian was mistakenly identified as Bitcoin's creator by Newsweek in 2014.\n\nFinney was diagnosed with ALS (Lou Gehrig's disease) in 2009 and continued contributing to Bitcoin until his physical limitations made it impossible. He passed away on August 28, 2014, and was cryopreserved by the Alcor Life Extension Foundation.\n\nThe \"Finney attack\" in Bitcoin is named after him: a type of [double-spend](/docs/glossary#double-spend) attack he described where a miner pre-mines a transaction and quickly broadcasts a conflicting one.\n\n[More](https://en.wikipedia.org/wiki/Hal_Finney_(computer_scientist))\n\n---\n\n## Len Sassaman\n\n![Len Sassaman](/images/people/Len_Sassaman.jpg)\n\n**Contribution:** Cypherpunk, anonymous remailer developer\n\nLen Sassaman was a cypherpunk, privacy advocate, and cryptographer who made significant contributions to anonymity and privacy-preserving technologies. He was a core developer of Mixmaster, the most widely-used anonymous remailer protocol, and worked on various cryptographic privacy tools.\n\nSassaman was embedded in the cypherpunk community that would give rise to Bitcoin. He studied under David Chaum and worked with Hal Finney on PGP-related projects. His work on anonymous communication systems directly relates to Bitcoin's privacy goals.\n\nTragically, Sassaman died by suicide on July 3, 2011, just as Bitcoin was gaining mainstream attention. A tribute was encoded into the Bitcoin blockchain at block 138725.\n\nSome have speculated that Sassaman was involved in Bitcoin's creation due to his technical skills, cypherpunk connections, and the timing of his death relative to Satoshi's disappearance, though there is no concrete evidence.\n\n[More](https://en.wikipedia.org/wiki/Len_Sassaman)\n\n---\n\n## Martti Malmi\n\n![Martti Malmi](/images/people/Martti_Malmi.jpg)\n\n**Contribution:** Early contributor (2009-11) - bitcoin.org, first exchange and community tools\n\nMartti Malmi (known online as Sirius) was one of Bitcoin's first contributors after Satoshi Nakamoto and Hal Finney. He began collaborating with Satoshi in 2009, helping to run and design bitcoin.org, implement an early, simple exchange, and build the first Bitcoin forum. Malmi wrote much of the early, user-facing infrastructure that allowed new users to learn about and obtain Bitcoin.\n\nHis work bridged the gap between Satoshi's protocol and the broader world: he made the project accessible, documented it, and created spaces for discussion. Malmi has described his communication with Satoshi as frequent and substantive during 2009â€“2010. He stepped back from active development in 2011. His contributions, though less celebrated than those of the protocol designers, were essential to Bitcoin's earliest adoption and community formation.\n\n[More](https://en.wikipedia.org/wiki/Martti_Malmi)\n\n---\n\n## Gavin Andresen\n\n![Gavin Andresen](/images/people/Gavin_Andresen.jpg)\n\n**Contribution:** Lead developer after Satoshi (2010-2014)\n\nGavin Andresen is a software developer who became the lead maintainer of Bitcoin's code after Satoshi Nakamoto's departure. In late 2010, Satoshi emailed Andresen: \"I've moved on to other things,\" and handed him access to the codebase and the project's alert key.\n\nAndresen was instrumental in Bitcoin's early development and professionalization. He:\n- Founded the Bitcoin Foundation in 2012\n- Advocated for Bitcoin in mainstream and government settings\n- Grew the core development team\n- Managed the transition from a one-person project to an open-source community\n\nHis role diminished after 2014, particularly following the blocksize debate and his controversial endorsement of Craig Wright's claim to be Satoshi in 2016 (which Andresen later said he was \"bamboozled\" about).\n\n[More](https://en.wikipedia.org/wiki/Gavin_Andresen)\n\n---\n\n## Laszlo Hanyecz\n\n![Laszlo Hanyecz](/images/people/Laszlo_Hanyecz.jpg)\n\n**Contribution:** First documented real-world Bitcoin transaction (May 2010) - \"Bitcoin pizza\"\n\nLaszlo Hanyecz is a programmer who, on May 22, 2010, completed the first known commercial transaction using Bitcoin: he paid 10,000 BTC for two pizzas delivered to his home in Florida. The deal was arranged on the Bitcointalk forum, where Hanyecz had offered to pay BTC for pizza delivery. A participant in the UK ordered the pizzas; Hanyecz sent the bitcoin. The exchange proved that Bitcoin could be used as a medium of exchange for real goods and services.\n\nThe \"Bitcoin pizza\" has become a celebrated moment in Bitcoin's history (May 22 is sometimes observed as Bitcoin Pizza Day) and a reminder of Bitcoin's early, experimental use. At later prices, those 10,000 BTC would be worth hundreds of millions of dollars; at the time, they were a fair price for two pizzas and a historic proof of concept. Hanyecz continued contributing to Bitcoin, including work on the GPU mining software that would precede [ASIC](/docs/glossary#asic-application-specific-integrated-circuit) miners.\n\n[More](https://en.wikipedia.org/wiki/Laszlo_Hanyecz)\n\n---\n\n## Wladimir van der Laan\n\n![Wladimir van der Laan](/images/people/Wladimir_Laan.jpg)\n\n**Contribution:** Bitcoin Core lead maintainer (2014-2021)\n\nWladimir van der Laan is a software developer who served as the lead maintainer of [Bitcoin Core](/docs/glossary#bitcoin-core) from 2014 to 2021. He took over the role from Gavin Andresen during a turbulent period that included the [blocksize wars](/docs/controversies/blocksize-wars), the intense debate over whether to increase Bitcoin's block size limit. Van der Laan maintained the Bitcoin Core repository, integrated contributions from a growing developer community, and shepherded the project through the activation of [SegWit](/docs/bitcoin/segwit) in 2017.\n\nHis tenure saw Bitcoin Core evolve from a smaller team into a distributed, open-source project with many regular contributors. Van der Laan emphasized process, review, and conservative change, values that have come to define Bitcoin's development culture. He stepped down as lead maintainer in 2021; the role has since been shared among several maintainers in a further decentralization of project stewardship.\n\n[More](https://en.wikipedia.org/wiki/Wladimir_van_der_Laan)\n\n\n---\n\n## Pieter Wuille\n\n![Pieter Wuille](/images/people/Pieter_Wuille.jpg)\n\n**Contribution:** SegWit (BIP 141), Taproot (BIP 340-342), libsecp256k1\n\nPieter Wuille is a Belgian software engineer and one of the most influential Bitcoin protocol developers. He is the primary author of [SegWit](/docs/bitcoin/segwit) (BIP 141), activated in 2017, which separated signature data from transaction data in the [block](/docs/glossary#block) structure, fixing [transaction malleability](/docs/bitcoin/transaction-malleability) and enabling second-layer protocols. He also co-designed [Taproot](/docs/bitcoin/taproot) (BIPs 340, 341, 342), Bitcoin's 2021 upgrade that introduced Schnorr signatures, [MAST](/docs/glossary#mast-merkle-abstract-syntax-tree), and improved privacy and flexibility for smart contracts.\n\nWuille created and maintains libsecp256k1, the cryptographic library used by Bitcoin Core for [elliptic curve](/docs/bitcoin/cryptography) operations, faster and more secure than generic crypto libraries. His work has shaped the security, scalability, and expressiveness of the Bitcoin protocol. He is a co-founder of Blockstream and remains an active Bitcoin Core contributor.\n\n[More](https://en.wikipedia.org/wiki/Pieter_Wuille)\n\n---\n\n## Gregory Maxwell\n\n![Gregory Maxwell](/images/people/Gregory_Maxwell.jpg)\n\n**Contribution:** Bitcoin Core developer, Blockstream co-founder, [CoinJoin](/docs/glossary#coinjoin), Confidential Transactions, [Sidechains](/docs/glossary#sidechain)\n\nGregory Maxwell (Greg) is a Bitcoin Core developer and one of the most influential protocol and privacy researchers in Bitcoin. He co-founded Blockstream in 2014 and has authored or co-authored numerous BIPs and designs, including work on [CoinJoin](/docs/glossary#coinjoin) (which improved the blind-signature-based mixers that preceded it), Confidential Transactions (CT), and the sidechain concept. He was a central voice in the [blocksize wars](/docs/controversies/blocksize-wars), arguing for [Layer 2](/docs/glossary#layer-2) scaling and against raising the block size limit. His advocacy for [SegWit](/docs/glossary#segwit-segregated-witness) and for a conservative, [decentralization](/docs/glossary#decentralization)-focused approach to scaling helped shape Bitcoin's current direction.\n\n[More](https://en.wikipedia.org/wiki/Gregory_Maxwell)\n\n---\n\n## Joseph Poon and Thaddeus Dryja\n\n![Joseph Poon and Thaddeus Dryja](/images/people/Poon_Dryja.jpg)\n\n**Contribution:** [Lightning Network](/docs/glossary#lightning-network) whitepaper (2015)\n\nJoseph Poon and Thaddeus Dryja authored \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments\" (2015), which described a second-layer network of payment channels that would allow fast, low-cost transactions without recording every payment on the [blockchain](/docs/glossary#blockchain). The design built on [HTLCs](/docs/glossary#htlc-hash-time-locked-contract), [time locks](/docs/glossary#time-lock), and [SegWit](/docs/glossary#segwit-segregated-witness) (which was still under debate) to fix [transaction malleability](/docs/glossary#transaction-malleability) and enable bi-directional channels. The Lightning Network, as specified in the [BOLT](/docs/glossary#bolt-basis-of-lightning-technology) documents and implemented by LND, Core Lightning, Eclair, and others, is the main [Layer 2](/docs/glossary#layer-2) for Bitcoin and is directly rooted in their whitepaper.\n\n[More](https://lightning.network/lightning-network-paper.pdf) (whitepaper)\n\n---\n\n## Andreas M. Antonopoulos\n\n![Andreas Antonopoulos](/images/people/Andreas_Antonopoulos.jpg)\n\n**Contribution:** Author, educator, Bitcoin evangelist\n\nAndreas M. Antonopoulos is a Greek-British author, speaker, and educator who has become one of the most influential voices in Bitcoin and blockchain education. He is best known for his book \"Mastering Bitcoin\" (2014), a detailed technical guide that has become the standard reference for Bitcoin developers.\n\nHis other works include:\n- \"The Internet of Money\" series (collected talks)\n- \"Mastering Ethereum\" (2018)\n- \"Mastering the Lightning Network\" (2021)\n\nAntonopoulos is known for his ability to explain complex technical concepts to general audiences. His YouTube channel and speaking engagements have introduced millions of people to Bitcoin. He has testified before government bodies and advocated for cryptocurrency-friendly policies.\n\nIn 2017, after it was revealed he had not held significant Bitcoin despite years of advocacy, the Bitcoin community donated over 100 BTC to him in appreciation of his educational contributions.\n\n[More](https://en.wikipedia.org/wiki/Andreas_Antonopoulos)\n\n---\n\n## Roger Ver\n\n![Roger Ver](/images/people/Roger_Ver.jpg)\n\n**Contribution:** Early investor, \"Bitcoin Jesus,\" Bitcoin Cash advocate\n\nRoger Ver is an early Bitcoin investor and promoter who became known as \"Bitcoin Jesus\" for his advocacy and funding of Bitcoin-related projects and businesses. He was an outspoken supporter of increasing Bitcoin's block size and, during the [blocksize wars](/docs/controversies/blocksize-wars), backed alternative implementations and the hard fork that created Bitcoin Cash (BCH) in August 2017. His shift from promoting Bitcoin (BTC) to Bitcoin Cash made him a polarizing figure. Understanding his role is part of understanding the scaling debate, the philosophy of on-chain vs. [Layer 2](/docs/glossary#layer-2) scaling, and the fact that Bitcoin has no single leader: divergent views can lead to [forks](/docs/glossary#fork) rather than forced changes to the main chain.\n\n[More](https://en.wikipedia.org/wiki/Roger_Ver)\n\n---\n\n## You ?\n\n![You](/images/people/Anon.jpg)\n\n**Contribution:** The future of Bitcoin - Your story is still being written\n\nThe pioneers on this page laid the groundwork, but Bitcoin's true potential will be realized by the collective efforts of its global community. Whether you're building infrastructure, creating applications, educating others, or simply using Bitcoin as peer-to-peer electronic cash, you are part of this ongoing experiment in decentralized money.\n\nThe question is not whether you can be a Bitcoin pioneer. It's what kind of pioneer you will choose to be.\n",
    "filename": "people.md"
  },
  "/docs/history/halvings": {
    "content": "# Bitcoin Halving Schedule\n\nBitcoin's [block reward](/docs/glossary#block-reward) halves every 210,000 blocks, which occurs approximately every 4 years. This creates a predictable, decreasing inflation rate and ensures the total supply will never exceed 21 million BTC.\n\n## Supply Formula\n\nThe total Bitcoin supply follows a geometric series:\n\n```\nTotal Supply = 210,000 Ã— 50 Ã— (1 + 1/2 + 1/4 + 1/8 + ...)\n             = 210,000 Ã— 50 Ã— 2\n             = 21,000,000 BTC\n```\n\nThis geometric series ensures that:\n- Each [halving](/docs/glossary#halving) period creates 210,000 blocks\n- Each period creates half the Bitcoin of the previous period\n- The series converges to exactly 21 million BTC\n- After 32 halvings, the subsidy becomes effectively 0\n\n---\n\n## Complete Halving Schedule\n\n| Event | Date | Block Height | Block Reward (BTC) | Total BTC Created in Period |\n|-------|------|--------------|-------------------|----------------------------|\n| **Bitcoin Launch** | 3 January 2009 | 0 (genesis block) | 50 | 10,500,000 BTC |\n| **Halving 1** | 28 November 2012 | 210,000 | 25 | 5,250,000 BTC |\n| **Halving 2** | 9 July 2016 | 420,000 | 12.5 | 2,625,000 BTC |\n| **Halving 3** | 11 May 2020 | 630,000 | 6.25 | 1,312,500 BTC |\n| **Halving 4** | 20 April 2024 | 840,000 | 3.125 | 656,250 BTC |\n| **Halving 5** | ~2028 | 1,050,000 | 1.5625 | 328,125 BTC |\n| **Halving 6** | ~2032 | 1,260,000 | 0.78125 | 164,062.5 BTC |\n| **Halving 7** | ~2036 | 1,470,000 | 0.390625 | 82,031.25 BTC |\n| **Halving 8** | ~2040 | 1,680,000 | 0.1953125 | 41,015.625 BTC |\n| **Halving 9** | ~2044 | 1,890,000 | 0.09765625 | 20,507.8125 BTC |\n| **Halving 10** | ~2048 | 2,100,000 | 0.048828125 | 10,253.90625 BTC |\n| **Halving 11** | ~2052 | 2,310,000 | 0.0244140625 | 5,126.953125 BTC |\n| **Halving 12** | ~2056 | 2,520,000 | 0.01220703125 | 2,563.4765625 BTC |\n| **Halving 13** | ~2060 | 2,730,000 | 0.006103515625 | 1,281.73828125 BTC |\n| **Halving 14** | ~2064 | 2,940,000 | 0.0030517578125 | 640.869140625 BTC |\n| **Halving 15** | ~2068 | 3,150,000 | 0.00152587890625 | 320.4345703125 BTC |\n| **Halving 16** | ~2072 | 3,360,000 | 0.000762939453125 | 160.21728515625 BTC |\n| **Halving 17** | ~2076 | 3,570,000 | 0.0003814697265625 | 80.108642578125 BTC |\n| **Halving 18** | ~2080 | 3,780,000 | 0.00019073486328125 | 40.0543212890625 BTC |\n| **Halving 19** | ~2084 | 3,990,000 | 0.000095367431640625 | 20.02716064453125 BTC |\n| **Halving 20** | ~2088 | 4,200,000 | 0.0000476837158203125 | 10.013580322265625 BTC |\n| **Halving 21** | ~2092 | 4,410,000 | 0.00002384185791015625 | 5.0067901611328125 BTC |\n| **Halving 22** | ~2096 | 4,620,000 | 0.000011920928955078125 | 2.50339508056640625 BTC |\n| **Halving 23** | ~2100 | 4,830,000 | 0.0000059604644775390625 | 1.251697540283203125 BTC |\n| **Halving 24** | ~2104 | 5,040,000 | 0.00000298023223876953125 | 0.6258487701416015625 BTC |\n| **Halving 25** | ~2108 | 5,250,000 | 0.000001490116119384765625 | 0.31292438507080078125 BTC |\n| **Halving 26** | ~2112 | 5,460,000 | 0.0000007450580596923828125 | 0.156462192535400390625 BTC |\n| **Halving 27** | ~2116 | 5,670,000 | 0.00000037252902984619140625 | 0.0782310962677001953125 BTC |\n| **Halving 28** | ~2120 | 5,880,000 | 0.000000186264514923095703125 | 0.03911554813385009765625 BTC |\n| **Halving 29** | ~2124 | 6,090,000 | 0.0000000931322574615478515625 | 0.019557774066925048828125 BTC |\n| **Halving 30** | ~2128 | 6,300,000 | 0.00000004656612873077392578125 | 0.0097788870334625244140625 BTC |\n| **Halving 31** | ~2132 | 6,510,000 | 0.000000023283064365386962890625 | 0.00488944351673126220703125 BTC |\n| **Halving 32** | ~2136 | 6,720,000 | 0.0000000116415321826934814453125 | 0.002444721758365631103515625 BTC |\n| **Halving 33+** | After 2140 | After 6,930,000 | 0 BTC | 0 BTC |\n\n**Note**: After halving 33, the subsidy becomes effectively 0 (less than 1 [satoshi](/docs/glossary#sat-satoshi) per block). The last Bitcoin will be mined around December 22, 2137.\n\n---\n\n## Key Facts\n\n- **Total Supply**: Exactly 21,000,000 BTC\n- **Total Halvings**: 32 halving events\n- **Halving Interval**: Every 210,000 blocks (~4 years)\n- **Initial Block Reward**: 50 BTC per block\n- **Current Block Reward**: 3.125 BTC (after 4th halving in 2024)\n- **Final Halving**: Block 6,720,000 (halving #32)\n- **Block Height at Completion**: ~6,930,000\n- **All Coins Issued**: December 22, 2137 (estimated)\n\n---\n\n## After All Coins Are Issued\n\nOnce all 21 million Bitcoin have been created (around December 22, 2137):\n\n- **No New Bitcoin**: Block rewards will be 0\n- **Miner Income**: Miners will rely entirely on [transaction fees](/docs/glossary#transaction-fee)\n- **Network Security**: Economic incentives remain through fee collection\n- **Inflation**: Bitcoin becomes deflationary (supply decreases if coins are lost)\n\n---\n\n## Related Topics\n\n- [Subsidy Equation](/docs/bitcoin/subsidy) - Mathematical formula and implementation details\n",
    "filename": "halvings.md"
  },
  "/docs/history/forks": {
    "content": "# Forks History\n\nBitcoin has undergone several protocol upgrades through both soft forks and hard forks. This document provides a table of all major forks in Bitcoin's history.\n\n## Understanding Forks\n\nThe fundamental difference between soft forks and hard forks comes down to one thing: **are the [consensus rules](/docs/glossary#consensus-rules) being tightened or loosened?**\n\n| | Soft Fork | Hard Fork |\n|---|-----------|-----------|\n| **Consensus rules** | Tightened (more restrictive) | Loosened (more permissive) |\n| **Old nodes** | Accept new blocks (still valid under old rules) | Reject new blocks (invalid under old rules) |\n| **Backward compatible** | Yes | No |\n| **Chain split risk** | Possible if contentious | Guaranteed without full upgrade |\n\n### Soft Fork\nA **soft fork** **tightens** the consensus rules. Blocks valid under new rules are always valid under old rules, so old nodes continue to accept them.\n\n**Example**: [SegWit](/docs/glossary#segwit-segregated-witness) made certain transaction formats invalid that were previously valid. Old nodes still accept SegWit blocks because they don't violate the old (looser) rules.\n\n**Can soft forks cause chain splits?** Yes, in certain scenarios:\n- **UASF (User Activated Soft Fork)**: If nodes enforce rules that miners don't follow, the chain can split. The 2017 BIP 148 UASF threatened a split if miners didn't signal for SegWit.\n- **Miner non-compliance**: If significant mining power produces blocks violating new soft fork rules, upgraded nodes reject those blocks, potentially causing a split.\n- **Contentious activation**: When there's community disagreement about whether to activate.\n\n### Hard Fork\nA **hard fork** **loosens** the consensus rules (or changes them incompatibly). Blocks valid under new rules may be invalid under old rules, so old nodes reject them.\n\n**Example**: Bitcoin Cash increased the [block size](/docs/glossary#block-size) limit from 1 MB to 8 MB. Old nodes reject these larger blocks as invalid, guaranteeing a chain split.\n\n---\n\n## Complete Fork History Table\n\n| Date | Block Height | Type | Name | BIP(s) | Description | Status |\n|------|--------------|------|------|--------|-------------|--------|\n| **2009-01-03** | 0 | - | Genesis Block | - | Bitcoin network launch | Active |\n| **2010-08-15** | 74,638 | Hard Fork | Value Overflow Incident | - | Fixed integer overflow bug | Resolved |\n| **2012-04-01** | 173,805 | Soft Fork | P2SH (Pay-to-Script-Hash) | [BIP 16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki) | Enabled complex scripts via script hashes | Active |\n| **2013-03-11** | 225,430 | Accidental | BerkeleyDB Fork | - | Database lock limit caused chain split | Resolved |\n| **2013-03-12** | 225,430 | Soft Fork | Strict DER Encoding | [BIP 66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki) | Required strict DER signature encoding | Active |\n| **2013-05-15** | 250,000 | Soft Fork | Strict Multisig | [BIP 65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki) | Required NULLDUMMY in multisig | Active |\n| **2015-12-08** | 388,381 | Soft Fork | CLTV (CheckLockTimeVerify) | [BIP 65](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki) | Enabled absolute time locks | Active |\n| **2016-07-04** | 419,328 | Soft Fork | CSV (CheckSequenceVerify) | [BIP 112](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki), [BIP 68](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki), [BIP 113](https://github.com/bitcoin/bips/blob/master/bip-0113.mediawiki) | Enabled relative time locks | Active |\n| **2017-08-01** | 478,558 | Hard Fork | Bitcoin Cash | - | Increased block size to 8 MB | Split Chain |\n| **2017-08-24** | 481,824 | Soft Fork | Segregated Witness (SegWit) | [BIP 141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki), [BIP 143](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki), [BIP 144](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki), [BIP 148](https://github.com/bitcoin/bips/blob/master/bip-0148.mediawiki) | Separated witness data, fixed malleability | Active |\n| **2018-11-15** | 556,766 | Hard Fork | Bitcoin SV | - | Bitcoin Cash fork, increased to 128 MB blocks | Split Chain |\n| **2021-11-14** | 709,632 | Soft Fork | Taproot | [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki), [BIP 342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki), [BIP 340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) | Schnorr signatures, improved privacy | Active |\n\n---\n\n## Activation Mechanisms\n\n### Soft Fork Activation Methods\n\n1. **BIP 9 (Version Bits)**\n   - Used for: CSV, SegWit, Taproot\n   - Requires: 95% of blocks signal support\n   - Grace period: 2016 blocks (~2 weeks)\n   - Example: Taproot activated via BIP 9\n\n2. **IsSuperMajority (Legacy)**\n   - Used for: P2SH, CLTV\n   - Requires: 75% of last 1000 blocks\n   - Example: P2SH activated via IsSuperMajority\n\n3. **User-Activated Soft Fork (UASF)**\n   - Used for: SegWit (BIP 148)\n   - Community-driven activation\n   - Example: SegWit UASF movement\n\n### Hard Fork Activation\n\nHard forks typically require:\n- All nodes to upgrade simultaneously\n- Or acceptance of chain split\n- Coordination among miners and nodes\n\n---\n\n## Fork Statistics\n\n### Soft Fork Adoption\n\n| Fork | Activation Date | Current Usage | Adoption Rate |\n|------|----------------|--------------|---------------|\n| P2SH | 2012-04-01 | Multisig, complex scripts | ~15-20% of transactions |\n| CLTV | 2015-12-08 | Time locks, escrow | ~1-2% of transactions |\n| CSV | 2016-07-04 | Lightning Network | Critical for LN |\n| SegWit | 2017-08-24 | Most transactions | ~80% of transactions |\n| Taproot | 2021-11-14 | Modern wallets | ~5-10% of transactions |\n\n### Hard Fork Results\n\n| Fork | Original Chain | New Chain | Current Status |\n|------|----------------|-----------|----------------|\n| Bitcoin Cash | Bitcoin (BTC) | Bitcoin Cash (BCH) | Both chains active |\n| Bitcoin SV | Bitcoin Cash (BCH) | Bitcoin SV (BSV) | Both chains active |\n\n---\n\n## Timeline Visualization\n\n```\n2009 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Genesis Block\n     â”‚\n2010 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Value Overflow Fix (Hard Fork)\n     â”‚\n2012 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ P2SH (Soft Fork)\n     â”‚\n2013 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ BerkeleyDB Fork (Accidental)\n     â”‚ Strict DER, Strict Multisig (Soft Forks)\n     â”‚\n2015 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ CLTV (Soft Fork)\n     â”‚\n2016 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ CSV (Soft Fork)\n     â”‚\n2017 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Bitcoin Cash (Hard Fork) â”€â”€â–º BCH\n     â”‚ SegWit (Soft Fork)\n     â”‚\n2018 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Bitcoin SV (Hard Fork) â”€â”€â–º BSV\n     â”‚\n2021 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Taproot (Soft Fork)\n     â”‚\n2024+ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     â”‚ Future upgrades...\n```\n\n---\n\n## Key Takeaways\n\n1. **Soft Forks are Preferred**: All major protocol upgrades since 2012 have been soft forks\n2. **Backward Compatibility**: Soft forks maintain backward compatibility with old nodes\n3. **Chain Splits**: Hard forks always create splits; soft forks can also split the chain if contentious (e.g., via UASF)\n4. **Activation Methods**: Different activation mechanisms (BIP 9, IsSuperMajority, UASF) with varying risks\n5. **Gradual Adoption**: New features take time to reach full adoption\n\n---\n\n## Potential Future Soft Forks\n\n- **Covenants**: Restrict how coins can be spent\n- **OP_CTV (CheckTemplateVerify)**: Transaction templates\n- **SIGHASH_ANYPREVOUT**: More flexible signature types\n- **Ephemeral Anchors**: Lightning Network improvements\n\nFor more details on script types and their evolution, see [Script System](/docs/bitcoin/script).\n\n---\n\n## References\n\n- [Bitcoin BIPs Repository](https://github.com/bitcoin/bips)\n- [Bitcoin Core Release Notes](https://bitcoincore.org/en/releases/)\n- [Bitcoin Wiki - Forks](https://en.bitcoin.it/wiki/Forks)\n- [UASF (User-Activated Soft Fork) History](https://en.bitcoin.it/wiki/UASF)\n",
    "filename": "forks.md"
  },
  "/docs/history/bips": {
    "content": "# Bitcoin Improvement Proposals (BIPs)\n\nBitcoin Improvement Proposals are the formal mechanism for proposing changes to Bitcoin. They document design decisions, protocol upgrades, and best practices for the Bitcoin ecosystem. BIPs are modeled after Python Enhancement Proposals (PEPs) and were introduced by Amir Taaki in 2011.\n\n## BIP Types\n\n| Type | Description | Examples |\n|------|-------------|----------|\n| **Standards Track** | Changes to the network protocol, transaction validity, or interoperability | BIP 141 (SegWit), BIP 341 (Taproot) |\n| **Informational** | Design issues, guidelines, or general information | BIP 2 (BIP Process) |\n| **Process** | Changes to the BIP process itself | BIP 1, BIP 2 |\n\n---\n\n## Consensus & Protocol BIPs\n\nThese BIPs define changes to the Bitcoin consensus rules and protocol.\n\n### BIP 9 - Version Bits with Timeout and Delay\n\n- **Status**: Final\n- **Activated**: 2016\n- **Description**: Mechanism for deploying [soft forks](/docs/glossary#soft-fork) using version bits in block headers. Allows multiple soft forks to be deployed in parallel with defined activation thresholds and timeouts.\n- **Key Concepts**: Miners signal readiness by setting bits in block version field. Activation requires 95% of blocks in a retarget period.\n\n### BIP 16 - Pay to Script Hash ([P2SH](/docs/glossary#p2sh-pay-to-script-hash))\n\n- **Status**: Final\n- **Activated**: April 1, 2012 (Block 173,805)\n- **Description**: Allows transactions to be sent to a [script](/docs/glossary#script) hash instead of a [public key](/docs/glossary#public-key) hash. The actual script is revealed only when spending.\n- **Impact**: Enabled [multisig](/docs/glossary#multisig-multi-signature) wallets, complex scripts, and reduced transaction sizes for senders.\n\n### BIP 34 - Block v2, Height in Coinbase\n\n- **Status**: Final\n- **Activated**: March 2013 (Block 227,931)\n- **Description**: Requires [block height](/docs/glossary#block-height) to be included in [coinbase transaction](/docs/glossary#coinbase-transaction). Ensures all coinbase transactions are unique.\n- **Impact**: Fixed duplicate transaction issue, enabled merged mining.\n\n### BIP 65 - OP_CHECKLOCKTIMEVERIFY ([CLTV](/docs/glossary#cltv-checklocktimeverify))\n\n- **Status**: Final\n- **Activated**: December 2015 (Block 388,381)\n- **Description**: Adds an [opcode](/docs/glossary#opcode) that allows a transaction [output](/docs/glossary#output) to be made unspendable until a specific block height or time.\n- **Use Cases**: Payment channels, escrow, [time-locked](/docs/glossary#time-lock) contracts, inheritance planning.\n\n### BIP 66 - Strict DER Signatures\n\n- **Status**: Final\n- **Activated**: July 2015 (Block 363,724)\n- **Description**: Requires all [ECDSA](/docs/glossary#ecdsa-elliptic-curve-digital-signature-algorithm) signatures to use strict DER encoding. Fixed signature malleability issues.\n- **Impact**: Security improvement, prerequisite for [SegWit](/docs/glossary#segwit-segregated-witness).\n\n### BIP 68 - Relative Lock-Time Using Consensus-Enforced Sequence Numbers\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Enables [relative time locks](/docs/glossary#relative-time-lock) based on the age of the referenced output. Uses the sequence field of transaction [inputs](/docs/glossary#input).\n- **Use Cases**: [Lightning Network](/docs/glossary#lightning-network) channels, bidirectional payment channels, revocable transactions.\n\n### BIP 112 - OP_CHECKSEQUENCEVERIFY ([CSV](/docs/glossary#csv-checksequenceverify))\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Companion to BIP 68. Adds an opcode to verify relative lock-times in scripts.\n- **Use Cases**: Lightning Network, revocable sequences, [hash time-locked contracts (HTLCs)](/docs/glossary#htlc-hash-time-locked-contract).\n\n### BIP 113 - Median Time-Past as Endpoint for Lock-Time Calculations\n\n- **Status**: Final\n- **Activated**: July 2016 (Block 419,328)\n- **Description**: Uses median time of past 11 blocks instead of block timestamp for time-based lock calculations. Prevents miners from manipulating timestamps.\n\n### BIP 141 - Segregated Witness (SegWit)\n\n- **Status**: Final\n- **Activated**: August 24, 2017 (Block 481,824)\n- **Description**: Major protocol upgrade that separates signature ([witness](/docs/glossary#witness)) data from transaction data. Fixes [transaction malleability](/docs/glossary#transaction-malleability), increases effective block capacity.\n- **Impact**: ~4MB effective block size, enabled Lightning Network, reduced fees for SegWit transactions.\n\n### BIP 143 - Transaction Signature Verification for Version 0 Witness Program\n\n- **Status**: Final\n- **Activated**: August 2017 (with SegWit)\n- **Description**: Defines how signatures are computed for SegWit transactions. Fixes quadratic hashing problem.\n- **Impact**: Improved performance for large transactions, security improvements.\n\n### BIP 144 - Segregated Witness (Peer Services)\n\n- **Status**: Final\n- **Activated**: August 2017 (with SegWit)\n- **Description**: Defines how SegWit transactions are transmitted over the network. New message types for witness data.\n\n### BIP 340 - [Schnorr Signatures](/docs/glossary#schnorr-signature) for secp256k1\n\n- **Status**: Final\n- **Activated**: November 14, 2021 (Block 709,632, with [Taproot](/docs/glossary#taproot))\n- **Description**: Introduces Schnorr signatures to Bitcoin. More efficient and enables signature aggregation.\n- **Benefits**: Smaller signatures, batch verification, key aggregation ([MuSig](/docs/glossary#musig)), improved privacy.\n\n### BIP 341 - Taproot: SegWit Version 1 Spending Rules\n\n- **Status**: Final\n- **Activated**: November 14, 2021 (Block 709,632)\n- **Description**: Major upgrade introducing Taproot outputs. Combines Schnorr signatures with [MAST](/docs/glossary#mast-merkle-abstract-syntax-tree) (Merkle Abstract Syntax Trees).\n- **Impact**: Better privacy (all transactions look similar), lower fees, more flexible smart contracts.\n\n### BIP 342 - Validation of Taproot Scripts\n\n- **Status**: Final\n- **Activated**: November 2021 (with Taproot)\n- **Description**: Defines script validation rules for Taproot. Introduces Tapscript with new opcodes and resource limits.\n\n---\n\n## Wallet & Key Management BIPs\n\nThese BIPs define standards for wallets, key derivation, and seed phrases.\n\n### BIP 32 - [Hierarchical Deterministic Wallets](/docs/glossary#hd-wallet-hierarchical-deterministic-wallet)\n\n- **Status**: Final\n- **Year**: 2012\n- **Description**: Defines HD wallets that generate a tree of keys from a single seed. Allows unlimited key generation and easy backup.\n- **Impact**: Foundation for modern wallet architecture. One [seed phrase](/docs/glossary#seed-phrase) backs up all keys.\n\n### BIP 39 - Mnemonic Code for Generating Deterministic Keys\n\n- **Status**: Proposed (widely adopted)\n- **Year**: 2013\n- **Description**: Defines the 12/24-word seed phrases used to backup wallets. Maps entropy to human-readable words.\n- **Word Lists**: 2048 words in multiple languages. English word list is most common.\n- **Security**: 12 words = 128 bits entropy, 24 words = 256 bits entropy.\n\n### BIP 44 - Multi-Account Hierarchy for Deterministic Wallets\n\n- **Status**: Proposed (widely adopted)\n- **Year**: 2014\n- **Description**: Defines the [derivation path](/docs/glossary#derivation-path) structure for HD wallets: `m/purpose'/coin_type'/account'/change/address_index`\n- **Path Example**: `m/44'/0'/0'/0/0` for first Bitcoin [address](/docs/glossary#address).\n\n### BIP 49 - Derivation Scheme for P2WPKH-nested-in-P2SH Addresses\n\n- **Status**: Final\n- **Year**: 2016\n- **Description**: Defines derivation paths for wrapped SegWit addresses (starting with `3`).\n- **Path**: `m/49'/0'/account'/change/address_index`\n\n### BIP 84 - Derivation Scheme for P2WPKH Based Accounts\n\n- **Status**: Proposed\n- **Year**: 2017\n- **Description**: Defines derivation paths for native SegWit addresses (starting with `bc1q`).\n- **Path**: `m/84'/0'/account'/change/address_index`\n\n### BIP 86 - Key Derivation for Single Key P2TR Outputs\n\n- **Status**: Proposed\n- **Year**: 2021\n- **Description**: Defines derivation paths for Taproot addresses (starting with `bc1p`).\n- **Path**: `m/86'/0'/account'/change/address_index`\n\n### BIP 174 - [Partially Signed Bitcoin Transactions (PSBT)](/docs/glossary#psbt-partially-signed-bitcoin-transaction)\n\n- **Status**: Proposed\n- **Year**: 2017\n- **Description**: Standard format for unsigned/partially signed transactions. Enables signing across multiple devices/wallets.\n- **Use Cases**: Hardware wallets, multisig coordination, air-gapped signing.\n\n### BIP 370 - PSBT Version 2\n\n- **Status**: Proposed\n- **Year**: 2021\n- **Description**: Improved PSBT format with better support for adding inputs/outputs during signing process.\n\n---\n\n## Address Format BIPs\n\nThese BIPs define Bitcoin address formats and encoding.\n\n### BIP 13 - Address Format for pay-to-script-hash\n\n- **Status**: Final\n- **Year**: 2012\n- **Description**: Defines P2SH address format. Addresses start with `3` on mainnet.\n\n### BIP 173 - Base32 Address Format for Native v0-16 Witness Outputs ([Bech32](/docs/glossary#bech32))\n\n- **Status**: Final\n- **Year**: 2017\n- **Description**: Defines Bech32 encoding for SegWit addresses. Addresses start with `bc1q` on [mainnet](/docs/glossary#mainnet).\n- **Benefits**: Error detection, all lowercase, more efficient QR codes.\n\n### BIP 350 - Bech32m Format for v1+ Witness Addresses\n\n- **Status**: Final\n- **Year**: 2020\n- **Description**: Modified Bech32 encoding for Taproot and future witness versions. Fixes a mutation weakness in Bech32.\n- **Format**: Taproot addresses start with `bc1p`.\n\n---\n\n## Transaction & Script BIPs\n\n### BIP 125 - Opt-in Full [Replace-by-Fee](/docs/glossary#rbf-replace-by-fee) Signaling\n\n- **Status**: Proposed\n- **Year**: 2015\n- **Description**: Allows transactions to signal replaceability. Enables [fee bumping](/docs/glossary#fee-bumping) by replacing unconfirmed transactions.\n- **Signaling**: Set sequence number < 0xFFFFFFFE on any input.\n\n### BIP 152 - [Compact Block](/docs/glossary#compact-block) Relay\n\n- **Status**: Final\n- **Year**: 2016\n- **Description**: Reduces bandwidth for block [propagation](/docs/glossary#propagation). Nodes share short transaction IDs instead of full transactions.\n- **Impact**: Faster block propagation, reduced bandwidth by ~90%.\n\n---\n\n## Lightning Network Related BIPs\n\n### BIP 118 - SIGHASH_ANYPREVOUT for Tapscript\n\n- **Status**: Draft\n- **Description**: New sighash type that allows signatures to apply to any input with the same script. Enables Eltoo payment channels.\n- **Impact**: Would simplify Lightning channel updates, enable channel factories.\n\n---\n\n## Informational BIPs\n\n### BIP 1 - BIP Purpose and Guidelines\n\n- **Status**: Active\n- **Year**: 2011\n- **Description**: Defines what BIPs are and the process for creating them.\n\n### BIP 2 - BIP Process, Revised\n\n- **Status**: Active\n- **Year**: 2016\n- **Description**: Updated BIP process with clearer status definitions and workflow.\n\n---\n\n## Complete BIP Categories Reference\n\n| Category | Key BIPs | Purpose |\n|----------|----------|---------|\n| **Consensus** | 9, 16, 34, 65, 66, 68, 112, 113, 141, 340, 341, 342 | Protocol rules |\n| **Wallet** | 32, 39, 44, 49, 84, 86, 174, 370 | Key management |\n| **Address** | 13, 173, 350 | Address formats |\n| **Transaction** | 125, 152 | Transaction handling |\n| **Future** | 118, 119 | Proposed upgrades |\n\n---\n\n## Resources\n\n- **[Official BIP Repository](https://github.com/bitcoin/bips)** - All BIPs on GitHub\n- **[BIP 2 - BIP Process](https://github.com/bitcoin/bips/blob/master/bip-0002.mediawiki)** - How to create a BIP\n- **[Bitcoin Wiki - BIPs](https://en.bitcoin.it/wiki/Bitcoin_Improvement_Proposals)** - Community documentation\n\n---\n\n## Related Topics\n\n- [Forks](/docs/history/forks) - How BIPs become protocol changes\n- [Script System](/docs/bitcoin/script) - Script-related BIPs in action\n",
    "filename": "bips.md"
  },
  "/docs/bitcoin": {
    "content": "# The Bitcoin Protocol\n\n**How Bitcoin works.**\n\nThe Bitcoin protocol is an elegant system of interlocking mechanisms that together create the world's first truly decentralized digital currency. At its core, it solves the seemingly impossible problem of achieving consensus among untrusted parties without a central authority.\n\n## Why the Protocol Matters\n\nEvery line of Bitcoin's protocol was carefully designed to create a system that is:\n\n- **Trustless**: No single entity can manipulate the rules\n- **Permissionless**: Anyone can participate without approval\n- **Censorship-resistant**: No one can prevent valid transactions\n- **Immutable**: History cannot be rewritten without enormous cost\n\nThe protocol transforms raw energy and mathematics into digital scarcity, creating something that has never existed before: a form of money that cannot be debased, confiscated, or counterfeited.\n\n---\n\n## Core Components\n\n### Cryptography\n\nThe mathematical foundation of Bitcoin. [Elliptic curve cryptography](/docs/bitcoin/cryptography) (specifically secp256k1) enables the creation of unforgeable digital signatures, while SHA-256 hash functions provide the computational basis for mining and data integrity.\n\n### Consensus\n\nBitcoin's [consensus mechanism](/docs/bitcoin/consensus) allows thousands of nodes worldwide to agree on a single transaction history without coordination. The combination of proof-of-work, the longest chain rule, and economic incentives creates a system where honesty is the most profitable strategy.\n\n### Script\n\n[Bitcoin Script](/docs/bitcoin/script) is a simple, stack-based programming language that defines spending conditions. While intentionally limited (no loops, no complex state), it enables powerful functionality like multi-signature wallets, time-locked transactions, and atomic swaps.\n\n### OP Codes\n\nThe [instruction set](/docs/bitcoin/op-codes) that powers Bitcoin Script. Each opcode performs a specific operation on the stack, from simple arithmetic to complex cryptographic verification. Understanding opcodes is essential for working with Bitcoin's programmable money features.\n\n### Block Structure\n\nBlocks are the fundamental units of Bitcoin's ledger. [Block propagation](/docs/bitcoin/blocks) across the network ensures all participants eventually see the same history, while the Merkle tree structure enables efficient verification without downloading full blocks.\n\n### Economic Rules\n\nThe [subsidy equation](/docs/bitcoin/subsidy) mathematically guarantees Bitcoin's fixed supply. Starting at 50 BTC per block and halving every 210,000 blocks, this creates a predictable, disinflationary monetary policy that will asymptotically approach 21 million coins.\n\n---\n\n## Network Participants\n\n**Nodes:**\n- [Full nodes](/docs/glossary#full-node): Store complete blockchain, validate all transactions\n- Light nodes: Store minimal data, rely on full nodes\n- Mining nodes: Create new blocks, secure the network\n\n**Miners:**\n- Verify transactions\n- Create new blocks\n- Secure the network through [proof-of-work](/docs/glossary#proof-of-work-pow)\n- Receive [block rewards](/docs/glossary#block-reward) and fees\n\n**Users:**\n- Send and receive bitcoin\n- Control their private keys\n- Participate in the network\n\n---\n\n## Interacting with Bitcoin\n\n### RPC Interface\n\nThe [RPC (Remote Procedure Call)](/docs/bitcoin/rpc) interface is how applications communicate with a Bitcoin node. It provides commands for querying blockchain state, constructing transactions, managing wallets, and monitoring network activity.\n\n---\n\n## The Elegance of Simplicity\n\nWhat makes the Bitcoin protocol remarkable is not its complexity, but its simplicity. Each component does one thing well:\n\n- **Hash functions** provide one-way data fingerprints\n- **Digital signatures** prove ownership without revealing secrets\n- **Proof-of-work** makes history expensive to rewrite\n- **Merkle trees** enable compact proofs\n- **Difficulty adjustment** maintains stable block times\n\nTogether, these simple building blocks create an unstoppable monetary network that has operated continuously since January 3, 2009.\n\n---\n\n## Explore the Protocol\n\nDive into the technical details:\n\n- [Cryptography](/docs/bitcoin/cryptography) - Hash functions, elliptic curves, and digital signatures\n- [Consensus](/docs/bitcoin/consensus) - How the network agrees on truth\n- [Transaction Lifecycle](/docs/bitcoin/transaction-lifecycle) - Transaction states and confirmations\n- [Script](/docs/bitcoin/script) - Bitcoin's programming language\n- [OP Codes](/docs/bitcoin/op-codes) - The instruction set reference\n- [Timelocks](/docs/bitcoin/timelocks) - Time-based spending conditions\n- [Sighash Types](/docs/bitcoin/sighash-types) - What signatures commit to (SIGHASH_ALL, SINGLE, NONE, ANYONECANPAY)\n- [Merkle Trees](/docs/bitcoin/merkle-trees) - Efficient transaction verification\n- [Blocks](/docs/bitcoin/blocks) - Block structure and propagation\n- [Subsidy](/docs/bitcoin/subsidy) - The mathematical supply schedule\n- [Transaction Fees](/docs/bitcoin/transaction-fees) - Fee market and estimation\n- [Transaction Malleability](/docs/bitcoin/transaction-malleability) - Historical issue and fix\n- [SegWit](/docs/bitcoin/segwit) - Segregated Witness protocol upgrade\n- [Taproot](/docs/bitcoin/taproot) - Schnorr signatures and MAST\n- [P2P Network Protocol](/docs/bitcoin/p2p-protocol) - Peer-to-peer communication\n- [RPC](/docs/bitcoin/rpc) - Node communication interface\n",
    "filename": "overview.md"
  },
  "/docs/bitcoin/cryptography": {
    "content": "# Cryptography in Bitcoin\n\nBitcoin relies on several cryptographic primitives to secure transactions, prove ownership, and maintain the integrity of the blockchain. Understanding these cryptographic foundations is essential for grasping how Bitcoin achieves trustless security.\n\n## The Power of Cryptography\n\nCryptography enables remarkable capabilities that seem almost magical:\n\n- **Prove knowledge without revealing it**: You can prove you know a secret (like a private key) without ever exposing the secret itself. This is how you sign Bitcoin transactions.\n- **Create unforgeable signatures**: Only the holder of a private key can create a valid signature, but anyone can verify it with the corresponding public key.\n- **Commit to data irrevocably**: Hash functions create unique fingerprints that bind you to specific data without revealing it until you choose to.\n- **Verify integrity instantly**: Detect any tampering with data, no matter how large, by comparing small hash values.\n\nThese concepts aren't unique to Bitcoin. You encounter cryptography daily:\n\n| Application | Cryptographic Use |\n|-------------|-------------------|\n| **HTTPS/TLS** | Encrypts web traffic, verifies website identity |\n| **PGP/GPG** | Email encryption and digital signatures |\n| **Signal/WhatsApp** | End-to-end encrypted messaging |\n| **SSH** | Secure remote server access |\n| **Password Storage** | Hashing passwords so they're never stored in plain text |\n\nBitcoin combines these proven cryptographic techniques in a novel way to create a trustless monetary system.\n\n---\n\n## Overview\n\nBitcoin uses cryptography for three main purposes:\n\n1. **Ownership & Authentication**: Proving you own bitcoin without revealing your private key\n2. **Integrity**: Ensuring data hasn't been tampered with\n3. **Proof-of-Work**: Securing the blockchain through computational work\n\n---\n\n## Hash Functions\n\nA **cryptographic hash function** takes any input data and produces a fixed-size output (the \"hash\" or \"digest\"). Hash functions are one-way: easy to compute, but practically impossible to reverse.\n\n**Properties of Cryptographic Hash Functions:**\n\n| Property | Description |\n|----------|-------------|\n| **Deterministic** | Same input always produces same output |\n| **Fast** | Quick to compute for any input |\n| **One-way** | Cannot derive input from output |\n| **Collision-resistant** | Infeasible to find two inputs with same output |\n| **Avalanche effect** | Small input change = completely different output |\n\n### SHA-256\n\nBitcoin's primary hash function is **[SHA-256](/docs/glossary#sha-256)** (Secure Hash Algorithm, 256-bit).\n\n**Characteristics:**\n- Output: 256 bits (32 bytes, 64 hex characters)\n- Designed by NSA, published in 2001\n- No known practical attacks\n\n**Example:**\n```\nInput:  \"Hello\"\nSHA-256: 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969\n\nInput:  \"Hello!\"\nSHA-256: 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7\n```\n\nNotice how adding a single character completely changes the output (avalanche effect).\n\n### Double SHA-256 ([SHA256D](/docs/glossary#sha256d))\n\nBitcoin often uses **double SHA-256**: `SHA256(SHA256(data))`\n\n**Used for:**\n- Block hashes\n- [Transaction IDs](/docs/glossary#transaction-id-txid) (TXIDs)\n- [Merkle tree](/docs/glossary#merkle-tree) nodes\n- [Proof-of-work](/docs/glossary#proof-of-work-pow)\n\n**Why double hashing?**\n- Defense against length-extension attacks\n- Additional security margin\n- Historical design choice by Satoshi\n\n### Code: SHA-256 and Double SHA-256\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse sha2::{Sha256, Digest};\n\nfn sha256(data: &[u8]) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    hasher.finalize().into()\n}\n\nfn double_sha256(data: &[u8]) -> [u8; 32] {\n    sha256(&sha256(data))\n}\n\nfn main() {\n    let message = b\"Hello\";\n    println!(\"SHA-256: {}\", hex::encode(sha256(message)));\n    println!(\"Double SHA-256: {}\", hex::encode(double_sha256(message)));\n}\n```\n\n```python\nimport hashlib\n\ndef sha256(data: bytes) -> bytes:\n    return hashlib.sha256(data).digest()\n\ndef double_sha256(data: bytes) -> bytes:\n    \"\"\"Bitcoin's double SHA-256\"\"\"\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\n# Example\nmessage = b\"Hello\"\nprint(f\"SHA-256: {sha256(message).hex()}\")\nprint(f\"Double SHA-256: {double_sha256(message).hex()}\")\n```\n\n```cpp\n#include <openssl/sha.h>\n#include <vector>\n#include <iomanip>\n#include <sstream>\n\nstd::vector<uint8_t> sha256(const std::vector<uint8_t>& data) {\n    std::vector<uint8_t> hash(SHA256_DIGEST_LENGTH);\n    SHA256(data.data(), data.size(), hash.data());\n    return hash;\n}\n\nstd::vector<uint8_t> double_sha256(const std::vector<uint8_t>& data) {\n    return sha256(sha256(data));\n}\n\nstd::string to_hex(const std::vector<uint8_t>& data) {\n    std::stringstream ss;\n    for (auto byte : data) {\n        ss << std::hex << std::setfill('0') << std::setw(2) << (int)byte;\n    }\n    return ss.str();\n}\n\nint main() {\n    std::vector<uint8_t> message = {'H', 'e', 'l', 'l', 'o'};\n    std::cout << \"SHA-256: \" << to_hex(sha256(message)) << std::endl;\n    std::cout << \"Double SHA-256: \" << to_hex(double_sha256(message)) << std::endl;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nfunc SHA256(data []byte) [32]byte {\n\treturn sha256.Sum256(data)\n}\n\nfunc DoubleSHA256(data []byte) [32]byte {\n\t// Bitcoin's double SHA-256\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second\n}\n\nfunc main() {\n\tmessage := []byte(\"Hello\")\n\tfmt.Printf(\"SHA-256: %s\\n\", hex.EncodeToString(SHA256(message)[:]))\n\tfmt.Printf(\"Double SHA-256: %s\\n\", hex.EncodeToString(DoubleSHA256(message)[:]))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction sha256(data) {\n  return crypto.createHash('sha256').update(data).digest();\n}\n\nfunction doubleSha256(data) {\n  return sha256(sha256(data));\n}\n\n// Example\nconst message = Buffer.from('Hello');\nconsole.log(`SHA-256: ${sha256(message).toString('hex')}`);\nconsole.log(`Double SHA-256: ${doubleSha256(message).toString('hex')}`);\n```\n:::\n\n### [RIPEMD-160](/docs/glossary#ripemd-160) and Hash160\n\n**RIPEMD-160** produces a 160-bit (20-byte) hash, used in combination with SHA-256.\n\n**Hash160 = RIPEMD160(SHA256(data))**\n\n**Used for:**\n- Bitcoin [addresses](/docs/glossary#address) ([P2PKH](/docs/glossary#p2pkh-pay-to-pubkey-hash), [P2SH](/docs/glossary#p2sh-pay-to-script-hash))\n- Shorter than SHA-256, reducing address length\n- Still cryptographically secure\n\n### Code: Hash160\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse ripemd::Ripemd160;\nuse sha2::{Sha256, Digest};\n\nfn hash160(data: &[u8]) -> [u8; 20] {\n    let sha256_hash = Sha256::digest(data);\n    let ripemd_hash = Ripemd160::digest(&sha256_hash);\n    ripemd_hash.into()\n}\n\nfn main() {\n    let public_key = hex::decode(\"02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737\").unwrap();\n    println!(\"Hash160: {}\", hex::encode(hash160(&public_key)));\n}\n```\n\n```python\nimport hashlib\n\ndef hash160(data: bytes) -> bytes:\n    \"\"\"RIPEMD160(SHA256(data)) - used for Bitcoin addresses\"\"\"\n    sha256_hash = hashlib.sha256(data).digest()\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    return ripemd160.digest()\n\n# Hash a public key\npublic_key = bytes.fromhex(\"02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737\")\nprint(f\"Hash160: {hash160(public_key).hex()}\")\n```\n\n```cpp\n#include <openssl/sha.h>\n#include <openssl/ripemd.h>\n\nstd::vector<uint8_t> hash160(const std::vector<uint8_t>& data) {\n    // First SHA-256\n    std::vector<uint8_t> sha256_hash(SHA256_DIGEST_LENGTH);\n    SHA256(data.data(), data.size(), sha256_hash.data());\n    \n    // Then RIPEMD-160\n    std::vector<uint8_t> hash(RIPEMD160_DIGEST_LENGTH);\n    RIPEMD160(sha256_hash.data(), sha256_hash.size(), hash.data());\n    return hash;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"golang.org/x/crypto/ripemd160\"\n)\n\n// Hash160 performs RIPEMD160(SHA256(data)) - used for Bitcoin addresses\nfunc Hash160(data []byte) []byte {\n\tsha256Hash := sha256.Sum256(data)\n\thasher := ripemd160.New()\n\thasher.Write(sha256Hash[:])\n\treturn hasher.Sum(nil)\n}\n\nfunc main() {\n\t// Hash a public key\n\tpublicKey, _ := hex.DecodeString(\"02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737\")\n\thash160 := Hash160(publicKey)\n\tfmt.Printf(\"Hash160: %s\\n\", hex.EncodeToString(hash160))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction hash160(data) {\n  const sha256Hash = crypto.createHash('sha256').update(data).digest();\n  return crypto.createHash('ripemd160').update(sha256Hash).digest();\n}\n\n// Hash a public key\nconst publicKey = Buffer.from('02b4632d08485ff1df2db55b9dafd23347d1c47a457072a1e87be26896549a8737', 'hex');\nconsole.log(`Hash160: ${hash160(publicKey).toString('hex')}`);\n```\n:::\n\n---\n\n## Elliptic Curve Cryptography\n\n![Elliptic Curve Cryptography](/images/docs/ECC.webp)\n\n**Elliptic Curve Cryptography (ECC)** is a public-key cryptography system based on the algebraic structure of elliptic curves over finite fields.\n\n**Why Bitcoin uses ECC:**\n- Smaller key sizes than RSA (256-bit vs 3072-bit for equivalent security)\n- Faster computation\n- Lower bandwidth and storage requirements\n\n### The secp256k1 Curve\n\nBitcoin uses the **secp256k1** elliptic curve (see [ECDSA](/docs/glossary#ecdsa-elliptic-curve-digital-signature-algorithm)), defined by the equation:\n\n```\nyÂ² = xÂ³ + 7 (mod p)\n```\n\n**Parameters:**\n- **p** (prime): 2Â²âµâ¶ - 2Â³Â² - 977\n- **Order (n)**: Number of points on the curve\n- **Generator point (G)**: Fixed starting point for key generation\n\n**Why secp256k1?**\n- Chosen by Satoshi (not the most common curve at the time)\n- Efficiently computable\n- No known weaknesses\n- Parameters are \"nothing up my sleeve\" numbers (verifiably random)\n\n### Key Generation\n\n**Private Key:**\n- Random 256-bit number (1 to n-1)\n- Must be kept secret\n- Generated from cryptographically secure random source\n\n**Public Key:**\n- Derived from private key: `Public Key = Private Key Ã— G`\n- Point multiplication on the elliptic curve\n- Cannot reverse to find private key (discrete logarithm problem)\n- Can be shared publicly\n\n**Key Relationship:**\n```\nRandom Number â†’ Private Key â†’ Public Key â†’ Bitcoin Address\n     (256 bits)    (256 bits)   (512 bits)   (160 bits)\n```\n\n### Code: Key Generation\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse secp256k1::{Secp256k1, SecretKey, PublicKey};\nuse secp256k1::rand::rngs::OsRng;\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate random private key\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    // Serialize keys\n    let private_key_bytes = secret_key.secret_bytes();\n    let public_key_compressed = public_key.serialize();                  // 33 bytes\n    let public_key_uncompressed = public_key.serialize_uncompressed();   // 65 bytes\n    \n    println!(\"Private Key: {}\", hex::encode(private_key_bytes));\n    println!(\"Public Key (compressed): {}\", hex::encode(public_key_compressed));\n    println!(\"Public Key (uncompressed): {}\", hex::encode(public_key_uncompressed));\n}\n```\n\n```python\nimport secrets\nfrom secp256k1 import PrivateKey\n\n# Generate random private key (32 bytes)\nprivate_key_bytes = secrets.token_bytes(32)\nprivate_key = PrivateKey(private_key_bytes)\n\n# Derive public key\npublic_key_compressed = private_key.pubkey.serialize()           # 33 bytes\npublic_key_uncompressed = private_key.pubkey.serialize(False)    # 65 bytes\n\nprint(f\"Private Key: {private_key_bytes.hex()}\")\nprint(f\"Public Key (compressed): {public_key_compressed.hex()}\")\nprint(f\"Public Key (uncompressed): {public_key_uncompressed.hex()}\")\n```\n\n```cpp\n#include <secp256k1.h>\n#include <random>\n\nint main() {\n    // Create context\n    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n    \n    // Generate random private key (use proper CSPRNG in production)\n    unsigned char private_key[32];\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(0, 255);\n    for (int i = 0; i < 32; i++) {\n        private_key[i] = dis(gen);\n    }\n    \n    // Verify private key is valid\n    while (!secp256k1_ec_seckey_verify(ctx, private_key)) {\n        for (int i = 0; i < 32; i++) private_key[i] = dis(gen);\n    }\n    \n    // Derive public key\n    secp256k1_pubkey pubkey;\n    secp256k1_ec_pubkey_create(ctx, &pubkey, private_key);\n    \n    // Serialize public key (compressed)\n    unsigned char public_key_compressed[33];\n    size_t len = 33;\n    secp256k1_ec_pubkey_serialize(ctx, public_key_compressed, &len, \n                                   &pubkey, SECP256K1_EC_COMPRESSED);\n    \n    secp256k1_context_destroy(ctx);\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n)\n\nfunc main() {\n\t// Generate random private key\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Serialize keys\n\tprivateKeyBytes := privateKey.Serialize()\n\tpublicKey := privateKey.PubKey()\n\tpublicKeyCompressed := publicKey.SerializeCompressed()     // 33 bytes\n\tpublicKeyUncompressed := publicKey.SerializeUncompressed()  // 65 bytes\n\n\tfmt.Printf(\"Private Key: %s\\n\", hex.EncodeToString(privateKeyBytes))\n\tfmt.Printf(\"Public Key (compressed): %s\\n\", hex.EncodeToString(publicKeyCompressed))\n\tfmt.Printf(\"Public Key (uncompressed): %s\\n\", hex.EncodeToString(publicKeyUncompressed))\n}\n```\n\n```javascript\nconst { randomBytes } = require('crypto');\nconst secp256k1 = require('secp256k1');\n\n// Generate random private key\nlet privateKey;\ndo {\n  privateKey = randomBytes(32);\n} while (!secp256k1.privateKeyVerify(privateKey));\n\n// Derive public key\nconst publicKeyCompressed = secp256k1.publicKeyCreate(privateKey, true);    // 33 bytes\nconst publicKeyUncompressed = secp256k1.publicKeyCreate(privateKey, false); // 65 bytes\n\nconsole.log(`Private Key: ${privateKey.toString('hex')}`);\nconsole.log(`Public Key (compressed): ${Buffer.from(publicKeyCompressed).toString('hex')}`);\nconsole.log(`Public Key (uncompressed): ${Buffer.from(publicKeyUncompressed).toString('hex')}`);\n```\n:::\n\n### The Discrete Logarithm Problem\n\n**Why can't you derive the private key from the public key?**\n\nGiven `Q = k Ã— G` where:\n- `Q` is the public key (known)\n- `G` is the generator point (known)\n- `k` is the private key (unknown)\n\nFinding `k` requires solving the **Elliptic Curve Discrete Logarithm Problem (ECDLP)**, which is computationally infeasible for sufficiently large numbers.\n\n**Security Level:**\n- 256-bit private key = ~128 bits of security\n- Would take billions of years with current technology\n- Quantum computers could theoretically break this (see future considerations)\n\n---\n\n## Digital Signatures\n\nA **digital signature** proves:\n1. **Authenticity**: Message came from the claimed sender\n2. **Integrity**: Message hasn't been altered\n3. **Non-repudiation**: Sender cannot deny sending\n\n### ECDSA (Elliptic Curve Digital Signature Algorithm)\n\nBitcoin originally used **ECDSA** for all signatures.\n\n**Signing Process:**\n1. Hash the message: `z = SHA256(message)`\n2. Generate random number `k` (nonce)\n3. Calculate point `R = k Ã— G`\n4. Calculate signature: `s = kâ»Â¹(z + r Ã— privateKey) mod n`\n5. Signature is the pair `(r, s)`\n\n**Verification Process:**\n1. Hash the message: `z = SHA256(message)`\n2. Calculate: `u1 = z Ã— sâ»Â¹ mod n`\n3. Calculate: `u2 = r Ã— sâ»Â¹ mod n`\n4. Calculate point: `P = u1 Ã— G + u2 Ã— PublicKey`\n5. Signature valid if `P.x = r`\n\n**ECDSA Characteristics:**\n- Signature size: 70-72 bytes (DER encoded)\n- Requires secure random nonce `k`\n- Reusing `k` exposes private key!\n\n### Code: ECDSA Signing and Verification\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse secp256k1::{Secp256k1, SecretKey, Message};\nuse sha2::{Sha256, Digest};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Private key\n    let private_key = SecretKey::from_slice(\n        &hex::decode(\"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\").unwrap()\n    ).unwrap();\n    \n    // Message to sign\n    let message = b\"Hello, Bitcoin!\";\n    let message_hash = Sha256::digest(message);\n    let msg = Message::from_digest_slice(&message_hash).unwrap();\n    \n    // Sign\n    let signature = secp.sign_ecdsa(&msg, &private_key);\n    println!(\"Message Hash: {}\", hex::encode(message_hash));\n    println!(\"Signature: {}\", hex::encode(signature.serialize_compact()));\n    \n    // Verify\n    let public_key = private_key.public_key(&secp);\n    let is_valid = secp.verify_ecdsa(&msg, &signature, &public_key).is_ok();\n    println!(\"Signature valid: {}\", is_valid);\n}\n```\n\n```python\nimport hashlib\nfrom secp256k1 import PrivateKey\n\n# Private key (use secrets.token_bytes(32) for real applications)\nprivate_key = PrivateKey(bytes.fromhex(\n    \"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\"\n))\n\n# Message to sign\nmessage = b\"Hello, Bitcoin!\"\nmessage_hash = hashlib.sha256(message).digest()\n\n# Sign\nsignature = private_key.ecdsa_sign(message_hash)\nsignature_der = private_key.ecdsa_serialize(signature)\n\nprint(f\"Message Hash: {message_hash.hex()}\")\nprint(f\"Signature (DER): {signature_der.hex()}\")\n\n# Verify\nis_valid = private_key.pubkey.ecdsa_verify(message_hash, signature)\nprint(f\"Signature valid: {is_valid}\")\n```\n\n```cpp\n#include <secp256k1.h>\n#include <openssl/sha.h>\n#include <cstring>\n\nint main() {\n    secp256k1_context* ctx = secp256k1_context_create(\n        SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY\n    );\n    \n    // Private key (initialize from hex in production)\n    unsigned char private_key[32];\n    // hex: \"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\"\n    \n    // Message hash\n    const char* message = \"Hello, Bitcoin!\";\n    unsigned char message_hash[SHA256_DIGEST_LENGTH];\n    SHA256((unsigned char*)message, strlen(message), message_hash);\n    \n    // Sign\n    secp256k1_ecdsa_signature signature;\n    secp256k1_ecdsa_sign(ctx, &signature, message_hash, private_key, NULL, NULL);\n    \n    // Serialize signature\n    unsigned char sig_serialized[64];\n    secp256k1_ecdsa_signature_serialize_compact(ctx, sig_serialized, &signature);\n    \n    // Get public key and verify\n    secp256k1_pubkey pubkey;\n    secp256k1_ec_pubkey_create(ctx, &pubkey, private_key);\n    int is_valid = secp256k1_ecdsa_verify(ctx, &signature, message_hash, &pubkey);\n    \n    secp256k1_context_destroy(ctx);\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcec/v2/ecdsa\"\n)\n\nfunc main() {\n\t// Private key\n\tprivateKeyBytes, _ := hex.DecodeString(\"e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35\")\n\tprivateKey, _ := btcec.PrivKeyFromBytes(privateKeyBytes)\n\n\t// Message to sign\n\tmessage := []byte(\"Hello, Bitcoin!\")\n\tmessageHash := sha256.Sum256(message)\n\n\t// Sign\n\tsignature := ecdsa.Sign(privateKey, messageHash[:])\n\tsignatureBytes := signature.Serialize()\n\n\tfmt.Printf(\"Message Hash: %s\\n\", hex.EncodeToString(messageHash[:]))\n\tfmt.Printf(\"Signature: %s\\n\", hex.EncodeToString(signatureBytes))\n\n\t// Verify\n\tpublicKey := privateKey.PubKey()\n\tisValid := signature.Verify(messageHash[:], publicKey)\n\tfmt.Printf(\"Signature valid: %v\\n\", isValid)\n}\n```\n\n```javascript\nconst crypto = require('crypto');\nconst secp256k1 = require('secp256k1');\n\n// Private key\nconst privateKey = Buffer.from(\n  'e8f32e723decf4051aefac8e2c93c9c5b214313817cdb01a1494b917c8436b35', 'hex'\n);\n\n// Message to sign\nconst message = Buffer.from('Hello, Bitcoin!');\nconst messageHash = crypto.createHash('sha256').update(message).digest();\n\n// Sign\nconst sigObj = secp256k1.ecdsaSign(messageHash, privateKey);\nconsole.log(`Message Hash: ${messageHash.toString('hex')}`);\nconsole.log(`Signature: ${Buffer.from(sigObj.signature).toString('hex')}`);\n\n// Verify\nconst publicKey = secp256k1.publicKeyCreate(privateKey);\nconst isValid = secp256k1.ecdsaVerify(sigObj.signature, messageHash, publicKey);\nconsole.log(`Signature valid: ${isValid}`);\n```\n:::\n\n### [Schnorr Signatures](/docs/glossary#schnorr-signature)\n\n![Schnorr Signature Equations](/images/docs/schnorr-equations.png)\n\n**Schnorr signatures** were introduced with the [Taproot](/docs/glossary#taproot) upgrade (2021).\n\n**Advantages over ECDSA:**\n- **Simpler**: Mathematically cleaner\n- **Smaller**: Fixed 64-byte signatures\n- **Linearity**: Enables key and signature aggregation\n- **Provably secure**: Better security proofs\n- **Batch verification**: Faster validation of multiple signatures\n\n**Signature Aggregation:**\nMultiple signatures can be combined into one, enabling:\n- **[MuSig](/docs/glossary#musig)**: Multi-signature schemes that look like single signatures\n- **Privacy**: Multi-party transactions appear as single-party\n- **Efficiency**: Reduced transaction size and fees\n\n### Code: BIP-340 Schnorr Tagged Hash\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse sha2::{Sha256, Digest};\n\nfn tagged_hash(tag: &str, msg: &[u8]) -> [u8; 32] {\n    let tag_hash = Sha256::digest(tag.as_bytes());\n    let mut hasher = Sha256::new();\n    hasher.update(&tag_hash);\n    hasher.update(&tag_hash);\n    hasher.update(msg);\n    hasher.finalize().into()\n}\n\nfn main() {\n    let challenge = tagged_hash(\"BIP0340/challenge\", b\"some data\");\n    println!(\"Challenge hash: {}\", hex::encode(challenge));\n}\n```\n\n```python\nimport hashlib\n\ndef tagged_hash(tag: str, msg: bytes) -> bytes:\n    \"\"\"BIP-340 tagged hash for domain separation\"\"\"\n    tag_hash = hashlib.sha256(tag.encode()).digest()\n    return hashlib.sha256(tag_hash + tag_hash + msg).digest()\n\n# Example tags used in Bitcoin\nchallenge = tagged_hash(\"BIP0340/challenge\", b\"some data\")\naux = tagged_hash(\"BIP0340/aux\", b\"random auxiliary data\")\nnonce = tagged_hash(\"BIP0340/nonce\", b\"nonce derivation input\")\n\nprint(f\"Challenge hash: {challenge.hex()}\")\n```\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <openssl/sha.h>\n\nusing Hash256 = std::array<uint8_t, 32>;\n\nHash256 sha256(const std::vector<uint8_t>& data) {\n    Hash256 hash;\n    SHA256(data.data(), data.size(), hash.data());\n    return hash;\n}\n\nHash256 tagged_hash(const std::string& tag, const std::vector<uint8_t>& msg) {\n    // Hash the tag\n    std::vector<uint8_t> tag_bytes(tag.begin(), tag.end());\n    Hash256 tag_hash = sha256(tag_bytes);\n    \n    // Concatenate: tag_hash || tag_hash || msg\n    std::vector<uint8_t> data;\n    data.insert(data.end(), tag_hash.begin(), tag_hash.end());\n    data.insert(data.end(), tag_hash.begin(), tag_hash.end());\n    data.insert(data.end(), msg.begin(), msg.end());\n    \n    return sha256(data);\n}\n\nstd::string to_hex(const Hash256& hash) {\n    std::string result;\n    for (uint8_t byte : hash) {\n        char buf[3];\n        snprintf(buf, sizeof(buf), \"%02x\", byte);\n        result += buf;\n    }\n    return result;\n}\n\nint main() {\n    std::vector<uint8_t> msg = {'s', 'o', 'm', 'e', ' ', 'd', 'a', 't', 'a'};\n    Hash256 challenge = tagged_hash(\"BIP0340/challenge\", msg);\n    std::cout << \"Challenge hash: \" << to_hex(challenge) << std::endl;\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nfunc TaggedHash(tag string, msg []byte) [32]byte {\n\ttagHash := sha256.Sum256([]byte(tag))\n\t\n\t// Concatenate: tag_hash || tag_hash || msg\n\tdata := make([]byte, 0, len(tagHash)*2+len(msg))\n\tdata = append(data, tagHash[:]...)\n\tdata = append(data, tagHash[:]...)\n\tdata = append(data, msg...)\n\t\n\treturn sha256.Sum256(data)\n}\n\nfunc main() {\n\t// Example tags used in Bitcoin\n\tchallenge := TaggedHash(\"BIP0340/challenge\", []byte(\"some data\"))\n\taux := TaggedHash(\"BIP0340/aux\", []byte(\"random auxiliary data\"))\n\tnonce := TaggedHash(\"BIP0340/nonce\", []byte(\"nonce derivation input\"))\n\t\n\tfmt.Printf(\"Challenge hash: %s\\n\", hex.EncodeToString(challenge[:]))\n\tfmt.Printf(\"Aux hash: %s\\n\", hex.EncodeToString(aux[:]))\n\tfmt.Printf(\"Nonce hash: %s\\n\", hex.EncodeToString(nonce[:]))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction taggedHash(tag, msg) {\n    const tagHash = crypto.createHash('sha256').update(tag).digest();\n    return crypto.createHash('sha256')\n        .update(tagHash)\n        .update(tagHash)\n        .update(msg)\n        .digest();\n}\n\n// Example tags used in Bitcoin\nconst challenge = taggedHash('BIP0340/challenge', Buffer.from('some data'));\nconst aux = taggedHash('BIP0340/aux', Buffer.from('random auxiliary data'));\nconst nonce = taggedHash('BIP0340/nonce', Buffer.from('nonce derivation input'));\n\nconsole.log(`Challenge hash: ${challenge.toString('hex')}`);\n```\n:::\n\n### Signing a Bitcoin Transaction\n\nWhen you spend bitcoin:\n\n1. **Construct transaction** with [inputs](/docs/glossary#input) and [outputs](/docs/glossary#output)\n2. **Create signature hash** (sighash) of transaction data\n3. **Sign** the sighash with your private key\n4. **Include signature** in transaction's [witness](/docs/glossary#witness)/[scriptSig](/docs/glossary#scriptsig)\n5. **Broadcast** transaction to network\n6. **Nodes verify** signature matches public key and transaction\n\n---\n\n## Merkle Trees\n\nA **Merkle tree** (or hash tree) is a data structure that efficiently summarizes and verifies large datasets.\n\n**Structure:**\n```\n                    Merkle Root\n                   /            \\\n              Hash AB          Hash CD\n             /      \\         /      \\\n         Hash A   Hash B   Hash C   Hash D\n            |        |        |        |\n           Tx A    Tx B     Tx C     Tx D\n```\n\n### How Bitcoin Uses Merkle Trees\n\n**Block Structure:**\n- Each block contains a **[Merkle root](/docs/glossary#merkle-root)** in its header\n- Merkle root summarizes all transactions in the block\n- Changing any transaction changes the Merkle root\n\n**Benefits:**\n1. **Efficient verification**: Prove transaction inclusion with O(log n) hashes\n2. **Compact proofs**: [SPV](/docs/glossary#spv-simplified-payment-verification) nodes don't need full blockchain\n3. **Data integrity**: Any tampering is immediately detectable\n\n### Merkle Proofs (SPV)\n\n**Simplified Payment Verification** allows lightweight clients to verify transactions without downloading the full blockchain.\n\n**To prove Tx B is in a block:**\n```\nProvide: Hash A, Hash CD\nClient calculates:\n  1. Hash B (from Tx B)\n  2. Hash AB = SHA256(Hash A + Hash B)\n  3. Merkle Root = SHA256(Hash AB + Hash CD)\n  4. Compare with block header's Merkle root\n```\n\n### Code: Merkle Tree and Proof Verification\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\nfn double_sha256(data: &[u8]) -> [u8; 32] {\n    let first = Sha256::digest(data);\n    Sha256::digest(&first).into()\n}\n\nfn merkle_root(mut hashes: Vec<[u8; 32]>) -> [u8; 32] {\n    if hashes.is_empty() {\n        return [0u8; 32];\n    }\n    \n    while hashes.len() > 1 {\n        // Duplicate last if odd\n        if hashes.len() % 2 == 1 {\n            hashes.push(*hashes.last().unwrap());\n        }\n        \n        // Hash pairs\n        hashes = hashes\n            .chunks(2)\n            .map(|pair| {\n                let mut combined = Vec::with_capacity(64);\n                combined.extend_from_slice(&pair[0]);\n                combined.extend_from_slice(&pair[1]);\n                double_sha256(&combined)\n            })\n            .collect();\n    }\n    \n    hashes[0]\n}\n\nfn verify_merkle_proof(tx_hash: [u8; 32], proof: &[[u8; 32]], \n                       root: [u8; 32], mut index: usize) -> bool {\n    let mut current = tx_hash;\n    for sibling in proof {\n        let mut combined = Vec::with_capacity(64);\n        if index % 2 == 0 {\n            combined.extend_from_slice(&current);\n            combined.extend_from_slice(sibling);\n        } else {\n            combined.extend_from_slice(sibling);\n            combined.extend_from_slice(&current);\n        }\n        current = double_sha256(&combined);\n        index /= 2;\n    }\n    current == root\n}\n```\n\n```python\nimport hashlib\n\ndef double_sha256(data: bytes) -> bytes:\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\ndef merkle_root(tx_hashes: list) -> bytes:\n    \"\"\"Calculate Merkle root from transaction hashes\"\"\"\n    if len(tx_hashes) == 0:\n        return bytes(32)\n    if len(tx_hashes) == 1:\n        return tx_hashes[0]\n    \n    # Duplicate last hash if odd number\n    if len(tx_hashes) % 2 == 1:\n        tx_hashes = tx_hashes + [tx_hashes[-1]]\n    \n    # Hash pairs\n    next_level = []\n    for i in range(0, len(tx_hashes), 2):\n        combined = tx_hashes[i] + tx_hashes[i + 1]\n        next_level.append(double_sha256(combined))\n    \n    return merkle_root(next_level)\n\ndef verify_merkle_proof(tx_hash: bytes, proof: list, root: bytes, index: int) -> bool:\n    \"\"\"Verify transaction inclusion using Merkle proof\"\"\"\n    current = tx_hash\n    for sibling in proof:\n        if index % 2 == 0:\n            current = double_sha256(current + sibling)\n        else:\n            current = double_sha256(sibling + current)\n        index //= 2\n    return current == root\n\n# Example: 4 transactions\ntx_hashes = [double_sha256(f\"tx{i}\".encode()) for i in range(4)]\nroot = merkle_root(tx_hashes)\nprint(f\"Merkle Root: {root.hex()}\")\n```\n\n```cpp\n#include <vector>\n#include <array>\n#include <openssl/sha.h>\n\nusing Hash = std::array<uint8_t, 32>;\n\nHash double_sha256(const std::vector<uint8_t>& data) {\n    Hash first, second;\n    SHA256(data.data(), data.size(), first.data());\n    SHA256(first.data(), first.size(), second.data());\n    return second;\n}\n\nHash merkle_root(std::vector<Hash> hashes) {\n    if (hashes.empty()) return Hash{};\n    \n    while (hashes.size() > 1) {\n        // Duplicate last if odd\n        if (hashes.size() % 2 == 1) {\n            hashes.push_back(hashes.back());\n        }\n        \n        // Hash pairs\n        std::vector<Hash> next_level;\n        for (size_t i = 0; i < hashes.size(); i += 2) {\n            std::vector<uint8_t> combined;\n            combined.insert(combined.end(), hashes[i].begin(), hashes[i].end());\n            combined.insert(combined.end(), hashes[i+1].begin(), hashes[i+1].end());\n            next_level.push_back(double_sha256(combined));\n        }\n        hashes = std::move(next_level);\n    }\n    \n    return hashes[0];\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nfunc DoubleSHA256(data []byte) [32]byte {\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second\n}\n\nfunc MerkleRoot(hashes [][]byte) [32]byte {\n\tif len(hashes) == 0 {\n\t\treturn [32]byte{}\n\t}\n\tif len(hashes) == 1 {\n\t\tvar result [32]byte\n\t\tcopy(result[:], hashes[0])\n\t\treturn result\n\t}\n\t\n\t// Duplicate last if odd\n\tif len(hashes)%2 == 1 {\n\t\thashes = append(hashes, hashes[len(hashes)-1])\n\t}\n\t\n\t// Hash pairs\n\tvar nextLevel [][]byte\n\tfor i := 0; i < len(hashes); i += 2 {\n\t\tcombined := append(hashes[i], hashes[i+1]...)\n\t\thash := DoubleSHA256(combined)\n\t\tnextLevel = append(nextLevel, hash[:])\n\t}\n\t\n\treturn MerkleRoot(nextLevel)\n}\n\nfunc VerifyMerkleProof(txHash []byte, proof [][]byte, root [32]byte, index int) bool {\n\tcurrent := make([]byte, 32)\n\tcopy(current, txHash)\n\t\n\tfor _, sibling := range proof {\n\t\tvar combined []byte\n\t\tif index%2 == 0 {\n\t\t\tcombined = append(current, sibling...)\n\t\t} else {\n\t\t\tcombined = append(sibling, current...)\n\t\t}\n\t\tcurrent = DoubleSHA256(combined)[:]\n\t\tindex = index / 2\n\t}\n\t\n\treturn hex.EncodeToString(current) == hex.EncodeToString(root[:])\n}\n\nfunc main() {\n\t// Example: 4 transactions\n\ttxHashes := make([][]byte, 4)\n\tfor i := 0; i < 4; i++ {\n\t\ttx := []byte(fmt.Sprintf(\"tx%d\", i))\n\t\thash := DoubleSHA256(tx)\n\t\ttxHashes[i] = hash[:]\n\t}\n\t\n\troot := MerkleRoot(txHashes)\n\tfmt.Printf(\"Merkle Root: %s\\n\", hex.EncodeToString(root[:]))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction doubleSha256(data) {\n    const first = crypto.createHash('sha256').update(data).digest();\n    return crypto.createHash('sha256').update(first).digest();\n}\n\nfunction merkleRoot(hashes) {\n    if (hashes.length === 0) return Buffer.alloc(32);\n    if (hashes.length === 1) return hashes[0];\n    \n    // Duplicate last if odd\n    if (hashes.length % 2 === 1) {\n        hashes.push(hashes[hashes.length - 1]);\n    }\n    \n    // Hash pairs\n    const nextLevel = [];\n    for (let i = 0; i < hashes.length; i += 2) {\n        const combined = Buffer.concat([hashes[i], hashes[i + 1]]);\n        nextLevel.push(doubleSha256(combined));\n    }\n    \n    return merkleRoot(nextLevel);\n}\n\nfunction verifyMerkleProof(txHash, proof, root, index) {\n    let current = txHash;\n    for (const sibling of proof) {\n        if (index % 2 === 0) {\n            current = doubleSha256(Buffer.concat([current, sibling]));\n        } else {\n            current = doubleSha256(Buffer.concat([sibling, current]));\n        }\n        index = Math.floor(index / 2);\n    }\n    return current.equals(root);\n}\n\n// Example: 4 transactions\nconst txHashes = [0, 1, 2, 3].map(i => \n    doubleSha256(Buffer.from(`tx${i}`))\n);\nconst root = merkleRoot(txHashes);\nconsole.log(`Merkle Root: ${root.toString('hex')}`);\n```\n:::\n\n---\n\n## Address Encoding\n\n### [Base58](/docs/glossary#base58)Check\n\n**Base58** encoding uses 58 characters (excluding 0, O, I, l to avoid confusion):\n\n```\n123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\n```\n\n**Base58Check** adds a checksum:\n1. Add version byte prefix\n2. Calculate checksum: `SHA256(SHA256(data))` (first 4 bytes)\n3. Append checksum to data\n4. Encode in Base58\n\n**Used for:** Legacy addresses (1..., 3...)\n\n### [Bech32](/docs/glossary#bech32) and Bech32m\n\n**Bech32** encoding (BIP-173) is used for [SegWit](/docs/glossary#segwit-segregated-witness) addresses:\n\n**Characteristics:**\n- Case-insensitive\n- Better error detection (BCH codes)\n- QR code friendly\n- Prefix: `bc1` for mainnet, `tb1` for testnet\n\n**Address Types:**\n- `bc1q...`: Native SegWit ([P2WPKH](/docs/glossary#p2wpkh-pay-to-witness-pubkey-hash), [P2WSH](/docs/glossary#p2wsh-pay-to-witness-script-hash)) - Bech32\n- `bc1p...`: Taproot ([P2TR](/docs/glossary#p2tr-pay-to-taproot)) - Bech32m\n\n**Bech32m** (BIP-350) is a modified version for Taproot addresses with improved error detection.\n\n### Code: Address Generation (Full Pipeline)\n\n:::code-group\n```rust\nuse bitcoin::{\n    Network, PrivateKey, PublicKey, Address,\n    secp256k1::{Secp256k1, rand},\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate private key\n    let (secret_key, _) = secp.generate_keypair(&mut rand::thread_rng());\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    \n    // Derive public key\n    let public_key = PublicKey::from_private_key(&secp, &private_key);\n    \n    // Generate addresses\n    let p2pkh = Address::p2pkh(&public_key, Network::Bitcoin);\n    let p2wpkh = Address::p2wpkh(&public_key, Network::Bitcoin).unwrap();\n    \n    println!(\"Private Key (WIF): {}\", private_key);\n    println!(\"Public Key: {}\", public_key);\n    println!(\"P2PKH Address: {}\", p2pkh);\n    println!(\"P2WPKH Address: {}\", p2wpkh);\n}\n```\n\n```python\nimport hashlib\nimport secrets\nfrom secp256k1 import PrivateKey\n\n# Base58 alphabet\nBASE58_ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef base58_encode(data: bytes) -> str:\n    num = int.from_bytes(data, 'big')\n    result = \"\"\n    while num > 0:\n        num, rem = divmod(num, 58)\n        result = BASE58_ALPHABET[rem] + result\n    for byte in data:\n        if byte == 0:\n            result = '1' + result\n        else:\n            break\n    return result\n\ndef base58check_encode(version: bytes, payload: bytes) -> str:\n    data = version + payload\n    checksum = hashlib.sha256(hashlib.sha256(data).digest()).digest()[:4]\n    return base58_encode(data + checksum)\n\ndef hash160(data: bytes) -> bytes:\n    sha256_hash = hashlib.sha256(data).digest()\n    return hashlib.new('ripemd160', sha256_hash).digest()\n\n# Bech32 encoding (simplified)\nBECH32_CHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\n\ndef bech32_polymod(values):\n    GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]\n    chk = 1\n    for v in values:\n        b = chk >> 25\n        chk = ((chk & 0x1ffffff) << 5) ^ v\n        for i in range(5):\n            chk ^= GEN[i] if ((b >> i) & 1) else 0\n    return chk\n\ndef bech32_encode(hrp: str, data: list) -> str:\n    values = [ord(c) >> 5 for c in hrp] + [0] + [ord(c) & 31 for c in hrp] + data\n    polymod = bech32_polymod(values + [0]*6) ^ 1\n    checksum = [(polymod >> 5*(5-i)) & 31 for i in range(6)]\n    return hrp + \"1\" + \"\".join(BECH32_CHARSET[d] for d in data + checksum)\n\ndef convertbits(data, frombits, tobits, pad=True):\n    acc, bits, ret = 0, 0, []\n    maxv = (1 << tobits) - 1\n    for value in data:\n        acc = (acc << frombits) | value\n        bits += frombits\n        while bits >= tobits:\n            bits -= tobits\n            ret.append((acc >> bits) & maxv)\n    if pad and bits:\n        ret.append((acc << (tobits - bits)) & maxv)\n    return ret\n\ndef generate_addresses():\n    \"\"\"Generate all address types from a single private key\"\"\"\n    # 1. Generate private key\n    private_key_bytes = secrets.token_bytes(32)\n    private_key = PrivateKey(private_key_bytes)\n    \n    # 2. Get compressed public key\n    public_key = private_key.pubkey.serialize()\n    \n    # 3. Hash160 the public key\n    pubkey_hash = hash160(public_key)\n    \n    # 4. Generate addresses\n    # P2PKH (Legacy) - starts with '1'\n    p2pkh = base58check_encode(b'\\x00', pubkey_hash)\n    \n    # P2WPKH (Native SegWit) - starts with 'bc1q'\n    witness_program = convertbits(list(pubkey_hash), 8, 5)\n    p2wpkh = bech32_encode(\"bc\", [0] + witness_program)\n    \n    return {\n        \"private_key\": private_key_bytes.hex(),\n        \"public_key\": public_key.hex(),\n        \"pubkey_hash\": pubkey_hash.hex(),\n        \"p2pkh_address\": p2pkh,\n        \"p2wpkh_address\": p2wpkh,\n    }\n\nresult = generate_addresses()\nprint(f\"Private Key: {result['private_key']}\")\nprint(f\"Public Key: {result['public_key']}\")\nprint(f\"P2PKH Address: {result['p2pkh_address']}\")\nprint(f\"P2WPKH Address: {result['p2wpkh_address']}\")\n```\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n#include <openssl/sha.h>\n#include <openssl/ripemd.h>\n#include <secp256k1.h>\n\nusing Hash256 = std::array<uint8_t, 32>;\nusing Hash160 = std::array<uint8_t, 20>;\n\nconst std::string BASE58_ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\nHash256 sha256(const std::vector<uint8_t>& data) {\n    Hash256 hash;\n    SHA256(data.data(), data.size(), hash.data());\n    return hash;\n}\n\nHash160 hash160(const std::vector<uint8_t>& data) {\n    Hash256 sha_hash;\n    SHA256(data.data(), data.size(), sha_hash.data());\n    Hash160 ripemd_hash;\n    RIPEMD160(sha_hash.data(), sha_hash.size(), ripemd_hash.data());\n    return ripemd_hash;\n}\n\nstd::string base58_encode(const std::vector<uint8_t>& data) {\n    std::vector<uint8_t> digits(data.size() * 138 / 100 + 1);\n    size_t digitslen = 1;\n    for (size_t i = 0; i < data.size(); i++) {\n        uint32_t carry = data[i];\n        for (size_t j = 0; j < digitslen; j++) {\n            carry += (uint32_t)(digits[j]) << 8;\n            digits[j] = carry % 58;\n            carry /= 58;\n        }\n        while (carry) {\n            digits[digitslen++] = carry % 58;\n            carry /= 58;\n        }\n    }\n    std::string result;\n    for (size_t i = 0; i < data.size() && data[i] == 0; i++) {\n        result += '1';\n    }\n    for (size_t i = 0; i < digitslen; i++) {\n        result += BASE58_ALPHABET[digits[digitslen - 1 - i]];\n    }\n    return result;\n}\n\nstd::string base58check_encode(uint8_t version, const Hash160& payload) {\n    std::vector<uint8_t> data;\n    data.push_back(version);\n    data.insert(data.end(), payload.begin(), payload.end());\n    \n    auto hash1 = sha256(data);\n    std::vector<uint8_t> hash1_vec(hash1.begin(), hash1.end());\n    auto hash2 = sha256(hash1_vec);\n    \n    data.insert(data.end(), hash2.begin(), hash2.begin() + 4);\n    return base58_encode(data);\n}\n\nint main() {\n    secp256k1_context* ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n    \n    // Generate random private key (use secure random in production)\n    uint8_t private_key[32];\n    // ... fill with secure random bytes ...\n    \n    // Generate public key\n    secp256k1_pubkey pubkey;\n    secp256k1_ec_pubkey_create(ctx, &pubkey, private_key);\n    \n    // Serialize compressed public key\n    std::vector<uint8_t> public_key(33);\n    size_t pk_len = 33;\n    secp256k1_ec_pubkey_serialize(ctx, public_key.data(), &pk_len, &pubkey, SECP256K1_EC_COMPRESSED);\n    \n    // Generate P2PKH address\n    Hash160 pubkey_hash = hash160(public_key);\n    std::string p2pkh = base58check_encode(0x00, pubkey_hash);\n    \n    std::cout << \"P2PKH Address: \" << p2pkh << std::endl;\n    \n    secp256k1_context_destroy(ctx);\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"golang.org/x/crypto/ripemd160\"\n)\n\nfunc hash160(data []byte) []byte {\n\tsha := sha256.Sum256(data)\n\thasher := ripemd160.New()\n\thasher.Write(sha[:])\n\treturn hasher.Sum(nil)\n}\n\nfunc generateAddresses() {\n\t// 1. Generate private key\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 2. Get compressed public key\n\tpublicKey := privateKey.PubKey()\n\tpublicKeyBytes := publicKey.SerializeCompressed()\n\n\t// 3. Hash160 the public key\n\tpubkeyHash := hash160(publicKeyBytes)\n\n\t// 4. Generate P2PKH address (Legacy - starts with '1')\n\tp2pkhAddr, err := btcutil.NewAddressPubKeyHash(pubkeyHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// 5. Generate P2WPKH address (Native SegWit - starts with 'bc1q')\n\tp2wpkhAddr, err := btcutil.NewAddressWitnessPubKeyHash(pubkeyHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Private Key: %x\\n\", privateKey.Serialize())\n\tfmt.Printf(\"Public Key: %s\\n\", hex.EncodeToString(publicKeyBytes))\n\tfmt.Printf(\"Pubkey Hash: %s\\n\", hex.EncodeToString(pubkeyHash))\n\tfmt.Printf(\"P2PKH Address: %s\\n\", p2pkhAddr.EncodeAddress())\n\tfmt.Printf(\"P2WPKH Address: %s\\n\", p2wpkhAddr.EncodeAddress())\n}\n\nfunc main() {\n\tgenerateAddresses()\n}\n```\n\n```javascript\nconst crypto = require('crypto');\nconst secp256k1 = require('secp256k1');\nconst { bech32 } = require('bech32');\n\nconst BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\nfunction sha256(data) {\n    return crypto.createHash('sha256').update(data).digest();\n}\n\nfunction hash160(data) {\n    const sha = sha256(data);\n    return crypto.createHash('ripemd160').update(sha).digest();\n}\n\nfunction base58Encode(buffer) {\n    let num = BigInt('0x' + buffer.toString('hex'));\n    let result = '';\n    while (num > 0n) {\n        result = BASE58_ALPHABET[Number(num % 58n)] + result;\n        num = num / 58n;\n    }\n    for (const byte of buffer) {\n        if (byte === 0) result = '1' + result;\n        else break;\n    }\n    return result;\n}\n\nfunction base58CheckEncode(version, payload) {\n    const data = Buffer.concat([Buffer.from([version]), payload]);\n    const checksum = sha256(sha256(data)).slice(0, 4);\n    return base58Encode(Buffer.concat([data, checksum]));\n}\n\nfunction generateAddresses() {\n    // 1. Generate private key\n    let privateKey;\n    do {\n        privateKey = crypto.randomBytes(32);\n    } while (!secp256k1.privateKeyVerify(privateKey));\n    \n    // 2. Get compressed public key\n    const publicKey = Buffer.from(secp256k1.publicKeyCreate(privateKey, true));\n    \n    // 3. Hash160 the public key\n    const pubkeyHash = hash160(publicKey);\n    \n    // 4. Generate P2PKH address (Legacy - starts with '1')\n    const p2pkh = base58CheckEncode(0x00, pubkeyHash);\n    \n    // 5. Generate P2WPKH address (Native SegWit - starts with 'bc1q')\n    const words = bech32.toWords(pubkeyHash);\n    words.unshift(0); // witness version 0\n    const p2wpkh = bech32.encode('bc', words);\n    \n    return {\n        privateKey: privateKey.toString('hex'),\n        publicKey: publicKey.toString('hex'),\n        pubkeyHash: pubkeyHash.toString('hex'),\n        p2pkhAddress: p2pkh,\n        p2wpkhAddress: p2wpkh\n    };\n}\n\nconst result = generateAddresses();\nconsole.log(`Private Key: ${result.privateKey}`);\nconsole.log(`Public Key: ${result.publicKey}`);\nconsole.log(`P2PKH Address: ${result.p2pkhAddress}`);\nconsole.log(`P2WPKH Address: ${result.p2wpkhAddress}`);\n```\n:::\n\n---\n\n## Cryptographic Security Assumptions\n\n### What Bitcoin Assumes\n\nBitcoin's security relies on these assumptions holding true:\n\n| Assumption | If Broken |\n|------------|-----------|\n| SHA-256 is collision-resistant | Could create invalid blocks |\n| SHA-256 is preimage-resistant | Could forge proof-of-work |\n| ECDLP is hard | Private keys could be derived from public keys |\n| Random number generation is secure | Private keys could be predicted |\n\n### Quantum Computing Considerations\n\n**Potential Threats:**\n- **Shor's algorithm** could break ECDSA/Schnorr (public key â†’ private key)\n- **Grover's algorithm** could speed up SHA-256 attacks (but only quadratic speedup)\n\n**Current Status:**\n- No quantum computer capable of breaking Bitcoin exists today\n- Estimates suggest decades before practical quantum threats\n- Bitcoin community is researching post-quantum solutions\n- Addresses that haven't revealed public keys are safer\n\n**Mitigations:**\n- Don't reuse addresses (limits public key exposure)\n- Post-quantum signature schemes being researched\n- Soft fork could add quantum-resistant signatures\n\n---\n\n## Summary\n\n| Cryptographic Primitive | Purpose in Bitcoin |\n|------------------------|-------------------|\n| SHA-256 | Block hashing, TXIDs, PoW |\n| SHA-256d (double) | Block headers, Merkle trees |\n| RIPEMD-160 | Address generation (Hash160) |\n| secp256k1 (ECC) | Key pairs, signatures |\n| ECDSA | Legacy transaction signatures |\n| Schnorr | Taproot signatures, aggregation |\n| Merkle Trees | Transaction summarization, SPV proofs |\n| Base58Check | Legacy address encoding |\n| Bech32/Bech32m | SegWit/Taproot address encoding |\n\n---\n\n## Resources\n\n- **[Bitcoin Developer Guide - Transactions](https://developer.bitcoin.org/devguide/transactions.html)** - Official documentation on transaction signing\n- **[Learn Me a Bitcoin](https://learnmeabitcoin.com)** - Visual explanations of Bitcoin cryptography\n- **[BIP-340: Schnorr Signatures](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)** - Schnorr signature specification\n- **[SEC 2: Recommended Elliptic Curve Domain Parameters](https://www.secg.org/sec2-v2.pdf)** - secp256k1 specification\n- **[libsecp256k1](https://github.com/bitcoin-core/secp256k1)** - Bitcoin Core's optimized secp256k1 C library\n",
    "filename": "cryptography.md"
  },
  "/docs/bitcoin/consensus": {
    "content": "# Consensus Mechanism\n\nBitcoin uses a consensus mechanism to achieve agreement among network participants about which transactions are valid and in what order they occurred. This consensus is reached without a central authority through a combination of cryptographic proof and economic incentives. The specific mechanism Bitcoin uses is formally known as **Nakamoto Consensus**, named after its pseudonymous creator.\n\n## The Significance of Consensus\n\n### The Byzantine Generals Problem\n\nBefore Bitcoin, achieving consensus in a distributed network with potentially hostile actors was an unsolved problem in computer science. The **Byzantine Generals Problem** illustrates this challenge:\n\nImagine several generals surrounding a city, needing to coordinate an attack. They can only communicate via messengers, but some generals may be traitors who send conflicting messages. How can the loyal generals reach agreement when they cannot trust all participants?\n\nThis mirrors the challenge of a distributed payment system: How can independent nodes agree on a transaction history when some participants may be malicious, messages can be delayed, and there is no central authority to arbitrate disputes?\n\n### Why This Matters\n\nIn traditional systems, consensus is achieved through trusted intermediarie: banks, clearinghouses, or central servers. These create single points of failure, censorship, and control. Bitcoin's breakthrough was achieving **trustless consensus**: agreement among strangers who have every reason to cheat each other.\n\n| Challenge | Traditional Solution | Bitcoin's Solution |\n|-----------|---------------------|-------------------|\n| Double-spending | Trusted third party | Proof-of-Work + longest chain |\n| Transaction ordering | Central database | Blockchain with timestamps |\n| Hostile actors | Legal enforcement | Economic incentives |\n| Network partitions | Authoritative server | Eventual consistency via PoW |\n| Sybil attacks | Identity verification | Computational cost |\n\n### Consensus in a Hostile Environment\n\nBitcoin assumes the network contains adversaries. Its consensus mechanism must function correctly even when:\n\n- **Nodes lie** about transactions they've seen\n- **Miners attempt** to include invalid transactions\n- **Attackers try** to reverse confirmed payments\n- **Network segments** become temporarily isolated\n- **Participants collude** to manipulate the system\n\nThe elegant solution combines cryptographic proof (making fraud detectable) with economic incentives (making honesty more profitable than cheating). This creates a system where rational actors are naturally aligned toward honest behavior, and irrational attackers face prohibitive costs.\n\n---\n\n## What Nodes Agree On\n\n**Consensus** means all honest participants agree on:\n- Which transactions are valid and their ordering\n- The current state of the blockchain (who owns what)\n- Which blocks form the canonical chain\n\n---\n\n## How Bitcoin Achieves Consensus\n\n### Proof-of-Work: Digital Gold Mining\n\nThe concept of proof-of-work predates Bitcoin. In 1997, **[Adam Back](/docs/history/people#adam-back)** invented [Hashcash](https://en.wikipedia.org/wiki/Hashcash), a proof-of-work system designed to combat email spam. The sender had to perform computational work to send an email: trivial for legitimate users, but prohibitively expensive for spammers sending millions of messages. Satoshi Nakamoto cited Hashcash in the [Bitcoin whitepaper](/whitepaper) and adapted its core mechanism for blockchain consensus.\n\nThe intuition behind proof-of-work mirrors **gold mining**. When someone presents you with a gold bar, you don't need to watch them mine it. The gold itself is proof that work was done. Gold cannot be created cheaply; its existence demonstrates that someone expended real resources (time, labor, equipment) to extract it from the earth. This is **implicit proof of work**.\n\nBitcoin mining works the same way. When a miner presents a valid block hash, the hash itself proves that computational work was performed. Just as you can verify gold's authenticity without witnessing the mining, anyone can verify a block's proof-of-work by checking the hash; without needing to redo the work or trust the miner.\n\n| Property | Gold | Bitcoin |\n|----------|------|---------|\n| Proof of work | Physical extraction from earth | Computational puzzle solution |\n| Verification | Assay testing (easy) | Hash check (instant) |\n| Forgery | Physically impossible to create cheaply | Computationally impossible to fake |\n| Scarcity | Geological limits | Protocol-enforced supply cap |\n| Cost | Energy, equipment, labor | Energy, ASICs, facilities |\n\nThis \"unforgeable costliness\" (a term coined by [Nick Szabo](/docs/history/people#nick-szabo)) is what gives both gold and bitcoin their monetary properties. The work cannot be faked, and the result can be easily verified by anyone.\n\n### How PoW Creates Consensus\n\nBitcoin uses **[Proof-of-Work](/docs/glossary#proof-of-work-pow)** (PoW) as its consensus mechanism. Miners compete to solve cryptographic puzzles, with [difficulty](/docs/glossary#difficulty) adjusting to maintain ~10 minute block intervals. The first miner to find a valid solution broadcasts the block, other nodes verify it, and the longest valid chain becomes the accepted truth.\n\n### The Consensus Process\n\n| Step | Action | Purpose |\n|------|--------|---------|\n| 1. Collect | Miners gather valid transactions from mempool | Build candidate block |\n| 2. Construct | Create block header (prev hash, merkle root, nonce) | Prepare for mining |\n| 3. Mine | Hash repeatedly until finding value below target | Prove computational work |\n| 4. Broadcast | Winner propagates block to network | Share new block |\n| 5. Verify | Nodes independently validate block | Ensure rule compliance |\n| 6. Extend | Miners build on longest valid chain | Reach consensus |\n\n---\n\n## Consensus Rules\n\nNodes validate three layers: **transactions** (valid signatures, unspent inputs, no [double-spends](/docs/glossary#double-spend)), **blocks** (correct structure, valid PoW, all transactions valid), and **chains** (blocks link correctly, longest chain is canonical).\n\n### Consensus Rules vs Policy\n\n| Aspect | Consensus Rules | Policy Rules |\n|--------|-----------------|--------------|\n| Scope | Network-wide, mandatory | Node-specific preferences |\n| Violation | Block/transaction rejected | May still be relayed by others |\n| Examples | 21M supply cap, block size limit | Minimum relay fee, mempool size |\n| Changes | Requires fork | Can change locally anytime |\n\n---\n\n## Achieving Consensus\n\n### The Longest Chain Rule\n\nThe chain with the most cumulative proof-of-work is considered valid. This simple rule ensures consensus emerges naturally: honest miners extend the longest chain because it's most profitable, attackers need >50% [hash rate](/docs/glossary#hash-rate) to create a competing chain, and the network converges on a single history.\n\n### Block Confirmations\n\nEach additional block makes transaction reversal exponentially more difficult ([confirmations](/docs/glossary#confirmation)):\n\n| Confirmations | Security Level | Typical Use Case |\n|---------------|----------------|------------------|\n| 0 (unconfirmed) | Low - can be double-spent | Small, trusted payments |\n| 1 | Moderate - single block of work | Low-value transactions |\n| 3 | Good - significant cost to reverse | Medium-value transactions |\n| 6 | High - standard security threshold | High-value transactions, exchanges |\n| 100+ | Required for coinbase maturity | Mining rewards |\n\n### Network Synchronization\n\nNodes stay synchronized by constantly sharing and verifying blocks. When temporary forks occur (e.g., two blocks found simultaneously), the network automatically resolves by accepting whichever chain becomes longest (typically within the next block).\n\n---\n\n## Security Through Consensus\n\n### 51% Attack\n\nA [51% attack](/docs/glossary#51-attack) occurs when an entity controls more than half the network's hash rate, enabling them to create a longer chain than honest miners and potentially reverse transactions. However, this attack faces severe practical barriers:\n\n| Barrier | Details |\n|---------|---------|\n| Hash rate required | >350 EH/s (half of ~700+ EH/s network) |\n| Hardware cost | Tens of billions in ASICs |\n| Electricity | Gigawatts of continuous power |\n| Opportunity cost | Could earn billions mining honestly |\n| Detection | Network would notice and potentially fork |\n\n### Economic Security\n\nBitcoin's security is fundamentally economic. Miners receive [block rewards](/docs/glossary#block-reward) + fees for honest behavior, making attacks unprofitable. The cost to attack exceeds any possible gain, and the network can respond by changing the PoW algorithm, rendering attacker hardware worthless.\n\n---\n\n## Consensus Properties\n\n| Property | Definition | Bitcoin's Implementation |\n|----------|------------|-------------------------|\n| **[Finality](/docs/glossary#finality)** | Transactions cannot be reversed | Probabilistic: 6+ confirmations is economically final |\n| **Liveness** | System continues producing blocks | ~10 min blocks; resilient to node failures |\n| **Safety** | No conflicting states | All nodes agree on single chain; no double-spends |\n\n---\n\n## Consensus Challenges\n\n### Network Partitions & Temporary Forks\n\n| Scenario | Cause | Resolution |\n|----------|-------|------------|\n| **Network partition** | Internet splits network into groups | Longest chain wins when reconnected |\n| **Temporary fork** | Two blocks found simultaneously | Next block determines winner |\n| **Stale block** | Valid block orphaned by longer chain | Transactions return to mempool |\n\nThese situations are normal and resolve automatically. The longest chain rule ensures eventual consistency without human intervention: a critical property for a trustless system.\n\n---\n\n## Comparison with Other Mechanisms\n\n| Aspect | Proof-of-Work (Bitcoin) | Proof-of-Stake |\n|--------|------------------------|----------------|\n| Security basis | Computational work (energy) | Staked capital |\n| Attack cost | Hardware + electricity | Acquire stake |\n| Energy use | High (security feature) | Low |\n| Track record | 15+ years, battle-tested | Newer, less proven |\n| Failure mode | 51% hash rate attack | \"Nothing at stake\" problem |\n\nBitcoin chose PoW because the energy expenditure creates unforgeable costliness: security that cannot be faked or granted by insiders. This aligns with the goal of trustless consensus in an adversarial environment.\n",
    "filename": "consensus.md"
  },
  "/docs/bitcoin/transaction-lifecycle": {
    "content": "# Transaction Lifecycle\n\nUnderstanding the complete lifecycle of a Bitcoin transaction helps developers build robust applications and users understand what happens when they send bitcoin.\n\n## Transaction Structure\n\n![Raw Bitcoin Transaction Bytes](/images/docs/raw-bitcoin-transacation-byte.jpg)\n\n![Transaction Binary Map](/images/docs/tx-binary-map.png)\n\nA Bitcoin transaction consists of:\n- **Version**: Identifies consensus rules\n- **Inputs**: References to previous transaction outputs (UTXOs)\n- **Outputs**: Creates new UTXOs with spending conditions\n- **Locktime**: Optional time-based spending restriction\n- **Witness Data** (SegWit): Signature data separated from transaction\n\nFor detailed transaction construction, see [Transaction Construction](/docs/bitcoin-development/transactions).\n\n---\n\n## Transaction States\n\nA transaction goes through several states:\n\n```text\n1. Created â†’ 2. Signed â†’ 3. Broadcast â†’ 4. Mempool â†’ \n5. Pending â†’ 6. Confirmed â†’ 7. Deeply Confirmed\n```\n\n---\n\n## State Transitions\n\n### 1. Created\n\nTransaction is constructed but not signed:\n\n```text\nStatus: Created\n- Inputs selected\n- Outputs defined\n- Fees calculated\n- Not yet signed\n```\n\n### 2. Signed\n\nPrivate keys sign the transaction:\n\n```text\nStatus: Signed\n- All inputs signed\n- Transaction valid\n- Ready to broadcast\n- Still local only\n```\n\n### 3. Broadcast\n\nTransaction sent to network:\n\n```text\nStatus: Broadcast\n- Sent to peer nodes\n- Propagating across network\n- Not yet in mempool\n- May be rejected\n```\n\n### 4. Mempool\n\nTransaction accepted by nodes:\n\n```text\nStatus: In Mempool\n- Validated by nodes\n- Waiting for miner selection\n- Can be replaced (RBF)\n- Can be dropped (low fee)\n```\n\n### 5. Pending\n\nTransaction included in block:\n\n```text\nStatus: Pending (0 confirmations)\n- Included in block\n- Block not yet confirmed\n- Can be reversed (reorg)\n- Not yet final\n```\n\n### 6. Confirmed\n\nBlock with transaction confirmed:\n\n```text\nStatus: Confirmed (1+ confirmations)\n- Block added to chain\n- Increasingly secure\n- Reversal very expensive\n- Generally considered final\n```\n\n### 7. Deeply Confirmed\n\nMany confirmations:\n\n```text\nStatus: Deeply Confirmed (6+ confirmations)\n- Extremely secure\n- Reversal practically impossible\n- Standard for high-value transactions\n```\n\n---\n\n## Code Examples\n\n### Tracking Transaction Status\n\n:::code-group\n```rust\nuse serde_json::json;\nuse reqwest;\n\n#[derive(Debug)]\nenum TxStatus {\n    NotFound,\n    InMempool,\n    Confirmed(u32), // Number of confirmations\n}\n\nasync fn get_transaction_status(txid: &str) -> Result<TxStatus, Box<dyn std::error::Error>> {\n    let url = format!(\"https://mempool.space/api/tx/{}/status\", txid);\n    let response = reqwest::get(&url).await?;\n    let data: serde_json::Value = response.json().await?;\n    \n    if data[\"confirmed\"].as_bool().unwrap_or(false) {\n        let confirmations = data[\"block_height\"].as_u64().unwrap_or(0);\n        Ok(TxStatus::Confirmed(confirmations as u32))\n    } else if data[\"in_mempool\"].as_bool().unwrap_or(false) {\n        Ok(TxStatus::InMempool)\n    } else {\n        Ok(TxStatus::NotFound)\n    }\n}\n```\n\n```python\nimport requests\n\ndef get_transaction_status(txid):\n    \"\"\"Get transaction status from mempool.space.\"\"\"\n    url = f\"https://mempool.space/api/tx/{txid}/status\"\n    response = requests.get(url)\n    data = response.json()\n    \n    if data.get(\"confirmed\"):\n        confirmations = data.get(\"block_height\", 0)\n        return f\"Confirmed ({confirmations} confirmations)\"\n    elif data.get(\"in_mempool\"):\n        return \"In Mempool\"\n    else:\n        return \"Not Found\"\n```\n\n```cpp\n#include <curl/curl.h>\n#include <json/json.h>\n#include <string>\n\nenum class TxStatus {\n    NotFound,\n    InMempool,\n    Confirmed\n};\n\nTxStatus get_transaction_status(const std::string& txid) {\n    CURL* curl = curl_easy_init();\n    std::string url = \"https://mempool.space/api/tx/\" + txid + \"/status\";\n    std::string response_data;\n    \n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);\n    curl_easy_perform(curl);\n    \n    Json::Value root;\n    Json::Reader reader;\n    reader.parse(response_data, root);\n    \n    if (root[\"confirmed\"].asBool()) {\n        return TxStatus::Confirmed;\n    } else if (root[\"in_mempool\"].asBool()) {\n        return TxStatus::InMempool;\n    }\n    \n    return TxStatus::NotFound;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype TxStatus struct {\n\tConfirmed  bool `json:\"confirmed\"`\n\tInMempool  bool `json:\"in_mempool\"`\n\tBlockHeight int `json:\"block_height\"`\n}\n\nfunc getTransactionStatus(txid string) (string, error) {\n\tresp, err := http.Get(\"https://mempool.space/api/tx/\" + txid + \"/status\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\t\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar status TxStatus\n\tjson.Unmarshal(body, &status)\n\t\n\tif status.Confirmed {\n\t\treturn \"Confirmed\", nil\n\t} else if status.InMempool {\n\t\treturn \"In Mempool\", nil\n\t}\n\t\n\treturn \"Not Found\", nil\n}\n```\n\n```javascript\nasync function getTransactionStatus(txid) {\n    const response = await fetch(\n        `https://mempool.space/api/tx/${txid}/status`\n    );\n    const data = await response.json();\n    \n    if (data.confirmed) {\n        return `Confirmed (${data.block_height} confirmations)`;\n    } else if (data.in_mempool) {\n        return 'In Mempool';\n    } else {\n        return 'Not Found';\n    }\n}\n```\n:::\n\n---\n\n## Reorganizations (Reorgs)\n\nA **reorganization** occurs when the blockchain splits and a different chain becomes the longest:\n\n```text\nOriginal Chain:\nBlock 100 â†’ Block 101 â†’ Block 102\n\nReorg:\nBlock 100 â†’ Block 101A â†’ Block 102A (longer chain)\n         â†’ Block 101B (orphaned)\n\nTransactions in Block 101B are now unconfirmed again\n```\n\n### Impact\n\n```text\nTransaction Status:\n- Was: Confirmed (in block 101B)\n- Now: Unconfirmed (block orphaned)\n- Risk: May not re-confirm\n```\n\n---\n\n## Orphan Transactions\n\n### Definition\n\n**Orphan transactions** are transactions that reference outputs that don't exist or are invalid:\n\n```text\nOrphan Transaction:\n- References UTXO that doesn't exist\n- Or references unconfirmed parent\n- Cannot be validated\n- Dropped from mempool\n```\n\n### Handling\n\n```text\n1. Transaction references unconfirmed parent\n2. Parent confirms â†’ Orphan becomes valid\n3. Orphan can now be included in block\n```\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Wait for confirmations**: Don't trust 0-conf for high value\n2. **Handle reorgs**: Transactions can be unconfirmed again\n3. **Monitor status**: Track transaction through lifecycle\n4. **Use RBF**: Allow fee bumping for stuck transactions\n\n### For Users\n\n1. **Be patient**: Confirmations take time\n2. **Check fees**: Low fees = slow confirmation\n3. **Verify addresses**: Double-check before sending\n4. **Use appropriate confirmations**: 6+ for large amounts\n\n---\n\n## Related Topics\n\n- [Mempool](/docs/mining/mempool) - Where transactions wait\n- [Block Visualizer](/block-visualizer) - See transactions flowing into blocks\n- [Transaction Fees](/docs/bitcoin/transaction-fees) - Fee calculation\n- [Block Propagation](/docs/bitcoin/blocks) - How blocks spread\n\n---\n\n## Resources\n\n- [mempool.space](https://mempool.space) - Transaction status tracking\n",
    "filename": "transaction-lifecycle.md"
  },
  "/docs/bitcoin/script": {
    "content": "# Bitcoin Script\n\nBitcoin Script is a programming language that defines **how bitcoin can be spent**. Every transaction output contains a **locking script** that sets the spending conditions. To spend that output, you must provide an **unlocking script** that satisfies those conditions.\n\n| Term | Also Called | Purpose |\n|------|-------------|---------|\n| **Locking Script** | scriptPubKey, output script | Defines *who* can spend and *under what conditions* |\n| **Unlocking Script** | scriptSig, input script, witness | Provides proof that spending conditions are met |\n\n---\n\n## How Does It Work?\n\nWhen you spend bitcoin, the network executes both scripts together:\n\n1. **Unlocking script runs first** (pushes signatures, keys, or other data onto the stack)\n2. **Locking script runs second** (verifies the data satisfies the conditions)\n3. **If the stack ends with `1` (true)**, the spend is valid\n\nScripts execute on a stack ([LIFO](/docs/glossary#lifo-last-in-first-out)). They are intentionally not Turing-complete: no loops means every script terminates, preventing denial-of-service attacks. Fewer features also means fewer vulnerabilities. Build and run scripts in [Stack Lab](/stack-lab).\n\n---\n\n## When Do Scripts Execute?\n\nScripts execute **when spending**, not when receiving. The locking script is stored with the output when bitcoin is sent. It only runs when someone later tries to spend that output.\n\n---\n\n## Script Types\n\nBitcoin Script has evolved over time, introducing new output types (address formats) that improve security, privacy, and efficiency. Each script type represents a different way to lock and unlock bitcoin.\n\n| Script Type | Full Name | Introduced | Block | BIP | Encoding | Prefix | Key Feature |\n|-------------|-----------|------------|-------|:---:|----------|--------|-------------|\n| **P2PK** | Pay&#8209;to&#8209;Pubkey | Jan 2009 | 0 | - | - | - | Earliest type. Locks directly to public key. No address format (raw pubkey in script). Rarely used today. |\n| **P2PKH** | Pay&#8209;to&#8209;Pubkey&#8209;Hash | Jan 2009 | 0 | - | [Base58](/docs/glossary#base58) | `1` | Original address type. Locks to hash of public key. More private than P2PK. |\n| **P2MS** | Pay&#8209;to&#8209;Multisig | Jan 2009 | 0 | - | - | - | Bare [multisig](/docs/glossary#multisig-multi-signature) (m-of-n). No address format. Limited to 3 keys for standardness. Superseded by P2SH. |\n| **P2SH** | Pay&#8209;to&#8209;Script&#8209;Hash | Apr 2012 | 173,805 | [16](https://github.com/bitcoin/bips/blob/master/bip-0016.mediawiki) | Base58 | `3` | Complex scripts (multisig, timelocks) as hash. Script revealed only when spending. |\n| **P2SH&#8209;P2WPKH** | Nested&#8209;SegWit | Aug 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | Base58 | `3` | P2WPKH wrapped in P2SH for backwards compatibility. Works with older wallets. |\n| **P2SH&#8209;P2WSH** | Nested&#8209;SegWit&#8209;Script | Aug 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | Base58 | `3` | P2WSH wrapped in P2SH. Complex scripts with SegWit benefits, backwards compatible. |\n| **P2WPKH** | Pay&#8209;to&#8209;Witness&#8209;Pubkey&#8209;Hash | Aug 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | [Bech32](/docs/glossary#bech32) | `bc1q` | Native [SegWit](/docs/glossary#segwit-segregated-witness). Lower fees, fixes [malleability](/docs/glossary#transaction-malleability). |\n| **P2WSH** | Pay&#8209;to&#8209;Witness&#8209;Script&#8209;Hash | Aug 2017 | 481,824 | [141](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki) | Bech32 | `bc1q` | Native SegWit for complex scripts. Used for multisig, timelocks with witness benefits. |\n| **P2TR** | Pay&#8209;to&#8209;Taproot | Nov 2021 | 709,632 | [341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) | Bech32m | `bc1p` | [Taproot](/docs/glossary#taproot) with [Schnorr](/docs/glossary#schnorr-signature) signatures and [MAST](/docs/glossary#mast-merkle-abstract-syntax-tree). Best privacy and efficiency. |\n\n**Example addresses:**\n- P2PKH: `1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa` (Satoshi's address)\n- P2SH / P2SH-P2WPKH: `3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy`\n- P2WPKH: `bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4`\n- P2TR: `bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297`\n\n**Note:** P2PK and P2MS have no address format; they use raw scripts. OP_RETURN outputs are unspendable and used for data embedding (max [~80 bytes](/docs/controversies/op-return)).\n\n---\n\n## Script Execution Examples\n\nEach script type has its own execution flow. The unlocking script runs first, then the locking script.\n\n### P2PK (Pay-to-Pubkey)\n\nThe simplest script: locks directly to a public key.\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `<pubkey> OP_CHECKSIG` |\n| **Unlocking** | `<signature>` |\n\n| Step | Operation | Stack |\n|------|-----------|-------|\n| 1 | Push `<signature>` | `[sig]` |\n| 2 | Push `<pubkey>` | `[sig, pubkey]` |\n| 3 | `OP_CHECKSIG` | `[1]` âœ… |\n\n<div class=\"divider-subtle\"></div>\n\n### P2PKH (Pay-to-Pubkey-Hash)\n\nMost common legacy type. Hides the public key until spending.\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_DUP OP_HASH160 <pubkeyhash> OP_EQUALVERIFY OP_CHECKSIG` |\n| **Unlocking** | `<signature> <publickey>` |\n\n| Step | Operation | Stack |\n|------|-----------|-------|\n| 1 | Push `<signature>` | `[sig]` |\n| 2 | Push `<publickey>` | `[sig, pubkey]` |\n| 3 | `OP_DUP` | `[sig, pubkey, pubkey]` |\n| 4 | `OP_HASH160` | `[sig, pubkey, hash160(pubkey)]` |\n| 5 | Push `<pubkeyhash>` | `[sig, pubkey, hash160(pubkey), pubkeyhash]` |\n| 6 | `OP_EQUALVERIFY` | `[sig, pubkey]` *(fails if hashes â‰ )* |\n| 7 | `OP_CHECKSIG` | `[1]` âœ… |\n\n<div class=\"divider-subtle\"></div>\n\n### P2MS (Bare Multisig)\n\nRequires m-of-n signatures. Example: 2-of-3.\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG` |\n| **Unlocking** | `OP_0 <sig1> <sig2>` |\n\n| Step | Operation | Stack |\n|------|-----------|-------|\n| 1 | Push `OP_0` (dummy) | `[0]` |\n| 2 | Push `<sig1>` | `[0, sig1]` |\n| 3 | Push `<sig2>` | `[0, sig1, sig2]` |\n| 4 | Push `OP_2` | `[0, sig1, sig2, 2]` |\n| 5 | Push pubkeys | `[0, sig1, sig2, 2, pk1, pk2, pk3]` |\n| 6 | Push `OP_3` | `[0, sig1, sig2, 2, pk1, pk2, pk3, 3]` |\n| 7 | `OP_CHECKMULTISIG` | `[1]` âœ… *(verifies 2 valid sigs from 3 keys)* |\n\n**Note:** `OP_0` is required due to an off-by-one bug in the original implementation.\n\n<div class=\"divider-subtle\"></div>\n\n### P2SH (Pay-to-Script-Hash)\n\nHides complex scripts behind a hash. Example wrapping a 2-of-3 multisig:\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_HASH160 <scripthash> OP_EQUAL` |\n| **Unlocking** | `OP_0 <sig1> <sig2> <redeemScript>` |\n\n| Step | Operation | Stack |\n|------|-----------|-------|\n| 1 | Push sigs + redeemScript | `[0, sig1, sig2, redeemScript]` |\n| 2 | `OP_HASH160` | `[0, sig1, sig2, hash160(redeemScript)]` |\n| 3 | Push `<scripthash>` | `[0, sig1, sig2, hash160(redeemScript), scripthash]` |\n| 4 | `OP_EQUAL` | `[0, sig1, sig2, 1]` *(if hashes match)* |\n| 5 | *Execute redeemScript* | `[1]` âœ… *(multisig verification)* |\n\n<div class=\"divider-subtle\"></div>\n\n### P2WPKH (Native SegWit)\n\nLike P2PKH but witness data is separate. Smaller, cheaper.\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_0 <20-byte-pubkeyhash>` |\n| **Witness** | `<signature> <publickey>` |\n\nExecution is similar to P2PKH, but signature/pubkey are in the witness (not scriptSig), so they don't count toward the base transaction size.\n\n<div class=\"divider-subtle\"></div>\n\n### P2WSH (Native SegWit Script)\n\nLike P2SH but with witness. Example: 2-of-3 multisig.\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_0 <32-byte-scripthash>` |\n| **Witness** | `OP_0 <sig1> <sig2> <witnessScript>` |\n\nThe witness script is hashed with SHA256 (not HASH160) and verified, then executed.\n\n<div class=\"divider-subtle\"></div>\n\n### P2TR (Taproot)\n\nTwo spending paths: key path (single sig) or script path (MAST).\n\n| Component | Script |\n|-----------|--------|\n| **Locking** | `OP_1 <32-byte-tweaked-pubkey>` |\n| **Witness (key path)** | `<schnorr-signature>` |\n\n**Key path:** Just provide a Schnorr signature. Looks identical to single-sig regardless of hidden scripts.\n\n**Script path:** Reveal the script and Merkle proof. Complex conditions stay hidden unless used.\n\n---\n\n## Locking Mechanisms\n\nBitcoin Script supports various ways to lock funds with different spending conditions.\n\n| Lock Type | Opcode | Use Cases | Script Pattern |\n|-----------|--------|-----------|----------------|\n| **Time Lock (Absolute)** | `OP_CHECKLOCKTIMEVERIFY` | Escrow, inheritance, vesting | `<time> OP_CLTV OP_DROP <pubkey> OP_CHECKSIG` |\n| **Time Lock (Relative)** | `OP_CHECKSEQUENCEVERIFY` | Payment channels, delayed spending | `<blocks> OP_CSV OP_DROP <pubkey> OP_CHECKSIG` |\n| **Multi-Signature** | `OP_CHECKMULTISIG` | Shared custody, corporate wallets | `OP_2 <pk1> <pk2> <pk3> OP_3 OP_CHECKMULTISIG` |\n| **Hash Lock** | `OP_HASH256` | Atomic swaps, HTLCs | `OP_HASH256 <hash> OP_EQUALVERIFY <pubkey> OP_CHECKSIG` |\n| **Conditional** | `OP_IF/OP_ELSE` | Multiple spending paths, refunds | `OP_IF <path1> OP_ELSE <path2> OP_ENDIF` |\n| **Data Embed** | `OP_RETURN` | Data storage, coin burning | `OP_RETURN <data>` |\n\n### Combined Locks\n\nLocks can be combined for complex conditions. Example: time-locked multisig with escape clause:\n\n```\nOP_IF\n  <locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP\n  OP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\nOP_ELSE\n  <pubkey4> OP_CHECKSIG\nOP_ENDIF\n```\n\n",
    "filename": "script.md"
  },
  "/docs/bitcoin/op-codes": {
    "content": "# OP Codes\n\nThe instruction set for Bitcoin. Bitcoin [Script](/docs/glossary#script) uses a stack-based programming language with various opcodes (operation codes) that perform different functions. This document provides a complete reference of Bitcoin OP codes with explanations and code examples. Try these opcodes in [Stack Lab](/stack-lab).\n\n## OP Code Categories\n\n| Category | Description | Examples |\n|----------|-------------|----------|\n| Stack Operations | Manipulate the stack | OP_DUP, OP_DROP, OP_SWAP |\n| Arithmetic | Mathematical operations | OP_ADD, OP_SUB |\n| Cryptographic | Hash functions and signatures | OP_SHA256, OP_CHECKSIG |\n| Comparison | Test conditions | OP_EQUAL, OP_LESSTHAN |\n| Control Flow | Conditional execution | OP_IF, OP_ELSE |\n| Time Locks | Transaction timing | OP_CLTV, OP_CSV |\n| Disabled | Removed for security | OP_MUL, OP_CAT |\n\n---\n\n## Script Execution Example\n\n:::code-group\n```rust\nuse std::collections::VecDeque;\n\n#[derive(Debug, Clone)]\nenum StackItem {\n    Bytes(Vec<u8>),\n    Int(i64),\n}\n\nstruct ScriptInterpreter {\n    stack: VecDeque<StackItem>,\n}\n\nimpl ScriptInterpreter {\n    fn new() -> Self {\n        Self { stack: VecDeque::new() }\n    }\n\n    fn push(&mut self, item: StackItem) {\n        self.stack.push_back(item);\n    }\n\n    fn pop(&mut self) -> Option<StackItem> {\n        self.stack.pop_back()\n    }\n\n    fn op_dup(&mut self) -> bool {\n        if let Some(top) = self.stack.back().cloned() {\n            self.stack.push_back(top);\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_add(&mut self) -> bool {\n        if let (Some(StackItem::Int(b)), Some(StackItem::Int(a))) = (self.pop(), self.pop()) {\n            self.push(StackItem::Int(a + b));\n            true\n        } else {\n            false\n        }\n    }\n\n    fn op_equal(&mut self) -> bool {\n        if let (Some(b), Some(a)) = (self.pop(), self.pop()) {\n            let equal = match (a, b) {\n                (StackItem::Int(x), StackItem::Int(y)) => x == y,\n                (StackItem::Bytes(x), StackItem::Bytes(y)) => x == y,\n                _ => false,\n            };\n            self.push(StackItem::Int(if equal { 1 } else { 0 }));\n            true\n        } else {\n            false\n        }\n    }\n}\n\nfn main() {\n    let mut interp = ScriptInterpreter::new();\n    \n    // Simulate: 5 3 OP_ADD 8 OP_EQUAL\n    interp.push(StackItem::Int(5));\n    interp.push(StackItem::Int(3));\n    interp.op_add();\n    interp.push(StackItem::Int(8));\n    interp.op_equal();\n    \n    println!(\"Result: {:?}\", interp.stack);  // [Int(1)] = true\n}\n```\n\n```python\nfrom typing import Union, List\nfrom hashlib import sha256, new as hashlib_new\n\nStackItem = Union[bytes, int]\n\nclass ScriptInterpreter:\n    def __init__(self):\n        self.stack: List[StackItem] = []\n\n    def push(self, item: StackItem):\n        self.stack.append(item)\n\n    def pop(self) -> StackItem:\n        return self.stack.pop()\n\n    def op_dup(self) -> bool:\n        \"\"\"OP_DUP: Duplicate top stack item.\"\"\"\n        if not self.stack:\n            return False\n        self.stack.append(self.stack[-1])\n        return True\n\n    def op_drop(self) -> bool:\n        \"\"\"OP_DROP: Remove top stack item.\"\"\"\n        if not self.stack:\n            return False\n        self.stack.pop()\n        return True\n\n    def op_add(self) -> bool:\n        \"\"\"OP_ADD: Add top two items.\"\"\"\n        if len(self.stack) < 2:\n            return False\n        b, a = self.pop(), self.pop()\n        self.push(a + b)\n        return True\n\n    def op_equal(self) -> bool:\n        \"\"\"OP_EQUAL: Check if top two items are equal.\"\"\"\n        if len(self.stack) < 2:\n            return False\n        b, a = self.pop(), self.pop()\n        self.push(1 if a == b else 0)\n        return True\n\n    def op_hash160(self) -> bool:\n        \"\"\"OP_HASH160: SHA256 then RIPEMD160.\"\"\"\n        if not self.stack:\n            return False\n        data = self.pop()\n        if isinstance(data, int):\n            data = data.to_bytes((data.bit_length() + 7) // 8, 'little')\n        sha = sha256(data).digest()\n        ripemd = hashlib_new('ripemd160', sha).digest()\n        self.push(ripemd)\n        return True\n\n# Example: 5 + 3 = 8 ?\ninterp = ScriptInterpreter()\ninterp.push(5)\ninterp.push(3)\ninterp.op_add()\ninterp.push(8)\ninterp.op_equal()\nprint(f\"Result: {interp.stack}\")  # [1] = true\n```\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <variant>\n#include <cstdint>\n\nusing StackItem = std::variant<std::vector<uint8_t>, int64_t>;\n\nclass ScriptInterpreter {\nprivate:\n    std::vector<StackItem> stack;\n\npublic:\n    void push(StackItem item) {\n        stack.push_back(std::move(item));\n    }\n\n    StackItem pop() {\n        auto item = std::move(stack.back());\n        stack.pop_back();\n        return item;\n    }\n\n    bool op_dup() {\n        if (stack.empty()) return false;\n        stack.push_back(stack.back());\n        return true;\n    }\n\n    bool op_add() {\n        if (stack.size() < 2) return false;\n        auto b = std::get<int64_t>(pop());\n        auto a = std::get<int64_t>(pop());\n        push(a + b);\n        return true;\n    }\n\n    bool op_equal() {\n        if (stack.size() < 2) return false;\n        auto b = pop();\n        auto a = pop();\n        push(static_cast<int64_t>(a == b ? 1 : 0));\n        return true;\n    }\n\n    void print_stack() const {\n        std::cout << \"Stack: [\";\n        for (const auto& item : stack) {\n            if (std::holds_alternative<int64_t>(item)) {\n                std::cout << std::get<int64_t>(item) << \" \";\n            }\n        }\n        std::cout << \"]\" << std::endl;\n    }\n};\n\nint main() {\n    ScriptInterpreter interp;\n    \n    // Simulate: 5 3 OP_ADD 8 OP_EQUAL\n    interp.push(int64_t{5});\n    interp.push(int64_t{3});\n    interp.op_add();\n    interp.push(int64_t{8});\n    interp.op_equal();\n    \n    interp.print_stack();  // [1] = true\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"golang.org/x/crypto/ripemd160\"\n)\n\ntype StackItem interface{}\n\ntype ScriptInterpreter struct {\n\tstack []StackItem\n}\n\nfunc NewScriptInterpreter() *ScriptInterpreter {\n\treturn &ScriptInterpreter{\n\t\tstack: make([]StackItem, 0),\n\t}\n}\n\nfunc (si *ScriptInterpreter) Push(item StackItem) {\n\tsi.stack = append(si.stack, item)\n}\n\nfunc (si *ScriptInterpreter) Pop() (StackItem, bool) {\n\tif len(si.stack) == 0 {\n\t\treturn nil, false\n\t}\n\titem := si.stack[len(si.stack)-1]\n\tsi.stack = si.stack[:len(si.stack)-1]\n\treturn item, true\n}\n\nfunc (si *ScriptInterpreter) OpDup() bool {\n\tif len(si.stack) == 0 {\n\t\treturn false\n\t}\n\tsi.stack = append(si.stack, si.stack[len(si.stack)-1])\n\treturn true\n}\n\nfunc (si *ScriptInterpreter) OpDrop() bool {\n\tif len(si.stack) == 0 {\n\t\treturn false\n\t}\n\tsi.stack = si.stack[:len(si.stack)-1]\n\treturn true\n}\n\nfunc (si *ScriptInterpreter) OpAdd() bool {\n\tif len(si.stack) < 2 {\n\t\treturn false\n\t}\n\tb, _ := si.Pop()\n\ta, _ := si.Pop()\n\t\n\tbInt, bOk := b.(int)\n\taInt, aOk := a.(int)\n\tif !aOk || !bOk {\n\t\treturn false\n\t}\n\tsi.Push(aInt + bInt)\n\treturn true\n}\n\nfunc (si *ScriptInterpreter) OpEqual() bool {\n\tif len(si.stack) < 2 {\n\t\treturn false\n\t}\n\tb, _ := si.Pop()\n\ta, _ := si.Pop()\n\t\n\tvar equal bool\n\tswitch aVal := a.(type) {\n\tcase int:\n\t\tif bVal, ok := b.(int); ok {\n\t\t\tequal = aVal == bVal\n\t\t}\n\tcase []byte:\n\t\tif bVal, ok := b.([]byte); ok {\n\t\t\tequal = string(aVal) == string(bVal)\n\t\t}\n\tdefault:\n\t\tequal = false\n\t}\n\t\n\tif equal {\n\t\tsi.Push(1)\n\t} else {\n\t\tsi.Push(0)\n\t}\n\treturn true\n}\n\nfunc (si *ScriptInterpreter) OpHash160() bool {\n\tif len(si.stack) == 0 {\n\t\treturn false\n\t}\n\tdata, _ := si.Pop()\n\t\n\tvar dataBytes []byte\n\tswitch v := data.(type) {\n\tcase []byte:\n\t\tdataBytes = v\n\tcase int:\n\t\tdataBytes = []byte{byte(v)}\n\tdefault:\n\t\treturn false\n\t}\n\t\n\tsha := sha256.Sum256(dataBytes)\n\thasher := ripemd160.New()\n\thasher.Write(sha[:])\n\tripemd := hasher.Sum(nil)\n\tsi.Push(ripemd)\n\treturn true\n}\n\nfunc main() {\n\tinterp := NewScriptInterpreter()\n\t\n\t// Simulate: 5 3 OP_ADD 8 OP_EQUAL\n\tinterp.Push(5)\n\tinterp.Push(3)\n\tinterp.OpAdd()\n\tinterp.Push(8)\n\tinterp.OpEqual()\n\t\n\tfmt.Printf(\"Result: %v\\n\", interp.stack) // [1] = true\n}\n```\n\n```javascript\nclass ScriptInterpreter {\n    constructor() {\n        this.stack = [];\n    }\n\n    push(item) {\n        this.stack.push(item);\n    }\n\n    pop() {\n        return this.stack.pop();\n    }\n\n    opDup() {\n        if (this.stack.length === 0) return false;\n        this.stack.push(this.stack[this.stack.length - 1]);\n        return true;\n    }\n\n    opDrop() {\n        if (this.stack.length === 0) return false;\n        this.stack.pop();\n        return true;\n    }\n\n    opAdd() {\n        if (this.stack.length < 2) return false;\n        const b = this.pop();\n        const a = this.pop();\n        this.push(a + b);\n        return true;\n    }\n\n    opEqual() {\n        if (this.stack.length < 2) return false;\n        const b = this.pop();\n        const a = this.pop();\n        // Deep comparison for buffers\n        const equal = Buffer.isBuffer(a) && Buffer.isBuffer(b) \n            ? a.equals(b) \n            : a === b;\n        this.push(equal ? 1 : 0);\n        return true;\n    }\n\n    opHash160() {\n        if (this.stack.length === 0) return false;\n        const crypto = require('crypto');\n        const data = this.pop();\n        const sha = crypto.createHash('sha256').update(data).digest();\n        const ripemd = crypto.createHash('ripemd160').update(sha).digest();\n        this.push(ripemd);\n        return true;\n    }\n}\n\n// Example: 5 + 3 = 8 ?\nconst interp = new ScriptInterpreter();\ninterp.push(5);\ninterp.push(3);\ninterp.opAdd();\ninterp.push(8);\ninterp.opEqual();\nconsole.log('Result:', interp.stack);  // [1] = true\n```\n:::\n\n---\n\n## Stack Operations\n\n| OP Code | Hex | Function |\n|---------|-----|----------|\n| OP_DUP | 0x76 | Duplicates top stack item |\n| OP_DROP | 0x75 | Removes top stack item |\n| OP_SWAP | 0x7c | Swaps top two items |\n| OP_OVER | 0x78 | Copies second-to-top to top |\n| OP_ROT | 0x7b | Rotates top three items |\n| OP_PICK | 0x79 | Copies nth item to top |\n| OP_ROLL | 0x7a | Moves nth item to top |\n| OP_2DROP | 0x6d | Removes top two items |\n| OP_2DUP | 0x6e | Duplicates top two items |\n| OP_3DUP | 0x6f | Duplicates top three items |\n| OP_NIP | 0x77 | Removes second-to-top item |\n| OP_TUCK | 0x7d | Copies top below second |\n\n### Examples\n\n```\nOP_DUP:\n  Before: [A]\n  After:  [A, A]\n\nOP_SWAP:\n  Before: [A, B]\n  After:  [B, A]\n\nOP_ROT:\n  Before: [A, B, C]\n  After:  [B, C, A]\n```\n\n---\n\n## Arithmetic Operations\n\n| OP Code | Hex | Function | Status |\n|---------|-----|----------|--------|\n| OP_ADD | 0x93 | a + b | Active |\n| OP_SUB | 0x94 | a - b | Active |\n| OP_1ADD | 0x8b | a + 1 | Active |\n| OP_1SUB | 0x8c | a - 1 | Active |\n| OP_NEGATE | 0x8f | -a | Active |\n| OP_ABS | 0x90 | abs(a) | Active |\n| OP_NOT | 0x91 | !a (logical) | Active |\n| OP_0NOTEQUAL | 0x92 | a != 0 | Active |\n| OP_MUL | 0x95 | a * b | **Disabled** |\n| OP_DIV | 0x96 | a / b | **Disabled** |\n| OP_MOD | 0x97 | a % b | **Disabled** |\n| OP_LSHIFT | 0x98 | a << b | **Disabled** |\n| OP_RSHIFT | 0x99 | a >> b | **Disabled** |\n\n> **Note**: OP_MUL, OP_DIV, OP_MOD, OP_LSHIFT, and OP_RSHIFT were disabled early in Bitcoin's history to prevent potential denial-of-service attacks through expensive computations.\n\n---\n\n## Comparison Operations\n\n| OP Code | Hex | Function |\n|---------|-----|----------|\n| OP_EQUAL | 0x87 | Returns 1 if equal, else 0 |\n| OP_EQUALVERIFY | 0x88 | OP_EQUAL + OP_VERIFY |\n| OP_LESSTHAN | 0x9f | a < b |\n| OP_GREATERTHAN | 0xa0 | a > b |\n| OP_LESSTHANOREQUAL | 0xa1 | a <= b |\n| OP_GREATERTHANOREQUAL | 0xa2 | a >= b |\n| OP_MIN | 0xa3 | min(a, b) |\n| OP_MAX | 0xa4 | max(a, b) |\n| OP_WITHIN | 0xa5 | min <= x < max |\n\n---\n\n## Cryptographic Operations\n\n| OP Code | Hex | Function |\n|---------|-----|----------|\n| OP_RIPEMD160 | 0xa6 | [RIPEMD-160](/docs/glossary#ripemd-160) hash |\n| OP_SHA1 | 0xa7 | SHA-1 hash |\n| OP_SHA256 | 0xa8 | [SHA-256](/docs/glossary#sha-256) hash |\n| OP_HASH160 | 0xa9 | SHA256 + RIPEMD160 |\n| OP_HASH256 | 0xaa | Double SHA-256 |\n| OP_CHECKSIG | 0xac | Verify [ECDSA](/docs/glossary#ecdsa-elliptic-curve-digital-signature-algorithm) signature |\n| OP_CHECKSIGVERIFY | 0xad | OP_CHECKSIG + OP_VERIFY |\n| OP_CHECKMULTISIG | 0xae | Verify [multisig](/docs/glossary#multisig-multi-signature) |\n| OP_CHECKMULTISIGVERIFY | 0xaf | OP_CHECKMULTISIG + OP_VERIFY |\n\n---\n\n## Bitwise Operations (Disabled)\n\n| OP Code | Hex | Function | Status |\n|---------|-----|----------|--------|\n| OP_AND | 0x84 | Bitwise AND | **Disabled** |\n| OP_OR | 0x85 | Bitwise OR | **Disabled** |\n| OP_XOR | 0x86 | Bitwise XOR | **Disabled** |\n| OP_INVERT | 0x83 | Bitwise NOT | **Disabled** |\n\nThese were disabled to prevent potential vulnerabilities in early Bitcoin.\n\n---\n\n## Control Flow\n\n| OP Code | Hex | Function |\n|---------|-----|----------|\n| OP_IF | 0x63 | Execute if top is non-zero |\n| OP_NOTIF | 0x64 | Execute if top is zero |\n| OP_ELSE | 0x67 | Else branch |\n| OP_ENDIF | 0x68 | End conditional |\n| OP_VERIFY | 0x69 | Fail if top is false |\n| OP_RETURN | 0x6a | Mark output unspendable |\n\n### Conditional Example\n\n```\n<condition>\nOP_IF\n    <execute if true>\nOP_ELSE\n    <execute if false>\nOP_ENDIF\n```\n\n---\n\n## Time Lock Operations\n\n### [OP_CHECKLOCKTIMEVERIFY](/docs/glossary#cltv-checklocktimeverify) (CLTV)\n\n**Code**: `0xb1`\n\nVerifies the transaction's nLockTime is at least the specified value (absolute time lock).\n\n```\n<locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\nUse cases:\n- Payment channels\n- Time-locked savings\n- Inheritance planning\n\n### [OP_CHECKSEQUENCEVERIFY](/docs/glossary#csv-checksequenceverify) (CSV)\n\n**Code**: `0xb2`\n\nVerifies the input's sequence number enforces a relative time lock.\n\n```\n<relative_locktime> OP_CHECKSEQUENCEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n```\n\nUse cases:\n- [Lightning Network](/docs/glossary#lightning-network) [HTLCs](/docs/glossary#htlc-hash-time-locked-contract)\n- Escrow with timeout\n- Revocable transactions\n\n---\n\n## Push Operations\n\n| OP Code | Hex | Function |\n|---------|-----|----------|\n| OP_0 / OP_FALSE | 0x00 | Push empty array (false) |\n| OP_1NEGATE | 0x4f | Push -1 |\n| OP_1 / OP_TRUE | 0x51 | Push 1 |\n| OP_2 - OP_16 | 0x52-0x60 | Push 2-16 |\n| OP_PUSHDATA1 | 0x4c | Next byte is length |\n| OP_PUSHDATA2 | 0x4d | Next 2 bytes are length |\n| OP_PUSHDATA4 | 0x4e | Next 4 bytes are length |\n\n---\n\n## Tapscript Opcodes (BIP 342)\n\nTaproot introduced new opcodes for Tapscript:\n\n### OP_CHECKSIGADD\n\n**Code**: `0xba`\n\nEnables efficient [Schnorr](/docs/glossary#schnorr-signature) signature aggregation for multisig.\n\n```\n<pubkey1> OP_CHECKSIG\n<pubkey2> OP_CHECKSIGADD\n<pubkey3> OP_CHECKSIGADD\n<threshold> OP_NUMEQUAL\n```\n\nBenefits over OP_CHECKMULTISIG:\n- No dummy element needed\n- More efficient batch validation\n- Works with Schnorr signatures\n\n### OP_SUCCESS Opcodes\n\nCodes `0x50, 0x62, 0x89-0x8a, 0x8d-0x8e, 0x95-0x99, 0xbb-0xfe`\n\nReserved for future upgrades. Any script containing these immediately succeeds, allowing soft fork upgrades.\n\n---\n\n## Disabled Opcodes\n\nThese opcodes were disabled for security reasons:\n\n| OP Code | Hex | Reason |\n|---------|-----|--------|\n| OP_CAT | 0x7e | Could create oversized scripts |\n| OP_SUBSTR | 0x7f | Security concerns |\n| OP_LEFT | 0x80 | Security concerns |\n| OP_RIGHT | 0x81 | Security concerns |\n| OP_INVERT | 0x83 | Security concerns |\n| OP_AND | 0x84 | Security concerns |\n| OP_OR | 0x85 | Security concerns |\n| OP_XOR | 0x86 | Security concerns |\n| OP_2MUL | 0x8d | Can be done with OP_ADD |\n| OP_2DIV | 0x8e | Security concerns |\n| OP_MUL | 0x95 | Expensive computation |\n| OP_DIV | 0x96 | Division by zero issues |\n| OP_MOD | 0x97 | Division by zero issues |\n| OP_LSHIFT | 0x98 | Could create large numbers |\n| OP_RSHIFT | 0x99 | Security concerns |\n\n> **OP_CAT Revival**: There is ongoing discussion about re-enabling OP_CAT with proper limits, as it would enable new use cases like covenants.\n\n---\n\n## Common Script Patterns\n\n### [P2PKH](/docs/glossary#p2pkh-pay-to-pubkey-hash) (Pay-to-Pubkey-Hash)\n\n```\nLocking Script (scriptPubKey):\nOP_DUP OP_HASH160 <pubkeyhash> OP_EQUALVERIFY OP_CHECKSIG\n\nUnlocking Script (scriptSig):\n<signature> <publickey>\n```\n\n### [P2SH](/docs/glossary#p2sh-pay-to-script-hash) (Pay-to-Script-Hash)\n\n```\nLocking Script:\nOP_HASH160 <scripthash> OP_EQUAL\n\nUnlocking Script:\n<data> ... <redeemscript>\n```\n\n### [Multisig](/docs/glossary#multisig-multi-signature) (2-of-3)\n\n```\nLocking Script:\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n\nUnlocking Script:\nOP_0 <sig1> <sig2>\n```\n\nNote: OP_0 is required due to a bug in OP_CHECKMULTISIG that pops one extra item.\n\n### HTLC (Hash Time-Locked Contract)\n\n```\nOP_IF\n    OP_SHA256 <hash> OP_EQUALVERIFY\n    <receiver_pubkey> OP_CHECKSIG\nOP_ELSE\n    <timeout> OP_CHECKLOCKTIMEVERIFY OP_DROP\n    <sender_pubkey> OP_CHECKSIG\nOP_ENDIF\n```\n\n---\n\n## Script Limits\n\n| Limit | Value | Purpose |\n|-------|-------|---------|\n| Max script size | 10,000 bytes | Prevent oversized scripts |\n| Max stack size | 1,000 items | Prevent stack overflow |\n| Max item size | 520 bytes | Prevent oversized items |\n| Max ops per script | 201 | Prevent expensive scripts |\n| Max multisig keys | 20 | Limit signature checks |\n| Max Tapscript size | No limit* | Weight-based limits apply |\n\n*Tapscript has no explicit size limit but is constrained by block weight.\n\n---\n\n## OP Code Quick Reference\n\n| Hex | Name | Description | Status |\n|-----|------|-------------|--------|\n| 0x00 | OP_0 | Push empty array | Active |\n| 0x4f | OP_1NEGATE | Push -1 | Active |\n| 0x51-0x60 | OP_1-OP_16 | Push 1-16 | Active |\n| 0x63 | OP_IF | Conditional | Active |\n| 0x64 | OP_NOTIF | Conditional | Active |\n| 0x67 | OP_ELSE | Conditional | Active |\n| 0x68 | OP_ENDIF | Conditional | Active |\n| 0x69 | OP_VERIFY | Verify | Active |\n| 0x6a | OP_RETURN | Data carrier | Active |\n| 0x75 | OP_DROP | Remove top | Active |\n| 0x76 | OP_DUP | Duplicate top | Active |\n| 0x77 | OP_NIP | Remove second | Active |\n| 0x78 | OP_OVER | Copy second | Active |\n| 0x79 | OP_PICK | Copy nth | Active |\n| 0x7a | OP_ROLL | Move nth | Active |\n| 0x7b | OP_ROT | Rotate 3 | Active |\n| 0x7c | OP_SWAP | Swap 2 | Active |\n| 0x7d | OP_TUCK | Tuck top | Active |\n| 0x7e | OP_CAT | Concatenate | Disabled |\n| 0x84 | OP_AND | Bitwise AND | Disabled |\n| 0x85 | OP_OR | Bitwise OR | Disabled |\n| 0x86 | OP_XOR | Bitwise XOR | Disabled |\n| 0x87 | OP_EQUAL | Equality | Active |\n| 0x88 | OP_EQUALVERIFY | Equal + verify | Active |\n| 0x93 | OP_ADD | Addition | Active |\n| 0x94 | OP_SUB | Subtraction | Active |\n| 0x95 | OP_MUL | Multiplication | Disabled |\n| 0x96 | OP_DIV | Division | Disabled |\n| 0x97 | OP_MOD | Modulo | Disabled |\n| 0xa6 | OP_RIPEMD160 | RIPEMD160 | Active |\n| 0xa7 | OP_SHA1 | SHA1 | Active |\n| 0xa8 | OP_SHA256 | SHA256 | Active |\n| 0xa9 | OP_HASH160 | SHA256+RIPEMD160 | Active |\n| 0xaa | OP_HASH256 | Double SHA256 | Active |\n| 0xac | OP_CHECKSIG | Check signature | Active |\n| 0xae | OP_CHECKMULTISIG | Check multisig | Active |\n| 0xb1 | OP_CLTV | Absolute timelock | Active |\n| 0xb2 | OP_CSV | Relative timelock | Active |\n| 0xba | OP_CHECKSIGADD | Tapscript multisig | Active |\n\n---\n\n## Related Topics\n\n- [Script System](/docs/bitcoin/script): How Bitcoin Script works\n- [OP_RETURN Debate](/docs/controversies/op-return): Controversy about data storage\n- [Taproot](/docs/glossary#taproot) - Schnorr signatures and Tapscript\n\n---\n\n## Resources\n\n- **[Bitcoin Wiki: Script](https://en.bitcoin.it/wiki/Script)**: Complete script reference\n- **[BIP 342: Tapscript](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)**: Tapscript specification\n- **[Learn Me a Bitcoin: Script](https://learnmeabitcoin.com/technical/script/)**: Visual script explanations\n",
    "filename": "op-codes.md"
  },
  "/docs/bitcoin/timelocks": {
    "content": "# Timelocks\n\nTimelocks prevent Bitcoin from being spent until certain time conditions are met. Bitcoin supports two types of timelocks: absolute (CLTV) and relative (CSV).\n\n## Types of Timelocks\n\n### Absolute Timelocks (CLTV)\n\n**CheckLockTimeVerify (CLTV)** prevents spending until a specific block height or Unix timestamp:\n\n```text\nExample:\n\"Can't spend until block 800,000\"\n\"Can't spend until January 1, 2025\"\n```\n\n### Relative Timelocks (CSV)\n\n**CheckSequenceVerify (CSV)** prevents spending until a certain time has passed since the UTXO was created:\n\n```text\nExample:\n\"Can't spend until 1000 blocks after this UTXO was confirmed\"\n\"Can't spend until 2 weeks after creation\"\n```\n\n---\n\n## Use Cases\n\n### Escrow\n\nHold funds until a dispute period expires:\n\n```text\nEscrow Contract:\n1. Funds locked with timelock\n2. Dispute period: 30 days\n3. After 30 days, funds can be released\n```\n\n### Inheritance\n\nTime-delayed access to funds:\n\n```text\nInheritance Scheme:\n1. Funds locked until specific date\n2. Beneficiary can claim after date\n3. Prevents immediate access\n```\n\n### Lightning Network\n\nHTLCs use timelocks for payment routing:\n\n```text\nHTLC Timelock:\n1. Payment locked with hash\n2. Timelock prevents indefinite locking\n3. Refund if not claimed in time\n```\n\n### Vesting\n\nGradual release of funds:\n\n```text\nVesting Schedule:\n- 25% after 1 year\n- 25% after 2 years\n- 50% after 3 years\n```\n\n---\n\n## Code Examples\n\n### Creating CLTV Timelock\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\nuse bitcoin::locktime::absolute::LockTime;\n\nfn create_cltv_script(locktime: LockTime, pubkey_hash: &[u8; 20]) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    script.push_slice(locktime.to_consensus_u32().to_le_bytes());\n    script.push_opcode(OP_CHECKLOCKTIMEVERIFY);\n    script.push_opcode(OP_DROP);\n    script.push_slice(pubkey_hash);\n    script.push_opcode(OP_CHECKSIG);\n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_CHECKLOCKTIMEVERIFY, OP_DROP, OP_CHECKSIG\n\ndef create_cltv_script(locktime, pubkey_hash):\n    \"\"\"Create CLTV timelock script.\"\"\"\n    return CScript([\n        locktime,  # Block height or timestamp\n        OP_CHECKLOCKTIMEVERIFY,\n        OP_DROP,\n        pubkey_hash,\n        OP_CHECKSIG,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::script create_cltv_script(\n    uint32_t locktime,\n    const bc::short_hash& pubkey_hash\n) {\n    bc::script script;\n    script.push_data(bc::to_chunk(locktime));\n    script.push_operation(bc::opcode::checklocktimeverify);\n    script.push_operation(bc::opcode::drop);\n    script.push_data(bc::to_chunk(pubkey_hash));\n    script.push_operation(bc::opcode::checksig);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createCLTVScript(locktime uint32, pubkeyHash []byte) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(int64(locktime))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddData(pubkeyHash)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createCLTVScript(locktime, pubkeyHash) {\n    return bitcoin.script.compile([\n        bitcoin.script.number.encode(locktime),\n        bitcoin.opcodes.OP_CHECKLOCKTIMEVERIFY,\n        bitcoin.opcodes.OP_DROP,\n        pubkeyHash,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n}\n```\n:::\n\n### Creating CSV Timelock\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\n\nfn create_csv_script(relative_blocks: u32, pubkey_hash: &[u8; 20]) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    script.push_slice(relative_blocks.to_le_bytes());\n    script.push_opcode(OP_CHECKSEQUENCEVERIFY);\n    script.push_opcode(OP_DROP);\n    script.push_slice(pubkey_hash);\n    script.push_opcode(OP_CHECKSIG);\n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_CHECKSEQUENCEVERIFY, OP_DROP, OP_CHECKSIG\n\ndef create_csv_script(relative_blocks, pubkey_hash):\n    \"\"\"Create CSV relative timelock script.\"\"\"\n    return CScript([\n        relative_blocks,  # Blocks to wait\n        OP_CHECKSEQUENCEVERIFY,\n        OP_DROP,\n        pubkey_hash,\n        OP_CHECKSIG,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::script create_csv_script(\n    uint32_t relative_blocks,\n    const bc::short_hash& pubkey_hash\n) {\n    bc::script script;\n    script.push_data(bc::to_chunk(relative_blocks));\n    script.push_operation(bc::opcode::checksequenceverify);\n    script.push_operation(bc::opcode::drop);\n    script.push_data(bc::to_chunk(pubkey_hash));\n    script.push_operation(bc::opcode::checksig);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createCSVScript(relativeBlocks uint32, pubkeyHash []byte) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(int64(relativeBlocks))\n\tbuilder.AddOp(txscript.OP_CHECKSEQUENCEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddData(pubkeyHash)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createCSVScript(relativeBlocks, pubkeyHash) {\n    return bitcoin.script.compile([\n        bitcoin.script.number.encode(relativeBlocks),\n        bitcoin.opcodes.OP_CHECKSEQUENCEVERIFY,\n        bitcoin.opcodes.OP_DROP,\n        pubkeyHash,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n}\n```\n:::\n\n---\n\n## Transaction-Level Timelocks\n\n### nLockTime\n\nTransaction-level absolute timelock:\n\n```text\nTransaction:\nâ”œâ”€â”€ nLockTime: Block height or timestamp\nâ””â”€â”€ nSequence: Must be < 0xFFFFFFFF for nLockTime to work\n```\n\n### nSequence\n\nTransaction-level relative timelock (when used with CSV):\n\n```text\nTransaction:\nâ”œâ”€â”€ nSequence: Relative locktime value\nâ””â”€â”€ Script: OP_CHECKSEQUENCEVERIFY\n```\n\n---\n\n## Technical Details\n\n### CLTV (BIP 65)\n\n- **Activated**: December 2015 (block 388,381)\n- **Opcode**: `OP_CHECKLOCKTIMEVERIFY` (0xb1)\n- **Checks**: Transaction's `nLockTime` field\n- **Values**: Block height (< 500,000,000) or Unix timestamp (â‰¥ 500,000,000)\n\n### CSV (BIP 112)\n\n- **Activated**: July 2016 (block 419,328)\n- **Opcode**: `OP_CHECKSEQUENCEVERIFY` (0xb2)\n- **Checks**: Transaction's `nSequence` field\n- **Values**: Blocks (mask 0x0000FFFF) or seconds (mask 0x40000000)\n\n---\n\n## Lightning Network Usage\n\n### HTLC Timelocks\n\nLightning uses timelocks for HTLCs:\n\n```text\nHTLC Structure:\nâ”œâ”€â”€ Hash lock: Reveal preimage\nâ””â”€â”€ Time lock: Refund if not claimed\n\nTimelock ensures:\n- Payments don't get stuck forever\n- Refunds are possible\n- Routing nodes have time to respond\n```\n\n### Channel Timelocks\n\nForce-close channels use timelocks:\n\n```text\nForce Close:\n1. Broadcast commitment transaction\n2. Wait for timelock (typically 144-2016 blocks)\n3. Access funds after timelock expires\n```\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Use appropriate timelocks**: Don't lock funds too long\n2. **Test timelock logic**: Verify conditions work correctly\n3. **Handle timelock expiry**: Plan for what happens after unlock\n4. **Consider median time**: CSV uses median time, not block time\n\n### For Users\n\n1. **Understand lock duration**: Know when funds become available\n2. **Plan ahead**: Don't lock funds you need immediately\n3. **Verify timelocks**: Check that conditions are correct\n\n---\n\n## Related Topics\n\n- [Bitcoin Script](/docs/bitcoin/script) - Script system overview\n- [OP Codes](/docs/bitcoin/op-codes) - Script opcodes\n- [Lightning Network](/docs/lightning) - Uses timelocks extensively\n- [Smart Contracts](/docs/wallets/smart-contracts) - Advanced timelock patterns\n\n---\n\n## Resources\n\n- [BIP 65: OP_CHECKLOCKTIMEVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki)\n- [BIP 112: OP_CHECKSEQUENCEVERIFY](https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki)\n- [BIP 68: Relative Lock-time](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)\n",
    "filename": "timelocks.md"
  },
  "/docs/bitcoin/sighash-types": {
    "content": "# Sighash Types\n\nWhen you sign a Bitcoin [transaction](/docs/bitcoin/transaction-lifecycle), the signature does not cover the raw transaction bytes. Instead, the signer first builds a **signature hash** (sighash): a structured digest of *parts* of the transaction. The **sighash type** (a byte appended to the signature or encoded in it) selects *which* parts are included. This controls what the signer commits to and what can be changed without invalidating the signature.\n\nUnderstanding sighash types is important for transaction construction, [smart contracts](/docs/wallets/smart-contracts), [RBF](/docs/bitcoin/transaction-fees#replace-by-fee-rbf-and-bip-125), and proposed upgrades such as [SIGHASH_ANYPREVOUT](/docs/advanced/covenants).\n\n## The Sighash (Signature Hash)\n\nFor each input, the signer:\n\n1. Builds a **sighash** from the transaction according to the sighash type.\n2. Signs the sighash with the private key.\n3. The signature (plus the sighash type byte) is placed in the [witness](/docs/glossary#witness) or [scriptSig](/docs/glossary#scriptsig).\n\nVerifiers recompute the sighash the same way and check the signature against it. If the transaction is modified in a part that was included in the sighash, the signature fails.\n\n---\n\n## Sighash Type Byte\n\nThe sighash type is one byte. Its bits mean:\n\n- **Low 3 bits** (mask `0x1f`): base type\n- **Bit 0x80** (`SIGHASH_ANYONECANPAY`): if set, only the *current* input is included in the sighash; other inputs are not committed to.\n\nSo `SIGHASH_ALL | SIGHASH_ANYONECANPAY` means â€œcommit to all outputs and to this input only; other inputs can change.â€\n\n---\n\n## Standard Sighash Types\n\n### SIGHASH_ALL (0x01)\n\n**Default and most common.** The sighash includes:\n\n- Version, [locktime](/docs/glossary#locktime)\n- All inputs (or only the current one if `ANYONECANPAY` is set): [outpoint](/docs/glossary#outpoint), [script](/docs/bitcoin/script) (or scriptCode for [SegWit](/docs/bitcoin/segwit)), sequence\n- All outputs: value and [scriptPubKey](/docs/glossary#scriptpubkey)\n\nThe signer commits to the whole [transaction](/docs/bitcoin/transaction-lifecycle) (or to all outputs and only this input with `ANYONECANPAY`). Changing any committed part invalidates the signature. For [SegWit](/docs/bitcoin/segwit) and [Taproot](/docs/bitcoin/taproot), the default used in most wallets is `SIGHASH_DEFAULT`, which is treated like `SIGHASH_ALL` (see below).\n\n### SIGHASH_NONE (0x02)\n\nThe sighash includes all inputs (or only the current one with `ANYONECANPAY`) but **no outputs**. The signer does not commit to where the BTC goes. Someone else can add or change outputs. Rarely used; required for some [contract](/docs/wallets/smart-contracts) patterns.\n\n### SIGHASH_SINGLE (0x03)\n\nThe sighash includes all inputs (or only the current one with `ANYONECANPAY`) and **only the output at the same index as the signed input**. Other outputs are not committed. If there is no output at that index, the sighash is defined as `0x01` repeated 32 times (invalid to sign). Useful when the signer only cares about â€œmy input goes to the output at my index.â€\n\n### SIGHASH_ANYONECANPAY (0x80)\n\nThis is a **flag** ORâ€™d with `ALL`, `NONE`, or `SINGLE`:\n\n- **SIGHASH_ALL | ANYONECANPAY (0x81)**: Commit to all outputs and only *this* input. Other inputs can be added or changed. Used for CoinJoin and similar: each signer signs only their input and agrees to the output set.\n- **SIGHASH_NONE | ANYONECANPAY (0x82)**: Commit only to this input; no outputs. Rare.\n- **SIGHASH_SINGLE | ANYONECANPAY (0x83)**: Commit only to this input and the output at the same index. Rare.\n\n---\n\n## SIGHASH_DEFAULT (0x00) and Taproot\n\nFor [Taproot](/docs/bitcoin/taproot) (and commonly for [SegWit](/docs/bitcoin/segwit) v0), the value **0x00** is used to mean **default** behavior: it is interpreted as **SIGHASH_ALL** (commit to all inputs and outputs). The extra byte is omitted in the signature encoding when the type is default, so the signature is 64 bytes for [Schnorr](/docs/bitcoin/cryptography#schnorr-signatures) rather than 65.\n\n---\n\n## Summary Table\n\n| Type | Name | Inputs in sighash | Outputs in sighash |\n|------|------|-------------------|--------------------|\n| 0x01 | SIGHASH_ALL | All (or current with 0x80) | All |\n| 0x02 | SIGHASH_NONE | All (or current with 0x80) | None |\n| 0x03 | SIGHASH_SINGLE | All (or current with 0x80) | Output at same index |\n| 0x80 | ANYONECANPAY | Bit flag: only current input | (depends on base) |\n| 0x00 | SIGHASH_DEFAULT | Treated as ALL | Treated as ALL |\n\n---\n\n## Use Cases\n\n- **Normal payments**: [SIGHASH_ALL](/docs/glossary#sighash) or SIGHASH_DEFAULT. Full commitment to the [transaction](/docs/bitcoin/transaction-lifecycle).\n- **[RBF](/docs/bitcoin/transaction-fees#replace-by-fee-rbf-and-bip-125)**: Same; the replacement is a new [transaction](/docs/bitcoin/transaction-lifecycle) with new signatures. Sighash types do not change.\n- **[CoinJoin](/docs/wallets/privacy)**: SIGHASH_ALL | SIGHASH_ANYONECANPAY so each participant signs only their input and agrees to the common outputs.\n- **Contract / [Covenant](/docs/advanced/covenants) designs**: SIGHASH_NONE, SIGHASH_SINGLE, or ANYONECANPAY can be used so that the signer does not commit to all outputs or all inputs. Proposed **SIGHASH_ANYPREVOUT** would allow reusing a signature across [transactions](/docs/bitcoin/transaction-lifecycle) with different outpoints, enabling more flexible [covenants](/docs/advanced/covenants) and [Lightning](/docs/lightning)-style protocols.\n\n---\n\n## Related Topics\n\n- [Cryptography](/docs/bitcoin/cryptography) - Signing and the structure of the signed message\n- [Transaction Lifecycle](/docs/bitcoin/transaction-lifecycle) - States of a transaction\n- [Transaction Fees](/docs/bitcoin/transaction-fees) - RBF and fee bumping\n- [Covenants](/docs/advanced/covenants) - SIGHASH_ANYPREVOUT and covenant designs\n- [Taproot](/docs/bitcoin/taproot) - SIGHASH_DEFAULT and Schnorr\n\n---\n\n## Resources\n\n- [BIP 143: Transaction Signature Verification for Version 0 Witness Program](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki) - SegWit sighash\n- [BIP 341: Taproot](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) - Taproot and Tapscript sighash\n- [Bitcoin Core: Sighash](https://github.com/bitcoin/bitcoin/blob/master/src/script/sign.cpp) - Implementation\n",
    "filename": "sighash-types.md"
  },
  "/docs/bitcoin/merkle-trees": {
    "content": "# Merkle Trees\n\nMerkle trees are a fundamental data structure in Bitcoin that enable efficient verification of transaction inclusion in blocks. They provide cryptographic proof that specific transactions are part of a block without downloading the entire block. The structure is named after [Ralph Merkle](/docs/history/people#ralph-merkle), who invented it in 1979; Satoshi cited the concept in the Bitcoin whitepaper.\n\n![Merkle Tree Structure](/images/docs/merkle-tree.png)\n\nA **Merkle tree** (also called a hash tree) is a binary tree where:\n\n- **Leaves**: Hash of individual transactions\n- **Internal nodes**: Hash of child nodes\n- **Root**: Single hash representing all transactions\n\nThe Merkle root is stored in the block header, providing a compact commitment to all transactions in the block.\n\n---\n\n## How It Works\n\n### Construction\n\n1. **Hash each transaction**: Create leaf nodes\n2. **Pair and hash**: Combine pairs, hash result\n3. **Repeat**: Continue until single root hash\n4. **Store root**: Root hash goes in block header\n\n### Verification\n\nTo prove transaction inclusion:\n\n1. **Request Merkle path**: Get hashes needed to reconstruct path\n2. **Reconstruct path**: Hash from transaction to root\n3. **Compare roots**: Match against block header root\n\n---\n\n## Code Examples\n\n### Building a Merkle Tree\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\nfn merkle_root(transactions: &[Vec<u8>]) -> [u8; 32] {\n    if transactions.is_empty() {\n        return [0; 32];\n    }\n    \n    let mut hashes: Vec<[u8; 32]> = transactions\n        .iter()\n        .map(|tx| {\n            let mut hasher = Sha256::new();\n            hasher.update(tx);\n            let first = hasher.finalize();\n            let mut hasher = Sha256::new();\n            hasher.update(first);\n            hasher.finalize().into()\n        })\n        .collect();\n    \n    while hashes.len() > 1 {\n        let mut next_level = Vec::new();\n        for i in (0..hashes.len()).step_by(2) {\n            if i + 1 < hashes.len() {\n                let combined = [hashes[i].as_ref(), hashes[i + 1].as_ref()].concat();\n                let mut hasher = Sha256::new();\n                hasher.update(&combined);\n                let first = hasher.finalize();\n                let mut hasher = Sha256::new();\n                hasher.update(first);\n                next_level.push(hasher.finalize().into());\n            } else {\n                next_level.push(hashes[i]);\n            }\n        }\n        hashes = next_level;\n    }\n    \n    hashes[0]\n}\n```\n\n```python\nimport hashlib\n\ndef sha256d(data):\n    \"\"\"Double SHA-256 hash.\"\"\"\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\ndef merkle_root(transactions):\n    \"\"\"Calculate Merkle root from transactions.\"\"\"\n    if not transactions:\n        return b'\\x00' * 32\n    \n    # Hash each transaction\n    hashes = [sha256d(tx) for tx in transactions]\n    \n    # Build tree\n    while len(hashes) > 1:\n        next_level = []\n        for i in range(0, len(hashes), 2):\n            if i + 1 < len(hashes):\n                combined = hashes[i] + hashes[i + 1]\n                next_level.append(sha256d(combined))\n            else:\n                next_level.append(hashes[i])\n        hashes = next_level\n    \n    return hashes[0]\n```\n\n```cpp\n#include <vector>\n#include <openssl/sha.h>\n\nvoid sha256d(const unsigned char* data, size_t len, unsigned char* out) {\n    unsigned char first[SHA256_DIGEST_LENGTH];\n    SHA256(data, len, first);\n    SHA256(first, SHA256_DIGEST_LENGTH, out);\n}\n\nvoid merkle_root(\n    const std::vector<std::vector<unsigned char>>& transactions,\n    unsigned char* root\n) {\n    if (transactions.empty()) {\n        memset(root, 0, 32);\n        return;\n    }\n    \n    std::vector<unsigned char> hashes;\n    for (const auto& tx : transactions) {\n        unsigned char hash[32];\n        sha256d(tx.data(), tx.size(), hash);\n        hashes.insert(hashes.end(), hash, hash + 32);\n    }\n    \n    while (hashes.size() > 32) {\n        std::vector<unsigned char> next_level;\n        for (size_t i = 0; i < hashes.size(); i += 64) {\n            if (i + 32 < hashes.size()) {\n                unsigned char combined[64];\n                memcpy(combined, &hashes[i], 32);\n                memcpy(combined + 32, &hashes[i + 32], 32);\n                unsigned char hash[32];\n                sha256d(combined, 64, hash);\n                next_level.insert(next_level.end(), hash, hash + 32);\n            } else {\n                next_level.insert(next_level.end(), \n                    hashes.begin() + i, hashes.end());\n            }\n        }\n        hashes = next_level;\n    }\n    \n    memcpy(root, hashes.data(), 32);\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n)\n\nfunc sha256d(data []byte) []byte {\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second[:]\n}\n\nfunc merkleRoot(transactions [][]byte) []byte {\n\tif len(transactions) == 0 {\n\t\treturn make([]byte, 32)\n\t}\n\t\n\thashes := make([][]byte, len(transactions))\n\tfor i, tx := range transactions {\n\t\thashes[i] = sha256d(tx)\n\t}\n\t\n\tfor len(hashes) > 1 {\n\t\tvar nextLevel [][]byte\n\t\tfor i := 0; i < len(hashes); i += 2 {\n\t\t\tif i+1 < len(hashes) {\n\t\t\t\tcombined := append(hashes[i], hashes[i+1]...)\n\t\t\t\tnextLevel = append(nextLevel, sha256d(combined))\n\t\t\t} else {\n\t\t\t\tnextLevel = append(nextLevel, hashes[i])\n\t\t\t}\n\t\t}\n\t\thashes = nextLevel\n\t}\n\t\n\treturn hashes[0]\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nfunction sha256d(data) {\n    const first = crypto.createHash('sha256').update(data).digest();\n    return crypto.createHash('sha256').update(first).digest();\n}\n\nfunction merkleRoot(transactions) {\n    if (transactions.length === 0) {\n        return Buffer.alloc(32, 0);\n    }\n    \n    let hashes = transactions.map(tx => sha256d(tx));\n    \n    while (hashes.length > 1) {\n        const nextLevel = [];\n        for (let i = 0; i < hashes.length; i += 2) {\n            if (i + 1 < hashes.length) {\n                const combined = Buffer.concat([hashes[i], hashes[i + 1]]);\n                nextLevel.push(sha256d(combined));\n            } else {\n                nextLevel.push(hashes[i]);\n            }\n        }\n        hashes = nextLevel;\n    }\n    \n    return hashes[0];\n}\n```\n:::\n\n---\n\n## SPV (Simplified Payment Verification)\n\nMerkle trees enable [SPV](/docs/glossary#spv-simplified-payment-verification) clients:\n\n```text\nSPV Client:\n1. Downloads block headers only (~80 bytes each)\n2. Requests Merkle proof for specific transaction\n3. Verifies proof without full block\n4. Confirms transaction inclusion\n```\n\n### Merkle Proof\n\n```text\nTo prove Tx2 is in block:\nâ”œâ”€â”€ Hash of Tx2 (leaf)\nâ”œâ”€â”€ Hash of Tx1 (sibling)\nâ”œâ”€â”€ Hash CD (parent sibling)\nâ””â”€â”€ Root hash (from block header)\n\nVerification:\n1. Hash(Tx2) = leaf hash\n2. Hash(Hash(Tx1) + Hash(Tx2)) = Hash AB\n3. Hash(Hash AB + Hash CD) = Root\n4. Root matches block header âœ“\n```\n\n---\n\n## Block Header\n\nMerkle root is stored in block header:\n\n```text\nBlock Header (80 bytes):\nâ”œâ”€â”€ Version (4 bytes)\nâ”œâ”€â”€ Previous Block Hash (32 bytes)\nâ”œâ”€â”€ Merkle Root (32 bytes) â† Merkle tree root\nâ”œâ”€â”€ Timestamp (4 bytes)\nâ”œâ”€â”€ Difficulty Target (4 bytes)\nâ””â”€â”€ Nonce (4 bytes)\n```\n\n---\n\n## Benefits\n\n### Efficiency\n\n- **Compact proofs**: Small Merkle paths vs. full blocks\n- **Fast verification**: Logarithmic complexity\n- **Bandwidth savings**: SPV clients need minimal data\n\n### Security\n\n- **Cryptographic integrity**: Any change breaks root hash\n- **Tamper detection**: Modified transactions invalidate root\n- **Trustless verification**: No need to trust third parties\n\n---\n\n## Related Topics\n\n- [Block Structure](/docs/bitcoin/blocks) - How blocks are organized\n- SPV - Simplified payment verification\n- [Cryptography](/docs/bitcoin/cryptography) - Hash functions\n\n---\n\n## Resources\n\n- [Merkle Tree Wikipedia](https://en.wikipedia.org/wiki/Merkle_tree)\n- [Bitcoin Merkle Trees](https://en.bitcoin.it/wiki/Protocol_documentation#Merkle_Trees)\n",
    "filename": "merkle-trees.md"
  },
  "/docs/bitcoin/blocks": {
    "content": "# Block Propagation\n\nThis document explains how blocks propagate through the Bitcoin network, including the [gossip protocol](/docs/glossary#gossip-protocol), validation process, and [orphan block](/docs/glossary#orphan-block) handling.\n\n## Block Structure\n\n![Bitcoin Block Overview](/images/docs/bitcoin-block-overview.jpg)\n\nA Bitcoin block consists of:\n- **Block Header** (80 bytes): Contains version, previous block hash, merkle root, timestamp, difficulty target, and nonce\n- **Transaction Count**: Variable-length integer indicating number of transactions\n- **Transactions**: List of transactions, starting with the coinbase transaction\n\nThe block header is hashed twice with SHA-256 to produce the block hash, which must meet the difficulty target for the block to be valid.\n\n---\n\n## Block Propagation Flow\n\n### 1. Block Discovery and Initial Broadcast\n\nWhen a miner finds a new block:\n\n1. **Miner solves [proof-of-work](/docs/glossary#proof-of-work-pow) puzzle**: Finds a valid nonce\n2. **Creates valid block**: Includes transactions from [mempool](/docs/glossary#mempool)\n3. **Immediately broadcasts**: Sends to all connected [peers](/docs/glossary#peer) (8-10 first-hop nodes)\n4. **First-hop nodes validate**: Each node checks the block\n5. **First-hop nodes forward**: Send to their peers (50-100 second-hop nodes)\n6. **Your node receives**: Eventually gets the block from one or more peers\n7. **Your node validates**: Thoroughly checks the block\n8. **Your node forwards**: Sends to peers who haven't seen it yet\n\n### 2. Gossip Protocol Mechanism\n\n**Key Rule**: Nodes never re-broadcast blocks back to the peer that sent them.\n\n**What happens:**\n- Peer A sends you the block\n- You validate and accept it\n- You forward to Peers D, E, F (but NOT back to Peer A)\n- This prevents infinite loops and network flooding\n\n### 3. Block Validation Process\n\nEach full node performs complete validation:\n\n1. **Header Validation**\n   - Proof-of-work meets [difficulty](/docs/glossary#difficulty) target\n   - Timestamp is reasonable\n   - Version is acceptable\n   - Previous block hash is correct\n\n2. **Transaction Validation**\n   - All transactions are valid\n   - No [double-spends](/docs/glossary#double-spend)\n   - Proper signatures\n   - [UTXO](/docs/glossary#utxo-unspent-transaction-output) references are correct\n   - [Consensus rules](/docs/glossary#consensus-rules) compliance\n\n3. **[Merkle Tree](/docs/glossary#merkle-tree) Verification**\n   - Merkle root matches transactions\n   - Tree structure is valid\n\n4. **Chain Validity**\n   - Builds on valid previous block\n   - Maintains blockchain integrity\n\n---\n\n## Compact Block Relay (BIP 152)\n\nCompact blocks dramatically reduce propagation bandwidth and latency:\n\n### How It Works\n\nInstead of sending full blocks (~1-2 MB), nodes send:\n1. **Block header** (80 bytes)\n2. **Short transaction IDs** (6 bytes each)\n3. **Prefilled transactions** (usually just the [coinbase](/docs/glossary#coinbase-transaction))\n\nThe receiving node reconstructs the full block using transactions already in its mempool.\n\n### Benefits\n\n- **90% bandwidth reduction**: Most transactions are already known\n- **Faster propagation**: Smaller data means quicker transmission\n- **Reduced orphan rates**: Faster propagation reduces stale blocks\n\n### Modes\n\n| Mode | Description | Use Case |\n|------|-------------|----------|\n| Low bandwidth | Request-based, saves bandwidth | Default for most peers |\n| High bandwidth | Pushed immediately | Selected fast peers (up to 3) |\n\n---\n\n## Headers-First Synchronization\n\nNew nodes use headers-first sync for efficient IBD (Initial Block Download):\n\n1. Download all block headers first (~60 MB total)\n2. Validate the header chain (proof-of-work, timestamps)\n3. Download full blocks in parallel from multiple peers\n4. Validate blocks against downloaded headers\n\nThis allows nodes to verify they're on the correct chain before downloading gigabytes of block data.\n\n---\n\n## Erlay Protocol\n\nErlay (BIP 330) improves transaction relay efficiency:\n\n- **Set reconciliation**: Nodes exchange transaction set differences instead of full announcements\n- **40% bandwidth reduction**: For transaction relay\n- **Better connectivity**: Enables more peer connections without bandwidth increase\n\n---\n\n## Monitoring Block Propagation\n\n### Subscribe to New Blocks via ZMQ\n\n:::code-group\n```rust\nuse zmq;\nuse std::error::Error;\n\nfn subscribe_to_blocks() -> Result<(), Box<dyn Error>> {\n    let context = zmq::Context::new();\n    let subscriber = context.socket(zmq::SUB)?;\n    \n    // Connect to Bitcoin Core's ZMQ endpoint\n    subscriber.connect(\"tcp://127.0.0.1:28332\")?;\n    subscriber.set_subscribe(b\"hashblock\")?;\n    \n    println!(\"Listening for new blocks...\");\n    \n    loop {\n        // Receive topic\n        let topic = subscriber.recv_bytes(0)?;\n        // Receive block hash (32 bytes, little-endian)\n        let hash = subscriber.recv_bytes(0)?;\n        // Receive sequence number\n        let _sequence = subscriber.recv_bytes(0)?;\n        \n        // Convert to hex (reverse for big-endian display)\n        let hash_hex: String = hash.iter()\n            .rev()\n            .map(|b| format!(\"{:02x}\", b))\n            .collect();\n        \n        println!(\"New block: {}\", hash_hex);\n    }\n}\n\nfn main() {\n    if let Err(e) = subscribe_to_blocks() {\n        eprintln!(\"Error: {}\", e);\n    }\n}\n```\n\n```python\nimport zmq\nimport binascii\n\ndef subscribe_to_blocks():\n    context = zmq.Context()\n    subscriber = context.socket(zmq.SUB)\n    \n    # Connect to Bitcoin Core's ZMQ endpoint\n    subscriber.connect(\"tcp://127.0.0.1:28332\")\n    subscriber.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n    \n    print(\"Listening for new blocks...\")\n    \n    while True:\n        # Receive multipart message: [topic, body, sequence]\n        topic, body, seq = subscriber.recv_multipart()\n        \n        # Convert hash to hex (reverse bytes for big-endian display)\n        block_hash = binascii.hexlify(body[::-1]).decode('ascii')\n        sequence = int.from_bytes(seq, 'little')\n        \n        print(f\"New block #{sequence}: {block_hash}\")\n\nif __name__ == \"__main__\":\n    subscribe_to_blocks()\n```\n\n```cpp\n#include <iostream>\n#include <zmq.hpp>\n#include <sstream>\n#include <iomanip>\n\nstd::string bytes_to_hex_reversed(const unsigned char* data, size_t len) {\n    std::stringstream ss;\n    for (int i = len - 1; i >= 0; --i) {\n        ss << std::hex << std::setfill('0') << std::setw(2) << (int)data[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    zmq::context_t context(1);\n    zmq::socket_t subscriber(context, zmq::socket_type::sub);\n    \n    // Connect to Bitcoin Core's ZMQ endpoint\n    subscriber.connect(\"tcp://127.0.0.1:28332\");\n    subscriber.set(zmq::sockopt::subscribe, \"hashblock\");\n    \n    std::cout << \"Listening for new blocks...\" << std::endl;\n    \n    while (true) {\n        zmq::message_t topic, body, seq;\n        \n        subscriber.recv(topic, zmq::recv_flags::none);\n        subscriber.recv(body, zmq::recv_flags::none);\n        subscriber.recv(seq, zmq::recv_flags::none);\n        \n        std::string hash = bytes_to_hex_reversed(\n            static_cast<unsigned char*>(body.data()), body.size());\n        \n        std::cout << \"New block: \" << hash << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\n\t\"github.com/pebbe/zmq4\"\n)\n\nfunc subscribeToBlocks() {\n\tsubscriber, err := zmq4.NewSocket(zmq4.SUB)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer subscriber.Close()\n\t\n\t// Connect to Bitcoin Core's ZMQ endpoint\n\terr = subscriber.Connect(\"tcp://127.0.0.1:28332\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t\n\terr = subscriber.SetSubscribe(\"hashblock\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t\n\tfmt.Println(\"Listening for new blocks...\")\n\t\n\tfor {\n\t\t// Receive multipart message: [topic, body, sequence]\n\t\tparts, err := subscriber.RecvMessageBytes(0)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t\n\t\tif len(parts) < 3 {\n\t\t\tcontinue\n\t\t}\n\t\t\n\t\t// Reverse bytes for big-endian display\n\t\tbody := parts[1]\n\t\thashHex := \"\"\n\t\tfor i := len(body) - 1; i >= 0; i-- {\n\t\t\thashHex += fmt.Sprintf(\"%02x\", body[i])\n\t\t}\n\t\t\n\t\tseq := parts[2]\n\t\tsequence := uint32(seq[0]) | uint32(seq[1])<<8 | uint32(seq[2])<<16 | uint32(seq[3])<<24\n\t\t\n\t\tfmt.Printf(\"New block #%d: %s\\n\", sequence, hashHex)\n\t}\n}\n\nfunc main() {\n\tsubscribeToBlocks()\n}\n```\n\n```javascript\nconst zmq = require('zeromq');\n\nasync function subscribeToBlocks() {\n    const subscriber = new zmq.Subscriber();\n    \n    // Connect to Bitcoin Core's ZMQ endpoint\n    subscriber.connect('tcp://127.0.0.1:28332');\n    subscriber.subscribe('hashblock');\n    \n    console.log('Listening for new blocks...');\n    \n    for await (const [topic, body, seq] of subscriber) {\n        // Reverse bytes for big-endian display\n        const hashHex = Buffer.from(body).reverse().toString('hex');\n        const sequence = seq.readUInt32LE(0);\n        \n        console.log(`New block #${sequence}: ${hashHex}`);\n    }\n}\n\nsubscribeToBlocks().catch(console.error);\n```\n:::\n\n### Parse Block Header\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\n#[derive(Debug)]\nstruct BlockHeader {\n    version: i32,\n    prev_block: [u8; 32],\n    merkle_root: [u8; 32],\n    timestamp: u32,\n    bits: u32,\n    nonce: u32,\n}\n\nimpl BlockHeader {\n    fn from_bytes(data: &[u8; 80]) -> Self {\n        BlockHeader {\n            version: i32::from_le_bytes(data[0..4].try_into().unwrap()),\n            prev_block: data[4..36].try_into().unwrap(),\n            merkle_root: data[36..68].try_into().unwrap(),\n            timestamp: u32::from_le_bytes(data[68..72].try_into().unwrap()),\n            bits: u32::from_le_bytes(data[72..76].try_into().unwrap()),\n            nonce: u32::from_le_bytes(data[76..80].try_into().unwrap()),\n        }\n    }\n    \n    fn hash(&self, data: &[u8; 80]) -> [u8; 32] {\n        // Double SHA256\n        let first = Sha256::digest(data);\n        let second = Sha256::digest(&first);\n        second.into()\n    }\n}\n\nfn main() {\n    // Example: Genesis block header (80 bytes)\n    let header_hex = \"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c\";\n    let header_bytes: Vec<u8> = hex::decode(header_hex).unwrap();\n    let header_array: [u8; 80] = header_bytes.try_into().unwrap();\n    \n    let header = BlockHeader::from_bytes(&header_array);\n    println!(\"Version: {}\", header.version);\n    println!(\"Timestamp: {}\", header.timestamp);\n    println!(\"Nonce: {}\", header.nonce);\n}\n```\n\n```python\nimport struct\nimport hashlib\nfrom dataclasses import dataclass\n\n@dataclass\nclass BlockHeader:\n    version: int\n    prev_block: bytes\n    merkle_root: bytes\n    timestamp: int\n    bits: int\n    nonce: int\n    \n    @classmethod\n    def from_bytes(cls, data: bytes) -> 'BlockHeader':\n        \"\"\"Parse 80-byte block header.\"\"\"\n        return cls(\n            version=struct.unpack('<i', data[0:4])[0],\n            prev_block=data[4:36],\n            merkle_root=data[36:68],\n            timestamp=struct.unpack('<I', data[68:72])[0],\n            bits=struct.unpack('<I', data[72:76])[0],\n            nonce=struct.unpack('<I', data[76:80])[0],\n        )\n    \n    def hash(self, data: bytes) -> bytes:\n        \"\"\"Calculate block hash (double SHA256).\"\"\"\n        return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n    \n    def hash_hex(self, data: bytes) -> str:\n        \"\"\"Return block hash as hex string (big-endian).\"\"\"\n        return self.hash(data)[::-1].hex()\n\n# Example: Genesis block header\nheader_hex = \"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c\"\nheader_bytes = bytes.fromhex(header_hex)\n\nheader = BlockHeader.from_bytes(header_bytes)\nprint(f\"Version: {header.version}\")\nprint(f\"Timestamp: {header.timestamp}\")\nprint(f\"Nonce: {header.nonce}\")\nprint(f\"Block hash: {header.hash_hex(header_bytes)}\")\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cstring>\n#include <array>\n#include <openssl/sha.h>\n\nstruct BlockHeader {\n    int32_t version;\n    uint8_t prev_block[32];\n    uint8_t merkle_root[32];\n    uint32_t timestamp;\n    uint32_t bits;\n    uint32_t nonce;\n    \n    static BlockHeader from_bytes(const uint8_t* data) {\n        BlockHeader header;\n        std::memcpy(&header.version, data, 4);\n        std::memcpy(header.prev_block, data + 4, 32);\n        std::memcpy(header.merkle_root, data + 36, 32);\n        std::memcpy(&header.timestamp, data + 68, 4);\n        std::memcpy(&header.bits, data + 72, 4);\n        std::memcpy(&header.nonce, data + 76, 4);\n        return header;\n    }\n    \n    std::array<uint8_t, 32> hash(const uint8_t* data) const {\n        std::array<uint8_t, 32> first, second;\n        SHA256(data, 80, first.data());\n        SHA256(first.data(), 32, second.data());\n        return second;\n    }\n};\n\nint main() {\n    // Parse and display block header\n    // (In practice, read from network or file)\n    std::cout << \"Block header parser ready\" << std::endl;\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\ntype BlockHeader struct {\n\tVersion     int32\n\tPrevBlock   [32]byte\n\tMerkleRoot  [32]byte\n\tTimestamp   uint32\n\tBits        uint32\n\tNonce       uint32\n}\n\nfunc ParseBlockHeader(data []byte) *BlockHeader {\n\theader := &BlockHeader{}\n\theader.Version = int32(binary.LittleEndian.Uint32(data[0:4]))\n\tcopy(header.PrevBlock[:], data[4:36])\n\tcopy(header.MerkleRoot[:], data[36:68])\n\theader.Timestamp = binary.LittleEndian.Uint32(data[68:72])\n\theader.Bits = binary.LittleEndian.Uint32(data[72:76])\n\theader.Nonce = binary.LittleEndian.Uint32(data[76:80])\n\treturn header\n}\n\nfunc (h *BlockHeader) Hash(data []byte) [32]byte {\n\t// Double SHA256\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second\n}\n\nfunc (h *BlockHeader) HashHex(data []byte) string {\n\thash := h.Hash(data)\n\t// Reverse bytes for big-endian display\n\treversed := make([]byte, 32)\n\tfor i := 0; i < 32; i++ {\n\t\treversed[i] = hash[31-i]\n\t}\n\treturn hex.EncodeToString(reversed)\n}\n\nfunc main() {\n\t// Example: Genesis block header\n\theaderHex := \"0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c\"\n\theaderBytes, _ := hex.DecodeString(headerHex)\n\n\theader := ParseBlockHeader(headerBytes)\n\tfmt.Printf(\"Version: %d\\n\", header.Version)\n\tfmt.Printf(\"Timestamp: %d\\n\", header.Timestamp)\n\tfmt.Printf(\"Nonce: %d\\n\", header.Nonce)\n\tfmt.Printf(\"Block hash: %s\\n\", header.HashHex(headerBytes))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nclass BlockHeader {\n    constructor(data) {\n        // Parse 80-byte header (little-endian)\n        this.version = data.readInt32LE(0);\n        this.prevBlock = data.slice(4, 36);\n        this.merkleRoot = data.slice(36, 68);\n        this.timestamp = data.readUInt32LE(68);\n        this.bits = data.readUInt32LE(72);\n        this.nonce = data.readUInt32LE(76);\n    }\n    \n    hash(data) {\n        // Double SHA256\n        const first = crypto.createHash('sha256').update(data).digest();\n        const second = crypto.createHash('sha256').update(first).digest();\n        return second;\n    }\n    \n    hashHex(data) {\n        // Return as big-endian hex string\n        return Buffer.from(this.hash(data)).reverse().toString('hex');\n    }\n}\n\n// Example: Genesis block header\nconst headerHex = '0100000000000000000000000000000000000000000000000000000000000000000000003ba3edfd7a7b12b27ac72c3e67768f617fc81bc3888a51323a9fb8aa4b1e5e4a29ab5f49ffff001d1dac2b7c';\nconst headerBytes = Buffer.from(headerHex, 'hex');\n\nconst header = new BlockHeader(headerBytes);\nconsole.log(`Version: ${header.version}`);\nconsole.log(`Timestamp: ${header.timestamp}`);\nconsole.log(`Nonce: ${header.nonce}`);\nconsole.log(`Block hash: ${header.hashHex(headerBytes)}`);\n```\n:::\n\n---\n\n## Orphan Block Scenarios\n\n### Simultaneous Block Discovery\n\nSometimes two miners find blocks at nearly the same time, creating a temporary fork:\n\n```\nBlock 850,000 (everyone agrees)\n       |\n       +-------------+-------------+\n       |             |             |\n  Block A      Block B (orphan) Block C\n  (main chain)      |\n       |        Block D\n  Block E       (also orphaned)\n  (main chain)\n       |\n    Winner!\n```\n\n### Timeline of Fork Resolution\n\n```\nTime 0:00    Miner A finds Block A\nTime 0:01    Miner B finds Block B (almost simultaneously)\nTime 0:02    Network splits: some nodes see A first, others see B\nTime 0:05    Some miners start building on Block A\nTime 0:06    Other miners start building on Block B\nTime 0:10    Block E found building on Block A\nTime 0:11    Chain A is now longer (more proof-of-work)\nTime 0:12    All nodes converge on Chain A\nTime 0:13    Block B and Block D become orphans\nTime 0:14    Orphaned transactions return to mempool\n```\n\n### What Happens to Orphaned Blocks\n\n- Block B and Block D are discarded\n- Unique transactions from orphans return to mempool\n- Miners' work on orphaned blocks is wasted\n- Network automatically converges on longest chain\n- This is why exchanges wait for 6 [confirmations](/docs/glossary#confirmation)\n\n---\n\n## Propagation Timing\n\n### Typical Network Performance\n\n| Stage | Time | Description |\n|-------|------|-------------|\n| Block found | 0:00 | Miner discovers valid hash |\n| First hop | ~1s | Direct peers receive block |\n| Second hop | ~2s | 50-100 nodes have block |\n| Your node | ~5s | Typical home node receives |\n| Most network | ~10s | >90% of nodes synchronized |\n| Full propagation | ~30s | Entire network synchronized |\n\n### Factors Affecting Speed\n\n**Fast Propagation:**\n- Well-connected nodes (many peers)\n- High-bandwidth connections\n- Geographic proximity to miners\n- Compact block relay enabled\n\n**Slow Propagation:**\n- Few peer connections\n- Low-bandwidth connections\n- Geographic distance from miners\n- Firewall restrictions\n\n---\n\n## Network Topology\n\n### Typical Node Connections\n\nA typical Bitcoin node has:\n- **8-10 outbound connections**: You connect TO other nodes\n- **Up to 125 inbound connections**: Other nodes connect TO you\n- **Diverse IP ranges**: Protection against [eclipse attacks](/docs/glossary#sybil-attack)\n\n### Connection Types\n\n| Type | Direction | Purpose | Limit |\n|------|-----------|---------|-------|\n| Outbound | You to peers | Request data | 8-10 |\n| Inbound | Peers to you | Serve data | 125 |\n| Block-relay-only | Outbound | Blocks only (privacy) | 2 |\n| Feeler | Temporary | Test new peers | 1-2 |\n\n---\n\n## Security Considerations\n\n### Why Validation is Critical\n\nEvery node validates every block because:\n\n- **No central authority to trust**\n- **Prevents invalid blocks from spreading**\n- **Ensures consensus rules are followed**\n- **Protects against malicious actors**\n- **Maintains network integrity**\n\nIf a node doesn't validate, it could spread invalid blocks and harm the network.\n\n### Economic Incentives\n\n**Miners are incentivized to:**\n- Find blocks quickly (first to market)\n- Broadcast blocks immediately (avoid orphaning)\n- Include high-fee transactions\n- Follow consensus rules (avoid rejection)\n\n**Nodes are incentivized to:**\n- Validate blocks (maintain network health)\n- Relay blocks quickly (help the network)\n- Stay connected (receive updates)\n\n---\n\n## Key Metrics\n\n| Metric | Target | Description |\n|--------|--------|-------------|\n| Block interval | ~10 min | Time between consecutive blocks |\n| Propagation delay | <10s | Time from discovery to your node |\n| Peer count | 8-125 | Number of active connections |\n| Validation time | <1s | Time to validate a block |\n| Orphan rate | <1% | Percentage of blocks orphaned |\n\n---\n\n## Summary\n\nBitcoin's block propagation mechanism is designed to be:\n\n- **Decentralized**: No single point of failure\n- **Resilient**: Multiple paths for block propagation\n- **Secure**: Every node validates every block\n- **Efficient**: Compact blocks reduce bandwidth by 90%\n- **Self-healing**: Orphan blocks are automatically resolved\n\n---\n\n## Resources\n\n- **[mempool.space](https://mempool.space)**: Real-time block explorer and mempool visualization\n- **[BIP 152: Compact Block Relay](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)**: Compact blocks specification\n- **[Bitcoin Core P2P documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/p2p.md)**: Network protocol details\n",
    "filename": "blocks.md"
  },
  "/docs/bitcoin/subsidy": {
    "content": "# Block Subsidy\n\nThe Bitcoin block subsidy is the amount of new Bitcoin created with each block. It follows a predictable mathematical formula that [halves](/docs/glossary#halving) every 210,000 blocks, creating Bitcoin's fixed supply schedule.\n\n## The Equation\n\n### Mathematical Formula\n\n```\nBlock Subsidy = 50 / (2^halvings)\n\nWhere:\n  halvings = floor(block_height / 210,000)\n```\n\n### Bitcoin Core Implementation\n\nIn Bitcoin Core (`validation.cpp`), the subsidy is calculated using bit shifting for efficiency:\n\n```cpp\nCAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n{\n    int halvings = nHeight / consensusParams.nSubsidyHalvingInterval;\n    // Force block reward to zero when right shift is undefined.\n    if (halvings >= 64)\n        return 0;\n\n    CAmount nSubsidy = 50 * COIN;\n    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n    nSubsidy >>= halvings;\n    return nSubsidy;\n}\n```\n\nThe right bit shift (`>>=`) divides by 2 for each halving, which is equivalent to the mathematical formula but more efficient.\n\n### Code Implementation\n\n:::code-group\n```rust\n/// Calculate block subsidy for any block height.\n/// Returns subsidy in BTC.\nfn get_block_subsidy(block_height: u64) -> f64 {\n    let halvings = block_height / 210_000;\n    if halvings >= 64 {\n        return 0.0;\n    }\n    50.0 / 2.0_f64.powi(halvings as i32)\n}\n\n/// Calculate block subsidy in satoshis (more precise).\nfn get_block_subsidy_sats(block_height: u64) -> u64 {\n    let halvings = block_height / 210_000;\n    if halvings >= 64 {\n        return 0;\n    }\n    let initial_subsidy: u64 = 50 * 100_000_000; // 50 BTC in satoshis\n    initial_subsidy >> halvings\n}\n\nfn main() {\n    println!(\"Block 0: {} BTC\", get_block_subsidy(0));\n    println!(\"Block 210,000: {} BTC\", get_block_subsidy(210_000));\n    println!(\"Block 840,000: {} BTC\", get_block_subsidy(840_000));\n}\n```\n\n```python\ndef get_block_subsidy(block_height: int) -> float:\n    \"\"\"\n    Calculate block subsidy for any block height.\n    Returns subsidy in BTC.\n    \"\"\"\n    halvings = block_height // 210_000\n    if halvings >= 64:\n        return 0.0\n    return 50.0 / (2 ** halvings)\n\ndef get_block_subsidy_sats(block_height: int) -> int:\n    \"\"\"Calculate block subsidy in satoshis (more precise).\"\"\"\n    halvings = block_height // 210_000\n    if halvings >= 64:\n        return 0\n    initial_subsidy = 50 * 100_000_000  # 50 BTC in satoshis\n    return initial_subsidy >> halvings\n\n# Examples\nprint(f\"Block 0: {get_block_subsidy(0)} BTC\")\nprint(f\"Block 210,000: {get_block_subsidy(210_000)} BTC\")\nprint(f\"Block 840,000: {get_block_subsidy(840_000)} BTC\")\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n#include <cmath>\n\n/**\n * Calculate block subsidy for any block height.\n * Returns subsidy in BTC.\n */\ndouble get_block_subsidy(uint64_t block_height) {\n    uint64_t halvings = block_height / 210000;\n    if (halvings >= 64) {\n        return 0.0;\n    }\n    return 50.0 / std::pow(2.0, static_cast<double>(halvings));\n}\n\n/**\n * Calculate block subsidy in satoshis (more precise).\n */\nuint64_t get_block_subsidy_sats(uint64_t block_height) {\n    uint64_t halvings = block_height / 210000;\n    if (halvings >= 64) {\n        return 0;\n    }\n    uint64_t initial_subsidy = 50ULL * 100000000ULL; // 50 BTC in satoshis\n    return initial_subsidy >> halvings;\n}\n\nint main() {\n    std::cout << \"Block 0: \" << get_block_subsidy(0) << \" BTC\" << std::endl;\n    std::cout << \"Block 210,000: \" << get_block_subsidy(210000) << \" BTC\" << std::endl;\n    std::cout << \"Block 840,000: \" << get_block_subsidy(840000) << \" BTC\" << std::endl;\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// GetBlockSubsidy calculates block subsidy for any block height.\n// Returns subsidy in BTC.\nfunc GetBlockSubsidy(blockHeight uint64) float64 {\n\thalvings := blockHeight / 210_000\n\tif halvings >= 64 {\n\t\treturn 0.0\n\t}\n\treturn 50.0 / math.Pow(2.0, float64(halvings))\n}\n\n// GetBlockSubsidySats calculates block subsidy in satoshis (more precise).\nfunc GetBlockSubsidySats(blockHeight uint64) uint64 {\n\thalvings := blockHeight / 210_000\n\tif halvings >= 64 {\n\t\treturn 0\n\t}\n\tinitialSubsidy := uint64(50 * 100_000_000) // 50 BTC in satoshis\n\treturn initialSubsidy >> halvings\n}\n\nfunc main() {\n\tfmt.Printf(\"Block 0: %.8f BTC\\n\", GetBlockSubsidy(0))\n\tfmt.Printf(\"Block 210,000: %.8f BTC\\n\", GetBlockSubsidy(210_000))\n\tfmt.Printf(\"Block 840,000: %.8f BTC\\n\", GetBlockSubsidy(840_000))\n}\n```\n\n```javascript\n/**\n * Calculate block subsidy for any block height.\n * Returns subsidy in BTC.\n */\nfunction getBlockSubsidy(blockHeight) {\n    const halvings = Math.floor(blockHeight / 210000);\n    if (halvings >= 64) {\n        return 0;\n    }\n    return 50.0 / Math.pow(2, halvings);\n}\n\n/**\n * Calculate block subsidy in satoshis (more precise).\n * Uses BigInt for precision with large numbers.\n */\nfunction getBlockSubsidySats(blockHeight) {\n    const halvings = Math.floor(blockHeight / 210000);\n    if (halvings >= 64) {\n        return 0n;\n    }\n    const initialSubsidy = 50n * 100_000_000n; // 50 BTC in satoshis\n    return initialSubsidy >> BigInt(halvings);\n}\n\n// Examples\nconsole.log(`Block 0: ${getBlockSubsidy(0)} BTC`);\nconsole.log(`Block 210,000: ${getBlockSubsidy(210000)} BTC`);\nconsole.log(`Block 840,000: ${getBlockSubsidy(840000)} BTC`);\n```\n:::\n\n---\n\n## Halving Schedule\n\n| Halving | Block Height | Date | Subsidy | Total Mined |\n|---------|--------------|------|---------|-------------|\n| 0 (Genesis) | 0 | Jan 2009 | 50 BTC | 0 |\n| 1 | 210,000 | Nov 2012 | 25 BTC | 10,500,000 |\n| 2 | 420,000 | Jul 2016 | 12.5 BTC | 15,750,000 |\n| 3 | 630,000 | May 2020 | 6.25 BTC | 18,375,000 |\n| 4 | 840,000 | Apr 2024 | 3.125 BTC | 19,687,500 |\n| 5 | 1,050,000 | ~2028 | 1.5625 BTC | 20,343,750 |\n| 6 | 1,260,000 | ~2032 | 0.78125 BTC | 20,671,875 |\n\n### Example Calculations\n\n**Block 0 (Genesis Block):**\n```\nhalvings = 0 / 210,000 = 0\nsubsidy = 50 / (2^0) = 50 BTC\n```\n\n**Block 840,000 (Fourth Halving):**\n```\nhalvings = 840,000 / 210,000 = 4\nsubsidy = 50 / (2^4) = 3.125 BTC\n```\n\n---\n\n## Total Supply\n\nThe total Bitcoin supply follows a geometric series that converges to exactly 21 million BTC:\n\n```\nTotal Supply = 210,000 blocks Ã— 50 BTC Ã— (1 + 1/2 + 1/4 + 1/8 + ...)\n             = 210,000 Ã— 50 Ã— 2\n             = 21,000,000 BTC\n```\n\n### Why 21 Million?\n\nThe limit arises from:\n- Initial subsidy: 50 BTC\n- Halving interval: 210,000 blocks\n- Geometric series sum: 50 Ã— 210,000 Ã— 2 = 21,000,000\n\nAfter approximately 64 halvings (around year 2140), the subsidy drops below 1 [satoshi](/docs/glossary#sat-satoshi) and becomes zero.\n\n---\n\n## Utility Functions\n\n### Calculate Total Supply Up to Block\n\n:::code-group\n```rust\nfn total_supply_up_to_block(block_height: u64) -> f64 {\n    let mut total = 0.0;\n    let mut current = 0u64;\n    \n    while current <= block_height {\n        let halvings = current / 210_000;\n        if halvings >= 64 { break; }\n        \n        let period_end = ((halvings + 1) * 210_000).min(block_height + 1);\n        let blocks = period_end - (halvings * 210_000);\n        let subsidy = 50.0 / 2.0_f64.powi(halvings as i32);\n        \n        total += blocks as f64 * subsidy;\n        current = period_end;\n    }\n    total\n}\n\nfn main() {\n    println!(\"Supply at block 840,000: {} BTC\", total_supply_up_to_block(840_000));\n}\n```\n\n```python\ndef total_supply_up_to_block(block_height: int) -> float:\n    \"\"\"Calculate total Bitcoin supply up to given block height.\"\"\"\n    total = 0.0\n    current = 0\n    \n    while current <= block_height:\n        halvings = current // 210_000\n        if halvings >= 64:\n            break\n        \n        period_end = min((halvings + 1) * 210_000, block_height + 1)\n        blocks = period_end - (halvings * 210_000)\n        subsidy = 50.0 / (2 ** halvings)\n        \n        total += blocks * subsidy\n        current = period_end\n    \n    return total\n\nprint(f\"Supply at block 840,000: {total_supply_up_to_block(840_000):,.0f} BTC\")\n```\n\n```cpp\n// Requires: #include <algorithm>\ndouble total_supply_up_to_block(uint64_t block_height) {\n    double total = 0.0;\n    uint64_t current = 0;\n    \n    while (current <= block_height) {\n        uint64_t halvings = current / 210000;\n        if (halvings >= 64) break;\n        \n        uint64_t period_end = std::min((halvings + 1) * 210000, block_height + 1);\n        uint64_t blocks = period_end - (halvings * 210000);\n        double subsidy = 50.0 / std::pow(2.0, static_cast<double>(halvings));\n        \n        total += static_cast<double>(blocks) * subsidy;\n        current = period_end;\n    }\n    return total;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc totalSupplyUpToBlock(blockHeight uint64) float64 {\n\ttotal := 0.0\n\tcurrent := uint64(0)\n\t\n\tfor current <= blockHeight {\n\t\thalvings := current / 210_000\n\t\tif halvings >= 64 {\n\t\t\tbreak\n\t\t}\n\t\t\n\t\tperiodEnd := uint64(math.Min(float64((halvings+1)*210_000), float64(blockHeight+1)))\n\t\tblocks := periodEnd - (halvings * 210_000)\n\t\tsubsidy := 50.0 / math.Pow(2.0, float64(halvings))\n\t\t\n\t\ttotal += float64(blocks) * subsidy\n\t\tcurrent = periodEnd\n\t}\n\treturn total\n}\n\nfunc main() {\n\tsupply := totalSupplyUpToBlock(840_000)\n\tfmt.Printf(\"Supply at block 840,000: %.0f BTC\\n\", supply)\n}\n```\n\n```javascript\nfunction totalSupplyUpToBlock(blockHeight) {\n    let total = 0;\n    let current = 0;\n    \n    while (current <= blockHeight) {\n        const halvings = Math.floor(current / 210000);\n        if (halvings >= 64) break;\n        \n        const periodEnd = Math.min((halvings + 1) * 210000, blockHeight + 1);\n        const blocks = periodEnd - (halvings * 210000);\n        const subsidy = 50.0 / Math.pow(2, halvings);\n        \n        total += blocks * subsidy;\n        current = periodEnd;\n    }\n    return total;\n}\n\nconsole.log(`Supply at block 840,000: ${totalSupplyUpToBlock(840000).toLocaleString()} BTC`);\n```\n:::\n\n### Find Next Halving\n\n:::code-group\n```rust\nfn next_halving(current_height: u64) -> (u64, u64) {\n    let current_halvings = current_height / 210_000;\n    let next_height = (current_halvings + 1) * 210_000;\n    let blocks_remaining = next_height - current_height;\n    (next_height, blocks_remaining)\n}\n\nfn main() {\n    let (next, remaining) = next_halving(880_000);\n    println!(\"Next halving at block {}, {} blocks remaining\", next, remaining);\n}\n```\n\n```python\ndef next_halving(current_height: int) -> tuple[int, int]:\n    \"\"\"Returns (next_halving_height, blocks_remaining).\"\"\"\n    current_halvings = current_height // 210_000\n    next_height = (current_halvings + 1) * 210_000\n    blocks_remaining = next_height - current_height\n    return next_height, blocks_remaining\n\nnext_height, remaining = next_halving(880_000)\nprint(f\"Next halving at block {next_height:,}, {remaining:,} blocks remaining\")\n```\n\n```cpp\nstd::pair<uint64_t, uint64_t> next_halving(uint64_t current_height) {\n    uint64_t current_halvings = current_height / 210000;\n    uint64_t next_height = (current_halvings + 1) * 210000;\n    uint64_t blocks_remaining = next_height - current_height;\n    return {next_height, blocks_remaining};\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc nextHalving(currentHeight uint64) (uint64, uint64) {\n\tcurrentHalvings := currentHeight / 210_000\n\tnextHeight := (currentHalvings + 1) * 210_000\n\tblocksRemaining := nextHeight - currentHeight\n\treturn nextHeight, blocksRemaining\n}\n\nfunc main() {\n\tnextHeight, remaining := nextHalving(880_000)\n\tfmt.Printf(\"Next halving at block %d, %d blocks remaining\\n\", nextHeight, remaining)\n}\n```\n\n```javascript\nfunction nextHalving(currentHeight) {\n    const currentHalvings = Math.floor(currentHeight / 210000);\n    const nextHeight = (currentHalvings + 1) * 210000;\n    const blocksRemaining = nextHeight - currentHeight;\n    return { nextHeight, blocksRemaining };\n}\n\nconst { nextHeight, blocksRemaining } = nextHalving(880000);\nconsole.log(`Next halving at block ${nextHeight.toLocaleString()}, ${blocksRemaining.toLocaleString()} blocks remaining`);\n```\n:::\n\n---\n\n## Block Reward Components\n\nThe total block reward consists of two parts:\n\n```\nTotal Block Reward = Block Subsidy + Transaction Fees\n```\n\n| Era | Subsidy | Typical Fees | Fee % |\n|-----|---------|--------------|-------|\n| 2009-2012 | 50 BTC | < 0.01 BTC | < 0.02% |\n| 2012-2016 | 25 BTC | 0.1-0.5 BTC | 0.4-2% |\n| 2016-2020 | 12.5 BTC | 0.5-2 BTC | 4-16% |\n| 2020-2024 | 6.25 BTC | 0.5-5 BTC | 8-80% |\n| 2024-2028 | 3.125 BTC | Variable | Growing |\n\nAs the subsidy decreases, transaction fees become increasingly important for [mining](/docs/glossary#mining-pool) economics and network security.\n\n---\n\n## Inflation Rate\n\nBitcoin's inflation rate decreases predictably over time:\n\n```\nAnnual Inflation = (Blocks per Year Ã— Subsidy) / Total Supply Ã— 100%\n\nExample (2024):\n- Blocks per year: ~52,560 (365.25 Ã— 24 Ã— 6)\n- Subsidy: 3.125 BTC\n- New BTC per year: ~164,250 BTC\n- Total supply: ~19,700,000 BTC\n- Inflation rate: ~0.83%\n```\n\n| Period | Approximate Inflation |\n|--------|----------------------|\n| 2009-2012 | > 25% |\n| 2016-2020 | ~4% |\n| 2020-2024 | ~1.8% |\n| 2024-2028 | ~0.8% |\n| After 2032 | < 0.5% |\n\n---\n\n## Key Properties\n\n### Predictability\n- Anyone can calculate the exact supply at any block height\n- No central authority can change the schedule\n- Requires network [consensus](/docs/glossary#consensus) to modify\n\n### Scarcity\n- Fixed maximum of 21 million BTC\n- Decreasing issuance over time\n- Eventually deflationary (lost coins exceed new issuance)\n\n### Security Transition\n- Early: Security funded primarily by subsidy\n- Current: Mix of subsidy and fees\n- Future: Security must come from [fee market](/docs/glossary#transaction-fee)\n\n---\n\n## Visual Representation\n\n```\nSubsidy (BTC)\n      â”‚\n50    â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n25    â”‚        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n12.5  â”‚                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n6.25  â”‚                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n3.125 â”‚                                â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n1.5625â”‚                                        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n      â”‚\n      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Blocks\n       0      210k    420k    630k    840k    1050k\n```\n\n---\n\n## Resources\n\n- **[Bitcoin Core: validation.cpp](https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp)**: Subsidy calculation in source code\n- **[Bitcoin Wiki: Controlled Supply](https://en.bitcoin.it/wiki/Controlled_supply)**: Detailed supply schedule\n- **[Clark Moody Dashboard](https://bitcoin.clarkmoody.com/dashboard/)**: Live supply statistics\n",
    "filename": "subsidy.md"
  },
  "/docs/bitcoin/transaction-fees": {
    "content": "# Transaction Fees\n\nTransaction fees are payments made to miners for including transactions in blocks. Understanding how fees work is essential for ensuring your transactions confirm in a timely manner.\n\n## Why Fees Exist\n\nFees serve multiple purposes:\n\n1. **Incentivize miners**: Reward miners for processing transactions\n2. **Prevent spam**: Make it expensive to flood the network\n3. **Prioritize transactions**: Higher fees = faster confirmation\n4. **Economic security**: Fees will replace block rewards over time\n\n---\n\n## Fee Calculation\n\n### Fee Rate\n\nFees are calculated based on **fee rate** (satoshis per virtual byte):\n\n```text\nFee = Transaction Size (vbytes) Ã— Fee Rate (sat/vB)\n\nExample:\n- Transaction size: 250 vbytes\n- Fee rate: 10 sat/vB\n- Total fee: 2,500 satoshis (0.000025 BTC)\n```\n\n### Virtual Size (vbytes)\n\nSince SegWit, transactions use **virtual size** instead of raw bytes:\n\n```text\nVirtual Size = Weight / 4\n\nWhere:\nWeight = (Base Size Ã— 4) + Total Size\n\nBase Size: Transaction without witness data\nTotal Size: Transaction with witness data\n```\n\n---\n\n## Fee Estimation\n\n### Methods\n\nWallets estimate fees using several approaches:\n\n1. **Mempool analysis**: Look at pending transactions\n2. **Fee estimation APIs**: Services like mempool.space\n3. **Bitcoin Core RPC**: `estimatesmartfee` command\n4. **Historical data**: Analyze past fee patterns\n\n### Fee Targets\n\nCommon confirmation targets:\n\n| Target | Description | Typical Fee Rate |\n|--------|-------------|-----------------|\n| **Next block** | Highest priority | 50-200+ sat/vB |\n| **3 blocks** | ~30 minutes | 20-50 sat/vB |\n| **6 blocks** | ~1 hour | 10-20 sat/vB |\n| **Economy** | No rush | 1-10 sat/vB |\n\n---\n\n## Code Examples\n\n### Estimating Fees\n\n:::code-group\n```rust\nuse serde_json::json;\nuse reqwest;\n\nasync fn estimate_fee_rate() -> Result<u64, Box<dyn std::error::Error>> {\n    let response = reqwest::get(\n        \"https://mempool.space/api/v1/fees/recommended\"\n    ).await?;\n    \n    let fees: serde_json::Value = response.json().await?;\n    let fee_rate = fees[\"fastestFee\"].as_u64().unwrap();\n    \n    Ok(fee_rate)\n}\n```\n\n```python\nimport requests\n\ndef estimate_fee_rate():\n    \"\"\"Estimate fee rate from mempool.space API.\"\"\"\n    response = requests.get(\n        \"https://mempool.space/api/v1/fees/recommended\"\n    )\n    fees = response.json()\n    return fees[\"fastestFee\"]  # sat/vB\n```\n\n```cpp\n#include <curl/curl.h>\n#include <json/json.h>\n\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* data) {\n    data->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\nint estimate_fee_rate() {\n    CURL* curl = curl_easy_init();\n    std::string response_data;\n    \n    curl_easy_setopt(curl, CURLOPT_URL, \n        \"https://mempool.space/api/v1/fees/recommended\");\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);\n    curl_easy_perform(curl);\n    \n    Json::Value root;\n    Json::Reader reader;\n    reader.parse(response_data, root);\n    \n    return root[\"fastestFee\"].asInt();\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype FeeRecommendation struct {\n\tFastestFee  int `json:\"fastestFee\"`\n\tHalfHourFee int `json:\"halfHourFee\"`\n\tHourFee     int `json:\"hourFee\"`\n}\n\nfunc estimateFeeRate() (int, error) {\n\tresp, err := http.Get(\"https://mempool.space/api/v1/fees/recommended\")\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\t\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar fees FeeRecommendation\n\tjson.Unmarshal(body, &fees)\n\t\n\treturn fees.FastestFee, nil\n}\n```\n\n```javascript\nasync function estimateFeeRate() {\n    const response = await fetch(\n        'https://mempool.space/api/v1/fees/recommended'\n    );\n    const fees = await response.json();\n    return fees.fastestFee; // sat/vB\n}\n```\n:::\n\n### Calculating Transaction Fee\n\n:::code-group\n```rust\nfn calculate_fee(tx_size_vbytes: usize, fee_rate_sat_per_vb: u64) -> u64 {\n    (tx_size_vbytes as u64) * fee_rate_sat_per_vb\n}\n\nfn calculate_fee_for_outputs(\n    input_count: usize,\n    output_count: usize,\n    fee_rate: u64,\n) -> u64 {\n    // Estimate transaction size\n    let base_size = 10; // Overhead\n    let input_size = 148; // P2PKH input\n    let output_size = 34; // P2PKH output\n    \n    let estimated_size = base_size + \n        (input_count * input_size) + \n        (output_count * output_size);\n    \n    calculate_fee(estimated_size, fee_rate)\n}\n```\n\n```python\ndef calculate_fee(tx_size_vbytes, fee_rate_sat_per_vb):\n    \"\"\"Calculate fee for transaction.\"\"\"\n    return tx_size_vbytes * fee_rate_sat_per_vb\n\ndef calculate_fee_for_outputs(input_count, output_count, fee_rate):\n    \"\"\"Estimate fee based on input/output counts.\"\"\"\n    base_size = 10  # Overhead\n    input_size = 148  # P2PKH input\n    output_size = 34  # P2PKH output\n    \n    estimated_size = (base_size + \n                      (input_count * input_size) + \n                      (output_count * output_size))\n    \n    return calculate_fee(estimated_size, fee_rate)\n```\n\n```cpp\nuint64_t calculate_fee(size_t tx_size_vbytes, uint64_t fee_rate_sat_per_vb) {\n    return tx_size_vbytes * fee_rate_sat_per_vb;\n}\n\nuint64_t calculate_fee_for_outputs(\n    size_t input_count,\n    size_t output_count,\n    uint64_t fee_rate\n) {\n    size_t base_size = 10;  // Overhead\n    size_t input_size = 148;  // P2PKH input\n    size_t output_size = 34;  // P2PKH output\n    \n    size_t estimated_size = base_size + \n        (input_count * input_size) + \n        (output_count * output_size);\n    \n    return calculate_fee(estimated_size, fee_rate);\n}\n```\n\n```go\nfunc calculateFee(txSizeVBytes int, feeRateSatPerVB int64) int64 {\n    return int64(txSizeVBytes) * feeRateSatPerVB\n}\n\nfunc calculateFeeForOutputs(\n    inputCount, outputCount int,\n    feeRate int64,\n) int64 {\n    baseSize := 10  // Overhead\n    inputSize := 148  // P2PKH input\n    outputSize := 34  // P2PKH output\n    \n    estimatedSize := baseSize + \n        (inputCount * inputSize) + \n        (outputCount * outputSize)\n    \n    return calculateFee(estimatedSize, feeRate)\n}\n```\n\n```javascript\nfunction calculateFee(txSizeVBytes, feeRateSatPerVB) {\n    return txSizeVBytes * feeRateSatPerVB;\n}\n\nfunction calculateFeeForOutputs(inputCount, outputCount, feeRate) {\n    const baseSize = 10;  // Overhead\n    const inputSize = 148;  // P2PKH input\n    const outputSize = 34;  // P2PKH output\n    \n    const estimatedSize = baseSize + \n        (inputCount * inputSize) + \n        (outputCount * outputSize);\n    \n    return calculateFee(estimatedSize, feeRate);\n}\n```\n:::\n\n---\n\n## Fee Bumping\n\nWhen a transaction is stuck in the [mempool](/docs/mining/mempool) because the fee rate is too low, you can increase the effective fee using **Replace-by-Fee (RBF)** or **Child Pays for Parent (CPFP)**.\n\n### Replace-by-Fee (RBF) and BIP 125\n\n**RBF** allows replacing an unconfirmed [transaction](/docs/bitcoin/transaction-lifecycle) with a new version that pays higher [fees](/docs/glossary#transaction-fee). The replacement must spend the same [inputs](/docs/glossary#input) and generally the same [outputs](/docs/glossary#output) (with stricter rules in BIP 125).\n\n#### BIP 125 Replaceability Rules\n\nFor a replacement to be accepted by [BIP 125](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki)-compliant nodes:\n\n1. **Replaceability signal**: The original transaction must signal that it is replaceable. This is done by setting the sequence of at least one input to a value below `0xfffffffe` (and not `0xffffffff`, which is used for [locktime](/docs/glossary#locktime) opt-out). In practice, `nSequence < 0xfffffffe` on any input makes the tx replaceable.\n\n2. **Higher fee**: The replacement must pay a **higher total fee** than the original.\n\n3. **Higher fee rate**: The replacement must have a **higher fee rate** (sat/vB) than the original.\n\n4. **No new unconfirmed inputs**: All [inputs](/docs/glossary#input) must be either:\n   - already in the mempool, or\n   - [confirmed](/docs/glossary#confirmation) in the chain.\n   The replacement cannot add inputs that are themselves unconfirmed and not in the mempool (to prevent dependency chains that complicate replacement).\n\n5. **Output and amount constraints**: The replacement cannot add new [outputs](/docs/glossary#output), cannot remove outputs, and cannot lower any output amount. It can only change the fee (by reducing one or more output amounts or by adding/using extra inputs that are already confirmed or in the mempool).\n\n#### Full RBF\n\n**Full RBF** (Replace-By-Fee regardless of signaling) is a **policy** option on some nodes (including Bitcoin Core 24+ with `-mempoolfullrbf=1`). With full RBF, *any* unconfirmed transaction can be replaced by a higher-fee version, even if the original did not signal replaceability (sequence was `0xffffffff`). This is **not** consensus; it is a relay policy. Miners and node operators may or may not enable it. When enabled, it allows fee bumping of \"non-RBF\" transactions, but recipients of unconfirmed [outputs](/docs/glossary#output) should treat them as replaceable.\n\n#### Replaceability in Wallets\n\n- **Senders**: To allow RBF, wallets set `nSequence` to e.g. `0xfffffffd` (or lower) on at least one input. Many wallets enable this by default.\n- **Receivers**: If you receive an unconfirmed payment, assume it can be double-spent or replaced until it has [confirmations](/docs/glossary#confirmation). For high-value accepts, wait for 1â€“6 confirmations.\n\n### Child Pays for Parent (CPFP)\n\n**CPFP** is used when you **cannot** replace the original (e.g., you are the **recipient** and donâ€™t control the [inputs](/docs/glossary#input), or the original is not RBF-signaling). You create a **child** [transaction](/docs/bitcoin/transaction-lifecycle) that spends an **output** of the stuck (parent) transaction and attach a high enough fee so that miners are willing to mine both parent and child together. Miners evaluate the **package** (parent + child) by the combined fee and combined size; a high-fee child makes the package profitable.\n\n```text\nParent Transaction:\n- Fee: 2 sat/vB (too low)\n- Status: Stuck in mempool\n- Has an output to you\n\nChild Transaction:\n- Spends the parentâ€™s output to you\n- Fee: e.g. 50 sat/vB\n- Miner includes both; combined fee makes the package attractive\n```\n\nCPFP works only if you control an [output](/docs/glossary#output) of the parent (e.g., you received the payment). The child must be valid and, under typical package relay rules, the parent+child package must meet the nodeâ€™s fee and size policies.\n\n### Transaction Pinning\n\n**Pinning** is a class of attacks where an attacker tries to *prevent* a victimâ€™s transaction from being replaced or from being mined, for example:\n\n- **RBF pinning**: The replacement is made to violate BIP 125 (e.g., by making the victimâ€™s replacement depend on unconfirmed inputs that are not in the mempool, or by other rule games) so nodes reject it.\n- **CPFP pinning**: The victimâ€™s child (or the package) is made to fail package validation, or the attacker spends the same parent output in a way that blocks the victimâ€™s child.\n\n**Package relay** and **package RBF** (see below) are designed to make fee bumping more robust and to reduce pinning: for example, by allowing replacement of a *package* (parent + child) and by standardizing how packages are validated and relayed.\n\n### Package Relay and Package RBF\n\n**Package relay** (and related **package RBF** ideas) allow nodes to accept and relay a **package** of related transactions (e.g., parent + child) as a unit. The mempool and [block construction](/docs/mining/block-construction) logic can then:\n\n- Evaluate the packageâ€™s total fee and total size when deciding to accept or to [mine](/docs/mining) it.\n- In **package RBF**, allow a *replacement* that is itself a package (e.g., a new parent+child that replaces a previous parent, or that bumps the effective fee of an unconfirmed parent via a new child).\n\nAs of this writing, package relay and package RBF are in [BIP process](https://github.com/bitcoin/bips) and/or implemented as optional node policy (e.g., in Bitcoin Core). They are important for [Lightning](/docs/lightning) and other [Layer 2](/docs/advanced/sidechains) protocols that need to reliably fee-bump [on-chain](/docs/glossary#on-chain) transactions.\n\n### When to Use RBF vs CPFP\n\n| Situation | Use |\n|-----------|-----|\n| You are the **sender** and control the inputs | **RBF**: Create a replacement that pays more (and meets BIP 125). |\n| You are the **recipient** and the sender did not enable RBF or you canâ€™t replace | **CPFP**: Spend the output you received with a high-fee child. |\n| You use **Lightning** or other L2 | RBF and CPFP (and, where available, package RBF) are used by the implementation to bump commitment or [HTLC](/docs/lightning/routing/htlc) transactions. |\n\n---\n\n## Fee Market Dynamics\n\n### Supply and Demand\n\n```text\nHigh Demand (many transactions):\n- Mempool fills up\n- Fees increase\n- Users compete for block space\n\nLow Demand (few transactions):\n- Mempool empties\n- Fees decrease\n- Even low fees confirm quickly\n```\n\n### Historical Patterns\n\nFees fluctuate based on:\n\n- **Network activity**: More users = higher fees\n- **Block space competition**: Limited space = bidding war\n- **Market events**: Price movements affect activity\n- **Time of day**: Regional usage patterns\n\n---\n\n## Best Practices\n\n### For Users\n\n1. **Use fee estimation**: Don't guess fees\n2. **Choose appropriate priority**: Don't overpay for non-urgent transactions\n3. **Use SegWit/Taproot**: Lower fees for same functionality\n4. **Monitor mempool**: Check current conditions before sending\n\n### For Developers\n\n1. **Implement fee estimation**: Use APIs or RPC\n2. **Support RBF**: Allow fee bumping\n3. **Handle fee errors**: Gracefully handle insufficient fees\n4. **Test fee logic**: Verify calculations are correct\n\n---\n\n## Related Topics\n\n- [Mempool](/docs/mining/mempool) - Where transactions wait\n- [Block Visualizer](/block-visualizer) - See transactions flowing into blocks\n- [Block Construction](/docs/mining/block-construction) - How miners select transactions\n- [SegWit](/docs/bitcoin/segwit) - Lower fees through weight units\n- [Transaction Lifecycle](/docs/bitcoin/transaction-lifecycle) - Transaction states\n\n---\n\n## Resources\n\n- [mempool.space](https://mempool.space) - Fee estimation and mempool visualization\n- [Bitcoin Core RPC: estimatesmartfee](https://developer.bitcoin.org/reference/rpc/estimatesmartfee.html)\n",
    "filename": "transaction-fees.md"
  },
  "/docs/bitcoin/transaction-malleability": {
    "content": "# Transaction Malleability\n\nTransaction malleability was a vulnerability in Bitcoin that allowed anyone to modify a transaction's signature without invalidating it, changing the transaction ID. SegWit fixed this issue in 2017.\n\n## What Was Transaction Malleability?\n\n**Transaction malleability** allowed modifying transaction signatures in ways that changed the transaction ID but didn't invalidate the transaction:\n\n```text\nOriginal Transaction:\nTXID: abc123...\nSignature: [valid signature]\n\nMalleated Transaction:\nTXID: def456... (different!)\nSignature: [modified but still valid]\n```\n\nBoth transactions were valid, but had different IDs.\n\n---\n\n## How It Worked\n\n### The Problem\n\nBefore SegWit, signatures were part of the transaction data used to calculate the TXID:\n\n```text\nTXID = SHA256D(serialized transaction)\n     = SHA256D(version + inputs + outputs + signatures + locktime)\n```\n\nSince signatures could be modified (DER encoding variations, S-value normalization), the TXID could change.\n\n### Attack Vector\n\n```text\n1. Alice broadcasts transaction: TXID = abc123...\n2. Attacker sees transaction in mempool\n3. Attacker modifies signature (malleates)\n4. Attacker broadcasts malleated version: TXID = def456...\n5. One version gets confirmed (def456...)\n6. Alice's original transaction (abc123...) never confirms\n7. Alice thinks transaction failed, but it actually succeeded\n```\n\n---\n\n## Impact\n\n### Problems Created\n\n1. **Payment Channels Impossible**: Couldn't build transactions depending on unconfirmed transactions\n2. **Lightning Network Blocked**: Required fixed transaction IDs\n3. **Transaction Tracking Issues**: TXIDs could change unexpectedly\n4. **Double-Spend Confusion**: Appeared like double-spend, but wasn't\n\n### Example: Payment Channel\n\n```text\nPayment Channel Setup:\n1. Create funding transaction: TXID = fund123...\n2. Create commitment transaction: depends on fund123...\n3. Attacker malleates funding tx: TXID = fund456...\n4. Commitment transaction becomes invalid!\n5. Payment channel fails to open\n```\n\n---\n\n## The Fix: SegWit\n\nSegWit separated witness (signature) data from transaction data:\n\n```text\nBefore SegWit:\nTXID = SHA256D(transaction with signatures)\n\nAfter SegWit:\nTXID = SHA256D(transaction WITHOUT witness)\nwtxid = SHA256D(transaction WITH witness)\n```\n\n**Key insight**: TXID no longer includes signatures, so it can't be changed by signature modifications.\n\n---\n\n## Historical Context\n\n### When It Was Discovered\n\n- **2011**: First discussions of malleability\n- **2013**: Mt. Gox blamed malleability for issues (later revealed as cover-up)\n- **2014**: More serious attention to the problem\n- **2017**: SegWit activated, fixing the issue\n\n### Mt. Gox Incident\n\nMt. Gox claimed transaction malleability caused their problems:\n\n```text\nClaimed:\n- Malleated transactions confused their system\n- Led to accounting errors\n- Caused exchange issues\n\nReality:\n- Malleability was real, but not the main issue\n- Poor security and management were the real problems\n- Used as excuse for larger failures\n```\n\n---\n\n## Technical Details\n\n### Signature Encoding Variations\n\nECDSA signatures have multiple valid encodings:\n\n```text\nDER Encoding:\n- S-value can be normalized (low or high)\n- Extra bytes can be added/removed\n- All produce valid signatures\n- All change the transaction hash\n```\n\n### S-Value Normalization\n\n```text\nECDSA Signature:\n- r value: 32 bytes\n- s value: 32 bytes (can be s or n-s)\n\nBoth are valid:\n- s = 0x1234...\n- s = n - 0x1234... (also valid)\n\nDifferent s values â†’ Different signature â†’ Different TXID\n```\n\n---\n\n## Current Status\n\n### SegWit Adoption\n\nAs of 2024:\n- **~80% of transactions** use SegWit\n- SegWit transactions are not malleable\n- Legacy transactions still technically malleable (rarely exploited)\n\n### Best Practices\n\n1. **Use SegWit addresses**: Automatically protected\n2. **Use Taproot addresses**: Also protected, better privacy\n3. **Avoid legacy addresses**: Still vulnerable (though rarely exploited)\n\n---\n\n## Related Topics\n\n- [SegWit](/docs/bitcoin/segwit) - The fix for malleability\n- [Transaction Lifecycle](/docs/bitcoin/transaction-lifecycle) - Transaction states\n- [Lightning Network](/docs/lightning) - Requires malleability fix\n\n---\n\n## Resources\n\n- [BIP 141: Segregated Witness](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)\n- [Transaction Malleability](https://en.bitcoin.it/wiki/Transaction_Malleability)\n",
    "filename": "transaction-malleability.md"
  },
  "/docs/bitcoin/segwit": {
    "content": "# Segregated Witness (SegWit)\n\nSegregated Witness (SegWit) is a major Bitcoin protocol upgrade activated in August 2017 (block 481,824). It separates signature (witness) data from transaction data, fixing transaction malleability and effectively increasing block capacity. SegWit was designed primarily by [Pieter Wuille](/docs/history/people#pieter-wuille) (BIP 141). **SegWit** separates the \"witness\" (signature data) from the transaction body, storing it in a separate structure. This fundamental change enables:\n\n- **Malleability fix**: Transaction IDs can no longer be changed after signing\n- **Capacity increase**: Effective block size up to ~4 MB (from 1 MB)\n- **Fee reduction**: Witness data costs less than transaction data\n- **Lightning Network**: Enables payment channels and off-chain scaling\n\n---\n\n## The Problem SegWit Solved\n\n### Transaction Malleability\n\nBefore SegWit, anyone could modify a transaction's signature without invalidating it, changing the transaction ID:\n\n```text\nOriginal Transaction:\nTXID: abc123...\n\nModified (malleated) Transaction:\nTXID: def456... (different ID, same validity)\n```\n\n**Impact**: \n- Made it impossible to build transactions that depend on unconfirmed transactions\n- Blocked development of payment channels (Lightning Network)\n- Created uncertainty in transaction tracking\n\n### Block Size Limit\n\nThe 1 MB block size limit created congestion:\n\n```text\nBefore SegWit:\n- Block size: 1 MB maximum\n- Transactions per block: ~2,000-3,000\n- Network capacity: ~7 transactions/second\n```\n\n---\n\n## How SegWit Works\n\n### Transaction Structure\n\nSegWit transactions have two parts:\n\n```text\nTransaction:\nâ”œâ”€â”€ Base Transaction (traditional structure)\nâ”‚   â”œâ”€â”€ Version\nâ”‚   â”œâ”€â”€ Inputs (without signatures)\nâ”‚   â”œâ”€â”€ Outputs\nâ”‚   â””â”€â”€ Locktime\nâ””â”€â”€ Witness Data (new, separate)\n    â””â”€â”€ Witness for each input\n```\n\n### Witness Structure\n\nEach input can have witness data:\n\n```text\nWitness:\nâ”œâ”€â”€ Number of witness elements (varint)\nâ””â”€â”€ Witness elements (stack items)\n    â”œâ”€â”€ Element 1 length (varint)\n    â”œâ”€â”€ Element 1 data\n    â”œâ”€â”€ Element 2 length (varint)\n    â””â”€â”€ Element 2 data\n```\n\n### Weight Units\n\nSegWit introduced **weight units** instead of bytes:\n\n```text\nWeight = (Base Size Ã— 4) + Total Size\n\nWhere:\n- Base Size: Transaction without witness data\n- Total Size: Transaction with witness data\n- Block limit: 4,000,000 weight units\n```\n\n**Effective capacity**:\n- Non-SegWit: ~1 MB per block\n- All SegWit: ~2-4 MB per block (depending on witness ratio)\n\n---\n\n## Address Types\n\n### P2WPKH (Pay-to-Witness-Pubkey-Hash)\n\nNative SegWit addresses starting with `bc1q`:\n\n```text\nFormat: bc1q + 32 characters\nExample: bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\n```\n\n### P2WSH (Pay-to-Witness-Script-Hash)\n\nSegWit version of P2SH for complex scripts:\n\n```text\nFormat: bc1q + 32 characters (longer)\nExample: bc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\n```\n\n### P2SH-P2WPKH (Nested SegWit)\n\nWrapped SegWit for backward compatibility:\n\n```text\nFormat: Starts with '3' (like P2SH)\nExample: 3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\n```\n\n---\n\n## Code Examples\n\n### Creating a SegWit Transaction\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network, Script, Transaction, TxIn, TxOut, Witness};\nuse bitcoin::hashes::Hash;\nuse bitcoin::secp256k1::{Secp256k1, SecretKey};\n\nfn create_segwit_transaction(\n    inputs: Vec<TxIn>,\n    outputs: Vec<TxOut>,\n    witness_data: Vec<Witness>,\n) -> Transaction {\n    let mut tx = Transaction {\n        version: 2,\n        lock_time: bitcoin::locktime::absolute::LockTime::ZERO,\n        input: inputs,\n        output: outputs,\n    };\n    \n    // Add witness data\n    for (i, witness) in witness_data.into_iter().enumerate() {\n        tx.input[i].witness = witness;\n    }\n    \n    tx\n}\n\nfn create_p2wpkh_witness(signature: Vec<u8>, pubkey: Vec<u8>) -> Witness {\n    let mut witness = Witness::new();\n    witness.push(signature);\n    witness.push(pubkey);\n    witness\n}\n```\n\n```python\nfrom bitcoin import SelectParams\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, CTxWitness\nfrom bitcoin.core.script import CScript\n\ndef create_segwit_transaction(inputs, outputs, witness_data):\n    \"\"\"Create a SegWit transaction.\"\"\"\n    tx = CTransaction()\n    tx.vin = inputs\n    tx.vout = outputs\n    tx.nVersion = 2\n    tx.nLockTime = 0\n    \n    # Add witness data\n    tx.wit = CTxWitness()\n    for witness in witness_data:\n        tx.wit.vtxinwit.append(witness)\n    \n    return tx\n\ndef create_p2wpkh_witness(signature, pubkey):\n    \"\"\"Create witness for P2WPKH spend.\"\"\"\n    witness = CTxWitness()\n    witness.stack = [signature, pubkey]\n    return witness\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::transaction create_segwit_transaction(\n    const std::vector<bc::input>& inputs,\n    const std::vector<bc::output>& outputs,\n    const std::vector<bc::witness>& witnesses\n) {\n    bc::transaction tx;\n    tx.set_version(2);\n    tx.set_locktime(0);\n    tx.set_inputs(inputs);\n    tx.set_outputs(outputs);\n    \n    // Add witness data\n    for (size_t i = 0; i < witnesses.size() && i < inputs.size(); ++i) {\n        tx.inputs()[i].set_witness(witnesses[i]);\n    }\n    \n    return tx;\n}\n\nbc::witness create_p2wpkh_witness(\n    const bc::ec_signature& signature,\n    const bc::ec_compressed& pubkey\n) {\n    bc::witness witness;\n    witness.push_back(bc::to_chunk(signature));\n    witness.push_back(bc::to_chunk(pubkey));\n    return witness;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/wire\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n)\n\nfunc createSegWitTransaction(\n\tinputs []*wire.TxIn,\n\toutputs []*wire.TxOut,\n\twitnessData [][]wire.TxWitness,\n) *wire.MsgTx {\n\ttx := wire.NewMsgTx(wire.TxVersion)\n\ttx.LockTime = 0\n\t\n\tfor _, input := range inputs {\n\t\ttx.AddTxIn(input)\n\t}\n\t\n\tfor _, output := range outputs {\n\t\ttx.AddTxOut(output)\n\t}\n\t\n\t// Add witness data\n\tfor i, witness := range witnessData {\n\t\tif i < len(tx.TxIn) {\n\t\t\ttx.TxIn[i].Witness = witness\n\t\t}\n\t}\n\t\n\treturn tx\n}\n\nfunc createP2WPKHWitness(signature, pubkey []byte) wire.TxWitness {\n\treturn wire.TxWitness{signature, pubkey}\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createSegWitTransaction(inputs, outputs, witnessData) {\n    const tx = new bitcoin.Transaction();\n    tx.version = 2;\n    tx.locktime = 0;\n    \n    // Add inputs\n    inputs.forEach(input => {\n        tx.addInput(input.hash, input.index, input.sequence);\n    });\n    \n    // Add outputs\n    outputs.forEach(output => {\n        tx.addOutput(output.address, output.value);\n    });\n    \n    // Add witness data\n    witnessData.forEach((witness, i) => {\n        if (i < tx.ins.length) {\n            tx.ins[i].witness = witness;\n        }\n    });\n    \n    return tx;\n}\n\nfunction createP2WPKHWitness(signature, pubkey) {\n    return [signature, pubkey];\n}\n```\n:::\n\n### Calculating Transaction Weight\n\n:::code-group\n```rust\nfn calculate_weight(tx: &Transaction) -> usize {\n    let base_size = tx.get_size_without_witness();\n    let total_size = tx.get_total_size();\n    (base_size * 4) + total_size\n}\n\nfn calculate_vsize(tx: &Transaction) -> usize {\n    let weight = calculate_weight(tx);\n    (weight + 3) / 4  // Round up\n}\n```\n\n```python\ndef calculate_weight(tx):\n    \"\"\"Calculate transaction weight.\"\"\"\n    base_size = len(tx.serialize_without_witness())\n    total_size = len(tx.serialize())\n    return (base_size * 4) + total_size\n\ndef calculate_vsize(tx):\n    \"\"\"Calculate virtual size (vbytes).\"\"\"\n    weight = calculate_weight(tx)\n    return (weight + 3) // 4  # Round up\n```\n\n```cpp\nsize_t calculate_weight(const bc::transaction& tx) {\n    size_t base_size = tx.serialized_size(false);\n    size_t total_size = tx.serialized_size(true);\n    return (base_size * 4) + total_size;\n}\n\nsize_t calculate_vsize(const bc::transaction& tx) {\n    size_t weight = calculate_weight(tx);\n    return (weight + 3) / 4;  // Round up\n}\n```\n\n```go\nfunc calculateWeight(tx *wire.MsgTx) int {\n    baseSize := tx.SerializeSizeStripped()\n    totalSize := tx.SerializeSize()\n    return (baseSize * 4) + totalSize\n}\n\nfunc calculateVSize(tx *wire.MsgTx) int {\n    weight := calculateWeight(tx)\n    return (weight + 3) / 4  // Round up\n}\n```\n\n```javascript\nfunction calculateWeight(tx) {\n    const baseSize = tx.byteLength(false);  // Without witness\n    const totalSize = tx.byteLength(true);  // With witness\n    return (baseSize * 4) + totalSize;\n}\n\nfunction calculateVSize(tx) {\n    const weight = calculateWeight(tx);\n    return Math.ceil(weight / 4);\n}\n```\n:::\n\n---\n\n## Transaction ID vs. Witness Transaction ID\n\n### Before SegWit\n\n```text\nTXID = SHA256D(serialized transaction)\n```\n\nProblem: Signature changes â†’ TXID changes (malleability)\n\n### After SegWit\n\n```text\nTXID = SHA256D(serialized transaction WITHOUT witness)\nwtxid = SHA256D(serialized transaction WITH witness)\n```\n\n**Key insight**: TXID no longer includes witness data, so it can't be changed by signature modifications.\n\n---\n\n## Benefits\n\n### 1. Malleability Fix\n\nTransactions can now safely reference unconfirmed transactions:\n\n```text\nBefore SegWit:\nParent TX: abc123... (unconfirmed)\nChild TX: references abc123...\nâ†’ Parent gets malleated â†’ def456...\nâ†’ Child TX becomes invalid!\n\nAfter SegWit:\nParent TX: abc123... (TXID fixed, can't be changed)\nChild TX: references abc123...\nâ†’ Always valid!\n```\n\n### 2. Effective Capacity Increase\n\n```text\nBlock Weight Limit: 4,000,000 weight units\n\nExample block:\n- Base size: 1,000,000 bytes\n- Witness size: 1,500,000 bytes\n- Total size: 2,500,000 bytes\n- Weight: (1,000,000 Ã— 4) + 2,500,000 = 6,500,000 weight units\n\nBut wait... that's over the limit!\n\nActual calculation:\n- Base: 1,000,000 bytes = 4,000,000 weight units\n- Witness: 1,500,000 bytes = 1,500,000 weight units\n- Total weight: 5,500,000 (over limit)\n\nRealistic SegWit block:\n- Base: 1,000,000 bytes = 4,000,000 weight units\n- Witness: 1,000,000 bytes = 1,000,000 weight units\n- Total: 5,000,000 weight units (over limit)\n\nOptimal SegWit block:\n- Base: 1,000,000 bytes = 4,000,000 weight units\n- Witness: 0 bytes = 0 weight units\n- Total: 4,000,000 weight units (at limit)\n\nWith mixed transactions:\n- ~2-3 MB effective capacity\n```\n\n### 3. Fee Savings\n\nWitness data costs 1/4 the weight of base data:\n\n```text\nLegacy transaction:\n- 250 bytes total\n- Fee: 250 bytes Ã— fee_rate\n\nSegWit transaction:\n- 100 bytes base + 150 bytes witness\n- Weight: (100 Ã— 4) + 250 = 650 weight units\n- Virtual size: 650 / 4 = 162.5 vbytes\n- Fee: 162.5 vbytes Ã— fee_rate (35% savings!)\n```\n\n---\n\n## Adoption\n\n### Current Usage\n\nAs of 2024:\n- **~80% of transactions** use SegWit\n- Most wallets support SegWit addresses\n- Lightning Network requires SegWit\n\n### Migration Path\n\n1. **P2SH-P2WPKH** (wrapped): Backward compatible, starts with '3'\n2. **P2WPKH** (native): Best efficiency, starts with 'bc1q'\n3. **P2TR** (Taproot): Latest standard, starts with 'bc1p'\n\n---\n\n## Technical Details\n\n### Witness Version\n\nSegWit uses witness version 0:\n\n```text\nWitness Program:\nâ”œâ”€â”€ Version (1 byte): 0x00\nâ””â”€â”€ Program (20 or 32 bytes)\n    â”œâ”€â”€ 20 bytes: P2WPKH\n    â””â”€â”€ 32 bytes: P2WSH\n```\n\n### Script Execution\n\nSegWit changes script execution:\n\n1. **Old**: ScriptSig + ScriptPubKey executed together\n2. **New**: Witness script replaces ScriptSig, ScriptPubKey is minimal\n\n```text\nP2WPKH ScriptPubKey:\nOP_0 <20-byte hash>\n\nWitness (replaces ScriptSig):\n<signature> <pubkey>\n```\n\n---\n\n## Related Topics\n\n- [Taproot](/docs/bitcoin/taproot) - Next major upgrade after SegWit\n- [Address Types](/docs/wallets/address-types) - Understanding SegWit addresses\n- [Transaction Fees](/docs/bitcoin/transaction-fees) - How SegWit affects fees\n- [Lightning Network](/docs/lightning) - Requires SegWit to function\n\n---\n\n## Resources\n\n- [BIP 141: Segregated Witness](https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki)\n- [BIP 143: Transaction Signature Verification](https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki)\n- [BIP 144: Segregated Witness (Peer Services)](https://github.com/bitcoin/bips/blob/master/bip-0144.mediawiki)\n",
    "filename": "segwit.md"
  },
  "/docs/bitcoin/taproot": {
    "content": "# Taproot\n\nTaproot is a major Bitcoin protocol upgrade activated in November 2021 (block 709,632). It combines Schnorr signatures with MAST (Merkle Abstract Syntax Trees) to provide better privacy, efficiency, and flexibility for Bitcoin transactions. [Pieter Wuille](/docs/history/people#pieter-wuille) was a key designer (BIPs 340, 341, 342). **Taproot** introduces a new output type (P2TR) that enables:\n\n- **Schnorr signatures**: More efficient than ECDSA, enables signature aggregation\n- **MAST**: Hides unused script conditions in a Merkle tree\n- **Better privacy**: Complex contracts look identical to simple payments\n- **Lower fees**: Smaller transaction sizes for complex scripts\n- **Key path spending**: Simple single-signature spends look normal\n\n---\n\n## Key Components\n\n### 1. Schnorr Signatures (BIP 340)\n\nSchnorr signatures replace ECDSA for Taproot outputs:\n\n**Benefits**:\n- **Linear**: Enables signature aggregation (MuSig)\n- **Smaller**: 64 bytes vs 71-72 bytes for ECDSA\n- **Batch verification**: Verify multiple signatures faster\n- **Proven security**: Simpler mathematics, better understood\n\n### 2. MAST (Merkle Abstract Syntax Trees)\n\nMAST allows multiple spending conditions while only revealing the one used:\n\n```text\nComplex Contract:\nâ”œâ”€â”€ Condition 1: 2-of-3 multisig\nâ”œâ”€â”€ Condition 2: Timelock + signature\nâ”œâ”€â”€ Condition 3: Hash preimage reveal\nâ””â”€â”€ Condition 4: Simple signature (key path)\n\nWhen spending:\n- Use Condition 4 â†’ Looks like simple payment\n- Use Condition 1 â†’ Only reveal that condition\n- Other conditions remain hidden in Merkle tree\n```\n\n### 3. Taproot Outputs (P2TR)\n\nAddresses start with `bc1p` and use Bech32m encoding:\n\n```text\nFormat: bc1p + 32 characters\nExample: bc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac36sfj9ugtg7etq5\n```\n\n---\n\n## How Taproot Works\n\n### Key Path vs. Script Path\n\nTaproot outputs can be spent in two ways:\n\n#### Key Path (Simple Spend)\n\n```text\nOutput: P2TR address\nSpend: Single Schnorr signature\nResult: Looks identical to any other Taproot spend\nPrivacy: Maximum (no script revealed)\n```\n\n#### Script Path (Complex Spend)\n\n```text\nOutput: P2TR address (with hidden script tree)\nSpend: Reveal one script branch + proof\nResult: Reveals only the used condition\nPrivacy: Good (other conditions hidden)\n```\n\n### Taproot Construction\n\n```text\n1. Create internal key (from private key)\n2. Create script tree (if needed)\n3. Compute taproot output key:\n   - If script tree: tweak internal key with script root\n   - If key path only: use internal key directly\n4. Generate P2TR address from output key\n```\n\n---\n\n## Code Examples\n\n### Creating a Taproot Address\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network, PublicKey, XOnlyPublicKey};\nuse bitcoin::secp256k1::{Secp256k1, SecretKey, KeyPair};\nuse bitcoin::taproot::{TaprootBuilder, TaprootSpendInfo};\n\nfn create_taproot_address(secret_key: SecretKey) -> (Address, TaprootSpendInfo) {\n    let secp = Secp256k1::new();\n    let keypair = KeyPair::from_secret_key(&secp, &secret_key);\n    let (x_only_pubkey, _) = keypair.x_only_public_key();\n    \n    // Create taproot spend info (key path only)\n    let spend_info = TaprootBuilder::new()\n        .add_key(x_only_pubkey, None)\n        .finalize(&secp, x_only_pubkey)\n        .unwrap();\n    \n    let address = Address::from_str(\n        &spend_info.output_key().to_string()\n    ).unwrap();\n    \n    (address, spend_info)\n}\n```\n\n```python\nfrom bitcoin import SelectParams\nfrom bitcoin.core import CKey\nfrom bitcoin.wallet import P2TRBitcoinAddress\nfrom bitcoin.taproot import TaprootSpendInfo, TaprootBuilder\n\ndef create_taproot_address(privkey):\n    \"\"\"Create a Taproot address from private key.\"\"\"\n    pubkey = privkey.pub\n    x_only_pubkey = pubkey[1:]  # Remove 0x02/0x03 prefix\n    \n    # Create taproot spend info (key path only)\n    builder = TaprootBuilder()\n    builder.add_key(x_only_pubkey, None)\n    spend_info = builder.finalize(x_only_pubkey)\n    \n    # Generate address\n    address = P2TRBitcoinAddress.from_output_key(\n        spend_info.output_pubkey()\n    )\n    \n    return address, spend_info\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::wallet::payment_address create_taproot_address(\n    const bc::ec_secret& secret\n) {\n    bc::ec_compressed pubkey;\n    bc::secret_to_public(pubkey, secret);\n    \n    // Extract x-only public key (remove y coordinate)\n    bc::data_chunk x_only(32);\n    std::copy(pubkey.begin() + 1, pubkey.end(), x_only.begin());\n    \n    // Create taproot output key\n    bc::hash_digest taproot_hash;\n    bc::taproot_tweak_pubkey(pubkey, taproot_hash);\n    \n    // Generate P2TR address\n    return bc::wallet::payment_address(\n        bc::wallet::payment_address::mainnet_p2tr,\n        taproot_hash\n    );\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createTaprootAddress(privKey *btcec.PrivateKey) (btcutil.Address, error) {\n\tpubKey := privKey.PubKey()\n\t\n\t// Create taproot output key (simplified - key path only)\n\toutputKey := txscript.ComputeTaprootOutputKey(pubKey, nil)\n\t\n\t// Generate P2TR address\n\taddr, err := btcutil.NewAddressTaproot(\n\t\toutputKey.SerializeCompressed()[1:], // x-only\n\t\t&chaincfg.MainNetParams,\n\t)\n\t\n\treturn addr, err\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { schnorr } = require('@noble/secp256k1');\n\nfunction createTaprootAddress(privateKey) {\n    // Derive public key\n    const publicKey = schnorr.getPublicKey(privateKey);\n    \n    // Create taproot output (simplified - key path only)\n    const { address } = bitcoin.payments.p2tr({\n        internalPubkey: publicKey.slice(1), // x-only\n    });\n    \n    return address;\n}\n```\n:::\n\n### Creating a MAST Script Tree\n\n:::code-group\n```rust\nuse bitcoin::taproot::{TaprootBuilder, LeafVersion};\nuse bitcoin::Script;\n\nfn create_mast_script_tree() -> TaprootBuilder {\n    let mut builder = TaprootBuilder::new();\n    \n    // Add script leaves\n    let script1 = Script::from_hex(\"...\").unwrap(); // 2-of-3 multisig\n    let script2 = Script::from_hex(\"...\").unwrap(); // Timelock\n    let script3 = Script::from_hex(\"...\").unwrap(); // Hash lock\n    \n    builder = builder.add_leaf(0, script1.clone()).unwrap();\n    builder = builder.add_leaf(0, script2.clone()).unwrap();\n    builder = builder.add_leaf(0, script3.clone()).unwrap();\n    \n    builder\n}\n```\n\n```python\nfrom bitcoin.taproot import TaprootBuilder, LeafVersion\nfrom bitcoin.core.script import CScript\n\ndef create_mast_script_tree():\n    \"\"\"Create a MAST script tree with multiple conditions.\"\"\"\n    builder = TaprootBuilder()\n    \n    # Add script leaves\n    script1 = CScript([...])  # 2-of-3 multisig\n    script2 = CScript([...])  # Timelock\n    script3 = CScript([...])  # Hash lock\n    \n    builder.add_leaf(0, script1)\n    builder.add_leaf(0, script2)\n    builder.add_leaf(0, script3)\n    \n    return builder\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::taproot_builder create_mast_script_tree() {\n    bc::taproot_builder builder;\n    \n    // Add script leaves\n    bc::script script1 = bc::script::from_string(\"...\");\n    bc::script script2 = bc::script::from_string(\"...\");\n    bc::script script3 = bc::script::from_string(\"...\");\n    \n    builder.add_leaf(0, script1);\n    builder.add_leaf(0, script2);\n    builder.add_leaf(0, script3);\n    \n    return builder;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createMASTScriptTree() *txscript.IndexedTapScriptTree {\n\t// Create script leaves\n\tscript1 := []byte{...} // 2-of-3 multisig\n\tscript2 := []byte{...} // Timelock\n\tscript3 := []byte{...} // Hash lock\n\t\n\tleaves := []txscript.TapLeaf{\n\t\ttxscript.NewBaseTapLeaf(script1),\n\t\ttxscript.NewBaseTapLeaf(script2),\n\t\ttxscript.NewBaseTapLeaf(script3),\n\t}\n\t\n\ttree := txscript.AssembleTaprootScriptTree(leaves...)\n\treturn tree\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createMASTScriptTree() {\n    // Create script leaves\n    const script1 = Buffer.from([...]); // 2-of-3 multisig\n    const script2 = Buffer.from([...]); // Timelock\n    const script3 = Buffer.from([...]); // Hash lock\n    \n    // Build Merkle tree (simplified)\n    const leaves = [script1, script2, script3];\n    // Note: Full MAST implementation requires Merkle tree construction\n    \n    return leaves;\n}\n```\n:::\n\n---\n\n## Privacy Benefits\n\n### Before Taproot\n\n```text\nMultisig Transaction:\n- Reveals all public keys\n- Reveals all signatures\n- Obvious it's a multisig\n- Linkable to other multisig transactions\n```\n\n### After Taproot\n\n```text\nMultisig Transaction (key path):\n- Looks identical to single-sig\n- No script revealed\n- No way to tell it's multisig\n- Maximum privacy\n```\n\n### Script Path Privacy\n\nEven when using script path:\n\n```text\nComplex Contract with 10 conditions:\n- Only reveals 1 used condition\n- Other 9 conditions hidden in Merkle tree\n- Much better than revealing all conditions\n```\n\n---\n\n## Efficiency Benefits\n\n### Signature Size\n\n```text\nECDSA (SegWit):\n- Signature: 71-72 bytes\n- Public key: 33 bytes\n- Total: ~104-105 bytes\n\nSchnorr (Taproot):\n- Signature: 64 bytes\n- Public key: 32 bytes (x-only)\n- Total: 96 bytes\n- Savings: ~8-9 bytes per input\n```\n\n### Transaction Size\n\nFor a 2-of-3 multisig:\n\n```text\nBefore Taproot (P2WSH):\n- Script: ~105 bytes\n- 2 signatures: ~142 bytes\n- Total: ~247 bytes\n\nAfter Taproot (key path):\n- 1 signature: 64 bytes\n- Total: 64 bytes\n- Savings: ~74%!\n```\n\n---\n\n## MuSig (Multi-Signature Aggregation)\n\nTaproot enables MuSig, where multiple signatures are combined into one:\n\n```text\nTraditional Multisig:\n- Key 1 signature: 71 bytes\n- Key 2 signature: 71 bytes\n- Key 3 signature: 71 bytes\n- Total: 213 bytes\n\nMuSig (Taproot):\n- Aggregated signature: 64 bytes\n- Savings: 70%!\n```\n\n---\n\n## Adoption\n\n### Current Usage\n\nAs of 2024:\n- **~5-10% of transactions** use Taproot\n- Growing adoption in modern wallets\n- Required for advanced smart contracts\n\n### Migration\n\n1. **Use P2TR addresses** for new outputs\n2. **Support Taproot** in wallet software\n3. **Migrate existing funds** to Taproot for better privacy\n\n---\n\n## Technical Details\n\n### Bech32m Encoding\n\nTaproot uses Bech32m (modified Bech32) instead of Bech32:\n\n- **Bech32**: Used for SegWit (P2WPKH, P2WSH)\n- **Bech32m**: Used for Taproot (P2TR)\n- **Difference**: Constant in checksum calculation\n\n### Taproot Version\n\nTaproot uses witness version 1:\n\n```text\nWitness Program:\nâ”œâ”€â”€ Version (1 byte): 0x01\nâ””â”€â”€ Program (32 bytes): Taproot output key\n```\n\n### Tapscript\n\nTaproot introduces Tapscript, a new scripting language:\n\n- Based on Bitcoin Script\n- New opcodes: `OP_CHECKSIGADD`\n- Resource limits similar to SegWit\n\n---\n\n## Related Topics\n\n- [SegWit](/docs/bitcoin/segwit) - Previous major upgrade\n- [Schnorr Signatures](/docs/bitcoin/cryptography#schnorr-signatures) - Signature scheme\n- [MAST](/docs/glossary#mast-merkle-abstract-syntax-tree) - Merkle Abstract Syntax Trees\n- [Address Types](/docs/wallets/address-types) - Understanding P2TR addresses\n\n---\n\n## Resources\n\n- [BIP 340: Schnorr Signatures](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki)\n- [BIP 341: Taproot](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)\n- [BIP 342: Validation of Taproot Scripts](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki)\n",
    "filename": "taproot.md"
  },
  "/docs/bitcoin/p2p-protocol": {
    "content": "# P2P Network Protocol\n\nBitcoin uses a peer-to-peer (P2P) network protocol for nodes to communicate, share blocks, and propagate transactions. Understanding the P2P protocol is essential for running nodes and understanding network behavior.\n\n## Network Architecture\n\n### Node Types\n\n```text\nFull Nodes:\n- Download and validate entire blockchain\n- Relay blocks and transactions\n- Maintain network consensus\n\nLight Nodes (SPV):\n- Download block headers only\n- Request specific transactions\n- Rely on full nodes for data\n```\n\n### Connection Model\n\n```text\nTypical Node:\nâ”œâ”€â”€ 8-10 outbound connections (you connect to others)\nâ”œâ”€â”€ Up to 125 inbound connections (others connect to you)\nâ””â”€â”€ Block-relay-only connections (privacy)\n```\n\n---\n\n## Protocol Messages\n\n### Handshake\n\nNodes establish connections through a handshake:\n\n```text\n1. Version Message: Announce capabilities\n2. Verack Message: Acknowledge version\n3. Connection established\n```\n\n### Core Messages\n\n| Message | Purpose |\n|---------|---------|\n| `version` | Initial handshake, announce capabilities |\n| `verack` | Acknowledge version message |\n| `addr` | Share peer addresses |\n| `inv` | Inventory announcement (blocks/tx) |\n| `getdata` | Request specific data |\n| `block` | Send block data |\n| `tx` | Send transaction data |\n| `headers` | Send block headers |\n| `getheaders` | Request block headers |\n| `ping` / `pong` | Keep connection alive |\n\n---\n\n## Code Examples\n\n### Establishing Connection\n\n:::code-group\n```rust\nuse std::net::TcpStream;\nuse bitcoin::network::message::{NetworkMessage, RawNetworkMessage};\nuse bitcoin::network::constants::Magic;\n\nfn connect_to_peer(address: &str) -> Result<(), Box<dyn std::error::Error>> {\n    let mut stream = TcpStream::connect(address)?;\n    \n    // Send version message\n    let version_msg = create_version_message();\n    send_message(&mut stream, &version_msg)?;\n    \n    // Wait for verack\n    let response = receive_message(&mut stream)?;\n    // Process verack...\n    \n    Ok(())\n}\n```\n\n```python\nimport socket\nfrom bitcoin.network import CVersionMessage, CVerAckMessage\n\ndef connect_to_peer(address, port):\n    \"\"\"Connect to a Bitcoin peer.\"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((address, port))\n    \n    # Send version message\n    version_msg = CVersionMessage()\n    send_message(sock, version_msg)\n    \n    # Wait for verack\n    response = receive_message(sock)\n    # Process verack...\n    \n    return sock\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nvoid connect_to_peer(const std::string& address, uint16_t port) {\n    bc::network::session session;\n    \n    // Connect to peer\n    session.connect(address, port, [](const bc::code& ec) {\n        if (ec) {\n            std::cerr << \"Connection failed: \" << ec.message() << std::endl;\n            return;\n        }\n        \n        // Send version message\n        bc::message::version version_msg;\n        session.send(version_msg, [](const bc::code& ec) {\n            // Handle send result\n        });\n    });\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/peer\"\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\nfunc connectToPeer(address string) (*peer.Peer, error) {\n\t// Create peer configuration\n\tcfg := &peer.Config{\n\t\tUserAgentName:    \"bitcoin-node\",\n\t\tUserAgentVersion: \"1.0.0\",\n\t}\n\t\n\t// Connect to peer\n\tp, err := peer.NewOutboundPeer(cfg, address)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Send version message\n\tmsg := wire.NewMsgVersion(...)\n\tp.QueueMessage(msg, nil)\n\t\n\treturn p, nil\n}\n```\n\n```javascript\nconst net = require('net');\nconst { Message } = require('bitcoin-protocol');\n\nfunction connectToPeer(address, port) {\n    return new Promise((resolve, reject) => {\n        const socket = new net.Socket();\n        \n        socket.connect(port, address, () => {\n            // Send version message\n            const versionMsg = new Message('version', {...});\n            socket.write(versionMsg.serialize());\n            \n            // Wait for verack\n            socket.on('data', (data) => {\n                const msg = Message.deserialize(data);\n                if (msg.command === 'verack') {\n                    resolve(socket);\n                }\n            });\n        });\n    });\n}\n```\n:::\n\n### Sending Inventory\n\n:::code-group\n```rust\nuse bitcoin::network::message::{NetworkMessage, InvMessage};\nuse bitcoin::network::message_network::Inventory;\n\nfn announce_transaction(txid: [u8; 32]) {\n    let inv = Inventory::new_transaction(txid);\n    let inv_msg = InvMessage::new(vec![inv]);\n    // Send to peers...\n}\n```\n\n```python\nfrom bitcoin.network import CInv, CInvMessage\n\ndef announce_transaction(txid):\n    \"\"\"Announce transaction to peers.\"\"\"\n    inv = CInv(CInv.MSG_TX, txid)\n    inv_msg = CInvMessage([inv])\n    # Send to peers...\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nvoid announce_transaction(const bc::hash_digest& txid) {\n    bc::message::inventory inv;\n    inv.set_type(bc::message::inventory::type_id::transaction);\n    inv.set_hash(txid);\n    \n    bc::message::inv inv_msg;\n    inv_msg.inventories().push_back(inv);\n    // Send to peers...\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\nfunc announceTransaction(txid *wire.ShaHash) {\n\tinv := wire.NewInvVect(wire.InvTypeTx, txid)\n\tinvMsg := wire.NewMsgInv()\n\tinvMsg.AddInvVect(inv)\n\t// Send to peers...\n}\n```\n\n```javascript\nconst { Message } = require('bitcoin-protocol');\n\nfunction announceTransaction(txid) {\n    const inv = {\n        type: 1, // MSG_TX\n        hash: txid,\n    };\n    const invMsg = new Message('inv', { inventories: [inv] });\n    // Send to peers...\n}\n```\n:::\n\n---\n\n## Message Flow\n\n### Block Propagation\n\n```text\n1. Miner finds block\n2. Sends 'inv' message to peers\n3. Peers request block with 'getdata'\n4. Miner sends 'block' message\n5. Peers validate and forward\n```\n\n### Transaction Propagation\n\n```text\n1. User creates transaction\n2. Sends 'inv' or 'tx' to peers\n3. Peers validate transaction\n4. Peers forward to their peers\n5. Transaction spreads across network\n```\n\n---\n\n## Peer Discovery\n\n### Methods\n\n1. **DNS Seeds**: Hardcoded DNS servers\n2. **Hardcoded Seeds**: Bootstrap IP addresses\n3. **Peer Exchange**: Peers share addresses\n4. **Manual Connection**: User-specified peers\n\n### Address Management\n\n```text\nKnown Addresses:\nâ”œâ”€â”€ Tried addresses (recently connected)\nâ”œâ”€â”€ New addresses (not yet tried)\nâ””â”€â”€ Banned addresses (avoid)\n```\n\n---\n\n## Network Security\n\n### Eclipse Attacks\n\nPrevented by:\n- Connecting to diverse IP ranges\n- Using multiple outbound connections\n- Verifying block data independently\n\n### Sybil Attacks\n\nMitigated by:\n- Requiring proof-of-work for blocks\n- Independent validation by all nodes\n- No trust in individual peers\n\n---\n\n## Compact Blocks (BIP 152)\n\nOptimization for faster block propagation:\n\n```text\nStandard Block:\n- Full block: ~1-2 MB\n- Slow propagation\n\nCompact Block:\n- Header + short IDs: ~20 KB\n- Receiver reconstructs from mempool\n- Much faster\n```\n\n---\n\n## P2P v2 / Encrypted Transport (BIP 324)\n\n[BIP 324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki) defines a **v2 P2P transport** that encrypts and authenticated the peer-to-peer link. [Messages](/docs/bitcoin/p2p-protocol#protocol-messages) (e.g., `version`, `verack`, `inv`, `block`, `tx`) are encrypted so that a passive on-path observer cannot read or tamper with them. This improves privacy (e.g., hiding which blocks or transactions are requested) and helps prevent some eclipse-style and downgrade attacks.\n\n- **Handshake**: v2 uses an [ECDH](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki)-based key agreement; once the shared secret is established, the rest of the session is [ChaCha20](/docs/glossary#chacha20)-Poly1305 encrypted.\n- **Rollout**: Bitcoin Core and other nodes can support both the legacy (unencrypted) and v2 transports; v2 is used when both peers support it. Adoption is increasing; see [Bitcoin Core](https://github.com/bitcoin/bitcoin) and [BIP 324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki) for the latest status.\n\n---\n\n## Related Topics\n\n- [Block Propagation](/docs/bitcoin/blocks) - How blocks spread\n- [Mempool](/docs/mining/mempool) - Transaction pool\n- [Node Types](/docs/development/node-types) - Different node configurations\n\n---\n\n## Resources\n\n- [Bitcoin Protocol Documentation](https://en.bitcoin.it/wiki/Protocol_documentation)\n- [BIP 152: Compact Block Relay](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)\n- [BIP 324: Version 2 P2P Encrypted Transport](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki)\n",
    "filename": "p2p-protocol.md"
  },
  "/docs/bitcoin/rpc": {
    "content": "# RPC Commands Reference\n\nThis document provides a guide for interacting with your Bitcoin node using both curl and bitcoin-cli commands via [RPC](/docs/glossary#rpc-remote-procedure-call).\n\n> **Try it live!** Test these commands directly in the [Bitcoin CLI Terminal](/terminal). Connected to mainnet, no setup required.\n\n---\n\n## RPC Configuration\n\n### bitcoin.conf Setup\n\nAdd these settings to your `bitcoin.conf` file:\n\n```ini\n# RPC Server Settings\nserver=1\nrpcuser=your_username\nrpcpassword=your_secure_password\nrpcport=8332\n\n# Restrict RPC to localhost (recommended)\nrpcbind=127.0.0.1\nrpcallowip=127.0.0.1\n\n# Optional: Enable transaction index for full tx lookups\ntxindex=1\n```\n\n### Environment Variables\n\n```bash\n# Set environment variables (replace with your actual credentials)\nexport BITCOIN_RPC_USER=\"your_username\"\nexport BITCOIN_RPC_PASSWORD=\"your_password\"\nexport BITCOIN_RPC_PORT=\"8332\"\n```\n\n---\n\n## Basic RPC Structure\n\n```bash\n# Set up alias for easier use\nalias btc='bitcoin-cli -rpcuser=$BITCOIN_RPC_USER -rpcpassword=$BITCOIN_RPC_PASSWORD -rpcport=$BITCOIN_RPC_PORT'\n\n# Then use simple commands\nbtc <method_name> [parameters]\n```\n\n---\n\n## Programmatic RPC Access\n\nFor building applications, you can interact with Bitcoin Core RPC programmatically:\n\n:::code-group\n```rust\nuse reqwest::blocking::Client;\nuse serde::{Deserialize, Serialize};\nuse serde_json::{json, Value};\n\n#[derive(Serialize)]\nstruct RpcRequest {\n    jsonrpc: &'static str,\n    id: &'static str,\n    method: String,\n    params: Vec<Value>,\n}\n\n#[derive(Deserialize)]\nstruct RpcResponse {\n    result: Option<Value>,\n    error: Option<RpcError>,\n}\n\n#[derive(Deserialize)]\nstruct RpcError {\n    code: i32,\n    message: String,\n}\n\n/// Bitcoin RPC client with error handling\nstruct BitcoinRpc {\n    url: String,\n    user: String,\n    password: String,\n    client: Client,\n}\n\nimpl BitcoinRpc {\n    fn new(url: &str, user: &str, password: &str) -> Self {\n        Self {\n            url: url.to_string(),\n            user: user.to_string(),\n            password: password.to_string(),\n            client: Client::builder()\n                .timeout(std::time::Duration::from_secs(30))\n                .build()\n                .expect(\"Failed to create HTTP client\"),\n        }\n    }\n\n    fn call(&self, method: &str, params: Vec<Value>) -> Result<Value, String> {\n        let request = RpcRequest {\n            jsonrpc: \"1.0\",\n            id: \"rust-client\",\n            method: method.to_string(),\n            params,\n        };\n\n        let response = self.client\n            .post(&self.url)\n            .basic_auth(&self.user, Some(&self.password))\n            .json(&request)\n            .send()\n            .map_err(|e| format!(\"Connection error: {}\", e))?;\n\n        let rpc_response: RpcResponse = response\n            .json()\n            .map_err(|e| format!(\"Parse error: {}\", e))?;\n\n        if let Some(error) = rpc_response.error {\n            return Err(format!(\"RPC error {}: {}\", error.code, error.message));\n        }\n\n        Ok(rpc_response.result.unwrap_or(Value::Null))\n    }\n\n    fn get_blockchain_info(&self) -> Result<Value, String> {\n        self.call(\"getblockchaininfo\", vec![])\n    }\n\n    fn get_block(&self, hash: &str, verbosity: i32) -> Result<Value, String> {\n        self.call(\"getblock\", vec![json!(hash), json!(verbosity)])\n    }\n\n    fn get_mempool_info(&self) -> Result<Value, String> {\n        self.call(\"getmempoolinfo\", vec![])\n    }\n}\n\nfn main() {\n    let rpc = BitcoinRpc::new(\"http://127.0.0.1:8332\", \"user\", \"password\");\n    \n    match rpc.get_blockchain_info() {\n        Ok(info) => println!(\"Block height: {}\", info[\"blocks\"]),\n        Err(e) => eprintln!(\"Error: {}\", e),\n    }\n}\n```\n\n```python\nimport requests\nfrom typing import Any, Optional\n\nclass BitcoinRpc:\n    \"\"\"Bitcoin RPC client with error handling.\"\"\"\n\n    def __init__(self, url: str, user: str, password: str, timeout: int = 30):\n        self.url = url\n        self.auth = (user, password)\n        self.timeout = timeout\n\n    def call(self, method: str, params: list = None) -> Any:\n        \"\"\"Make an RPC call with error handling.\"\"\"\n        payload = {\n            \"jsonrpc\": \"1.0\",\n            \"id\": \"python-client\",\n            \"method\": method,\n            \"params\": params or []\n        }\n\n        try:\n            response = requests.post(\n                self.url,\n                json=payload,\n                auth=self.auth,\n                timeout=self.timeout\n            )\n            response.raise_for_status()\n        except requests.exceptions.ConnectionError:\n            raise ConnectionError(f\"Cannot connect to {self.url}\")\n        except requests.exceptions.Timeout:\n            raise TimeoutError(f\"Request timed out after {self.timeout}s\")\n\n        data = response.json()\n        \n        if data.get(\"error\"):\n            error = data[\"error\"]\n            raise Exception(f\"RPC error {error['code']}: {error['message']}\")\n        \n        return data.get(\"result\")\n\n    def get_blockchain_info(self) -> dict:\n        return self.call(\"getblockchaininfo\")\n\n    def get_block(self, block_hash: str, verbosity: int = 1) -> dict:\n        return self.call(\"getblock\", [block_hash, verbosity])\n\n    def get_mempool_info(self) -> dict:\n        return self.call(\"getmempoolinfo\")\n\n# Usage\nrpc = BitcoinRpc(\"http://127.0.0.1:8332\", \"user\", \"password\")\n\ntry:\n    info = rpc.get_blockchain_info()\n    print(f\"Block height: {info['blocks']}\")\nexcept Exception as e:\n    print(f\"Error: {e}\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <stdexcept>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nclass BitcoinRpc {\nprivate:\n    std::string url;\n    std::string user;\n    std::string password;\n    \n    static size_t write_callback(void* contents, size_t size, size_t nmemb, std::string* out) {\n        out->append(static_cast<char*>(contents), size * nmemb);\n        return size * nmemb;\n    }\n\npublic:\n    BitcoinRpc(const std::string& url, const std::string& user, const std::string& password)\n        : url(url), user(user), password(password) {}\n\n    json call(const std::string& method, const json& params = json::array()) {\n        CURL* curl = curl_easy_init();\n        if (!curl) {\n            throw std::runtime_error(\"Failed to initialize CURL\");\n        }\n\n        std::string response;\n        json payload = {\n            {\"jsonrpc\", \"1.0\"},\n            {\"id\", \"cpp-client\"},\n            {\"method\", method},\n            {\"params\", params}\n        };\n        \n        std::string post_data = payload.dump();\n        std::string auth = user + \":\" + password;\n        \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data.c_str());\n        curl_easy_setopt(curl, CURLOPT_USERPWD, auth.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, 30L);\n        \n        struct curl_slist* headers = curl_slist_append(nullptr, \"Content-Type: application/json\");\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        \n        CURLcode res = curl_easy_perform(curl);\n        curl_slist_free_all(headers);\n        curl_easy_cleanup(curl);\n        \n        if (res != CURLE_OK) {\n            throw std::runtime_error(std::string(\"Connection error: \") + curl_easy_strerror(res));\n        }\n        \n        json data = json::parse(response);\n        \n        if (!data[\"error\"].is_null()) {\n            throw std::runtime_error(\"RPC error \" + \n                std::to_string(data[\"error\"][\"code\"].get<int>()) + \": \" +\n                data[\"error\"][\"message\"].get<std::string>());\n        }\n        \n        return data[\"result\"];\n    }\n\n    json get_blockchain_info() { return call(\"getblockchaininfo\"); }\n    json get_block(const std::string& hash, int verbosity = 1) {\n        return call(\"getblock\", {hash, verbosity});\n    }\n    json get_mempool_info() { return call(\"getmempoolinfo\"); }\n};\n\nint main() {\n    try {\n        BitcoinRpc rpc(\"http://127.0.0.1:8332\", \"user\", \"password\");\n        auto info = rpc.get_blockchain_info();\n        std::cout << \"Block height: \" << info[\"blocks\"] << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype RPCRequest struct {\n\tJSONRPC string        `json:\"jsonrpc\"`\n\tID      string        `json:\"id\"`\n\tMethod  string        `json:\"method\"`\n\tParams  []interface{} `json:\"params\"`\n}\n\ntype RPCResponse struct {\n\tResult interface{} `json:\"result\"`\n\tError  *RPCError   `json:\"error\"`\n}\n\ntype RPCError struct {\n\tCode    int    `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\ntype BitcoinRPC struct {\n\turl      string\n\tuser     string\n\tpassword string\n\tclient   *http.Client\n}\n\nfunc NewBitcoinRPC(url, user, password string) *BitcoinRPC {\n\treturn &BitcoinRPC{\n\t\turl:      url,\n\t\tuser:     user,\n\t\tpassword: password,\n\t\tclient: &http.Client{\n\t\t\tTimeout: 30 * time.Second,\n\t\t},\n\t}\n}\n\nfunc (rpc *BitcoinRPC) Call(method string, params []interface{}) (interface{}, error) {\n\trequest := RPCRequest{\n\t\tJSONRPC: \"1.0\",\n\t\tID:      \"go-client\",\n\t\tMethod:  method,\n\t\tParams:  params,\n\t}\n\n\tjsonData, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", rpc.url, bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tauth := base64.StdEncoding.EncodeToString([]byte(rpc.user + \":\" + rpc.password))\n\treq.Header.Set(\"Authorization\", \"Basic \"+auth)\n\n\tresp, err := rpc.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar response RPCResponse\n\tif err := json.Unmarshal(body, &response); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif response.Error != nil {\n\t\treturn nil, fmt.Errorf(\"RPC error %d: %s\", response.Error.Code, response.Error.Message)\n\t}\n\n\treturn response.Result, nil\n}\n\nfunc (rpc *BitcoinRPC) GetBlockchainInfo() (interface{}, error) {\n\treturn rpc.Call(\"getblockchaininfo\", []interface{}{})\n}\n\nfunc main() {\n\trpc := NewBitcoinRPC(\"http://127.0.0.1:8332\", \"user\", \"password\")\n\n\tinfo, err := rpc.GetBlockchainInfo()\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\tinfoMap := info.(map[string]interface{})\n\tfmt.Printf(\"Block height: %.0f\\n\", infoMap[\"blocks\"])\n}\n```\n\n```javascript\nconst axios = require('axios');\n\nclass BitcoinRpc {\n  constructor(url, user, password, timeout = 30000) {\n    this.url = url;\n    this.auth = { username: user, password: password };\n    this.timeout = timeout;\n  }\n\n  async call(method, params = []) {\n    const payload = {\n      jsonrpc: '1.0',\n      id: 'js-client',\n      method: method,\n      params: params\n    };\n\n    try {\n      const response = await axios.post(this.url, payload, {\n        auth: this.auth,\n        timeout: this.timeout,\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      if (response.data.error) {\n        const { code, message } = response.data.error;\n        throw new Error(`RPC error ${code}: ${message}`);\n      }\n\n      return response.data.result;\n    } catch (error) {\n      if (error.code === 'ECONNREFUSED') {\n        throw new Error(`Cannot connect to ${this.url}`);\n      }\n      if (error.code === 'ETIMEDOUT') {\n        throw new Error(`Request timed out after ${this.timeout}ms`);\n      }\n      throw error;\n    }\n  }\n\n  async getBlockchainInfo() {\n    return this.call('getblockchaininfo');\n  }\n\n  async getBlock(blockHash, verbosity = 1) {\n    return this.call('getblock', [blockHash, verbosity]);\n  }\n\n  async getMempoolInfo() {\n    return this.call('getmempoolinfo');\n  }\n}\n\n// Usage\nasync function main() {\n  const rpc = new BitcoinRpc('http://127.0.0.1:8332', 'user', 'password');\n\n  try {\n    const info = await rpc.getBlockchainInfo();\n    console.log(`Block height: ${info.blocks}`);\n  } catch (error) {\n    console.error(`Error: ${error.message}`);\n  }\n}\n\nmain();\n```\n:::\n\n---\n\n## Essential Node Information Commands\n\n### 1. Blockchain Information\n\n```bash\nbtc getblockchaininfo\n```\n\n**Key fields to monitor:**\n- `blocks`: Current [block height](/docs/glossary#block-height)\n- `headers`: Number of headers downloaded\n- `verificationprogress`: Sync progress (0.0 to 1.0)\n- `initialblockdownload`: Whether still in [IBD](/docs/glossary#ibd-initial-block-download)\n- `pruned`: Whether node is pruned\n\n### 2. Network Information\n\n```bash\nbtc getnetworkinfo\n```\n\n**Key fields:**\n- `connections`: Total peer connections\n- `connections_in`: Incoming connections\n- `connections_out`: Outgoing connections\n- `version`: Bitcoin Core version\n- `subversion`: Detailed version info\n\n### 3. Mempool Information\n\n```bash\nbtc getmempoolinfo\n```\n\n**Key fields:**\n- `size`: Number of transactions in [mempool](/docs/glossary#mempool)\n- `bytes`: Total mempool size in bytes\n- `total_fee`: Total fees in mempool\n\n### 4. Block Information\n\n```bash\n# Get latest block hash\nbtc getbestblockhash\n\n# Get block by hash\nbtc getblock <block_hash>\n\n# Get block by height\nbtc getblockhash <height>\n```\n\n### 5. Transaction Information\n\n```bash\n# Get transaction by ID\nbtc getrawtransaction <txid> true\n\n# Get transaction from mempool\nbtc getmempoolentry <txid>\n```\n\n---\n\n## Wallet Commands\n\n### 6. Wallet Information\n\n```bash\n# List wallets\nbtc listwallets\n\n# Get wallet info\nbtc getwalletinfo\n\n# Get balance\nbtc getbalance\n```\n\n### 7. Wallet Management\n\n```bash\n# List all loaded wallets\nbtc listwallets\n\n# Get info about specific wallet\nbtc -rpcwallet=<walletname> getwalletinfo\n\n# Unload a wallet (removes from memory)\nbtc unloadwallet <walletname>\n\n# Load a wallet\nbtc loadwallet <walletname>\n\n# Get transactions from specific wallet\nbtc -rpcwallet=<walletname> listtransactions \"*\" 100\n\n# Get balance from specific wallet\nbtc -rpcwallet=<walletname> getbalance\n```\n\n---\n\n## Advanced Diagnostic Commands\n\n### 8. Index Information\n\n```bash\n# Check if transaction index is available\nbtc getindexinfo\n\n# Calculate indexing progress percentage\nbtc getindexinfo | jq '.txindex.best_block_height / 880000 * 100'\n\n# Check if indexing is complete\nbtc getindexinfo | jq '.txindex.synced'\n\n# Monitor indexing in real-time (updates every 30 seconds)\nwatch -n 30 'btc getindexinfo | jq \".txindex.best_block_height\"'\n```\n\n### 9. UTXO Set Information\n\nThe [UTXO Set](/docs/fundamentals/utxos#the-utxo-set) is the complete database of all unspent transaction outputs. These commands allow you to query information about it.\n\n```bash\n# Get UTXO set statistics (can be slow)\nbtc gettxoutsetinfo\n\n# Get specific fields\nbtc gettxoutsetinfo | jq '{total_amount, transactions, height}'\n```\n\n### 10. Peer Information\n\n```bash\n# Get peer information\nbtc getpeerinfo\n\n# Get connection summary\nbtc getnetworkinfo | jq '{connections, connections_in, connections_out}'\n```\n\n---\n\n## 11. ZMQ Notifications\n\n[ZeroMQ](/docs/glossary#zmq-zeromq) provides real-time notifications for blockchain events, enabling instant detection of new blocks and transactions without polling.\n\n### Configuration\n\nAdd to your `bitcoin.conf`:\n```ini\n# ZMQ Notifications\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28333\nzmqpubrawblock=tcp://127.0.0.1:28334\nzmqpubrawtx=tcp://127.0.0.1:28335\n```\n\n### Benefits\n- **Instant notifications**: No polling delays\n- **Lower resource usage**: No constant RPC calls\n- **Better reliability**: Catches blocks even after node restarts\n- **Real-time monitoring**: Perfect for blockchain monitoring applications\n\n### Verification\n```bash\n# Check if ZMQ is enabled in Bitcoin logs\ngrep -i zmq ~/.bitcoin/debug.log\n\n# Check Bitcoin help for ZMQ options\nbitcoind -h | grep zmq\n```\n\n---\n\n## Troubleshooting\n\n### Connection Issues\n\n```bash\n# Test RPC connection\nbtc getblockchaininfo | jq '.chain'\n\n# Check network status\nbtc getnetworkinfo | jq '{connections, connections_in, connections_out}'\n\n# Verify wallet is accessible\nbtc getwalletinfo | jq '{walletname, txcount, balance}'\n\n# Check if node is still syncing\nbtc getblockchaininfo | jq '{verificationprogress, initialblockdownload}'\n```\n\n### Common RPC Error Codes\n\n| Code | Meaning | Solution |\n|------|---------|----------|\n| -1 | General error | Check logs for details |\n| -5 | Invalid address or key | Verify input format |\n| -8 | Invalid parameter | Check parameter types |\n| -25 | Transaction verification failed | Check inputs/outputs |\n| -26 | Transaction already in mempool | Already broadcast |\n| -27 | Transaction already in chain | Already confirmed |\n| -28 | Node initializing | Wait for startup |\n\n### Log Monitoring\n```bash\n# Check recent activity in logs\ntail -20 ~/.bitcoin/debug.log\n\n# Monitor logs in real-time\ntail -f ~/.bitcoin/debug.log\n\n# Check for errors in logs\ngrep -i error ~/.bitcoin/debug.log | tail -10\n```\n\n---\n\n## JSON Output Formatting\n\nTo make the output more readable, pipe through `jq`:\n\n```bash\n# Install jq if not available\n# macOS: brew install jq\n# Ubuntu: apt install jq\n\nbtc getblockchaininfo | jq '{blocks, verificationprogress}'\n```\n\n---\n\n## Resources\n\n- **[mempool.space](https://mempool.space)**: Real-time Bitcoin mempool and block explorer\n- **[Clark Moody's Bitcoin Dashboard](https://dashboard.clarkmoody.com)**: Bitcoin metrics and analytics\n- **[Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)**: Bitcoin Core source code repository\n- **[Bitcoin Core RPC Docs](https://developer.bitcoin.org/reference/rpc/)**: Official RPC documentation\n",
    "filename": "rpc.md"
  },
  "/docs/mining": {
    "content": "# Bitcoin Mining\n\nBitcoin mining is the process by which new Bitcoin transactions are verified and added to the blockchain. Miners compete to solve cryptographic puzzles using computational power, and the first miner to solve the puzzle gets to add the next block to the blockchain and receive a reward.\n\n## Why \"Mining\"?\n\nThe term \"mining\" is borrowed from gold mining. Just as gold miners expend resources (labor, equipment, energy) to extract gold from the earth, Bitcoin miners expend computational resources (hardware, electricity) to \"extract\" new bitcoin from the protocol.\n\nThe analogy runs deeper:\n\n| Gold Mining | Bitcoin Mining |\n|-------------|----------------|\n| Requires work to extract value | Requires computational work ([proof-of-work](/docs/glossary#proof-of-work-pow)) |\n| Gold supply is finite | Bitcoin supply is capped at 21 million |\n| Gets harder to mine over time (deeper deposits) | Gets harder over time ([difficulty adjustment](/docs/mining/difficulty)) |\n| New gold enters circulation through mining | New bitcoin enters circulation through mining |\n| Anyone can mine (permissionless) | Anyone can mine (permissionless) |\n\nThis parallel was intentional. [Satoshi Nakamoto](/docs/history/people) designed Bitcoin to be \"digital gold\": a scarce, hard money that requires real-world cost to produce, preventing arbitrary inflation.\n\n---\n\n## What Mining Does\n\nMining serves two critical functions:\n1. **Transaction Processing**: Validating and confirming transactions\n2. **Currency Issuance**: Creating new bitcoin according to the predetermined [supply schedule](/docs/history/halvings)\n\n---\n\n## How Mining Works\n\n### Block Creation Process\n\n1. **Transaction Collection**: Miners collect pending transactions from the [mempool](/docs/glossary#mempool)\n2. **Block Construction**: Miners assemble transactions into a candidate block\n3. **Proof-of-Work**: Miners repeatedly hash the [block header](/docs/glossary#block-header) with different [nonce](/docs/glossary#nonce) values\n4. **Difficulty Target**: The hash must be below a certain target (determined by network [difficulty](/docs/glossary#difficulty))\n5. **Block Discovery**: When a miner finds a valid hash, they broadcast the block to the network\n6. **Block Validation**: Other nodes verify the block and add it to their blockchain\n7. **Reward**: The successful miner receives the [block reward](/docs/glossary#block-reward) plus [transaction fees](/docs/glossary#transaction-fee)\n\n### The Mining Algorithm\n\nThe core of Bitcoin mining is finding a nonce that, when combined with the block header data and hashed twice with [SHA-256](/docs/glossary#sha-256), produces a value below the current difficulty target.\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\n/// Demonstrates the basic mining hash calculation.\n/// In real mining, this would be optimized and run billions of times.\nfn mine_block_header(header: &[u8], target: &[u8; 32]) -> Option<u32> {\n    for nonce in 0..u32::MAX {\n        // Create header with nonce (simplified - real headers are 80 bytes)\n        let mut data = header.to_vec();\n        data.extend_from_slice(&nonce.to_le_bytes());\n        \n        // Double SHA-256 (SHA256D)\n        let first_hash = Sha256::digest(&data);\n        let hash = Sha256::digest(&first_hash);\n        \n        // Check if hash is below target (simplified comparison)\n        if hash.as_slice() < target {\n            return Some(nonce);\n        }\n    }\n    None\n}\n\nfn main() {\n    // Example: very easy target for demonstration\n    let header = b\"example block header data\";\n    let easy_target = [0x0F; 32]; // Very easy target\n    \n    if let Some(nonce) = mine_block_header(header, &easy_target) {\n        println!(\"Found valid nonce: {}\", nonce);\n    }\n}\n```\n\n```python\nimport hashlib\nimport struct\n\ndef sha256d(data: bytes) -> bytes:\n    \"\"\"Double SHA-256 hash.\"\"\"\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\ndef mine_block_header(header: bytes, target: bytes, max_nonce: int = 1_000_000) -> int | None:\n    \"\"\"\n    Demonstrates the basic mining hash calculation.\n    In real mining, this would be optimized and run billions of times.\n    \n    Args:\n        header: Block header data (without nonce)\n        target: 32-byte target hash\n        max_nonce: Maximum nonces to try\n    \n    Returns:\n        Valid nonce if found, None otherwise\n    \"\"\"\n    for nonce in range(max_nonce):\n        # Add nonce to header (little-endian 4-byte integer)\n        data = header + struct.pack('<I', nonce)\n        \n        # Double SHA-256\n        hash_result = sha256d(data)\n        \n        # Check if hash is below target\n        if hash_result < target:\n            return nonce\n    \n    return None\n\n# Example: very easy target for demonstration\nheader = b\"example block header data\"\neasy_target = bytes([0x0F] * 32)  # Very easy target\n\nnonce = mine_block_header(header, easy_target)\nif nonce is not None:\n    print(f\"Found valid nonce: {nonce}\")\n```\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstring>\n#include <openssl/sha.h>\n\n/**\n * Performs double SHA-256 (SHA256D) hash.\n */\nvoid sha256d(const unsigned char* data, size_t len, unsigned char* out) {\n    unsigned char first_hash[SHA256_DIGEST_LENGTH];\n    SHA256(data, len, first_hash);\n    SHA256(first_hash, SHA256_DIGEST_LENGTH, out);\n}\n\n/**\n * Demonstrates the basic mining hash calculation.\n * In real mining, this would be optimized and run billions of times.\n * \n * @param header Block header data\n * @param header_len Length of header\n * @param target 32-byte target hash\n * @param max_nonce Maximum nonces to try\n * @return Valid nonce if found, -1 otherwise\n */\nint64_t mine_block_header(const unsigned char* header, size_t header_len,\n                          const unsigned char* target, uint32_t max_nonce = 1000000) {\n    std::vector<unsigned char> data(header_len + 4);\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    \n    for (uint32_t nonce = 0; nonce < max_nonce; ++nonce) {\n        // Create header with nonce\n        memcpy(data.data(), header, header_len);\n        memcpy(data.data() + header_len, &nonce, 4);  // Little-endian\n        \n        // Double SHA-256\n        sha256d(data.data(), data.size(), hash);\n        \n        // Check if hash is below target\n        if (memcmp(hash, target, 32) < 0) {\n            return nonce;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    // Example: very easy target for demonstration\n    const unsigned char header[] = \"example block header data\";\n    unsigned char easy_target[32];\n    memset(easy_target, 0x0F, 32);  // Very easy target\n    \n    int64_t nonce = mine_block_header(header, strlen((char*)header), easy_target);\n    if (nonce >= 0) {\n        std::cout << \"Found valid nonce: \" << nonce << std::endl;\n    }\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\n// sha256d performs double SHA-256 hash\nfunc sha256d(data []byte) []byte {\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second[:]\n}\n\n// mineBlockHeader demonstrates the basic mining hash calculation.\n// In real mining, this would be optimized and run billions of times.\nfunc mineBlockHeader(header []byte, target []byte, maxNonce uint32) (uint32, bool) {\n\tdata := make([]byte, len(header)+4)\n\tcopy(data, header)\n\t\n\tfor nonce := uint32(0); nonce < maxNonce; nonce++ {\n\t\t// Add nonce to header (little-endian 4-byte integer)\n\t\tbinary.LittleEndian.PutUint32(data[len(header):], nonce)\n\t\t\n\t\t// Double SHA-256\n\t\thash := sha256d(data)\n\t\t\n\t\t// Check if hash is below target\n\t\tif compareBytes(hash, target) < 0 {\n\t\t\treturn nonce, true\n\t\t}\n\t}\n\treturn 0, false\n}\n\nfunc compareBytes(a, b []byte) int {\n\tfor i := 0; i < len(a) && i < len(b); i++ {\n\t\tif a[i] < b[i] {\n\t\t\treturn -1\n\t\t}\n\t\tif a[i] > b[i] {\n\t\t\treturn 1\n\t\t}\n\t}\n\treturn 0\n}\n\nfunc main() {\n\t// Example: very easy target for demonstration\n\theader := []byte(\"example block header data\")\n\teasyTarget := make([]byte, 32)\n\tfor i := range easyTarget {\n\t\teasyTarget[i] = 0x0F // Very easy target\n\t}\n\t\n\tnonce, found := mineBlockHeader(header, easyTarget, 1_000_000)\n\tif found {\n\t\tfmt.Printf(\"Found valid nonce: %d\\n\", nonce)\n\t}\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\n/**\n * Performs double SHA-256 (SHA256D) hash.\n * @param {Buffer} data - Data to hash\n * @returns {Buffer} - Double SHA-256 hash\n */\nfunction sha256d(data) {\n    const firstHash = crypto.createHash('sha256').update(data).digest();\n    return crypto.createHash('sha256').update(firstHash).digest();\n}\n\n/**\n * Demonstrates the basic mining hash calculation.\n * In real mining, this would be optimized and run billions of times.\n * \n * @param {Buffer} header - Block header data (without nonce)\n * @param {Buffer} target - 32-byte target hash\n * @param {number} maxNonce - Maximum nonces to try\n * @returns {number|null} - Valid nonce if found, null otherwise\n */\nfunction mineBlockHeader(header, target, maxNonce = 1_000_000) {\n    for (let nonce = 0; nonce < maxNonce; nonce++) {\n        // Add nonce to header (little-endian 4-byte integer)\n        const nonceBuffer = Buffer.alloc(4);\n        nonceBuffer.writeUInt32LE(nonce);\n        const data = Buffer.concat([header, nonceBuffer]);\n        \n        // Double SHA-256\n        const hash = sha256d(data);\n        \n        // Check if hash is below target\n        if (hash.compare(target) < 0) {\n            return nonce;\n        }\n    }\n    return null;\n}\n\n// Example: very easy target for demonstration\nconst header = Buffer.from('example block header data');\nconst easyTarget = Buffer.alloc(32, 0x0F);  // Very easy target\n\nconst nonce = mineBlockHeader(header, easyTarget);\nif (nonce !== null) {\n    console.log(`Found valid nonce: ${nonce}`);\n}\n```\n:::\n\n### Mining Hardware\n\n- **[ASIC](/docs/glossary#asic-application-specific-integrated-circuit) Miners**: Application-Specific Integrated Circuits designed specifically for Bitcoin mining (most efficient)\n- **GPU Mining**: Graphics Processing Units (less efficient than ASICs, rarely profitable)\n- **CPU Mining**: Central Processing Units (least efficient, primarily educational)\n\nSee [Hardware Evolution](/docs/mining/hardware) for the complete history of mining hardware development.\n\n### Mining Pools\n\nMost miners join [mining pools](/docs/glossary#mining-pool) to:\n- **Reduce Variance**: Share rewards with other miners\n- **Consistent Payouts**: Receive smaller but regular payments\n- **Lower Barrier**: Don't need to find a full block individually\n- **Combine Hash Power**: Pool [hash rate](/docs/glossary#hash-rate) increases chances of finding blocks\n\nSee [Mining Pools](/docs/mining/pools) for detailed information on pool operations and payout schemes.\n\n---\n\n## Key Concepts\n\n| Concept | Description |\n|---------|-------------|\n| **Proof-of-Work** | Cryptographic puzzle that miners solve to validate blocks |\n| **Block Reward** | Currently 3.125 BTC per block (after 2024 [halving](/docs/glossary#halving)) |\n| **Difficulty** | Adjusts every 2016 blocks to maintain ~10 minute block times |\n| **Hash Rate** | Measure of mining power (network: ~700 EH/s) |\n| **[Coinbase Transaction](/docs/glossary#coinbase-transaction)** | Special transaction that creates new bitcoin as block reward |\n\n---\n\n## Why Mining Matters\n\n### Network Security\n\nMining provides Bitcoin's security through proof-of-work. To attack the network, an adversary would need to control more than 50% of the global hash rate: an astronomically expensive proposition requiring billions of dollars in hardware and electricity. See [Mining Attacks](/docs/mining/attacks) for more on security considerations.\n\n### Decentralization\n\nUnlike traditional payment systems with central authorities, Bitcoin's mining is permissionless. Anyone with hardware and electricity can participate, contributing to the network's [decentralization](/docs/fundamentals/decentralization).\n\n### Monetary Policy Enforcement\n\nMining enforces Bitcoin's fixed [supply schedule](/docs/history/halvings). The protocol rules embedded in mining software ensure that:\n- Only ~21 million bitcoin will ever exist\n- Block rewards halve every 210,000 blocks\n- No entity can create bitcoin outside the rules\n\n---\n\n## Mining Today\n\n### Current Statistics (2024)\n\n- **Network Hash Rate**: ~700 EH/s (exahashes per second)\n- **Block Reward**: 3.125 BTC\n- **Average Block Time**: ~10 minutes\n- **Difficulty**: Adjusts every ~2 weeks\n- **Daily Blocks**: ~144\n\n### Who Mines?\n\nModern Bitcoin mining is dominated by:\n- **Industrial Operations**: Large-scale facilities with thousands of ASICs\n- **Mining Pools**: Collectives that combine hash power\n- **Home Miners**: Hobbyists and those with cheap electricity\n\n---\n\n## Related Topics\n\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How the mining algorithm works\n- [Difficulty Adjustment](/docs/mining/difficulty) - How difficulty adjusts to maintain block times\n- [Mining Economics](/docs/mining/economics) - Block rewards, fees, and profitability\n- [Block Construction](/docs/mining/block-construction) - How miners build blocks\n- [Mining Pools](/docs/mining/pools) - Collaborative mining operations\n- [Mining Attacks](/docs/mining/attacks) - Mining-specific attack vectors\n- [Network Attacks & Security](/docs/mining/network-attacks) - Network-layer security threats\n",
    "filename": "overview.md"
  },
  "/docs/mining/proof-of-work": {
    "content": "# Proof-of-Work Mechanism\n\nBitcoin uses a **proof-of-work** consensus mechanism where miners compete to solve a cryptographic puzzle. This process secures the network and validates transactions.\n\n## How It Works\n\n1. **Block Construction**: Miners collect transactions from the [mempool](/docs/glossary#mempool) and create a candidate block\n2. **Nonce Search**: Miners repeatedly hash the [block header](/docs/glossary#block-header) with different [nonce](/docs/glossary#nonce) values\n3. **Difficulty Target**: The hash must be below a certain target (set by network [difficulty](/docs/glossary#difficulty))\n4. **Success**: When a miner finds a valid hash, they broadcast the block to the network\n5. **Reward**: The miner receives the [block reward](/docs/glossary#block-reward) (currently 3.125 BTC) plus [transaction fees](/docs/glossary#transaction-fee)\n\n---\n\n## Mining Difficulty\n\n- **Adjustment**: Every 2016 blocks (~2 weeks), the difficulty adjusts based on network [hash rate](/docs/glossary#hash-rate)\n- **Target**: Maintains ~10 minute average [block time](/docs/glossary#block-time)\n- **Current Network Hash Rate**: ~700 EH/s (exahashes per second)\n- **See Also**: [Difficulty Adjustment](/docs/mining/difficulty) for detailed explanation\n\n---\n\n## Technical Details\n\n### Block Headers\n- **Size**: 80 bytes of block metadata\n- **Components**: Version, previous block hash, [merkle root](/docs/glossary#merkle-root), timestamp, [difficulty target](/docs/glossary#difficulty-target), nonce\n- **Hash Function**: [SHA256D](/docs/glossary#sha256d) (double SHA-256)\n\n### Nonce Space\n- **Range**: 0 to 4,294,967,295 (2^32 - 1)\n- **Exhaustion**: If all nonces fail, miners change the [coinbase transaction](/docs/glossary#coinbase-transaction) or timestamp\n- **Search Space**: Effectively unlimited through coinbase modifications\n\n### Target Difficulty\n- **Network-Wide**: All miners compete against the same target\n- **Dynamic**: Adjusts every 2016 blocks based on actual vs. target block time\n- **Purpose**: Maintains consistent block production rate\n\n---\n\n## Hash Function: SHA256D\n\nBitcoin uses a double SHA-256 hash function:\n\n```\nhash = SHA256(SHA256(block_header))\n```\n\nThis means:\n1. First SHA-256 hash of the block header\n2. Second SHA-256 hash of the first hash result\n3. Result must be below the network difficulty target\n\n### SHA256D Implementation\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse sha2::{Sha256, Digest};\n\n/// Performs double SHA-256 (SHA256D) hash.\n/// This is the core hashing algorithm used in Bitcoin mining.\nfn sha256d(data: &[u8]) -> [u8; 32] {\n    let first_hash = Sha256::digest(data);\n    let second_hash = Sha256::digest(&first_hash);\n    second_hash.into()\n}\n\n/// Checks if a hash meets the difficulty target.\n/// The hash must be numerically less than the target.\nfn meets_target(hash: &[u8; 32], target: &[u8; 32]) -> bool {\n    // Compare bytes from most significant to least significant\n    for i in (0..32).rev() {\n        if hash[i] < target[i] {\n            return true;\n        } else if hash[i] > target[i] {\n            return false;\n        }\n    }\n    true // Equal hashes meet the target\n}\n\n/// Constructs an 80-byte block header and performs proof-of-work.\nfn mine_block(\n    version: u32,\n    prev_hash: &[u8; 32],\n    merkle_root: &[u8; 32],\n    timestamp: u32,\n    bits: u32,\n    target: &[u8; 32],\n) -> Option<(u32, [u8; 32])> {\n    let mut header = [0u8; 80];\n    \n    // Build header (all fields little-endian)\n    header[0..4].copy_from_slice(&version.to_le_bytes());\n    header[4..36].copy_from_slice(prev_hash);\n    header[36..68].copy_from_slice(merkle_root);\n    header[68..72].copy_from_slice(&timestamp.to_le_bytes());\n    header[72..76].copy_from_slice(&bits.to_le_bytes());\n    \n    for nonce in 0..u32::MAX {\n        header[76..80].copy_from_slice(&nonce.to_le_bytes());\n        let hash = sha256d(&header);\n        \n        if meets_target(&hash, target) {\n            return Some((nonce, hash));\n        }\n    }\n    None\n}\n\nfn main() {\n    let data = b\"Hello, Bitcoin!\";\n    let hash = sha256d(data);\n    println!(\"SHA256D hash: {}\", hex::encode(hash));\n}\n```\n\n```python\nimport hashlib\nimport struct\n\ndef sha256d(data: bytes) -> bytes:\n    \"\"\"\n    Performs double SHA-256 (SHA256D) hash.\n    This is the core hashing algorithm used in Bitcoin mining.\n    \n    Args:\n        data: The data to hash\n    \n    Returns:\n        32-byte SHA256D hash\n    \"\"\"\n    first_hash = hashlib.sha256(data).digest()\n    return hashlib.sha256(first_hash).digest()\n\ndef meets_target(hash_bytes: bytes, target: bytes) -> bool:\n    \"\"\"\n    Checks if a hash meets the difficulty target.\n    The hash must be numerically less than the target.\n    \n    Args:\n        hash_bytes: 32-byte hash to check\n        target: 32-byte target threshold\n    \n    Returns:\n        True if hash meets target (is less than target)\n    \"\"\"\n    # Compare as big-endian integers\n    return int.from_bytes(hash_bytes, 'big') < int.from_bytes(target, 'big')\n\ndef mine_block(version: int, prev_hash: bytes, merkle_root: bytes,\n               timestamp: int, bits: int, target: bytes,\n               max_nonce: int = 1_000_000) -> tuple[int, bytes] | None:\n    \"\"\"\n    Constructs an 80-byte block header and performs proof-of-work.\n    \n    Args:\n        version: Block version\n        prev_hash: 32-byte previous block hash\n        merkle_root: 32-byte merkle root\n        timestamp: Unix timestamp\n        bits: Compact difficulty representation\n        target: 32-byte target hash\n        max_nonce: Maximum nonces to try\n    \n    Returns:\n        Tuple of (nonce, hash) if found, None otherwise\n    \"\"\"\n    # Build header without nonce (76 bytes)\n    header_base = struct.pack('<I', version)  # 4 bytes\n    header_base += prev_hash                   # 32 bytes\n    header_base += merkle_root                 # 32 bytes\n    header_base += struct.pack('<I', timestamp)  # 4 bytes\n    header_base += struct.pack('<I', bits)     # 4 bytes\n    \n    for nonce in range(max_nonce):\n        header = header_base + struct.pack('<I', nonce)\n        hash_result = sha256d(header)\n        \n        if meets_target(hash_result, target):\n            return (nonce, hash_result)\n    \n    return None\n\n# Example usage\ndata = b\"Hello, Bitcoin!\"\nhash_result = sha256d(data)\nprint(f\"SHA256D hash: {hash_result.hex()}\")\n```\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <openssl/sha.h>\n\n/**\n * Performs double SHA-256 (SHA256D) hash.\n * This is the core hashing algorithm used in Bitcoin mining.\n * \n * @param data Input data to hash\n * @param len Length of input data\n * @param out Output buffer for 32-byte hash\n */\nvoid sha256d(const unsigned char* data, size_t len, unsigned char* out) {\n    unsigned char first_hash[SHA256_DIGEST_LENGTH];\n    SHA256(data, len, first_hash);\n    SHA256(first_hash, SHA256_DIGEST_LENGTH, out);\n}\n\n/**\n * Checks if a hash meets the difficulty target.\n * The hash must be numerically less than the target.\n * \n * @param hash 32-byte hash to check\n * @param target 32-byte target threshold\n * @return true if hash meets target\n */\nbool meets_target(const unsigned char* hash, const unsigned char* target) {\n    // Compare bytes from most significant to least significant\n    for (int i = 31; i >= 0; --i) {\n        if (hash[i] < target[i]) return true;\n        if (hash[i] > target[i]) return false;\n    }\n    return true;  // Equal hashes meet the target\n}\n\n/**\n * Constructs an 80-byte block header and performs proof-of-work.\n * \n * @param version Block version\n * @param prev_hash 32-byte previous block hash\n * @param merkle_root 32-byte merkle root\n * @param timestamp Unix timestamp\n * @param bits Compact difficulty representation\n * @param target 32-byte target hash\n * @param out_nonce Output: valid nonce if found\n * @param out_hash Output: resulting hash\n * @param max_nonce Maximum nonces to try\n * @return true if valid nonce found\n */\nbool mine_block(uint32_t version, const unsigned char* prev_hash,\n                const unsigned char* merkle_root, uint32_t timestamp,\n                uint32_t bits, const unsigned char* target,\n                uint32_t* out_nonce, unsigned char* out_hash,\n                uint32_t max_nonce = 1000000) {\n    unsigned char header[80];\n    \n    // Build header (all fields little-endian)\n    memcpy(header, &version, 4);\n    memcpy(header + 4, prev_hash, 32);\n    memcpy(header + 36, merkle_root, 32);\n    memcpy(header + 68, &timestamp, 4);\n    memcpy(header + 72, &bits, 4);\n    \n    for (uint32_t nonce = 0; nonce < max_nonce; ++nonce) {\n        memcpy(header + 76, &nonce, 4);\n        sha256d(header, 80, out_hash);\n        \n        if (meets_target(out_hash, target)) {\n            *out_nonce = nonce;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    const char* data = \"Hello, Bitcoin!\";\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    \n    sha256d((unsigned char*)data, strlen(data), hash);\n    \n    std::cout << \"SHA256D hash: \";\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// SHA256D performs double SHA-256 (SHA256D) hash.\nfunc SHA256D(data []byte) []byte {\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second[:]\n}\n\n// MeetsTarget checks if a hash meets the difficulty target.\n// The hash must be numerically less than the target.\nfunc MeetsTarget(hash []byte, target []byte) bool {\n\t// Compare bytes from most significant to least significant\n\tfor i := 31; i >= 0; i-- {\n\t\tif hash[i] < target[i] {\n\t\t\treturn true\n\t\t}\n\t\tif hash[i] > target[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true // Equal hashes meet the target\n}\n\n// MineBlock constructs an 80-byte block header and performs proof-of-work.\nfunc MineBlock(version uint32, prevHash []byte, merkleRoot []byte, timestamp uint32, bits uint32, target []byte, maxNonce uint32) (uint32, []byte, bool) {\n\theader := make([]byte, 80)\n\t\n\t// Build header (all fields little-endian)\n\tbinary.LittleEndian.PutUint32(header[0:4], version)\n\tcopy(header[4:36], prevHash)\n\tcopy(header[36:68], merkleRoot)\n\tbinary.LittleEndian.PutUint32(header[68:72], timestamp)\n\tbinary.LittleEndian.PutUint32(header[72:76], bits)\n\t\n\tfor nonce := uint32(0); nonce < maxNonce; nonce++ {\n\t\tbinary.LittleEndian.PutUint32(header[76:80], nonce)\n\t\t\n\t\thash := SHA256D(header)\n\t\t\n\t\tif MeetsTarget(hash, target) {\n\t\t\treturn nonce, hash, true\n\t\t}\n\t}\n\treturn 0, nil, false\n}\n\nfunc main() {\n\t// Example usage\n\tdata := []byte(\"Hello, Bitcoin!\")\n\thash := SHA256D(data)\n\tfmt.Printf(\"SHA256D hash: %s\\n\", hex.EncodeToString(hash))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\n/**\n * Performs double SHA-256 (SHA256D) hash.\n * This is the core hashing algorithm used in Bitcoin mining.\n * \n * @param {Buffer} data - The data to hash\n * @returns {Buffer} - 32-byte SHA256D hash\n */\nfunction sha256d(data) {\n    const firstHash = crypto.createHash('sha256').update(data).digest();\n    return crypto.createHash('sha256').update(firstHash).digest();\n}\n\n/**\n * Checks if a hash meets the difficulty target.\n * The hash must be numerically less than the target.\n * \n * @param {Buffer} hash - 32-byte hash to check\n * @param {Buffer} target - 32-byte target threshold\n * @returns {boolean} - True if hash meets target\n */\nfunction meetsTarget(hash, target) {\n    // compare() returns negative if hash < target\n    return hash.compare(target) < 0;\n}\n\n/**\n * Constructs an 80-byte block header and performs proof-of-work.\n * \n * @param {number} version - Block version\n * @param {Buffer} prevHash - 32-byte previous block hash\n * @param {Buffer} merkleRoot - 32-byte merkle root\n * @param {number} timestamp - Unix timestamp\n * @param {number} bits - Compact difficulty representation\n * @param {Buffer} target - 32-byte target hash\n * @param {number} maxNonce - Maximum nonces to try\n * @returns {{nonce: number, hash: Buffer}|null} - Result or null\n */\nfunction mineBlock(version, prevHash, merkleRoot, timestamp, bits, target, maxNonce = 1_000_000) {\n    // Build header without nonce (76 bytes)\n    const headerBase = Buffer.alloc(76);\n    headerBase.writeUInt32LE(version, 0);\n    prevHash.copy(headerBase, 4);\n    merkleRoot.copy(headerBase, 36);\n    headerBase.writeUInt32LE(timestamp, 68);\n    headerBase.writeUInt32LE(bits, 72);\n    \n    const header = Buffer.alloc(80);\n    headerBase.copy(header);\n    \n    for (let nonce = 0; nonce < maxNonce; nonce++) {\n        header.writeUInt32LE(nonce, 76);\n        const hash = sha256d(header);\n        \n        if (meetsTarget(hash, target)) {\n            return { nonce, hash };\n        }\n    }\n    return null;\n}\n\n// Example usage\nconst data = Buffer.from('Hello, Bitcoin!');\nconst hash = sha256d(data);\nconsole.log(`SHA256D hash: ${hash.toString('hex')}`);\n```\n:::\n\n---\n\n## Mining Process Flow\n\n```\n1. Collect Transactions\n   â†“\n2. Build Block Header\n   â†“\n3. Hash Block Header\n   â†“\n4. Check if Hash < Target\n   â”œâ”€ Yes â†’ Broadcast Block â†’ Receive Reward\n   â””â”€ No â†’ Increment Nonce â†’ Repeat from Step 3\n```\n\n---\n\n## Educational Value\n\n### What You'll Learn\n1. **Block Construction**: How Bitcoin blocks are built\n2. **Mining Algorithms**: SHA256D hash function\n3. **Network Protocol**: RPC communication with Bitcoin node\n4. **Difficulty Adjustment**: How network difficulty works\n5. **Economic Incentives**: Why mining is competitive\n\n### Technical Concepts\n- **Block Headers**: 80-byte block metadata\n- **Coinbase Transactions**: Special reward transactions\n- **Merkle Trees**: Transaction organization\n- **Nonce Space**: 4.3 billion possible values\n- **Difficulty Target**: Network-wide mining target\n\n---\n\n## Related Topics\n\n- [Bitcoin Mining](/docs/mining) - Mining architecture and concepts\n- [Mining Economics](/docs/mining/economics) - Rewards and profitability\n- [Difficulty Adjustment](/docs/mining/difficulty) - How difficulty adjusts over time\n- [Block Construction](/docs/mining/block-construction) - How blocks are assembled\n",
    "filename": "proof-of-work.md"
  },
  "/docs/mining/difficulty": {
    "content": "# Difficulty Adjustment\n\nBitcoin's difficulty adjustment is a critical mechanism that maintains the network's target [block time](/docs/glossary#block-time) of approximately 10 minutes. Every 2016 blocks (~2 weeks), the network automatically adjusts the mining difficulty based on the actual time it took to mine the previous 2016 blocks.\n\n## How Difficulty Adjustment Works\n\n### Adjustment Formula\n\nThe difficulty adjusts every **2016 blocks** (approximately every 2 weeks) using the formula:\n\n```\nNew Difficulty = Old Difficulty Ã— (Target Time / Actual Time)\n```\n\nWhere:\n- **Target Time**: 2016 blocks Ã— 10 minutes = 20,160 minutes (2 weeks)\n- **Actual Time**: Time it took to mine the previous 2016 blocks\n\n### Adjustment Rules\n\n- **If blocks were mined too fast** (less than 2 weeks): Difficulty increases\n- **If blocks were mined too slow** (more than 2 weeks): Difficulty decreases\n- **Maximum adjustment**: Â±4x per period (prevents extreme swings)\n\n---\n\n## Why Difficulty Adjustment Exists\n\n### Maintaining Block Time\n\n- **Target**: ~10 minutes per block\n- **Purpose**: Predictable block creation rate\n- **Benefit**: Consistent transaction confirmation times\n\n### Network Security\n\n- **Hash Rate Changes**: Network [hash rate](/docs/glossary#hash-rate) fluctuates\n- **Hardware Improvements**: New [ASICs](/docs/glossary#asic-application-specific-integrated-circuit) increase network hash rate\n- **Miner Participation**: Miners join/leave the network\n- **Adaptation**: Difficulty adjusts to maintain security\n\n### Economic Stability\n\n- **Predictable Rewards**: Miners can estimate earnings\n- **Consistent Block Times**: Users know confirmation times\n- **Network Health**: Prevents too-fast or too-slow block creation\n\n---\n\n## Historical Difficulty Adjustments\n\n### Early Bitcoin (2009-2012)\n- **Difficulty**: Very low (could mine with CPU)\n- **Adjustments**: Frequent large increases as hash rate grew\n- **Network**: Small, growing hash rate\n\n### ASIC Era (2013-Present)\n- **Difficulty**: Rapidly increasing\n- **Adjustments**: Regular increases as ASICs improved\n- **Network**: Massive hash rate growth\n\n### Current State (2024)\n- **Difficulty**: ~700+ trillion (extremely high)\n- **Adjustments**: More stable, smaller percentage changes\n- **Network**: Mature, large hash rate\n\n---\n\n## Difficulty Metrics\n\n### Current Network Stats\n- **Block Time**: Maintained at ~10 minutes average\n- **Hash Rate**: ~700 EH/s (exahashes per second)\n- **Difficulty**: Adjusts every 2016 blocks\n- **Adjustment Frequency**: Approximately every 2 weeks\n\n### Difficulty Calculation\n\nThe difficulty target is calculated from the block header:\n- **Target Hash**: Maximum hash value that's considered valid\n- **Lower Target**: Higher difficulty (harder to find valid hash)\n- **Higher Target**: Lower difficulty (easier to find valid hash)\n\n---\n\n## Impact on Miners\n\n### Hash Rate Changes\n\nWhen network hash rate increases:\n- **Difficulty increases** in next adjustment\n- **Same hardware** produces fewer valid hashes\n- **Mining becomes harder** for all miners\n\nWhen network hash rate decreases:\n- **Difficulty decreases** in next adjustment\n- **Same hardware** produces more valid hashes\n- **Mining becomes easier** for all miners\n\n### Profitability Considerations\n\n- **Difficulty increases**: Reduce profitability (unless hash rate increases)\n- **Difficulty decreases**: Increase profitability (if hash rate stays same)\n- **Long-term trend**: Difficulty generally increases over time\n\n---\n\n## Technical Details\n\n### [Block Header](/docs/glossary#block-header) Fields\n\nThe difficulty is encoded in the block header's `nBits` field:\n- **Compact representation**: 32-bit value\n- **Target calculation**: Converts nBits to full 256-bit [difficulty target](/docs/glossary#difficulty-target)\n- **Validation**: Block hash must be less than target\n\n### Adjustment Algorithm\n\n:::code-group\n```rust\n/// Simplified difficulty adjustment\n///\n/// # Arguments\n///\n/// * `old_difficulty` - Previous difficulty value\n/// * `actual_time` - Time in minutes to mine 2016 blocks\n/// * `target_time` - Target time (default: 20160 minutes)\n///\n/// # Returns\n///\n/// New difficulty value\nfn adjust_difficulty(old_difficulty: f64, actual_time: f64, target_time: f64) -> f64 {\n    // Default target_time: 2016 blocks Ã— 10 minutes = 20,160 minutes\n    let target_time = if target_time == 0.0 { 20160.0 } else { target_time };\n    \n    let mut ratio = target_time / actual_time;\n    \n    // Limit adjustment to Â±4x\n    ratio = ratio.clamp(0.25, 4.0);\n    \n    old_difficulty * ratio\n}\n\nfn main() {\n    // Example: blocks mined in 18,000 minutes (faster than target)\n    let new_diff = adjust_difficulty(100_000.0, 18_000.0, 20_160.0);\n    println!(\"New difficulty: {}\", new_diff); // ~112,000\n}\n```\n\n```python\ndef adjust_difficulty(old_difficulty, actual_time, target_time=20160):\n    \"\"\"\n    Simplified difficulty adjustment.\n    \n    Args:\n        old_difficulty: Previous difficulty value\n        actual_time: Time in minutes to mine 2016 blocks\n        target_time: Target time (2016 blocks Ã— 10 minutes = 20,160 minutes)\n    \n    Returns:\n        New difficulty value\n    \"\"\"\n    ratio = target_time / actual_time\n    \n    # Limit adjustment to Â±4x\n    ratio = max(0.25, min(4.0, ratio))\n    \n    new_difficulty = old_difficulty * ratio\n    return new_difficulty\n```\n\n```cpp\n#include <algorithm>\n#include <iostream>\n\n/**\n * Simplified difficulty adjustment.\n * \n * @param old_difficulty Previous difficulty value\n * @param actual_time Time in minutes to mine 2016 blocks\n * @param target_time Target time (2016 blocks Ã— 10 minutes = 20,160 minutes)\n * @return New difficulty value\n */\ndouble adjust_difficulty(double old_difficulty, double actual_time, double target_time = 20160.0) {\n    double ratio = target_time / actual_time;\n    \n    // Limit adjustment to Â±4x\n    ratio = std::clamp(ratio, 0.25, 4.0);\n    \n    double new_difficulty = old_difficulty * ratio;\n    return new_difficulty;\n}\n\nint main() {\n    // Example: blocks mined in 18,000 minutes (faster than target)\n    double new_diff = adjust_difficulty(100000.0, 18000.0);\n    std::cout << \"New difficulty: \" << new_diff << std::endl; // ~112,000\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// AdjustDifficulty performs simplified difficulty adjustment\nfunc AdjustDifficulty(oldDifficulty float64, actualTime float64, targetTime float64) float64 {\n\tif targetTime == 0 {\n\t\ttargetTime = 20160.0 // Default: 2016 blocks Ã— 10 minutes\n\t}\n\t\n\tratio := targetTime / actualTime\n\t\n\t// Limit adjustment to Â±4x\n\tratio = math.Max(0.25, math.Min(4.0, ratio))\n\t\n\tnewDifficulty := oldDifficulty * ratio\n\treturn newDifficulty\n}\n\nfunc main() {\n\t// Example: blocks mined in 18,000 minutes (faster than target)\n\tnewDiff := AdjustDifficulty(100_000.0, 18_000.0, 20_160.0)\n\tfmt.Printf(\"New difficulty: %.0f\\n\", newDiff) // ~112,000\n}\n```\n\n```javascript\n/**\n * Simplified difficulty adjustment.\n * \n * @param {number} oldDifficulty - Previous difficulty value\n * @param {number} actualTime - Time in minutes to mine 2016 blocks\n * @param {number} targetTime - Target time (default: 20160 minutes)\n * @returns {number} New difficulty value\n */\nfunction adjustDifficulty(oldDifficulty, actualTime, targetTime = 20160) {\n    let ratio = targetTime / actualTime;\n    \n    // Limit adjustment to Â±4x\n    ratio = Math.max(0.25, Math.min(4.0, ratio));\n    \n    const newDifficulty = oldDifficulty * ratio;\n    return newDifficulty;\n}\n\n// Example: blocks mined in 18,000 minutes (faster than target)\nconst newDiff = adjustDifficulty(100_000, 18_000);\nconsole.log(`New difficulty: ${newDiff}`); // ~112,000\n```\n:::\n\n### Validation\n\n- **Every 2016 blocks**: Check if adjustment needed\n- **Block height**: Must be multiple of 2016\n- **Genesis block**: Block 0, no adjustment\n- **First adjustment**: Block 2016\n\n---\n\n## Related Topics\n\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How the mining algorithm works\n- [Mining Economics](/docs/mining/economics) - How difficulty affects profitability\n- [Bitcoin Mining](/docs/mining) - General mining concepts\n",
    "filename": "difficulty.md"
  },
  "/docs/mining/mempool": {
    "content": "# The Mempool\n\nThe **mempool** (memory pool) is Bitcoin's waiting room for unconfirmed transactions. When you broadcast a transaction, it doesn't immediately go into a block. It first enters the mempool, where it waits for a miner to include it in the next block.\n\nEvery [full node](/docs/glossary#full-node) maintains its own mempool. There is no single, global mempool; each node has its own view of pending transactions, though they generally converge through transaction propagation across the network.\n\n## How the Mempool Works\n\n### Transaction Lifecycle\n\n1. **Broadcast**: User signs and broadcasts a transaction\n2. **Validation**: Nodes verify the transaction is valid (correct signatures, sufficient funds, proper format)\n3. **Mempool Entry**: Valid transactions enter the node's mempool\n4. **Propagation**: Nodes relay transactions to their [peers](/docs/glossary#peer)\n5. **Selection**: Miners select transactions from their mempool to include in blocks\n6. **Confirmation**: Once included in a block, the transaction leaves the mempool\n\n### Mempool Policies\n\nEach node can set its own mempool policies:\n\n- **Size Limit**: Maximum memory allocated to the mempool (default: 300 MB in Bitcoin Core)\n- **Minimum Fee Rate**: Transactions below this rate are rejected\n- **Transaction Expiration**: Transactions may be dropped after a period (default: 2 weeks)\n- **Replace-by-Fee**: Whether to accept transaction replacements\n\n---\n\n## Querying the Mempool\n\nYou can query mempool information using Bitcoin Core's [RPC](/docs/glossary#rpc-remote-procedure-call) interface:\n\n:::code-group\n```rust\nuse bitcoincore_rpc::{Auth, Client, RpcApi};\nuse serde_json::Value;\n\n/// Query mempool information using Bitcoin Core RPC.\nfn query_mempool() -> Result<(), Box<dyn std::error::Error>> {\n    // Connect to Bitcoin Core\n    let client = Client::new(\n        \"http://127.0.0.1:8332\",\n        Auth::UserPass(\"rpcuser\".to_string(), \"rpcpassword\".to_string()),\n    )?;\n    \n    // Get mempool info (size, bytes, usage, fees)\n    let mempool_info: Value = client.call(\"getmempoolinfo\", &[])?;\n    println!(\"Mempool Info:\");\n    println!(\"  Size: {} transactions\", mempool_info[\"size\"]);\n    println!(\"  Bytes: {} bytes\", mempool_info[\"bytes\"]);\n    println!(\"  Memory Usage: {} bytes\", mempool_info[\"usage\"]);\n    println!(\"  Min Fee Rate: {} BTC/kB\", mempool_info[\"mempoolminfee\"]);\n    \n    // Get all transaction IDs in mempool\n    let txids: Vec<String> = client.call(\"getrawmempool\", &[false.into()])?;\n    println!(\"\\nTotal transactions: {}\", txids.len());\n    \n    // Get detailed mempool with fee information\n    let mempool_verbose: Value = client.call(\"getrawmempool\", &[true.into()])?;\n    \n    // Find highest fee transactions\n    if let Some(obj) = mempool_verbose.as_object() {\n        let mut fees: Vec<(&str, f64)> = obj.iter()\n            .filter_map(|(txid, info)| {\n                info[\"fees\"][\"base\"].as_f64().map(|fee| (txid.as_str(), fee))\n            })\n            .collect();\n        fees.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());\n        \n        println!(\"\\nTop 5 highest fee transactions:\");\n        for (txid, fee) in fees.iter().take(5) {\n            println!(\"  {}: {:.8} BTC\", &txid[..16], fee);\n        }\n    }\n    \n    Ok(())\n}\n\nfn main() {\n    if let Err(e) = query_mempool() {\n        eprintln!(\"Error: {}\", e);\n    }\n}\n```\n\n```python\nfrom bitcoinrpc.authproxy import AuthServiceProxy\nimport json\n\ndef query_mempool():\n    \"\"\"Query mempool information using Bitcoin Core RPC.\"\"\"\n    \n    # Connect to Bitcoin Core\n    rpc = AuthServiceProxy(\"http://rpcuser:rpcpassword@127.0.0.1:8332\")\n    \n    # Get mempool info (size, bytes, usage, fees)\n    mempool_info = rpc.getmempoolinfo()\n    print(\"Mempool Info:\")\n    print(f\"  Size: {mempool_info['size']} transactions\")\n    print(f\"  Bytes: {mempool_info['bytes']} bytes\")\n    print(f\"  Memory Usage: {mempool_info['usage']} bytes\")\n    print(f\"  Min Fee Rate: {mempool_info['mempoolminfee']} BTC/kB\")\n    \n    # Get all transaction IDs in mempool\n    txids = rpc.getrawmempool(False)\n    print(f\"\\nTotal transactions: {len(txids)}\")\n    \n    # Get detailed mempool with fee information\n    mempool_verbose = rpc.getrawmempool(True)\n    \n    # Find highest fee transactions\n    fees = [\n        (txid, info['fees']['base'])\n        for txid, info in mempool_verbose.items()\n    ]\n    fees.sort(key=lambda x: x[1], reverse=True)\n    \n    print(\"\\nTop 5 highest fee transactions:\")\n    for txid, fee in fees[:5]:\n        print(f\"  {txid[:16]}: {fee:.8f} BTC\")\n    \n    # Estimate fee for different confirmation targets\n    print(\"\\nFee Estimates (sat/vB):\")\n    for target in [1, 3, 6, 12, 24]:\n        try:\n            estimate = rpc.estimatesmartfee(target)\n            if 'feerate' in estimate:\n                # Convert BTC/kB to sat/vB\n                sat_per_vb = estimate['feerate'] * 100_000\n                print(f\"  {target} blocks: {sat_per_vb:.1f} sat/vB\")\n        except Exception:\n            pass\n\nif __name__ == \"__main__\":\n    query_mempool()\n```\n\n```cpp\n#include <iostream>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\n// Callback for CURL response\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* userp) {\n    userp->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\n/**\n * Make a JSON-RPC call to Bitcoin Core.\n */\njson rpc_call(const std::string& method, const json& params = json::array()) {\n    CURL* curl = curl_easy_init();\n    std::string response;\n    \n    json request = {\n        {\"jsonrpc\", \"1.0\"},\n        {\"id\", \"cpp\"},\n        {\"method\", method},\n        {\"params\", params}\n    };\n    \n    std::string request_str = request.dump();\n    \n    curl_easy_setopt(curl, CURLOPT_URL, \"http://127.0.0.1:8332\");\n    curl_easy_setopt(curl, CURLOPT_USERPWD, \"rpcuser:rpcpassword\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, request_str.c_str());\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    \n    curl_easy_perform(curl);\n    curl_easy_cleanup(curl);\n    \n    return json::parse(response)[\"result\"];\n}\n\n/**\n * Query mempool information using Bitcoin Core RPC.\n */\nvoid query_mempool() {\n    // Get mempool info\n    json mempool_info = rpc_call(\"getmempoolinfo\");\n    std::cout << \"Mempool Info:\" << std::endl;\n    std::cout << \"  Size: \" << mempool_info[\"size\"] << \" transactions\" << std::endl;\n    std::cout << \"  Bytes: \" << mempool_info[\"bytes\"] << \" bytes\" << std::endl;\n    std::cout << \"  Memory Usage: \" << mempool_info[\"usage\"] << \" bytes\" << std::endl;\n    std::cout << \"  Min Fee Rate: \" << mempool_info[\"mempoolminfee\"] << \" BTC/kB\" << std::endl;\n    \n    // Get transaction count\n    json txids = rpc_call(\"getrawmempool\", {false});\n    std::cout << \"\\nTotal transactions: \" << txids.size() << std::endl;\n    \n    // Get detailed mempool\n    json mempool_verbose = rpc_call(\"getrawmempool\", {true});\n    \n    // Collect and sort by fee\n    std::vector<std::pair<std::string, double>> fees;\n    for (auto& [txid, info] : mempool_verbose.items()) {\n        fees.emplace_back(txid, info[\"fees\"][\"base\"].get<double>());\n    }\n    std::sort(fees.begin(), fees.end(),\n              [](auto& a, auto& b) { return a.second > b.second; });\n    \n    std::cout << \"\\nTop 5 highest fee transactions:\" << std::endl;\n    for (int i = 0; i < std::min(5, (int)fees.size()); ++i) {\n        std::cout << \"  \" << fees[i].first.substr(0, 16) \n                  << \": \" << fees[i].second << \" BTC\" << std::endl;\n    }\n}\n\nint main() {\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    query_mempool();\n    curl_global_cleanup();\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\n// RPCCall makes a JSON-RPC call to Bitcoin Core\nfunc RPCCall(method string, params []interface{}) (interface{}, error) {\n\trequest := map[string]interface{}{\n\t\t\"jsonrpc\": \"1.0\",\n\t\t\"id\":      \"go\",\n\t\t\"method\":  method,\n\t\t\"params\":  params,\n\t}\n\n\tjsonData, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(\"POST\", \"http://127.0.0.1:8332\", bytes.NewBuffer(jsonData))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\tauth := base64.StdEncoding.EncodeToString([]byte(\"rpcuser:rpcpassword\"))\n\treq.Header.Set(\"Authorization\", \"Basic \"+auth)\n\n\tclient := &http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar result struct {\n\t\tResult interface{} `json:\"result\"`\n\t\tError  interface{} `json:\"error\"`\n\t}\n\n\tif err := json.Unmarshal(body, &result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif result.Error != nil {\n\t\treturn nil, fmt.Errorf(\"RPC error: %v\", result.Error)\n\t}\n\n\treturn result.Result, nil\n}\n\n// QueryMempool queries mempool information using Bitcoin Core RPC\nfunc QueryMempool() error {\n\t// Get mempool info\n\tmempoolInfo, err := RPCCall(\"getmempoolinfo\", []interface{}{})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinfo := mempoolInfo.(map[string]interface{})\n\tfmt.Println(\"Mempool Info:\")\n\tfmt.Printf(\"  Size: %.0f transactions\\n\", info[\"size\"])\n\tfmt.Printf(\"  Bytes: %.0f bytes\\n\", info[\"bytes\"])\n\tfmt.Printf(\"  Memory Usage: %.0f bytes\\n\", info[\"usage\"])\n\tfmt.Printf(\"  Min Fee Rate: %v BTC/kB\\n\", info[\"mempoolminfee\"])\n\n\t// Get all transaction IDs\n\ttxids, err := RPCCall(\"getrawmempool\", []interface{}{false})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttxidList := txids.([]interface{})\n\tfmt.Printf(\"\\nTotal transactions: %d\\n\", len(txidList))\n\n\t// Get detailed mempool\n\tmempoolVerbose, err := RPCCall(\"getrawmempool\", []interface{}{true})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tverboseMap := mempoolVerbose.(map[string]interface{})\n\ttype feeEntry struct {\n\t\ttxid string\n\t\tfee  float64\n\t}\n\n\tvar fees []feeEntry\n\tfor txid, info := range verboseMap {\n\t\tinfoMap := info.(map[string]interface{})\n\t\tfeesMap := infoMap[\"fees\"].(map[string]interface{})\n\t\tfee := feesMap[\"base\"].(float64)\n\t\tfees = append(fees, feeEntry{txid: txid, fee: fee})\n\t}\n\n\t// Sort by fee (simplified - would use sort.Slice in real code)\n\tfmt.Println(\"\\nTop 5 highest fee transactions:\")\n\tfor i := 0; i < 5 && i < len(fees); i++ {\n\t\tfmt.Printf(\"  %s: %.8f BTC\\n\", fees[i].txid[:16], fees[i].fee)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tif err := QueryMempool(); err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t}\n}\n```\n\n```javascript\nconst http = require('http');\n\n/**\n * Make a JSON-RPC call to Bitcoin Core.\n * @param {string} method - RPC method name\n * @param {Array} params - Method parameters\n * @returns {Promise<any>} - RPC result\n */\nfunction rpcCall(method, params = []) {\n    return new Promise((resolve, reject) => {\n        const data = JSON.stringify({\n            jsonrpc: '1.0',\n            id: 'js',\n            method,\n            params\n        });\n        \n        const options = {\n            hostname: '127.0.0.1',\n            port: 8332,\n            path: '/',\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Authorization': 'Basic ' + Buffer.from('rpcuser:rpcpassword').toString('base64')\n            }\n        };\n        \n        const req = http.request(options, (res) => {\n            let body = '';\n            res.on('data', chunk => body += chunk);\n            res.on('end', () => {\n                const response = JSON.parse(body);\n                if (response.error) reject(response.error);\n                else resolve(response.result);\n            });\n        });\n        \n        req.on('error', reject);\n        req.write(data);\n        req.end();\n    });\n}\n\n/**\n * Query mempool information using Bitcoin Core RPC.\n */\nasync function queryMempool() {\n    // Get mempool info\n    const mempoolInfo = await rpcCall('getmempoolinfo');\n    console.log('Mempool Info:');\n    console.log(`  Size: ${mempoolInfo.size} transactions`);\n    console.log(`  Bytes: ${mempoolInfo.bytes} bytes`);\n    console.log(`  Memory Usage: ${mempoolInfo.usage} bytes`);\n    console.log(`  Min Fee Rate: ${mempoolInfo.mempoolminfee} BTC/kB`);\n    \n    // Get all transaction IDs\n    const txids = await rpcCall('getrawmempool', [false]);\n    console.log(`\\nTotal transactions: ${txids.length}`);\n    \n    // Get detailed mempool\n    const mempoolVerbose = await rpcCall('getrawmempool', [true]);\n    \n    // Sort by fee\n    const fees = Object.entries(mempoolVerbose)\n        .map(([txid, info]) => ({ txid, fee: info.fees.base }))\n        .sort((a, b) => b.fee - a.fee);\n    \n    console.log('\\nTop 5 highest fee transactions:');\n    fees.slice(0, 5).forEach(({ txid, fee }) => {\n        console.log(`  ${txid.slice(0, 16)}: ${fee.toFixed(8)} BTC`);\n    });\n    \n    // Fee estimates\n    console.log('\\nFee Estimates (sat/vB):');\n    for (const target of [1, 3, 6, 12, 24]) {\n        try {\n            const estimate = await rpcCall('estimatesmartfee', [target]);\n            if (estimate.feerate) {\n                // Convert BTC/kB to sat/vB\n                const satPerVb = estimate.feerate * 100_000;\n                console.log(`  ${target} blocks: ${satPerVb.toFixed(1)} sat/vB`);\n            }\n        } catch (e) {}\n    }\n}\n\nqueryMempool().catch(console.error);\n```\n:::\n\n---\n\n## Fee Market Dynamics\n\nThe mempool creates a **fee market** where users bid for block space.\n\n### How Fees Work\n\n- Transactions pay fees measured in **satoshis per virtual byte (sat/vB)**\n- Miners prioritize higher-fee transactions (more profit per block)\n- When blocks are full, low-fee transactions wait longer\n- [Fee rates](/docs/glossary#fee-rate) fluctuate based on demand for block space\n\n### Fee Estimation\n\nWallets estimate fees by analyzing the mempool:\n\n```\nCurrent mempool state:\nâ”œâ”€â”€ 1-2 blocks: 50+ sat/vB (high priority)\nâ”œâ”€â”€ 3-6 blocks: 20-50 sat/vB (medium priority)\nâ”œâ”€â”€ 7+ blocks: 10-20 sat/vB (low priority)\nâ””â”€â”€ Eventually: 1-10 sat/vB (no rush)\n```\n\nDuring congestion, fees spike. During quiet periods, even 1 sat/vB transactions confirm quickly.\n\n### Mempool Congestion\n\nWhen transaction volume exceeds block capacity:\n\n1. **Mempool grows**: Unconfirmed transactions accumulate\n2. **Fees rise**: Users bid higher to get confirmed faster\n3. **Low-fee eviction**: Nodes drop lowest-fee transactions when mempool is full\n4. **Backlog clears**: Eventually, transaction volume decreases and the mempool empties\n\n---\n\n## Replace-by-Fee (RBF)\n\n**[RBF](/docs/glossary#rbf-replace-by-fee)** allows replacing an unconfirmed transaction with a new version paying a higher fee.\n\n### How RBF Works\n\n1. Original transaction signals RBF capability (sequence number < 0xfffffffe)\n2. User broadcasts replacement with higher fee\n3. Nodes replace the original with the new transaction\n4. Miners see only the higher-fee version\n\n### RBF Use Cases\n\n- **Fee bumping**: Speed up a stuck transaction\n- **Payment updates**: Change the amount or destination before [confirmation](/docs/glossary#confirmation)\n- **Consolidation**: Combine outputs more efficiently\n\n### Full RBF vs Opt-in RBF\n\n- **Opt-in RBF**: Only transactions that signal RBF can be replaced (current default)\n- **Full RBF**: Any unconfirmed transaction can be replaced (controversial, increasingly adopted)\n\n---\n\n## Child Pays for Parent (CPFP)\n\nAn alternative to RBF for [fee bumping](/docs/glossary#fee-bumping).\n\n### How CPFP Works\n\n1. Parent transaction is stuck with low fee\n2. Create a child transaction spending the parent's output\n3. Child pays a high enough fee to cover both transactions\n4. Miners include both (they want the child's high fee)\n\n### CPFP vs RBF\n\n| Aspect | RBF | [CPFP](/docs/glossary#cpfp-child-pays-for-parent) |\n|--------|-----|------|\n| Who can bump | Sender only | Sender or recipient |\n| Requires | RBF signaling | Spendable output |\n| Efficiency | More efficient | Uses extra block space |\n\n---\n\n## Mempool Visualization\n\nThe mempool can be visualized as a queue sorted by fee rate:\n\n```\nBlock Space Available: ~1 MB (4 MWU)\n\nFee Rate (sat/vB)\n    â”‚\n100+â”‚ â–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in next block\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆ\n 50 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in 1-3 blocks\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n 20 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† Confirmed in 3-6 blocks\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n 10 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† May wait hours/days\n    â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n  1 â”‚ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â† May never confirm\n    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n      Transaction Volume (by size)\n```\n\n---\n\n## Mempool Sniping and Games\n\n### Transaction Pinning\n\nAn attack where someone prevents a transaction from being replaced:\n\n1. Attacker creates a low-fee child transaction\n2. Child is large, making CPFP expensive\n3. Original transaction is \"pinned\" and hard to bump\n\nThis is a concern for [Lightning Network](/docs/lightning) and other Layer 2 protocols.\n\n### Front-Running\n\nWatching the mempool to exploit pending transactions:\n\n1. See a profitable pending transaction\n2. Create your own transaction with higher fee\n3. Your transaction confirms first\n\nCommon in DeFi on other chains, less relevant for Bitcoin's simpler transactions.\n\n---\n\n## Mempool Tools and Resources\n\n> **Query the mempool yourself!** Try `getmempoolinfo` and `getrawmempool` in the [Bitcoin CLI Terminal](/terminal).\n\n> **Explore visually!** See transactions flowing into blocks with our interactive [Block Visualizer](/block-visualizer).\n\n### Mempool Explorers\n\n- **[mempool.space](https://mempool.space)**: Beautiful visualization of mempool and fee estimates\n- **[jochen-hoenicke.de/queue](https://jochen-hoenicke.de/queue/)**: Historical mempool data\n- **[mempoolexplorer.com](https://mempoolexplorer.com)**: Detailed mempool analytics\n\n### What You Can Learn\n\n- Current fee rates for different confirmation targets\n- Mempool size and growth trends\n- Transaction propagation status\n- Historical congestion patterns\n\n---\n\n## Implications for Users\n\n### Sending Transactions\n\n1. **Check mempool first**: See current fee rates before sending\n2. **Use appropriate fees**: Overpaying wastes money; underpaying causes delays\n3. **Enable RBF**: Always signal RBF for flexibility\n4. **Batch transactions**: Combine multiple payments to save fees\n\n### Receiving Transactions\n\n1. **Wait for confirmations**: Unconfirmed transactions can be replaced or dropped\n2. **Check RBF status**: RBF transactions are more easily [double-spent](/docs/glossary#double-spend) before confirmation\n3. **Monitor mempool**: Track your incoming transaction's position\n\n---\n\n## Technical Details\n\n### Mempool Data Structures\n\nBitcoin Core maintains several structures:\n\n- **mapTx**: Main transaction storage, indexed multiple ways\n- **Ancestor/Descendant tracking**: For CPFP calculations\n- **Fee rate buckets**: For efficient transaction selection\n\n### Transaction Relay Policies\n\nNot all valid transactions are relayed:\n\n- **Dust limit**: Outputs below ~546 sats are non-standard\n- **OP_RETURN size**: Limited to 80 bytes by default (policy, not consensus)\n- **Non-standard scripts**: Some valid scripts aren't relayed\n\n### Mempool Accept Rules\n\nTransactions must pass:\n\n1. **Consensus rules**: Valid signatures, scripts, amounts\n2. **Standardness rules**: Follow common patterns\n3. **Policy rules**: Meet node's minimum fee, size limits\n4. **Package rules**: Ancestor/descendant limits (25 transactions, 101 KB)\n\n---\n\n## Summary\n\nThe mempool is the heartbeat of Bitcoin's transaction processing:\n\n- **Waiting room**: Where transactions queue for confirmation\n- **Fee market**: Creates price discovery for block space\n- **Strategic space**: RBF and CPFP allow fee management\n- **Per-node**: Each node has its own mempool view\n\nUnderstanding the mempool helps you:\n- Set appropriate fees\n- Troubleshoot stuck transactions\n- Understand network congestion\n- Make informed timing decisions\n\n---\n\n## Related Topics\n\n- [Mining Economics](/docs/mining/economics) - How miners profit from fees\n- [Block Construction](/docs/mining/block-construction) - How miners select transactions\n- [Proof-of-Work](/docs/mining/proof-of-work) - The mining process\n\n---\n\n## Resources\n\n- [mempool.space](https://mempool.space) - Real-time mempool visualization\n- [Bitcoin Core mempool documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-limits.md) - Technical details\n",
    "filename": "mempool.md"
  },
  "/docs/mining/block-construction": {
    "content": "# Block Construction\n\nBlock construction is the process by which miners assemble a new block from pending transactions. This is where the [mempool](/docs/glossary#mempool) meets the blockchain. Miners must decide which transactions to include, how to order them, and how to structure the block for maximum profit while following [consensus rules](/docs/glossary#consensus-rules).\n\n## Anatomy of a Block\n\nA Bitcoin block consists of two main parts:\n\n### Block Header (80 bytes)\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Version (4 bytes)                               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Previous Block Hash (32 bytes)                  â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Merkle Root (32 bytes)                          â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Timestamp (4 bytes)                             â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Difficulty Target (4 bytes)                     â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚ Nonce (4 bytes)                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\nAll numeric fields (version, timestamp, [difficulty target](/docs/glossary#difficulty-target), [nonce](/docs/glossary#nonce)) are stored in [little endian](/docs/glossary#little-endian) byte order. The previous block hash and merkle root are stored as-is (32 bytes each).\n\n### Block Body\n\n- **Coinbase Transaction**: First transaction, creates new bitcoin\n- **Regular Transactions**: Payments selected from the mempool\n\n---\n\n## The Coinbase Transaction\n\nThe coinbase transaction is special: it's the only transaction that creates new bitcoin.\n\n### Structure\n\n```\nInputs:\n  - No previous output (creates coins from nothing)\n  - Coinbase data: Arbitrary data (up to 100 bytes)\n    - Must include block height (BIP34)\n    - Often includes miner identifier, messages, extra nonce\n\nOutputs:\n  - Block reward: Currently 3.125 BTC (after April 2024 halving)\n  - Transaction fees: Sum of all fees from included transactions\n  - Can have multiple outputs (pool payouts, etc.)\n```\n\n### Famous Coinbase Messages\n\n- **Genesis Block**: \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\"\n- **Block 629999** (pre-halving): \"NYTimes 09/Apr/2020 With $2.3T Injection, Fed's Plan Far Exceeds 2008 Rescue\"\n\n### Coinbase Maturity\n\nCoinbase outputs cannot be spent until 100 blocks have passed. This prevents issues if the block is [orphaned](/docs/glossary#orphan-block).\n\n---\n\n## Transaction Selection\n\nMiners want to maximize revenue, which means selecting transactions that pay the highest fees per unit of block space.\n\n### The Knapsack Problem\n\nBlock construction is a variant of the knapsack optimization problem:\n\n- **Constraint**: Block weight limit (4 million [weight units](/docs/glossary#weight-units) â‰ˆ 1 MB base + 3 MB witness)\n- **Objective**: Maximize total fees\n- **Complication**: Transaction dependencies (child transactions require parents)\n\n### Fee Rate Priority\n\nTransactions are generally sorted by **[fee rate](/docs/glossary#fee-rate)** (satoshis per virtual byte):\n\n```\nPriority Queue:\n1. Tx A: 100 sat/vB, 250 vB â†’ 25,000 sats fee\n2. Tx B: 80 sat/vB, 500 vB â†’ 40,000 sats fee\n3. Tx C: 50 sat/vB, 200 vB â†’ 10,000 sats fee\n...\n```\n\n### Ancestor Fee Rate\n\nWhen transactions have dependencies, miners calculate the **ancestor fee rate**:\n\n```\nParent Tx: 10 sat/vB, 200 vB\nChild Tx: 100 sat/vB, 150 vB\n\nAncestor fee rate of child = (10Ã—200 + 100Ã—150) / (200 + 150)\n                           = 17,000 / 350 = 48.6 sat/vB\n```\n\nThis is how [CPFP](/docs/glossary#cpfp-child-pays-for-parent) (Child Pays for Parent) works: the child's high fee pulls the parent along.\n\n### Block Template Algorithm\n\nBitcoin Core's `getblocktemplate` uses this approach:\n\n1. **Sort by ancestor fee rate**: Calculate effective fee rate for each transaction\n2. **Add highest-fee transactions**: Fill the block greedily\n3. **Handle dependencies**: Include all ancestors when adding a transaction\n4. **Respect limits**: Stay within weight and sigop limits\n5. **Update calculations**: Recalculate fee rates as transactions are added\n\n---\n\n## Block Weight and SegWit\n\nSince [SegWit](/docs/glossary#segwit-segregated-witness) (2017), blocks use **weight** instead of raw size:\n\n```\nBlock Weight = (Base Size Ã— 4) + Witness Size\n\nMaximum Block Weight = 4,000,000 weight units (4 MWU)\n```\n\n### Practical Capacity\n\n- **Non-SegWit transactions**: ~1 MB per block\n- **All SegWit transactions**: Up to ~2.3 MB per block\n- **Typical mixed blocks**: ~1.5-2 MB\n\n### Why Weight Matters for Miners\n\nSegWit transactions are \"discounted\" because their [witness](/docs/glossary#witness) data costs less weight. This means:\n\n- SegWit transactions can pay lower absolute fees for the same priority\n- Miners can fit more transactions in a block\n- More fees collected overall\n\n---\n\n## Constructing the Merkle Root\n\nAll transactions in a block are hashed into a **[Merkle tree](/docs/glossary#merkle-tree)**:\n\n```\n                    Merkle Root\n                   /           \\\n              Hash AB          Hash CD\n             /      \\         /      \\\n         Hash A    Hash B   Hash C   Hash D\n           |         |        |        |\n          Tx A      Tx B     Tx C     Tx D\n```\n\n### Why Merkle Trees?\n\n- **Efficient verification**: Prove a transaction is in a block with O(log n) hashes\n- **Compact proofs**: [SPV](/docs/glossary#spv-simplified-payment-verification) wallets only need the Merkle path, not the full block\n- **Tamper detection**: Any change to any transaction changes the root\n\n### Merkle Tree Construction\n\n1. Hash each transaction (double SHA-256)\n2. Pair hashes and hash together\n3. If odd number, duplicate the last hash\n4. Repeat until one hash remains (the root)\n\n### Merkle Tree Implementation\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse sha2::{Sha256, Digest};\n\n/// Performs double SHA-256 (SHA256D) hash.\nfn sha256d(data: &[u8]) -> [u8; 32] {\n    let first = Sha256::digest(data);\n    Sha256::digest(&first).into()\n}\n\n/// Computes the Merkle root from a list of transaction hashes.\n/// \n/// # Arguments\n/// * `tx_hashes` - Vector of 32-byte transaction hashes (txids)\n/// \n/// # Returns\n/// The 32-byte Merkle root\nfn compute_merkle_root(tx_hashes: Vec<[u8; 32]>) -> [u8; 32] {\n    if tx_hashes.is_empty() {\n        return [0u8; 32];\n    }\n    \n    let mut level = tx_hashes;\n    \n    while level.len() > 1 {\n        let mut next_level = Vec::new();\n        \n        // Process pairs\n        for chunk in level.chunks(2) {\n            let left = chunk[0];\n            // If odd number, duplicate the last hash\n            let right = if chunk.len() == 2 { chunk[1] } else { chunk[0] };\n            \n            // Concatenate and hash\n            let mut combined = [0u8; 64];\n            combined[..32].copy_from_slice(&left);\n            combined[32..].copy_from_slice(&right);\n            \n            next_level.push(sha256d(&combined));\n        }\n        \n        level = next_level;\n    }\n    \n    level[0]\n}\n\n/// Generates a Merkle proof for a transaction at a given index.\nfn generate_merkle_proof(tx_hashes: &[[u8; 32]], tx_index: usize) -> Vec<([u8; 32], bool)> {\n    let mut proof = Vec::new();\n    let mut index = tx_index;\n    let mut level: Vec<[u8; 32]> = tx_hashes.to_vec();\n    \n    while level.len() > 1 {\n        // Determine sibling\n        let sibling_index = if index % 2 == 0 { index + 1 } else { index - 1 };\n        let sibling = if sibling_index < level.len() {\n            level[sibling_index]\n        } else {\n            level[index] // Duplicate if odd\n        };\n        \n        // true = sibling is on the right\n        proof.push((sibling, index % 2 == 0));\n        \n        // Move to next level\n        let mut next_level = Vec::new();\n        for chunk in level.chunks(2) {\n            let left = chunk[0];\n            let right = if chunk.len() == 2 { chunk[1] } else { chunk[0] };\n            let mut combined = [0u8; 64];\n            combined[..32].copy_from_slice(&left);\n            combined[32..].copy_from_slice(&right);\n            next_level.push(sha256d(&combined));\n        }\n        \n        level = next_level;\n        index /= 2;\n    }\n    \n    proof\n}\n\nfn main() {\n    // Example: 4 transaction hashes\n    let tx_hashes: Vec<[u8; 32]> = vec![\n        sha256d(b\"tx1\"),\n        sha256d(b\"tx2\"),\n        sha256d(b\"tx3\"),\n        sha256d(b\"tx4\"),\n    ];\n    \n    let root = compute_merkle_root(tx_hashes.clone());\n    println!(\"Merkle root: {}\", hex::encode(root));\n    \n    // Generate proof for tx at index 2\n    let proof = generate_merkle_proof(&tx_hashes, 2);\n    println!(\"Proof has {} elements\", proof.len());\n}\n```\n\n```python\nimport hashlib\n\ndef sha256d(data: bytes) -> bytes:\n    \"\"\"Performs double SHA-256 (SHA256D) hash.\"\"\"\n    return hashlib.sha256(hashlib.sha256(data).digest()).digest()\n\ndef compute_merkle_root(tx_hashes: list[bytes]) -> bytes:\n    \"\"\"\n    Computes the Merkle root from a list of transaction hashes.\n    \n    Args:\n        tx_hashes: List of 32-byte transaction hashes (txids)\n    \n    Returns:\n        32-byte Merkle root\n    \"\"\"\n    if not tx_hashes:\n        return bytes(32)\n    \n    level = list(tx_hashes)\n    \n    while len(level) > 1:\n        next_level = []\n        \n        # Process pairs\n        for i in range(0, len(level), 2):\n            left = level[i]\n            # If odd number, duplicate the last hash\n            right = level[i + 1] if i + 1 < len(level) else level[i]\n            \n            # Concatenate and hash\n            combined = left + right\n            next_level.append(sha256d(combined))\n        \n        level = next_level\n    \n    return level[0]\n\ndef generate_merkle_proof(tx_hashes: list[bytes], tx_index: int) -> list[tuple[bytes, bool]]:\n    \"\"\"\n    Generates a Merkle proof for a transaction at a given index.\n    \n    Args:\n        tx_hashes: List of transaction hashes\n        tx_index: Index of the transaction to prove\n    \n    Returns:\n        List of (sibling_hash, is_right) tuples\n    \"\"\"\n    proof = []\n    index = tx_index\n    level = list(tx_hashes)\n    \n    while len(level) > 1:\n        # Determine sibling\n        sibling_index = index + 1 if index % 2 == 0 else index - 1\n        sibling = level[sibling_index] if sibling_index < len(level) else level[index]\n        \n        # True = sibling is on the right\n        proof.append((sibling, index % 2 == 0))\n        \n        # Move to next level\n        next_level = []\n        for i in range(0, len(level), 2):\n            left = level[i]\n            right = level[i + 1] if i + 1 < len(level) else level[i]\n            next_level.append(sha256d(left + right))\n        \n        level = next_level\n        index //= 2\n    \n    return proof\n\ndef verify_merkle_proof(tx_hash: bytes, proof: list[tuple[bytes, bool]], root: bytes) -> bool:\n    \"\"\"Verifies a Merkle proof.\"\"\"\n    current = tx_hash\n    \n    for sibling, is_right in proof:\n        if is_right:\n            current = sha256d(current + sibling)\n        else:\n            current = sha256d(sibling + current)\n    \n    return current == root\n\n# Example usage\ntx_hashes = [sha256d(f\"tx{i}\".encode()) for i in range(1, 5)]\n\nroot = compute_merkle_root(tx_hashes)\nprint(f\"Merkle root: {root.hex()}\")\n\n# Generate and verify proof for tx at index 2\nproof = generate_merkle_proof(tx_hashes, 2)\nprint(f\"Proof has {len(proof)} elements\")\n\nis_valid = verify_merkle_proof(tx_hashes[2], proof, root)\nprint(f\"Proof valid: {is_valid}\")\n```\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <array>\n#include <iomanip>\n#include <openssl/sha.h>\n\nusing Hash = std::array<unsigned char, 32>;\n\n/** Performs double SHA-256 (SHA256D) hash. */\nHash sha256d(const unsigned char* data, size_t len) {\n    Hash first, second;\n    SHA256(data, len, first.data());\n    SHA256(first.data(), 32, second.data());\n    return second;\n}\n\n/** Computes the Merkle root from a list of transaction hashes. */\nHash computeMerkleRoot(std::vector<Hash> txHashes) {\n    if (txHashes.empty()) {\n        return Hash{};\n    }\n    \n    std::vector<Hash> level = std::move(txHashes);\n    \n    while (level.size() > 1) {\n        std::vector<Hash> nextLevel;\n        \n        for (size_t i = 0; i < level.size(); i += 2) {\n            Hash left = level[i];\n            // If odd number, duplicate the last hash\n            Hash right = (i + 1 < level.size()) ? level[i + 1] : level[i];\n            \n            // Concatenate and hash\n            unsigned char combined[64];\n            std::copy(left.begin(), left.end(), combined);\n            std::copy(right.begin(), right.end(), combined + 32);\n            \n            nextLevel.push_back(sha256d(combined, 64));\n        }\n        \n        level = std::move(nextLevel);\n    }\n    \n    return level[0];\n}\n\n/** Merkle proof element: hash and position indicator. */\nstruct ProofElement {\n    Hash hash;\n    bool isRight;  // true if sibling is on the right\n};\n\n/** Generates a Merkle proof for a transaction at a given index. */\nstd::vector<ProofElement> generateMerkleProof(\n    const std::vector<Hash>& txHashes, size_t txIndex) {\n    \n    std::vector<ProofElement> proof;\n    size_t index = txIndex;\n    std::vector<Hash> level = txHashes;\n    \n    while (level.size() > 1) {\n        // Determine sibling\n        size_t siblingIndex = (index % 2 == 0) ? index + 1 : index - 1;\n        Hash sibling = (siblingIndex < level.size()) \n            ? level[siblingIndex] : level[index];\n        \n        proof.push_back({sibling, index % 2 == 0});\n        \n        // Move to next level\n        std::vector<Hash> nextLevel;\n        for (size_t i = 0; i < level.size(); i += 2) {\n            Hash left = level[i];\n            Hash right = (i + 1 < level.size()) ? level[i + 1] : level[i];\n            unsigned char combined[64];\n            std::copy(left.begin(), left.end(), combined);\n            std::copy(right.begin(), right.end(), combined + 32);\n            nextLevel.push_back(sha256d(combined, 64));\n        }\n        \n        level = std::move(nextLevel);\n        index /= 2;\n    }\n    \n    return proof;\n}\n\nvoid printHash(const Hash& hash) {\n    for (unsigned char byte : hash) {\n        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)byte;\n    }\n}\n\nint main() {\n    // Example: 4 transaction hashes\n    std::vector<Hash> txHashes;\n    for (int i = 1; i <= 4; ++i) {\n        std::string tx = \"tx\" + std::to_string(i);\n        txHashes.push_back(sha256d((unsigned char*)tx.c_str(), tx.size()));\n    }\n    \n    Hash root = computeMerkleRoot(txHashes);\n    std::cout << \"Merkle root: \";\n    printHash(root);\n    std::cout << std::endl;\n    \n    // Generate proof for tx at index 2\n    auto proof = generateMerkleProof(txHashes, 2);\n    std::cout << \"Proof has \" << proof.size() << \" elements\" << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// SHA256D performs double SHA-256 hash\nfunc SHA256D(data []byte) []byte {\n\tfirst := sha256.Sum256(data)\n\tsecond := sha256.Sum256(first[:])\n\treturn second[:]\n}\n\n// ComputeMerkleRoot computes the Merkle root from a list of transaction hashes\nfunc ComputeMerkleRoot(txHashes [][]byte) []byte {\n\tif len(txHashes) == 0 {\n\t\treturn make([]byte, 32)\n\t}\n\t\n\tif len(txHashes) == 1 {\n\t\treturn txHashes[0]\n\t}\n\t\n\t// Build next level\n\tvar nextLevel [][]byte\n\tfor i := 0; i < len(txHashes); i += 2 {\n\t\tif i+1 < len(txHashes) {\n\t\t\t// Pair of hashes\n\t\t\tcombined := append(txHashes[i], txHashes[i+1]...)\n\t\t\tnextLevel = append(nextLevel, SHA256D(combined))\n\t\t} else {\n\t\t\t// Odd one out, hash with itself\n\t\t\tcombined := append(txHashes[i], txHashes[i]...)\n\t\t\tnextLevel = append(nextLevel, SHA256D(combined))\n\t\t}\n\t}\n\t\n\treturn ComputeMerkleRoot(nextLevel)\n}\n\n// GenerateMerkleProof generates a Merkle proof for a transaction at the given index\nfunc GenerateMerkleProof(txHashes [][]byte, txIndex int) [][]byte {\n\tif txIndex < 0 || txIndex >= len(txHashes) {\n\t\treturn nil\n\t}\n\t\n\tvar proof [][]byte\n\tlevel := txHashes\n\tindex := txIndex\n\t\n\tfor len(level) > 1 {\n\t\tsiblingIndex := index ^ 1 // XOR to get sibling\n\t\tif siblingIndex < len(level) {\n\t\t\tproof = append(proof, level[siblingIndex])\n\t\t}\n\t\t\n\t\t// Build next level\n\t\tvar nextLevel [][]byte\n\t\tfor i := 0; i < len(level); i += 2 {\n\t\t\tif i+1 < len(level) {\n\t\t\t\tcombined := append(level[i], level[i+1]...)\n\t\t\t\tnextLevel = append(nextLevel, SHA256D(combined))\n\t\t\t} else {\n\t\t\t\tcombined := append(level[i], level[i]...)\n\t\t\t\tnextLevel = append(nextLevel, SHA256D(combined))\n\t\t\t}\n\t\t}\n\t\t\n\t\tlevel = nextLevel\n\t\tindex = index / 2\n\t}\n\t\n\treturn proof\n}\n\n// VerifyMerkleProof verifies a Merkle proof\nfunc VerifyMerkleProof(txHash []byte, proof [][]byte, root []byte) bool {\n\tcurrent := txHash\n\t\n\tfor _, sibling := range proof {\n\t\tcombined := append(current, sibling...)\n\t\tcurrent = SHA256D(combined)\n\t}\n\t\n\treturn hex.EncodeToString(current) == hex.EncodeToString(root)\n}\n\nfunc main() {\n\t// Example usage\n\ttxHashes := make([][]byte, 4)\n\tfor i := 0; i < 4; i++ {\n\t\ttxData := []byte(fmt.Sprintf(\"tx%d\", i+1))\n\t\ttxHashes[i] = SHA256D(txData)\n\t}\n\t\n\troot := ComputeMerkleRoot(txHashes)\n\tfmt.Printf(\"Merkle root: %s\\n\", hex.EncodeToString(root))\n\t\n\t// Generate and verify proof for tx at index 2\n\tproof := GenerateMerkleProof(txHashes, 2)\n\tfmt.Printf(\"Proof has %d elements\\n\", len(proof))\n\t\n\tisValid := VerifyMerkleProof(txHashes[2], proof, root)\n\tfmt.Printf(\"Proof valid: %v\\n\", isValid)\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\n/**\n * Performs double SHA-256 (SHA256D) hash.\n * @param {Buffer} data - Data to hash\n * @returns {Buffer} - 32-byte hash\n */\nfunction sha256d(data) {\n    const first = crypto.createHash('sha256').update(data).digest();\n    return crypto.createHash('sha256').update(first).digest();\n}\n\n/**\n * Computes the Merkle root from a list of transaction hashes.\n * @param {Buffer[]} txHashes - Array of 32-byte transaction hashes\n * @returns {Buffer} - 32-byte Merkle root\n */\nfunction computeMerkleRoot(txHashes) {\n    if (txHashes.length === 0) {\n        return Buffer.alloc(32);\n    }\n    \n    let level = [...txHashes];\n    \n    while (level.length > 1) {\n        const nextLevel = [];\n        \n        for (let i = 0; i < level.length; i += 2) {\n            const left = level[i];\n            // If odd number, duplicate the last hash\n            const right = (i + 1 < level.length) ? level[i + 1] : level[i];\n            \n            // Concatenate and hash\n            const combined = Buffer.concat([left, right]);\n            nextLevel.push(sha256d(combined));\n        }\n        \n        level = nextLevel;\n    }\n    \n    return level[0];\n}\n\n/**\n * Generates a Merkle proof for a transaction at a given index.\n * @param {Buffer[]} txHashes - Array of transaction hashes\n * @param {number} txIndex - Index of the transaction to prove\n * @returns {Array<{hash: Buffer, isRight: boolean}>} - Proof elements\n */\nfunction generateMerkleProof(txHashes, txIndex) {\n    const proof = [];\n    let index = txIndex;\n    let level = [...txHashes];\n    \n    while (level.length > 1) {\n        // Determine sibling\n        const siblingIndex = (index % 2 === 0) ? index + 1 : index - 1;\n        const sibling = (siblingIndex < level.length) \n            ? level[siblingIndex] : level[index];\n        \n        // true = sibling is on the right\n        proof.push({ hash: sibling, isRight: index % 2 === 0 });\n        \n        // Move to next level\n        const nextLevel = [];\n        for (let i = 0; i < level.length; i += 2) {\n            const left = level[i];\n            const right = (i + 1 < level.length) ? level[i + 1] : level[i];\n            nextLevel.push(sha256d(Buffer.concat([left, right])));\n        }\n        \n        level = nextLevel;\n        index = Math.floor(index / 2);\n    }\n    \n    return proof;\n}\n\n/**\n * Verifies a Merkle proof.\n * @param {Buffer} txHash - Transaction hash to verify\n * @param {Array} proof - Merkle proof\n * @param {Buffer} root - Expected Merkle root\n * @returns {boolean} - True if proof is valid\n */\nfunction verifyMerkleProof(txHash, proof, root) {\n    let current = txHash;\n    \n    for (const { hash: sibling, isRight } of proof) {\n        if (isRight) {\n            current = sha256d(Buffer.concat([current, sibling]));\n        } else {\n            current = sha256d(Buffer.concat([sibling, current]));\n        }\n    }\n    \n    return current.equals(root);\n}\n\n// Example usage\nconst txHashes = [1, 2, 3, 4].map(i => sha256d(Buffer.from(`tx${i}`)));\n\nconst root = computeMerkleRoot(txHashes);\nconsole.log(`Merkle root: ${root.toString('hex')}`);\n\n// Generate and verify proof for tx at index 2\nconst proof = generateMerkleProof(txHashes, 2);\nconsole.log(`Proof has ${proof.length} elements`);\n\nconst isValid = verifyMerkleProof(txHashes[2], proof, root);\nconsole.log(`Proof valid: ${isValid}`);\n```\n:::\n\n---\n\n## The Block Template\n\nWhen a miner requests work, they receive a **[block template](/docs/glossary#block-template)**:\n\n```json\n{\n  \"version\": 536870912,\n  \"previousblockhash\": \"00000000000000000002a7c...\",\n  \"transactions\": [\n    {\n      \"txid\": \"abc123...\",\n      \"fee\": 25000,\n      \"weight\": 1000\n    },\n    ...\n  ],\n  \"coinbasevalue\": 312510000,\n  \"target\": \"00000000000000000004b3f...\",\n  \"mintime\": 1699999999,\n  \"mutable\": [\"time\", \"transactions\", \"coinbase\"]\n}\n```\n\n### Template Updates\n\nMiners should update their template:\n\n- **Every few seconds**: To include new high-fee transactions\n- **When a new block arrives**: Previous block hash changes\n- **When transactions confirm**: Remove now-invalid transactions\n\n---\n\n## Empty Blocks\n\nSometimes miners produce **empty blocks** (only coinbase transaction):\n\n### Why Empty Blocks?\n\n1. **Speed**: Immediately after finding a block, miners start on the next\n2. **Validation lag**: New block's transactions aren't yet validated\n3. **Profit**: [Block reward](/docs/glossary#block-reward) alone is still profitable\n\n### SPV Mining\n\nSome pools practice \"SPV mining\":\n\n1. See new block header from competitor\n2. Start mining on top immediately (without validating transactions)\n3. If the previous block was invalid, their block is also invalid\n\nThis is risky but provides a head start.\n\n---\n\n## Extra Nonce\n\nThe 4-byte nonce in the header provides only 2Â³Â² possibilities, which is not enough for modern [ASICs](/docs/glossary#asic-application-specific-integrated-circuit).\n\n### Expanding the Search Space\n\nMiners use additional variables:\n\n1. **Extra nonce in coinbase**: Arbitrary data that changes the Merkle root\n2. **Timestamp**: Can be adjusted within limits\n3. **Version bits**: Some bits can be rolled\n\n```\nSearch space:\n- Nonce: 4 bytes â†’ 2Â³Â² combinations\n- Extra nonce: 4-8 bytes â†’ 2Â³Â²-2â¶â´ combinations\n- Combined: Effectively unlimited\n```\n\n---\n\n## Block Propagation Incentives\n\nMiners want their blocks to propagate quickly:\n\n### Compact Blocks (BIP 152)\n\nInstead of sending full blocks:\n\n1. Send block header + short transaction IDs\n2. Receiver reconstructs from mempool\n3. Request only missing transactions\n\nReduces block propagation from megabytes to kilobytes.\n\n### FIBRE Network\n\nA private relay network for miners:\n\n- Uses forward error correction\n- Optimized routing\n- Reduces orphan risk from slow propagation\n\n---\n\n## Practical Example\n\nBuilding a block step by step:\n\n```\n1. Start with empty block\n   - Weight used: 0 / 4,000,000\n   - Fees collected: 0\n\n2. Create coinbase transaction\n   - Block reward: 3.125 BTC\n   - Reserve space for coinbase: ~200 weight units\n\n3. Select transactions from mempool\n   - Tx1: 50 sat/vB, 500 vB, 25,000 sat fee âœ“\n   - Tx2: 45 sat/vB, 1000 vB, 45,000 sat fee âœ“\n   - Tx3: 40 sat/vB, 800 vB, 32,000 sat fee âœ“\n   ...continue until block is full...\n\n4. Calculate Merkle root from all transactions\n\n5. Assemble block header\n   - Version: 0x20000000\n   - Previous hash: [from chain tip]\n   - Merkle root: [calculated]\n   - Timestamp: [current time]\n   - Bits: [current difficulty]\n   - Nonce: [start searching]\n\n6. Mine (search for valid nonce)\n```\n\n---\n\n## Summary\n\nBlock construction is where mining meets economics:\n\n- **Coinbase creates new bitcoin** plus collects all fees\n- **Transaction selection** optimizes for fee revenue\n- **Merkle trees** provide efficient verification\n- **Weight limits** determine block capacity\n- **Propagation speed** affects orphan risk\n\nMiners balance:\n- Including high-fee transactions (more profit)\n- Keeping blocks small (faster propagation)\n- Updating templates (fresh transactions)\n- Starting quickly (after new block found)\n\n---\n\n## Related Topics\n\n- [Mempool](/docs/mining/mempool) - Where transactions wait\n- [Block Visualizer](/block-visualizer) - See transactions flowing into blocks\n- [Proof-of-Work](/docs/mining/proof-of-work) - Finding valid blocks\n- [Mining Economics](/docs/mining/economics) - Revenue and costs\n- [Mining Pools](/docs/mining/pools) - Collaborative mining\n\n---\n\n## Resources\n\n- [BIP 152: Compact Blocks](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki)\n- [Bitcoin Core getblocktemplate](https://developer.bitcoin.org/reference/rpc/getblocktemplate.html)\n",
    "filename": "block-construction.md"
  },
  "/docs/mining/economics": {
    "content": "# Mining Economics\n\nUnderstanding the economics of Bitcoin mining is essential for anyone considering participating in the network. This page covers the revenue sources, cost factors, and profitability calculations that determine whether mining is financially viable.\n\n## Block Rewards\n\nThe primary revenue source for miners is the block reward, which consists of two components:\n\n| Component | Description | Current Value |\n|-----------|-------------|---------------|\n| **Block Subsidy** | New bitcoin created with each block | 3.125 BTC |\n| **[Transaction Fees](/docs/glossary#transaction-fee)** | Sum of fees from included transactions | 0.1-1+ BTC |\n\n- **Current Reward**: 3.125 BTC per block (after 2024 [halving](/docs/glossary#halving))\n- **Next Halving**: ~2028 (reward will be 1.5625 BTC)\n- **Total Reward**: Block subsidy + transaction fees\n\n---\n\n## Cost Analysis\n\n### Electricity Costs\n\nElectricity is typically the largest ongoing cost for miners:\n\n- **Power Consumption**: Varies by hardware (modern ASICs: 3,000-3,500W)\n- **Cost Calculation**: Power (kW) Ã— Hours Ã— Electricity rate ($/kWh)\n- **Consideration**: Mining profitability depends heavily on electricity costs\n- **Regional Variation**: Electricity rates vary from $0.02 to $0.30+ per kWh\n\n### Hardware Costs\n\n- **[ASIC](/docs/glossary#asic-application-specific-integrated-circuit) Purchase**: $2,000â€“$15,000+ per unit\n- **Depreciation**: Hardware loses value as newer, more efficient models release\n- **Lifespan**: Typically 2-4 years of competitive operation\n- **Maintenance**: Fans, power supplies may need replacement\n\n### Other Costs\n\n- **Cooling**: Air conditioning or immersion cooling systems\n- **Facility**: Rent, construction, or space allocation\n- **Internet**: Reliable, low-latency connection\n- **Personnel**: Monitoring and maintenance staff (for larger operations)\n\n---\n\n## Profitability Calculation\n\nMining profitability depends on several factors. Here's how to calculate expected returns:\n\n:::code-group\n```rust\n/// Mining profitability calculator\n/// \n/// Calculates daily profit based on hardware specs and costs.\n\nstruct MiningCalculator {\n    hash_rate_th: f64,      // Hashrate in TH/s\n    power_watts: f64,        // Power consumption in watts\n    electricity_rate: f64,   // $/kWh\n    pool_fee_percent: f64,   // Pool fee percentage (e.g., 2.0 for 2%)\n    btc_price: f64,          // Current BTC price in USD\n    network_hash_rate_eh: f64, // Network hashrate in EH/s\n    block_reward: f64,       // Block reward in BTC\n}\n\nimpl MiningCalculator {\n    /// Calculate daily revenue in BTC\n    fn daily_btc_revenue(&self) -> f64 {\n        // Blocks per day\n        let blocks_per_day = 144.0;\n        \n        // Your share of the network (TH/s vs EH/s = 1e6 ratio)\n        let network_share = self.hash_rate_th / (self.network_hash_rate_eh * 1_000_000.0);\n        \n        // Daily BTC before pool fees\n        let gross_btc = network_share * blocks_per_day * self.block_reward;\n        \n        // After pool fees\n        gross_btc * (1.0 - self.pool_fee_percent / 100.0)\n    }\n    \n    /// Calculate daily electricity cost in USD\n    fn daily_electricity_cost(&self) -> f64 {\n        let kwh_per_day = (self.power_watts / 1000.0) * 24.0;\n        kwh_per_day * self.electricity_rate\n    }\n    \n    /// Calculate daily profit in USD\n    fn daily_profit(&self) -> f64 {\n        let revenue = self.daily_btc_revenue() * self.btc_price;\n        let cost = self.daily_electricity_cost();\n        revenue - cost\n    }\n    \n    /// Calculate break-even electricity rate\n    fn break_even_electricity_rate(&self) -> f64 {\n        let daily_revenue = self.daily_btc_revenue() * self.btc_price;\n        let kwh_per_day = (self.power_watts / 1000.0) * 24.0;\n        daily_revenue / kwh_per_day\n    }\n}\n\nfn main() {\n    let calc = MiningCalculator {\n        hash_rate_th: 140.0,        // Antminer S19 XP: 140 TH/s\n        power_watts: 3010.0,        // 3010W consumption\n        electricity_rate: 0.05,     // $0.05/kWh\n        pool_fee_percent: 2.0,      // 2% pool fee\n        btc_price: 60_000.0,        // $60,000 per BTC\n        network_hash_rate_eh: 700.0, // 700 EH/s\n        block_reward: 3.125,\n    };\n    \n    println!(\"Daily BTC: {:.8} BTC\", calc.daily_btc_revenue());\n    println!(\"Daily Revenue: ${:.2}\", calc.daily_btc_revenue() * calc.btc_price);\n    println!(\"Daily Electricity: ${:.2}\", calc.daily_electricity_cost());\n    println!(\"Daily Profit: ${:.2}\", calc.daily_profit());\n    println!(\"Break-even rate: ${:.4}/kWh\", calc.break_even_electricity_rate());\n}\n```\n\n```python\nclass MiningCalculator:\n    \"\"\"\n    Mining profitability calculator.\n    Calculates daily profit based on hardware specs and costs.\n    \"\"\"\n    \n    def __init__(\n        self,\n        hash_rate_th: float,        # Hashrate in TH/s\n        power_watts: float,          # Power consumption in watts\n        electricity_rate: float,     # $/kWh\n        pool_fee_percent: float,     # Pool fee percentage\n        btc_price: float,            # Current BTC price in USD\n        network_hash_rate_eh: float, # Network hashrate in EH/s\n        block_reward: float = 3.125  # Block reward in BTC\n    ):\n        self.hash_rate_th = hash_rate_th\n        self.power_watts = power_watts\n        self.electricity_rate = electricity_rate\n        self.pool_fee_percent = pool_fee_percent\n        self.btc_price = btc_price\n        self.network_hash_rate_eh = network_hash_rate_eh\n        self.block_reward = block_reward\n    \n    def daily_btc_revenue(self) -> float:\n        \"\"\"Calculate daily revenue in BTC.\"\"\"\n        blocks_per_day = 144\n        \n        # Your share of the network (TH/s vs EH/s = 1e6 ratio)\n        network_share = self.hash_rate_th / (self.network_hash_rate_eh * 1_000_000)\n        \n        # Daily BTC before pool fees\n        gross_btc = network_share * blocks_per_day * self.block_reward\n        \n        # After pool fees\n        return gross_btc * (1 - self.pool_fee_percent / 100)\n    \n    def daily_electricity_cost(self) -> float:\n        \"\"\"Calculate daily electricity cost in USD.\"\"\"\n        kwh_per_day = (self.power_watts / 1000) * 24\n        return kwh_per_day * self.electricity_rate\n    \n    def daily_profit(self) -> float:\n        \"\"\"Calculate daily profit in USD.\"\"\"\n        revenue = self.daily_btc_revenue() * self.btc_price\n        cost = self.daily_electricity_cost()\n        return revenue - cost\n    \n    def break_even_electricity_rate(self) -> float:\n        \"\"\"Calculate break-even electricity rate in $/kWh.\"\"\"\n        daily_revenue = self.daily_btc_revenue() * self.btc_price\n        kwh_per_day = (self.power_watts / 1000) * 24\n        return daily_revenue / kwh_per_day\n\n# Example: Antminer S19 XP\ncalc = MiningCalculator(\n    hash_rate_th=140.0,         # 140 TH/s\n    power_watts=3010.0,         # 3010W\n    electricity_rate=0.05,      # $0.05/kWh\n    pool_fee_percent=2.0,       # 2% pool fee\n    btc_price=60_000.0,         # $60,000 per BTC\n    network_hash_rate_eh=700.0  # 700 EH/s\n)\n\nprint(f\"Daily BTC: {calc.daily_btc_revenue():.8f} BTC\")\nprint(f\"Daily Revenue: ${calc.daily_btc_revenue() * calc.btc_price:.2f}\")\nprint(f\"Daily Electricity: ${calc.daily_electricity_cost():.2f}\")\nprint(f\"Daily Profit: ${calc.daily_profit():.2f}\")\nprint(f\"Break-even rate: ${calc.break_even_electricity_rate():.4f}/kWh\")\n```\n\n```cpp\n#include <iostream>\n#include <iomanip>\n\n/**\n * Mining profitability calculator.\n * Calculates daily profit based on hardware specs and costs.\n */\nclass MiningCalculator {\nprivate:\n    double hash_rate_th;        // Hashrate in TH/s\n    double power_watts;         // Power consumption in watts\n    double electricity_rate;    // $/kWh\n    double pool_fee_percent;    // Pool fee percentage\n    double btc_price;           // Current BTC price in USD\n    double network_hash_rate_eh; // Network hashrate in EH/s\n    double block_reward;        // Block reward in BTC\n\npublic:\n    MiningCalculator(double hash_rate_th, double power_watts,\n                     double electricity_rate, double pool_fee_percent,\n                     double btc_price, double network_hash_rate_eh,\n                     double block_reward = 3.125)\n        : hash_rate_th(hash_rate_th), power_watts(power_watts),\n          electricity_rate(electricity_rate), pool_fee_percent(pool_fee_percent),\n          btc_price(btc_price), network_hash_rate_eh(network_hash_rate_eh),\n          block_reward(block_reward) {}\n\n    /** Calculate daily revenue in BTC */\n    double dailyBtcRevenue() const {\n        const double blocks_per_day = 144.0;\n        \n        // Your share of the network (TH/s vs EH/s = 1e6 ratio)\n        double network_share = hash_rate_th / (network_hash_rate_eh * 1000000.0);\n        \n        // Daily BTC before pool fees\n        double gross_btc = network_share * blocks_per_day * block_reward;\n        \n        // After pool fees\n        return gross_btc * (1.0 - pool_fee_percent / 100.0);\n    }\n\n    /** Calculate daily electricity cost in USD */\n    double dailyElectricityCost() const {\n        double kwh_per_day = (power_watts / 1000.0) * 24.0;\n        return kwh_per_day * electricity_rate;\n    }\n\n    /** Calculate daily profit in USD */\n    double dailyProfit() const {\n        double revenue = dailyBtcRevenue() * btc_price;\n        double cost = dailyElectricityCost();\n        return revenue - cost;\n    }\n\n    /** Calculate break-even electricity rate in $/kWh */\n    double breakEvenElectricityRate() const {\n        double daily_revenue = dailyBtcRevenue() * btc_price;\n        double kwh_per_day = (power_watts / 1000.0) * 24.0;\n        return daily_revenue / kwh_per_day;\n    }\n};\n\nint main() {\n    // Example: Antminer S19 XP\n    MiningCalculator calc(\n        140.0,    // 140 TH/s\n        3010.0,   // 3010W\n        0.05,     // $0.05/kWh\n        2.0,      // 2% pool fee\n        60000.0,  // $60,000 per BTC\n        700.0     // 700 EH/s\n    );\n\n    std::cout << std::fixed << std::setprecision(8);\n    std::cout << \"Daily BTC: \" << calc.dailyBtcRevenue() << \" BTC\" << std::endl;\n    \n    std::cout << std::setprecision(2);\n    std::cout << \"Daily Revenue: $\" << calc.dailyBtcRevenue() * 60000.0 << std::endl;\n    std::cout << \"Daily Electricity: $\" << calc.dailyElectricityCost() << std::endl;\n    std::cout << \"Daily Profit: $\" << calc.dailyProfit() << std::endl;\n    \n    std::cout << std::setprecision(4);\n    std::cout << \"Break-even rate: $\" << calc.breakEvenElectricityRate() << \"/kWh\" << std::endl;\n\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\n// MiningCalculator calculates mining profitability based on hardware specs and costs.\ntype MiningCalculator struct {\n\tHashRateTh        float64 // Hashrate in TH/s\n\tPowerWatts        float64 // Power consumption in watts\n\tElectricityRate   float64 // $/kWh\n\tPoolFeePercent    float64 // Pool fee percentage\n\tBTCPrice          float64 // Current BTC price in USD\n\tNetworkHashRateEh float64 // Network hashrate in EH/s\n\tBlockReward       float64 // Block reward in BTC\n}\n\nfunc NewMiningCalculator(hashRateTh, powerWatts, electricityRate, poolFeePercent, btcPrice, networkHashRateEh, blockReward float64) *MiningCalculator {\n\treturn &MiningCalculator{\n\t\tHashRateTh:        hashRateTh,\n\t\tPowerWatts:        powerWatts,\n\t\tElectricityRate:   electricityRate,\n\t\tPoolFeePercent:    poolFeePercent,\n\t\tBTCPrice:          btcPrice,\n\t\tNetworkHashRateEh: networkHashRateEh,\n\t\tBlockReward:       blockReward,\n\t}\n}\n\n// DailyBtcRevenue calculates daily revenue in BTC\nfunc (m *MiningCalculator) DailyBtcRevenue() float64 {\n\tblocksPerDay := 144.0\n\t\n\t// Your share of the network (TH/s vs EH/s = 1e6 ratio)\n\tnetworkShare := m.HashRateTh / (m.NetworkHashRateEh * 1_000_000.0)\n\t\n\t// Daily BTC before pool fees\n\tgrossBtc := networkShare * blocksPerDay * m.BlockReward\n\t\n\t// After pool fees\n\treturn grossBtc * (1.0 - m.PoolFeePercent/100.0)\n}\n\n// DailyElectricityCost calculates daily electricity cost in USD\nfunc (m *MiningCalculator) DailyElectricityCost() float64 {\n\tkwhPerDay := (m.PowerWatts / 1000.0) * 24.0\n\treturn kwhPerDay * m.ElectricityRate\n}\n\n// DailyProfit calculates daily profit in USD\nfunc (m *MiningCalculator) DailyProfit() float64 {\n\trevenue := m.DailyBtcRevenue() * m.BTCPrice\n\tcost := m.DailyElectricityCost()\n\treturn revenue - cost\n}\n\n// BreakEvenElectricityRate calculates break-even electricity rate in $/kWh\nfunc (m *MiningCalculator) BreakEvenElectricityRate() float64 {\n\tdailyRevenue := m.DailyBtcRevenue() * m.BTCPrice\n\tkwhPerDay := (m.PowerWatts / 1000.0) * 24.0\n\treturn dailyRevenue / kwhPerDay\n}\n\nfunc main() {\n\t// Example: Antminer S19 XP\n\tcalc := NewMiningCalculator(\n\t\t140.0,    // 140 TH/s\n\t\t3010.0,   // 3010W\n\t\t0.05,     // $0.05/kWh\n\t\t2.0,      // 2% pool fee\n\t\t60_000.0, // $60,000 per BTC\n\t\t700.0,    // 700 EH/s\n\t\t3.125,    // 3.125 BTC block reward\n\t)\n\t\n\tfmt.Printf(\"Daily BTC: %.8f BTC\\n\", calc.DailyBtcRevenue())\n\tfmt.Printf(\"Daily Revenue: $%.2f\\n\", calc.DailyBtcRevenue()*calc.BTCPrice)\n\tfmt.Printf(\"Daily Electricity: $%.2f\\n\", calc.DailyElectricityCost())\n\tfmt.Printf(\"Daily Profit: $%.2f\\n\", calc.DailyProfit())\n\tfmt.Printf(\"Break-even rate: $%.4f/kWh\\n\", calc.BreakEvenElectricityRate())\n}\n```\n\n```javascript\n/**\n * Mining profitability calculator.\n * Calculates daily profit based on hardware specs and costs.\n */\nclass MiningCalculator {\n    /**\n     * @param {number} hashRateTh - Hashrate in TH/s\n     * @param {number} powerWatts - Power consumption in watts\n     * @param {number} electricityRate - $/kWh\n     * @param {number} poolFeePercent - Pool fee percentage\n     * @param {number} btcPrice - Current BTC price in USD\n     * @param {number} networkHashRateEh - Network hashrate in EH/s\n     * @param {number} blockReward - Block reward in BTC (default 3.125)\n     */\n    constructor(hashRateTh, powerWatts, electricityRate, poolFeePercent,\n                btcPrice, networkHashRateEh, blockReward = 3.125) {\n        this.hashRateTh = hashRateTh;\n        this.powerWatts = powerWatts;\n        this.electricityRate = electricityRate;\n        this.poolFeePercent = poolFeePercent;\n        this.btcPrice = btcPrice;\n        this.networkHashRateEh = networkHashRateEh;\n        this.blockReward = blockReward;\n    }\n\n    /** Calculate daily revenue in BTC */\n    dailyBtcRevenue() {\n        const blocksPerDay = 144;\n        \n        // Your share of the network (TH/s vs EH/s = 1e6 ratio)\n        const networkShare = this.hashRateTh / (this.networkHashRateEh * 1_000_000);\n        \n        // Daily BTC before pool fees\n        const grossBtc = networkShare * blocksPerDay * this.blockReward;\n        \n        // After pool fees\n        return grossBtc * (1 - this.poolFeePercent / 100);\n    }\n\n    /** Calculate daily electricity cost in USD */\n    dailyElectricityCost() {\n        const kwhPerDay = (this.powerWatts / 1000) * 24;\n        return kwhPerDay * this.electricityRate;\n    }\n\n    /** Calculate daily profit in USD */\n    dailyProfit() {\n        const revenue = this.dailyBtcRevenue() * this.btcPrice;\n        const cost = this.dailyElectricityCost();\n        return revenue - cost;\n    }\n\n    /** Calculate break-even electricity rate in $/kWh */\n    breakEvenElectricityRate() {\n        const dailyRevenue = this.dailyBtcRevenue() * this.btcPrice;\n        const kwhPerDay = (this.powerWatts / 1000) * 24;\n        return dailyRevenue / kwhPerDay;\n    }\n}\n\n// Example: Antminer S19 XP\nconst calc = new MiningCalculator(\n    140.0,    // 140 TH/s\n    3010.0,   // 3010W\n    0.05,     // $0.05/kWh\n    2.0,      // 2% pool fee\n    60_000.0, // $60,000 per BTC\n    700.0     // 700 EH/s\n);\n\nconsole.log(`Daily BTC: ${calc.dailyBtcRevenue().toFixed(8)} BTC`);\nconsole.log(`Daily Revenue: $${(calc.dailyBtcRevenue() * calc.btcPrice).toFixed(2)}`);\nconsole.log(`Daily Electricity: $${calc.dailyElectricityCost().toFixed(2)}`);\nconsole.log(`Daily Profit: $${calc.dailyProfit().toFixed(2)}`);\nconsole.log(`Break-even rate: $${calc.breakEvenElectricityRate().toFixed(4)}/kWh`);\n```\n:::\n\n---\n\n## Mining Profitability Factors\n\n### Network [Hash Rate](/docs/glossary#hash-rate)\n- **Current**: ~700 EH/s (exahashes per second)\n- **Trend**: Generally increasing over time\n- **Impact**: Higher network hash rate means smaller share of rewards\n\n### [Difficulty](/docs/glossary#difficulty) Adjustment\n- **Frequency**: Every 2016 blocks (~2 weeks)\n- **Purpose**: Maintains ~10 minute [block times](/docs/glossary#block-time)\n- **Effect**: Adjusts to network hash rate changes\n- **See Also**: [Difficulty Adjustment](/docs/mining/difficulty) for detailed explanation\n\n### Block Rewards\n- **Halving Schedule**: Every 210,000 blocks (~4 years)\n- **Current**: 3.125 BTC per block\n- **Future**: Will decrease to 0 by ~2140\n\n### Transaction Fees\n- **Variable**: Depends on network congestion\n- **Current Average**: 0.1-1+ BTC per block\n- **Future**: Will become primary miner income as subsidies decrease\n\n---\n\n## Pool Mining Economics\n\n### How [Pool Mining](/docs/glossary#mining-pool) Works\n1. Miners contribute [hash power](/docs/glossary#hash-rate) to pool\n2. Pool finds blocks collectively\n3. Rewards distributed based on contribution\n4. More consistent payouts than solo mining\n\n### Pool Fees\n- **Typical Fee**: 1-2% of rewards\n- **Payout Threshold**: Minimum amount before payout\n- **Payment Frequency**: Daily or weekly\n\n### Payout Schemes\n\n| Scheme | Description | Risk |\n|--------|-------------|------|\n| **PPS** | Pay Per Share - fixed payment per valid share | Pool bears variance |\n| **FPPS** | Full PPS - includes estimated transaction fees | Pool bears variance |\n| **PPLNS** | Pay Per Last N Shares - proportional when blocks found | Miner bears variance |\n| **PROP** | Proportional - divide rewards by shares since last block | Miner bears variance |\n\nSee [Mining Pools](/docs/mining/pools) for detailed information on pool operations.\n\n---\n\n## Individual vs Pool Mining\n\n### Solo Mining\n- **Probability**: Extremely low for individual miners\n- **Time to Block**: Could take years or never happen\n- **Reward**: Full block reward when successful\n- **Best For**: Very large operations only\n\n### Pool Mining\n- **Consistent Payouts**: Small but regular rewards\n- **Reduced Variance**: Share rewards with other miners\n- **Lower Barrier**: Don't need massive hash rate\n- **Best For**: Most miners\n\n---\n\n## Related Topics\n\n- [Bitcoin Mining](/docs/mining) - Mining architecture and concepts\n- [Proof-of-Work Mechanism](/docs/mining/proof-of-work) - How mining works\n- [Difficulty Adjustment](/docs/mining/difficulty) - How difficulty affects profitability\n- [Mining Pools](/docs/mining/pools) - Pool operations and payout schemes\n- [Hardware Evolution](/docs/mining/hardware) - Mining hardware efficiency\n",
    "filename": "economics.md"
  },
  "/docs/mining/pools": {
    "content": "# Mining Pools\n\nA mining pool is a collective of miners who combine their computational resources to increase their chances of finding blocks. When the pool finds a block, the reward is distributed among participants based on their contributed work.\n\nSolo mining is like playing the lottery: you might wait years for a payout. Pool mining provides regular, predictable income at the cost of sharing rewards.\n\n## Why Mining Pools Exist\n\n### The Variance Problem\n\nConsider a solo miner with 0.001% of total network hashrate:\n\n- **Expected time to find a block**: ~1,000,000 blocks Ã· 0.00001 = 100,000,000 minutes â‰ˆ **190 years**\n- **Block reward**: 3.125 BTC (when you finally find one)\n- **Reality**: You might find one tomorrow, or never\n\nThis variance is unacceptable for anyone running mining as a business.\n\n### Pool Solution\n\nBy combining hashpower:\n\n- **Regular payouts**: Daily or even hourly\n- **Predictable income**: Based on contributed work\n- **Reduced variance**: Pool finds blocks frequently\n- **Small miner viability**: Even small operations can profit\n\n---\n\n## How Mining Pools Work\n\n### Basic Flow\n\n```\n1. Miner connects to pool\n2. Pool sends work (block template)\n3. Miner searches for valid shares\n4. Miner submits shares to pool\n5. Pool validates shares and credits miner\n6. When pool finds a block, distribute rewards\n```\n\n### Shares vs Blocks\n\n**Shares** are proof that a miner is working:\n\n- A share is a hash that meets a lower [difficulty](/docs/glossary#difficulty) than the network target\n- Easy to find (every few seconds)\n- Proves miner is honestly hashing\n- Pool uses shares to measure contribution\n\n**Blocks** are what actually pays:\n\n- A hash that meets the full network difficulty\n- Rare (pool might find one every few hours)\n- Contains the actual bitcoin reward\n\n```\nNetwork difficulty: 00000000000000000004b3f...\nPool share difficulty: 00000000004b3f...\n                       â†‘ Much easier target\n```\n\n### Share Difficulty and Validation\n\nPools set a share difficulty that's much lower than the network difficulty. Here's how share validation works:\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\n/// Share difficulty and validation for mining pools.\n\n/// Converts a difficulty value to a 256-bit target.\n/// Target = MAX_TARGET / difficulty\nfn difficulty_to_target(difficulty: f64) -> [u8; 32] {\n    // Bitcoin's max target (difficulty 1)\n    // 0x00000000FFFF0000000000000000000000000000000000000000000000000000\n    let max_target: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n    \n    // For simplicity, we'll use a scaled approach\n    // Real implementation would use big integer division\n    let scale = (1.0 / difficulty * 65535.0) as u16;\n    let mut target = [0u8; 32];\n    target[4] = (scale >> 8) as u8;\n    target[5] = scale as u8;\n    target\n}\n\n/// Validates if a hash meets the share difficulty.\nfn validate_share(hash: &[u8; 32], share_difficulty: f64) -> bool {\n    let target = difficulty_to_target(share_difficulty);\n    \n    // Compare hash to target (hash must be less than target)\n    for i in 0..32 {\n        if hash[i] < target[i] {\n            return true;\n        } else if hash[i] > target[i] {\n            return false;\n        }\n    }\n    true\n}\n\n/// Calculates the expected shares per block for a given share difficulty.\nfn expected_shares_per_block(share_difficulty: f64, network_difficulty: f64) -> f64 {\n    network_difficulty / share_difficulty\n}\n\n/// Calculates miner payout based on shares submitted.\nstruct PoolPayout {\n    block_reward: f64,      // BTC\n    pool_fee_percent: f64,  // e.g., 2.0 for 2%\n}\n\nimpl PoolPayout {\n    /// Calculate proportional payout for a miner.\n    fn calculate_payout(&self, miner_shares: u64, total_shares: u64) -> f64 {\n        let net_reward = self.block_reward * (1.0 - self.pool_fee_percent / 100.0);\n        let share_ratio = miner_shares as f64 / total_shares as f64;\n        net_reward * share_ratio\n    }\n    \n    /// Calculate PPS (Pay Per Share) value.\n    fn pps_value(&self, share_difficulty: f64, network_difficulty: f64) -> f64 {\n        let net_reward = self.block_reward * (1.0 - self.pool_fee_percent / 100.0);\n        let expected_shares = expected_shares_per_block(share_difficulty, network_difficulty);\n        net_reward / expected_shares\n    }\n}\n\nfn main() {\n    let share_difficulty = 65536.0;  // Pool share difficulty\n    let network_difficulty = 70_000_000_000_000.0;  // ~70 trillion\n    \n    println!(\"Share difficulty: {}\", share_difficulty);\n    println!(\"Network difficulty: {:.0}\", network_difficulty);\n    println!(\"Expected shares per block: {:.0}\", \n             expected_shares_per_block(share_difficulty, network_difficulty));\n    \n    let payout = PoolPayout {\n        block_reward: 3.125,\n        pool_fee_percent: 2.0,\n    };\n    \n    // Example: miner contributed 50,000 out of 1,000,000 shares\n    let miner_payout = payout.calculate_payout(50_000, 1_000_000);\n    println!(\"\\nMiner payout (50k/1M shares): {:.8} BTC\", miner_payout);\n    \n    let pps_per_share = payout.pps_value(share_difficulty, network_difficulty);\n    println!(\"PPS value per share: {:.12} BTC\", pps_per_share);\n}\n```\n\n```python\nimport hashlib\nimport struct\n\ndef difficulty_to_target(difficulty: float) -> bytes:\n    \"\"\"\n    Converts a difficulty value to a 256-bit target.\n    Target = MAX_TARGET / difficulty\n    \n    Args:\n        difficulty: The difficulty value\n    \n    Returns:\n        32-byte target\n    \"\"\"\n    # Bitcoin's max target (difficulty 1)\n    max_target = 0x00000000FFFF0000000000000000000000000000000000000000000000000000\n    \n    target_int = int(max_target / difficulty)\n    return target_int.to_bytes(32, 'big')\n\ndef validate_share(hash_bytes: bytes, share_difficulty: float) -> bool:\n    \"\"\"\n    Validates if a hash meets the share difficulty.\n    \n    Args:\n        hash_bytes: 32-byte hash result\n        share_difficulty: Pool share difficulty\n    \n    Returns:\n        True if hash meets the share target\n    \"\"\"\n    target = difficulty_to_target(share_difficulty)\n    \n    # Hash must be less than target\n    return hash_bytes < target\n\ndef expected_shares_per_block(share_difficulty: float, network_difficulty: float) -> float:\n    \"\"\"\n    Calculates the expected shares per block for a given share difficulty.\n    \n    Args:\n        share_difficulty: Pool share difficulty\n        network_difficulty: Network difficulty\n    \n    Returns:\n        Expected number of shares to find one block\n    \"\"\"\n    return network_difficulty / share_difficulty\n\nclass PoolPayout:\n    \"\"\"Calculates pool payouts for different schemes.\"\"\"\n    \n    def __init__(self, block_reward: float, pool_fee_percent: float):\n        \"\"\"\n        Args:\n            block_reward: Block reward in BTC\n            pool_fee_percent: Pool fee percentage (e.g., 2.0 for 2%)\n        \"\"\"\n        self.block_reward = block_reward\n        self.pool_fee_percent = pool_fee_percent\n    \n    def proportional_payout(self, miner_shares: int, total_shares: int) -> float:\n        \"\"\"\n        Calculate proportional payout for a miner.\n        \n        Args:\n            miner_shares: Shares submitted by miner\n            total_shares: Total shares in the round\n        \n        Returns:\n            Payout in BTC\n        \"\"\"\n        net_reward = self.block_reward * (1 - self.pool_fee_percent / 100)\n        share_ratio = miner_shares / total_shares\n        return net_reward * share_ratio\n    \n    def pps_value(self, share_difficulty: float, network_difficulty: float) -> float:\n        \"\"\"\n        Calculate PPS (Pay Per Share) value per share.\n        \n        Args:\n            share_difficulty: Pool share difficulty\n            network_difficulty: Network difficulty\n        \n        Returns:\n            BTC value per share\n        \"\"\"\n        net_reward = self.block_reward * (1 - self.pool_fee_percent / 100)\n        expected_shares = expected_shares_per_block(share_difficulty, network_difficulty)\n        return net_reward / expected_shares\n    \n    def pplns_payout(self, miner_shares: int, window_shares: list[tuple[str, int]], \n                     n: int) -> float:\n        \"\"\"\n        Calculate PPLNS payout (Pay Per Last N Shares).\n        \n        Args:\n            miner_shares: Miner's shares in the window\n            window_shares: List of (miner_id, shares) in the window\n            n: Window size (last N shares)\n        \n        Returns:\n            Payout in BTC\n        \"\"\"\n        total_in_window = sum(shares for _, shares in window_shares)\n        net_reward = self.block_reward * (1 - self.pool_fee_percent / 100)\n        return net_reward * (miner_shares / total_in_window)\n\n# Example usage\nshare_difficulty = 65536\nnetwork_difficulty = 70_000_000_000_000  # ~70 trillion\n\nprint(f\"Share difficulty: {share_difficulty}\")\nprint(f\"Network difficulty: {network_difficulty:,.0f}\")\nprint(f\"Expected shares per block: {expected_shares_per_block(share_difficulty, network_difficulty):,.0f}\")\n\npayout = PoolPayout(block_reward=3.125, pool_fee_percent=2.0)\n\n# Example: miner contributed 50,000 out of 1,000,000 shares\nminer_payout = payout.proportional_payout(50_000, 1_000_000)\nprint(f\"\\nMiner payout (50k/1M shares): {miner_payout:.8f} BTC\")\n\npps_per_share = payout.pps_value(share_difficulty, network_difficulty)\nprint(f\"PPS value per share: {pps_per_share:.12f} BTC\")\n```\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <vector>\n#include <string>\n\n/**\n * Calculates the expected shares per block for a given share difficulty.\n */\ndouble expectedSharesPerBlock(double shareDifficulty, double networkDifficulty) {\n    return networkDifficulty / shareDifficulty;\n}\n\n/**\n * Pool payout calculator for different schemes.\n */\nclass PoolPayout {\nprivate:\n    double blockReward;\n    double poolFeePercent;\n\npublic:\n    PoolPayout(double blockReward, double poolFeePercent)\n        : blockReward(blockReward), poolFeePercent(poolFeePercent) {}\n\n    /** Net reward after pool fee */\n    double netReward() const {\n        return blockReward * (1.0 - poolFeePercent / 100.0);\n    }\n\n    /** Calculate proportional payout for a miner */\n    double proportionalPayout(uint64_t minerShares, uint64_t totalShares) const {\n        double shareRatio = static_cast<double>(minerShares) / totalShares;\n        return netReward() * shareRatio;\n    }\n\n    /** Calculate PPS (Pay Per Share) value per share */\n    double ppsValue(double shareDifficulty, double networkDifficulty) const {\n        double expectedShares = expectedSharesPerBlock(shareDifficulty, networkDifficulty);\n        return netReward() / expectedShares;\n    }\n\n    /** Calculate FPPS (Full Pay Per Share) including transaction fees */\n    double fppsValue(double shareDifficulty, double networkDifficulty, \n                     double avgTxFees) const {\n        double totalReward = blockReward + avgTxFees;\n        double netTotal = totalReward * (1.0 - poolFeePercent / 100.0);\n        double expectedShares = expectedSharesPerBlock(shareDifficulty, networkDifficulty);\n        return netTotal / expectedShares;\n    }\n};\n\n/**\n * Validates if a hash meets the share difficulty target.\n * Compares hash bytes to calculated target.\n */\nbool validateShare(const unsigned char* hash, double shareDifficulty) {\n    // Simplified: check leading zero bytes\n    // Real implementation would compare full 256-bit values\n    int requiredZeroBytes = static_cast<int>(std::log2(shareDifficulty) / 8);\n    \n    for (int i = 0; i < requiredZeroBytes && i < 32; ++i) {\n        if (hash[i] != 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    double shareDifficulty = 65536.0;\n    double networkDifficulty = 70000000000000.0;  // ~70 trillion\n    \n    std::cout << \"Share difficulty: \" << shareDifficulty << std::endl;\n    std::cout << \"Network difficulty: \" << std::fixed << std::setprecision(0) \n              << networkDifficulty << std::endl;\n    std::cout << \"Expected shares per block: \" \n              << expectedSharesPerBlock(shareDifficulty, networkDifficulty) << std::endl;\n    \n    PoolPayout payout(3.125, 2.0);  // 3.125 BTC reward, 2% fee\n    \n    // Example: miner contributed 50,000 out of 1,000,000 shares\n    double minerPayout = payout.proportionalPayout(50000, 1000000);\n    std::cout << std::setprecision(8);\n    std::cout << \"\\nMiner payout (50k/1M shares): \" << minerPayout << \" BTC\" << std::endl;\n    \n    double ppsPerShare = payout.ppsValue(shareDifficulty, networkDifficulty);\n    std::cout << std::setprecision(12);\n    std::cout << \"PPS value per share: \" << ppsPerShare << \" BTC\" << std::endl;\n    \n    // FPPS with average 0.25 BTC transaction fees\n    double fppsPerShare = payout.fppsValue(shareDifficulty, networkDifficulty, 0.25);\n    std::cout << \"FPPS value per share: \" << fppsPerShare << \" BTC\" << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// DifficultyToTarget converts a difficulty value to a 256-bit target\nfunc DifficultyToTarget(difficulty float64) float64 {\n\t// Simplified: return difficulty as target ratio\n\t// Real implementation would use big.Int for 256-bit precision\n\treturn 1.0 / difficulty\n}\n\n// ValidateShare validates if a hash meets the share difficulty\nfunc ValidateShare(hash []byte, shareDifficulty float64) bool {\n\t// Simplified validation - real implementation would compare full 256-bit values\n\t// Check leading zero bytes based on difficulty\n\trequiredZeroBytes := int(math.Log2(shareDifficulty) / 8.0)\n\tfor i := 0; i < requiredZeroBytes && i < len(hash); i++ {\n\t\tif hash[i] != 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// ExpectedSharesPerBlock calculates the expected shares per block for a given share difficulty\nfunc ExpectedSharesPerBlock(shareDifficulty float64, networkDifficulty float64) float64 {\n\treturn networkDifficulty / shareDifficulty\n}\n\n// PoolPayout represents a pool payout calculator for different schemes\ntype PoolPayout struct {\n\tBlockReward     float64\n\tPoolFeePercent  float64\n}\n\nfunc NewPoolPayout(blockReward float64, poolFeePercent float64) *PoolPayout {\n\treturn &PoolPayout{\n\t\tBlockReward:    blockReward,\n\t\tPoolFeePercent: poolFeePercent,\n\t}\n}\n\n// NetReward returns net reward after pool fee\nfunc (p *PoolPayout) NetReward() float64 {\n\treturn p.BlockReward * (1.0 - p.PoolFeePercent/100.0)\n}\n\n// ProportionalPayout calculates proportional payout for a miner\nfunc (p *PoolPayout) ProportionalPayout(minerShares uint64, totalShares uint64) float64 {\n\tshareRatio := float64(minerShares) / float64(totalShares)\n\treturn p.NetReward() * shareRatio\n}\n\n// PPSValue calculates PPS (Pay Per Share) value per share\nfunc (p *PoolPayout) PPSValue(shareDifficulty float64, networkDifficulty float64) float64 {\n\texpected := ExpectedSharesPerBlock(shareDifficulty, networkDifficulty)\n\treturn p.NetReward() / expected\n}\n\n// FPPSValue calculates FPPS including transaction fees\nfunc (p *PoolPayout) FPPSValue(shareDifficulty float64, networkDifficulty float64, avgTxFees float64) float64 {\n\ttotalReward := p.BlockReward + avgTxFees\n\tnetTotal := totalReward * (1.0 - p.PoolFeePercent/100.0)\n\texpected := ExpectedSharesPerBlock(shareDifficulty, networkDifficulty)\n\treturn netTotal / expected\n}\n\n// PPLNSPayout calculates PPLNS payout\nfunc (p *PoolPayout) PPLNSPayout(minerShares uint64, windowTotal uint64) float64 {\n\treturn p.NetReward() * (float64(minerShares) / float64(windowTotal))\n}\n\nfunc main() {\n\tshareDifficulty := 65536.0\n\tnetworkDifficulty := 70_000_000_000_000.0 // ~70 trillion\n\n\tfmt.Printf(\"Share difficulty: %.0f\\n\", shareDifficulty)\n\tfmt.Printf(\"Network difficulty: %.0f\\n\", networkDifficulty)\n\tfmt.Printf(\"Expected shares per block: %.0f\\n\", ExpectedSharesPerBlock(shareDifficulty, networkDifficulty))\n\n\tpayout := NewPoolPayout(3.125, 2.0) // 3.125 BTC reward, 2% fee\n\n\t// Example: miner contributed 50,000 out of 1,000,000 shares\n\tminerPayout := payout.ProportionalPayout(50_000, 1_000_000)\n\tfmt.Printf(\"\\nMiner payout (50k/1M shares): %.8f BTC\\n\", minerPayout)\n\n\tppsPerShare := payout.PPSValue(shareDifficulty, networkDifficulty)\n\tfmt.Printf(\"PPS value per share: %.12f BTC\\n\", ppsPerShare)\n\n\t// FPPS with average 0.25 BTC transaction fees\n\tfppsPerShare := payout.FPPSValue(shareDifficulty, networkDifficulty, 0.25)\n\tfmt.Printf(\"FPPS value per share: %.12f BTC\\n\", fppsPerShare)\n}\n```\n\n```javascript\n/**\n * Converts a difficulty value to a 256-bit target.\n * @param {number} difficulty - The difficulty value\n * @returns {BigInt} - Target as BigInt\n */\nfunction difficultyToTarget(difficulty) {\n    // Bitcoin's max target (difficulty 1)\n    const maxTarget = BigInt('0x00000000FFFF0000000000000000000000000000000000000000000000000000');\n    return maxTarget / BigInt(Math.floor(difficulty));\n}\n\n/**\n * Validates if a hash meets the share difficulty.\n * @param {Buffer} hashBytes - 32-byte hash result\n * @param {number} shareDifficulty - Pool share difficulty\n * @returns {boolean} - True if hash meets the share target\n */\nfunction validateShare(hashBytes, shareDifficulty) {\n    const hashInt = BigInt('0x' + hashBytes.toString('hex'));\n    const target = difficultyToTarget(shareDifficulty);\n    return hashInt < target;\n}\n\n/**\n * Calculates the expected shares per block for a given share difficulty.\n * @param {number} shareDifficulty - Pool share difficulty\n * @param {number} networkDifficulty - Network difficulty\n * @returns {number} - Expected shares per block\n */\nfunction expectedSharesPerBlock(shareDifficulty, networkDifficulty) {\n    return networkDifficulty / shareDifficulty;\n}\n\n/**\n * Pool payout calculator for different schemes.\n */\nclass PoolPayout {\n    /**\n     * @param {number} blockReward - Block reward in BTC\n     * @param {number} poolFeePercent - Pool fee percentage\n     */\n    constructor(blockReward, poolFeePercent) {\n        this.blockReward = blockReward;\n        this.poolFeePercent = poolFeePercent;\n    }\n\n    /** Net reward after pool fee */\n    netReward() {\n        return this.blockReward * (1 - this.poolFeePercent / 100);\n    }\n\n    /**\n     * Calculate proportional payout for a miner.\n     * @param {number} minerShares - Shares submitted by miner\n     * @param {number} totalShares - Total shares in the round\n     * @returns {number} - Payout in BTC\n     */\n    proportionalPayout(minerShares, totalShares) {\n        const shareRatio = minerShares / totalShares;\n        return this.netReward() * shareRatio;\n    }\n\n    /**\n     * Calculate PPS (Pay Per Share) value per share.\n     * @param {number} shareDifficulty - Pool share difficulty\n     * @param {number} networkDifficulty - Network difficulty\n     * @returns {number} - BTC value per share\n     */\n    ppsValue(shareDifficulty, networkDifficulty) {\n        const expected = expectedSharesPerBlock(shareDifficulty, networkDifficulty);\n        return this.netReward() / expected;\n    }\n\n    /**\n     * Calculate FPPS including transaction fees.\n     * @param {number} shareDifficulty - Pool share difficulty\n     * @param {number} networkDifficulty - Network difficulty\n     * @param {number} avgTxFees - Average transaction fees per block\n     * @returns {number} - BTC value per share\n     */\n    fppsValue(shareDifficulty, networkDifficulty, avgTxFees) {\n        const totalReward = this.blockReward + avgTxFees;\n        const netTotal = totalReward * (1 - this.poolFeePercent / 100);\n        const expected = expectedSharesPerBlock(shareDifficulty, networkDifficulty);\n        return netTotal / expected;\n    }\n\n    /**\n     * Calculate PPLNS payout.\n     * @param {number} minerShares - Miner's shares in window\n     * @param {number} windowTotal - Total shares in window\n     * @returns {number} - Payout in BTC\n     */\n    pplnsPayout(minerShares, windowTotal) {\n        return this.netReward() * (minerShares / windowTotal);\n    }\n}\n\n// Example usage\nconst shareDifficulty = 65536;\nconst networkDifficulty = 70_000_000_000_000;  // ~70 trillion\n\nconsole.log(`Share difficulty: ${shareDifficulty}`);\nconsole.log(`Network difficulty: ${networkDifficulty.toLocaleString()}`);\nconsole.log(`Expected shares per block: ${expectedSharesPerBlock(shareDifficulty, networkDifficulty).toLocaleString()}`);\n\nconst payout = new PoolPayout(3.125, 2.0);  // 3.125 BTC reward, 2% fee\n\n// Example: miner contributed 50,000 out of 1,000,000 shares\nconst minerPayout = payout.proportionalPayout(50_000, 1_000_000);\nconsole.log(`\\nMiner payout (50k/1M shares): ${minerPayout.toFixed(8)} BTC`);\n\nconst ppsPerShare = payout.ppsValue(shareDifficulty, networkDifficulty);\nconsole.log(`PPS value per share: ${ppsPerShare.toFixed(12)} BTC`);\n\n// FPPS with average 0.25 BTC transaction fees\nconst fppsPerShare = payout.fppsValue(shareDifficulty, networkDifficulty, 0.25);\nconsole.log(`FPPS value per share: ${fppsPerShare.toFixed(12)} BTC`);\n```\n:::\n\n### Contribution Tracking\n\nPools track each miner's work:\n\n```\nMiner A: 1,000,000 shares (10 TH/s)\nMiner B: 500,000 shares (5 TH/s)\nMiner C: 100,000 shares (1 TH/s)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal:   1,600,000 shares\n\nBlock found! Reward: 3.125 BTC\n\nMiner A: 3.125 Ã— (1,000,000 / 1,600,000) = 1.953 BTC\nMiner B: 3.125 Ã— (500,000 / 1,600,000) = 0.977 BTC\nMiner C: 3.125 Ã— (100,000 / 1,600,000) = 0.195 BTC\n```\n\n---\n\n## Payout Schemes\n\nDifferent pools use different methods to distribute rewards.\n\n### Pay Per Share (PPS)\n\n- **How it works**: Pool pays fixed amount per share, regardless of whether blocks are found\n- **Miner risk**: None; guaranteed payment for work\n- **Pool risk**: High; pool absorbs variance\n- **Fees**: Higher (2-4%) to compensate pool risk\n\n```\nShare submitted â†’ Immediate credit\nNo waiting for blocks\nPool takes the gamble\n```\n\n### Full Pay Per Share (FPPS)\n\n- **Like PPS, but**: Also includes estimated [transaction fees](/docs/glossary#transaction-fee)\n- **Benefit**: Miners get share of fees, not just block reward\n- **Popular because**: Transaction fees are increasingly important\n\n### Pay Per Last N Shares (PPLNS)\n\n- **How it works**: When block found, reward distributed based on last N shares\n- **Miner risk**: Medium; payment depends on luck and timing\n- **Pool risk**: Lower; only pays when blocks found\n- **Fees**: Lower (1-2%)\n- **Loyalty rewarded**: Miners who stay connected get better returns\n\n```\nBlock found!\nLook at last 1,000,000 shares\nYour 50,000 shares = 5% of reward\n```\n\n### PROP (Proportional)\n\n- **How it works**: Reward split proportionally among all shares since last block\n- **Problem**: Vulnerable to pool hopping\n- **Rarely used**: PPLNS is preferred\n\n### Score-Based\n\n- **How it works**: Recent shares weighted more heavily\n- **Benefit**: Discourages pool hopping\n- **Complexity**: Harder to understand and verify\n\n---\n\n## Pool Protocols\n\n### [Stratum](/docs/glossary#stratum) (v1)\n\nThe dominant mining protocol since 2012:\n\n```\nPool â†’ Miner: Here's the block template\nMiner â†’ Pool: Here's a valid share\nPool â†’ Miner: Share accepted, new work\n```\n\n**Characteristics**:\n- Simple and widely supported\n- Pool controls [block template](/docs/glossary#block-template) completely\n- Miner just hashes what they're told\n\n**Downsides**:\n- Miners can't choose transactions\n- Pool has complete control over block content\n- Potential for censorship\n\n### Stratum V2\n\nModern replacement addressing Stratum v1's issues:\n\n**Key improvements**:\n- **Job negotiation**: Miners can propose their own block templates\n- **Encryption**: Communication is encrypted and authenticated\n- **Efficiency**: Binary protocol (not JSON), less bandwidth\n- **[Decentralization](/docs/fundamentals/decentralization)**: Miners regain some sovereignty\n\n```\nTraditional (Stratum v1):\nPool â†’ Miner: \"Hash this exact template\"\n\nStratum V2 (with job negotiation):\nMiner â†’ Pool: \"Here's my proposed template\"\nPool â†’ Miner: \"Approved, hash it\"\n```\n\n### BetterHash (Predecessor to Stratum V2)\n\nMatt Corallo's proposal that influenced Stratum V2:\n\n- Miners construct their own blocks\n- Pool only provides coinbase and validates shares\n- Never widely adopted, but ideas live on\n\n---\n\n## Centralization Concerns\n\nMining pools create centralization pressure:\n\n### The Problem\n\n```\nTop pools control majority of hashrate:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Foundry USA     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 31.94%  â”‚\nâ”‚ AntPool         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 14.98%           â”‚\nâ”‚ F2Pool          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 12.90%            â”‚\nâ”‚ ViaBTC          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 10.32%             â”‚\nâ”‚ SpiderPool      â–ˆâ–ˆâ–ˆ 7.14%                â”‚\nâ”‚ MARA Pool       â–ˆâ–ˆ 5.75%                 â”‚\nâ”‚ Others          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 16.97%          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Risks**:\n- Pool operator could censor transactions\n- Pool could attempt [double-spend](/docs/glossary#double-spend) attacks\n- Government could pressure large pools\n- Collusion between pools\n\n### Mitigating Factors\n\n- **Miners can switch pools**: Instant exit if pool misbehaves\n- **Pool reputation matters**: Bad behavior means losing miners\n- **Stratum V2**: Gives miners more control\n- **Geographic distribution**: Pools operate in different jurisdictions\n\n### Decentralized Pools\n\nAttempts to remove pool operators:\n\n**P2Pool** (historical):\n- Miners run pool nodes\n- Separate blockchain tracks shares\n- No central operator\n- Died due to complexity and variance for small miners\n\n**Braidpool** (in development):\n- Modern attempt at decentralized pooling\n- Uses DAG structure for share tracking\n- Still experimental\n\n---\n\n## Choosing a Pool\n\nFactors to consider:\n\n### Payout Method\n- **PPS/FPPS**: Stable income, higher fees\n- **PPLNS**: Variable income, lower fees, rewards loyalty\n\n### Fees\n- Range from 0% to 4%\n- Consider fee vs payout method trade-off\n\n### Minimum Payout\n- Some pools hold funds until threshold\n- Lower threshold = more frequent payouts\n- Higher threshold = lower transaction fee percentage\n\n### Server Locations\n- Closer servers = less latency\n- Less latency = fewer stale shares\n- Stale shares = lost money\n\n### Transparency\n- Can you verify payouts?\n- Is hashrate displayed accurately?\n- What's the pool's track record?\n\n### Stratum V2 Support\n- Gives you more control\n- Better for network decentralization\n- Still being adopted\n\n---\n\n## Pool Economics\n\n### Pool Revenue\n\n```\nBlock reward:           3.125 BTC\nAverage transaction fees: 0.25 BTC\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal per block:        3.375 BTC\n\nPool finds 10 blocks/day:\nDaily revenue: 33.75 BTC\n```\n\n### Pool Costs\n\n- **Infrastructure**: Servers, bandwidth, monitoring\n- **Development**: Software maintenance\n- **Operations**: Staff, support\n- **Variance buffer**: Reserve for unlucky streaks (PPS pools)\n\n### Miner Economics\n\n```\nYour hashrate: 100 TH/s\nNetwork hashrate: 500 EH/s\nYour share: 0.00002%\n\nDaily block rewards: 450 blocks Ã— 3.375 BTC = 1,518.75 BTC\nYour share: 1,518.75 Ã— 0.00002% = 0.000304 BTC/day\n\nAt $60,000/BTC: ~$18/day revenue\nElectricity: ~$12/day (varies widely)\nProfit: ~$6/day\n```\n\n---\n\n## Setting Up Pool Mining\n\n### Requirements\n\n1. **Mining hardware**: [ASICs](/docs/glossary#asic-application-specific-integrated-circuit) for Bitcoin\n2. **Pool account**: Register with chosen pool\n3. **Mining software**: CGMiner, BFGMiner, or manufacturer software\n4. **Wallet**: For receiving payouts\n\n### Basic Configuration\n\n```\nPool URL: stratum+tcp://pool.example.com:3333\nUsername: your_wallet_address.worker_name\nPassword: x (often ignored)\n```\n\n### Multiple Pools (Failover)\n\n```\nPrimary: pool1.example.com:3333\nSecondary: pool2.example.com:3333\nTertiary: pool3.example.com:3333\n```\n\nIf primary fails, automatically switch to secondary.\n\n---\n\n## Summary\n\nMining pools solve the variance problem:\n\n- **Combine resources**: Small miners can participate\n- **Regular payouts**: Predictable income\n- **Shared risk**: Pool absorbs variance (PPS) or shares it (PPLNS)\n\nTrade-offs:\n- **Fees**: Pools take 1-4%\n- **Centralization**: Large pools control significant hashrate\n- **Control**: Traditional pools control block construction\n\nThe future is moving toward:\n- **Stratum V2**: More miner control\n- **Decentralized pools**: No central operator\n- **Transaction selection**: Miners choosing what to include\n\n---\n\n## Related Topics\n\n- [Mining Economics](/docs/mining/economics) - Profitability calculations\n- [Block Construction](/docs/mining/block-construction) - How blocks are built\n- [Proof-of-Work](/docs/mining/proof-of-work) - The mining algorithm\n- [Hardware Evolution](/docs/mining/hardware) - Mining equipment history\n\n---\n\n## Resources\n\n- [Stratum V2](https://stratumprotocol.org/) - Next-generation mining protocol\n- [Braidpool](https://github.com/braidpool/braidpool) - Decentralized pool project\n- [Mining Pool Stats](https://miningpoolstats.stream/bitcoin) - Pool hashrate distribution\n",
    "filename": "pools.md"
  },
  "/docs/mining/hardware": {
    "content": "# Mining Hardware Evolution\n\nBitcoin mining hardware has undergone a remarkable evolution, from hobbyists running CPUs on laptops to industrial-scale operations with purpose-built silicon. This progression represents one of the fastest hardware development cycles in computing history, driven by the economic incentives of [proof-of-work](/docs/glossary#proof-of-work-pow) mining.\n\n## The Four Eras of Mining Hardware\n\n### Era 1: CPU Mining (2009-2010)\n\n**The Beginning**\n\nWhen [Satoshi](/docs/history/people#satoshi-nakamoto) launched Bitcoin, mining was done on ordinary computer CPUs:\n\n- **Hardware**: Intel/AMD desktop processors\n- **Hashrate**: 1-20 MH/s\n- **Power**: 50-150W\n- **Efficiency**: ~0.1 MH/J\n- **Who mined**: Cypherpunks, early adopters, Satoshi\n\n**Why CPUs Work**\n\n[SHA-256](/docs/glossary#sha-256) (Bitcoin's hash function) is computationally simple:\n- Bitwise operations (AND, OR, XOR)\n- 32-bit additions\n- No complex branching\n- Highly parallelizable\n\nCPUs can do this, but they're general-purpose. Most of their transistors do things irrelevant to hashing.\n\n**The End of CPU Mining**\n\nBy late 2010, GPU mining emerged. CPU miners quickly became unprofitable and disappeared.\n\n### Era 2: GPU Mining (2010-2013)\n\n**The GPU Advantage**\n\nGraphics cards excel at parallel computation:\n\n- **Hardware**: AMD Radeon, NVIDIA GeForce\n- **Hashrate**: 10-800 MH/s\n- **Power**: 100-300W\n- **Efficiency**: ~2-4 MH/J\n- **Improvement**: 10-50x over CPUs\n\n**Why GPUs Excel**\n\n```\nCPU: 4-8 cores, each very fast, complex\n     Good at: varied tasks, branching logic\n     \nGPU: 1000+ cores, each slower, simpler\n     Good at: same operation on many data points\n     Perfect for: trying billions of nonces\n```\n\n**The GPU Mining Era**\n\n- AMD cards preferred (better for SHA-256)\n- Mining farms with racks of graphics cards\n- Gaming GPU shortages began\n- Some miners used OpenCL/CUDA optimizations\n\n**Popular GPU Mining Cards**\n\n| Card | Hashrate | Power | Era |\n|------|----------|-------|-----|\n| ATI Radeon 5870 | 400 MH/s | 200W | 2010 |\n| AMD Radeon 7970 | 700 MH/s | 250W | 2012 |\n| AMD R9 290X | 900 MH/s | 300W | 2013 |\n\n### Era 3: FPGA Mining (2011-2013)\n\n**Field Programmable Gate Arrays**\n\nFPGAs are chips that can be reconfigured for specific tasks:\n\n- **Hardware**: Xilinx, Altera FPGAs\n- **Hashrate**: 100-800 MH/s\n- **Power**: 20-80W\n- **Efficiency**: ~10-20 MH/J\n- **Improvement**: 5-10x efficiency over GPUs\n\n**FPGA Advantages**\n\n- Much more power efficient than GPUs\n- Could be reprogrammed if algorithm changed\n- Lower heat generation\n\n**FPGA Disadvantages**\n\n- Expensive development\n- Limited availability\n- Required technical expertise\n- Quickly obsoleted by ASICs\n\n**Short-Lived Era**\n\nFPGAs were a transitional technology. The efficiency gains made ASICs inevitable and economically viable.\n\n### Era 4: ASIC Mining (2013-Present)\n\n**Application-Specific Integrated Circuits**\n\nASICs are chips designed to do one thing only: SHA-256 hashing.\n\n- **Hardware**: Custom silicon from Bitmain, MicroBT, Canaan, etc.\n- **Hashrate**: 1 TH/s â†’ 250+ TH/s (2013 â†’ 2024)\n- **Power**: 500-3500W per unit\n- **Efficiency**: 100 J/TH â†’ 15 J/TH (improving constantly)\n- **Improvement**: 1000x+ over GPUs\n\n**Why ASICs Dominate**\n\n```\nGPU: General-purpose silicon\n     - 30% doing hashing\n     - 70% doing other stuff\n\nASIC: Purpose-built silicon\n     - 100% doing hashing\n     - Nothing wasted\n```\n\nEvery transistor in an ASIC is dedicated to SHA-256. No graphics processing, no floating point, no cache hierarchy, just hashing.\n\n---\n\n## ASIC Evolution\n\n### Generation Timeline\n\n| Era | Example | Hashrate | Efficiency | Year |\n|-----|---------|----------|------------|------|\n| Gen 1 | Avalon 1 | 66 GH/s | 9,000 J/TH | 2013 |\n| Gen 2 | Antminer S1 | 180 GH/s | 2,000 J/TH | 2013 |\n| Gen 3 | Antminer S5 | 1.15 TH/s | 510 J/TH | 2014 |\n| Gen 4 | Antminer S7 | 4.7 TH/s | 250 J/TH | 2015 |\n| Gen 5 | Antminer S9 | 14 TH/s | 100 J/TH | 2016 |\n| Gen 6 | Antminer S17 | 56 TH/s | 45 J/TH | 2019 |\n| Gen 7 | Antminer S19 | 95 TH/s | 34 J/TH | 2020 |\n| Gen 8 | Antminer S19 XP | 140 TH/s | 21 J/TH | 2022 |\n| Gen 9 | Antminer S21 | 200 TH/s | 17.5 J/TH | 2023 |\n| Gen 10 | Antminer S21 XP | 270 TH/s | 13.5 J/TH | 2024 |\n\n### Process Node Shrinks\n\nASIC efficiency improves primarily through semiconductor process improvements:\n\n```\n2013: 110nm, 55nm\n2014: 28nm\n2016: 16nm\n2018: 7nm\n2020: 5nm\n2023: 3nm (emerging)\n```\n\nSmaller transistors = less power per hash = better efficiency.\n\n### Major Manufacturers\n\n**Bitmain (China)**\n- Market leader, Antminer series\n- Founded 2013 by Jihan Wu and Micree Zhan\n- Controversial: BCH support, internal conflicts\n- Products: S9, S17, S19, S21 series\n\n**MicroBT (China)**\n- Strong competitor, Whatsminer series\n- Founded 2016 by former Bitmain engineer\n- Known for reliability\n- Products: M20, M30, M50, M60 series\n\n**Canaan (China)**\n- First ASIC manufacturer (Avalon)\n- Publicly traded (NASDAQ: CAN)\n- Products: Avalon series\n\n**Intel (USA)**\n- Entered market 2022 with Blockscale\n- Focused on efficiency\n- Exited market 2024\n\n**Bitfury (Netherlands/USA)**\n- Vertically integrated (makes and uses chips)\n- Known for immersion cooling\n- Products: Clarke, Bitfury B8\n\n---\n\n## Efficiency Metrics\n\n### Joules per Terahash (J/TH)\n\nThe key efficiency metric:\n\n```\nJ/TH = Watts Ã· (Terahashes per second)\n\nExample: 3000W machine doing 100 TH/s\nEfficiency = 3000 Ã· 100 = 30 J/TH\n```\n\nLower is better. Modern machines: 15-25 J/TH.\n\n### Hashrate per Dollar\n\nConsider total cost of ownership:\n\n```\nMachine cost: $5,000\nHashrate: 100 TH/s\nLifespan: 3 years\n\nCost per TH/s/year: $5,000 Ã· 100 Ã· 3 = $16.67\n```\n\n### Break-Even Analysis\n\n```\nRevenue per TH/day: ~$0.08 (varies with difficulty and price)\nElectricity cost: $0.05/kWh\nMachine efficiency: 25 J/TH\n\nPower per TH/day: 25 J/s Ã— 86,400 s = 2.16 MJ = 0.6 kWh\nElectricity per TH/day: 0.6 Ã— $0.05 = $0.03\n\nProfit per TH/day: $0.08 - $0.03 = $0.05\n```\n\n---\n\n## Industrial Mining Operations\n\n### Scale\n\nModern mining farms:\n\n- **Hashrate**: 1-50 EH/s (exahashes per second)\n- **Power**: 50-500 MW\n- **Machines**: 10,000-100,000+ ASICs\n- **Investment**: $100M-$1B+\n\n### Infrastructure Requirements\n\n**Power**\n- Cheap electricity is critical ($0.02-0.05/kWh ideal)\n- Substations, transformers, distribution\n- Often: stranded energy, renewables, flared gas\n\n**Cooling**\n- ASICs generate enormous heat\n- Air cooling: fans, ducting, outdoor air\n- Immersion cooling: machines submerged in dielectric fluid\n- Target: 15-25Â°C ambient\n\n**Networking**\n- Low latency to [pools](/docs/mining/pools)\n- Redundant connections\n- Monitoring systems\n\n**Security**\n- Physical security (machines are valuable)\n- Cybersecurity (prevent hashrate theft)\n- Fire suppression\n\n### Geographic Distribution\n\nMining gravitates toward cheap power:\n\n- **United States**: Texas (wind), Georgia (nuclear), Wyoming\n- **Canada**: Quebec (hydro), Alberta\n- **Kazakhstan**: Coal power (declining due to regulations)\n- **Russia**: Siberia (hydro, cold climate)\n- **Nordic countries**: Hydro, geothermal, cold\n- **Middle East**: UAE, Oman (cheap natural gas)\n\n---\n\n## Home Mining\n\n### Is It Viable?\n\nFor most people in most places: marginally, or no.\n\n**Challenges**:\n- Electricity costs ($0.10-0.30/kWh residential)\n- Noise (70-80 dB, like a vacuum cleaner)\n- Heat (3kW space heater per machine)\n- Space and ventilation\n\n**Where It Works**:\n- Cheap or free electricity\n- Cold climates (use heat)\n- Off-grid (solar, hydro)\n- Learning/hobby purposes\n\n### Home Mining Options\n\n**Full ASIC**\n- Antminer S9 (old, cheap, inefficient)\n- Small new units (Antminer S19 nano)\n- Noise and heat issues\n\n**USB/Low-power**\n- FutureBit Apollo\n- Nerdminer (ESP32)\n- Not profitable, but educational\n\n**Heating Integration**\n- Heatbit, Hestiia\n- ASIC mining as home heating\n- Heat is a feature, not waste\n\n---\n\n## The ASIC Trap\n\n### No Escape\n\nOnce ASICs exist, there's no going back:\n\n1. **ASICs are 10,000x more efficient** than GPUs\n2. **GPU miners can't compete**\n3. **ASIC investment creates lock-in**\n4. **Algorithm changes would destroy investment**\n\n### ASIC Resistance (Other Coins)\n\nSome cryptocurrencies tried to resist ASICs:\n\n- **Memory-hard algorithms**: Ethereum (Ethash), Monero (RandomX)\n- **Frequent algorithm changes**: Monero\n- **ASIC-resistant designs**: Often just delays ASICs\n\nBitcoin's position: ASICs are a feature, not a bug. They represent committed capital that can't be repurposed.\n\n---\n\n## Future Trends\n\n### Efficiency Limits\n\nPhysical limits are approaching:\n\n- **3nm/2nm processes**: Near atomic scale\n- **Thermodynamic limits**: Minimum energy per computation\n- **Diminishing returns**: Each generation improves less\n\n### Immersion Cooling\n\nSubmerging ASICs in dielectric fluid:\n\n- **Better cooling**: Removes heat more efficiently\n- **Overclocking**: Run chips faster\n- **Longevity**: Less thermal stress\n- **Density**: More machines per space\n\n### Stranded Energy\n\nMining as flexible load:\n\n- **Flared gas**: Capture otherwise wasted energy\n- **Curtailed renewables**: Use excess wind/solar\n- **Grid balancing**: Ramp up/down based on demand\n- **Remote locations**: Monetize energy that can't reach grid\n\n### Vertical Integration\n\nLarge miners building their own chips:\n\n- **Reduce reliance on Bitmain/MicroBT**\n- **Custom optimizations**\n- **Supply chain control**\n- **Examples**: Bitfury, Intel (briefly), Block/Square (planned)\n\n---\n\n## Summary\n\nThe evolution of mining hardware:\n\n| Era | Technology | Efficiency Gain | Timeline |\n|-----|------------|-----------------|----------|\n| 1 | CPU | Baseline | 2009-2010 |\n| 2 | GPU | 10-50x | 2010-2013 |\n| 3 | FPGA | 5-10x | 2011-2013 |\n| 4 | ASIC | 1000x+ | 2013-present |\n\nKey takeaways:\n\n- **ASICs dominate** and will continue to\n- **Efficiency is everything**: J/TH determines profitability\n- **Industrial scale** is increasingly dominant\n- **Hardware is expensive** and depreciates quickly\n- **Location matters**: Cheap power wins\n\n---\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - What the hardware computes\n- [Mining Economics](/docs/mining/economics) - Profitability analysis\n- [Mining Pools](/docs/mining/pools) - How miners collaborate\n- [Difficulty Adjustment](/docs/mining/difficulty) - How network responds to hashrate\n\n---\n\n## Resources\n\n- [ASIC Miner Value](https://www.asicminervalue.com/) - Profitability calculator\n- [Hashrate Index](https://hashrateindex.com/) - Mining market data\n- [Cambridge Bitcoin Electricity Consumption Index](https://ccaf.io/cbeci) - Network energy use\n",
    "filename": "hardware.md"
  },
  "/docs/mining/attacks": {
    "content": "# Mining Attacks\n\nBitcoin's [proof-of-work](/docs/glossary#proof-of-work-pow) security model is designed to make attacks economically irrational. However, understanding potential attacks is crucial for appreciating Bitcoin's security properties and the incentives that protect the network.\n\nThis section covers theoretical attacks on Bitcoin mining, their costs, and why they generally don't happen.\n\n## The 51% Attack\n\nThe most discussed attack on Bitcoin: what if someone controls more than half the network's [hashrate](/docs/glossary#hash-rate)?\n\n### What It Enables\n\nWith >50% hashrate, an attacker can:\n\n1. **Double-spend**: Reverse their own transactions\n2. **Block transactions**: Prevent specific transactions from confirming\n3. **Empty blocks**: Mine blocks with no transactions (censorship)\n\n### What It Doesn't Enable\n\nEven with 51%, an attacker **cannot**:\n\n- **Steal coins**: Can't create valid signatures for others' coins\n- **Change consensus rules**: Can't create coins, change block rewards\n- **Spend anyone's coins**: Only their own (for double-spends)\n- **Modify historical transactions**: Only recent blocks (cost increases with depth)\n\n### How It Works\n\n```\nHonest chain:    A â†’ B â†’ C â†’ D â†’ E â†’ F\n                              â†‘\n                        Attacker buys something\n                        \nAttacker mines secretly:\n                 A â†’ B â†’ C â†’ D'â†’ E'â†’ F'â†’ G'\n                              â†‘\n                        Same coins spent differently\n                        \nWhen attacker's chain is longer, it becomes the valid chain.\nThe honest chain is orphaned. Double-spend succeeds.\n```\n\n### Attack Success Probability\n\nThe probability of a successful double-spend attack depends on the attacker's hashrate and the number of [confirmations](/docs/glossary#confirmation) the victim waits for:\n\n:::code-group\n```rust\n/// Calculates the probability of a successful double-spend attack.\n/// Based on the analysis in Satoshi's whitepaper.\n\n/// Calculate attack success probability using Poisson distribution.\n/// \n/// # Arguments\n/// * `q` - Attacker's fraction of total hashrate (0.0 to 1.0)\n/// * `z` - Number of confirmations to overcome\nfn attack_success_probability(q: f64, z: u32) -> f64 {\n    if q >= 0.5 {\n        return 1.0; // Attacker always wins with majority\n    }\n    \n    let p = 1.0 - q; // Honest miners' fraction\n    let lambda = (z as f64) * (q / p);\n    \n    let mut sum = 0.0;\n    let mut poisson_term = (-lambda).exp();\n    \n    for k in 0..=z {\n        // Probability attacker catches up from k blocks behind\n        let catch_up_prob = if k <= z {\n            (q / p).powi((z - k) as i32)\n        } else {\n            1.0\n        };\n        \n        sum += poisson_term * (1.0 - catch_up_prob);\n        poisson_term *= lambda / ((k + 1) as f64);\n    }\n    \n    1.0 - sum\n}\n\n/// Simpler approximation for attack probability.\nfn attack_probability_simple(q: f64, z: u32) -> f64 {\n    if q >= 0.5 {\n        return 1.0;\n    }\n    \n    // Approximation: (q/p)^z where p = 1-q\n    let p = 1.0 - q;\n    (q / p).powi(z as i32)\n}\n\n/// Calculate required confirmations for a given security level.\nfn required_confirmations(q: f64, target_probability: f64) -> u32 {\n    if q >= 0.5 {\n        return u32::MAX; // Never safe\n    }\n    \n    for z in 1..100 {\n        if attack_success_probability(q, z) < target_probability {\n            return z;\n        }\n    }\n    100\n}\n\nfn main() {\n    println!(\"Double-Spend Attack Success Probability\\n\");\n    println!(\"Attacker hashrate | 1 conf | 3 conf | 6 conf | 12 conf\");\n    println!(\"-\".repeat(60));\n    \n    for q in [0.10, 0.20, 0.30, 0.40, 0.45] {\n        print!(\"      {:.0}%          |\", q * 100.0);\n        for z in [1, 3, 6, 12] {\n            let prob = attack_success_probability(q, z);\n            print!(\" {:.4} |\", prob);\n        }\n        println!();\n    }\n    \n    println!(\"\\nRequired confirmations for 0.1% attack probability:\");\n    for q in [0.10, 0.20, 0.30] {\n        let confs = required_confirmations(q, 0.001);\n        println!(\"  {:.0}% attacker: {} confirmations\", q * 100.0, confs);\n    }\n}\n```\n\n```python\nimport math\n\ndef attack_success_probability(q: float, z: int) -> float:\n    \"\"\"\n    Calculate the probability of a successful double-spend attack.\n    Based on the analysis in Satoshi's whitepaper.\n    \n    Args:\n        q: Attacker's fraction of total hashrate (0.0 to 1.0)\n        z: Number of confirmations to overcome\n    \n    Returns:\n        Probability of successful attack (0.0 to 1.0)\n    \"\"\"\n    if q >= 0.5:\n        return 1.0  # Attacker always wins with majority\n    \n    p = 1 - q  # Honest miners' fraction\n    lambda_val = z * (q / p)\n    \n    total = 0.0\n    poisson_term = math.exp(-lambda_val)\n    \n    for k in range(z + 1):\n        # Probability attacker catches up from k blocks behind\n        catch_up_prob = (q / p) ** (z - k) if k <= z else 1.0\n        total += poisson_term * (1 - catch_up_prob)\n        poisson_term *= lambda_val / (k + 1)\n    \n    return 1 - total\n\ndef attack_probability_simple(q: float, z: int) -> float:\n    \"\"\"\n    Simpler approximation for attack probability.\n    Good for quick estimates when q is small.\n    \"\"\"\n    if q >= 0.5:\n        return 1.0\n    \n    p = 1 - q\n    return (q / p) ** z\n\ndef required_confirmations(q: float, target_probability: float) -> int:\n    \"\"\"\n    Calculate required confirmations for a given security level.\n    \n    Args:\n        q: Attacker's fraction of hashrate\n        target_probability: Maximum acceptable attack probability\n    \n    Returns:\n        Number of confirmations needed\n    \"\"\"\n    if q >= 0.5:\n        return float('inf')  # Never safe\n    \n    for z in range(1, 100):\n        if attack_success_probability(q, z) < target_probability:\n            return z\n    return 100\n\ndef cost_of_attack(q: float, network_hashrate_eh: float, \n                   electricity_cost: float, hours: float) -> float:\n    \"\"\"\n    Estimate the cost of running a 51% attack.\n    \n    Args:\n        q: Attacker's target fraction of hashrate\n        network_hashrate_eh: Current network hashrate in EH/s\n        electricity_cost: Cost per kWh in dollars\n        hours: Duration of attack in hours\n    \n    Returns:\n        Estimated cost in dollars\n    \"\"\"\n    # Attacker needs q/(1-q) times the honest hashrate\n    attacker_hashrate = network_hashrate_eh * (q / (1 - q))\n    \n    # Assume 25 J/TH efficiency (modern ASICs)\n    joules_per_th = 25\n    power_watts = attacker_hashrate * 1e6 * joules_per_th  # EH to TH\n    power_kw = power_watts / 1000\n    \n    # Electricity cost\n    electricity = power_kw * hours * electricity_cost\n    \n    # Hardware cost (rough estimate: $50 per TH/s)\n    hardware_cost_per_th = 50\n    hardware = attacker_hashrate * 1e6 * hardware_cost_per_th\n    \n    return electricity + hardware\n\n# Print attack probability table\nprint(\"Double-Spend Attack Success Probability\\n\")\nprint(\"Attacker hashrate | 1 conf | 3 conf | 6 conf | 12 conf\")\nprint(\"-\" * 60)\n\nfor q in [0.10, 0.20, 0.30, 0.40, 0.45]:\n    probs = [attack_success_probability(q, z) for z in [1, 3, 6, 12]]\n    print(f\"      {q*100:.0f}%          | {probs[0]:.4f} | {probs[1]:.4f} | {probs[2]:.4f} | {probs[3]:.4f}\")\n\nprint(\"\\nRequired confirmations for 0.1% attack probability:\")\nfor q in [0.10, 0.20, 0.30]:\n    confs = required_confirmations(q, 0.001)\n    print(f\"  {q*100:.0f}% attacker: {confs} confirmations\")\n\nprint(\"\\nEstimated attack cost (51% for 1 hour):\")\ncost = cost_of_attack(0.51, 700, 0.05, 1)\nprint(f\"  ${cost/1e9:.2f} billion (hardware + electricity)\")\n```\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n\n/**\n * Calculate the probability of a successful double-spend attack.\n * Based on the analysis in Satoshi's whitepaper.\n * \n * @param q Attacker's fraction of total hashrate (0.0 to 1.0)\n * @param z Number of confirmations to overcome\n * @return Probability of successful attack (0.0 to 1.0)\n */\ndouble attackSuccessProbability(double q, int z) {\n    if (q >= 0.5) {\n        return 1.0; // Attacker always wins with majority\n    }\n    \n    double p = 1.0 - q; // Honest miners' fraction\n    double lambda = z * (q / p);\n    \n    double sum = 0.0;\n    double poissonTerm = exp(-lambda);\n    \n    for (int k = 0; k <= z; ++k) {\n        // Probability attacker catches up from k blocks behind\n        double catchUpProb = pow(q / p, z - k);\n        sum += poissonTerm * (1.0 - catchUpProb);\n        poissonTerm *= lambda / (k + 1);\n    }\n    \n    return 1.0 - sum;\n}\n\n/**\n * Simpler approximation for attack probability.\n */\ndouble attackProbabilitySimple(double q, int z) {\n    if (q >= 0.5) {\n        return 1.0;\n    }\n    double p = 1.0 - q;\n    return pow(q / p, z);\n}\n\n/**\n * Calculate required confirmations for a given security level.\n */\nint requiredConfirmations(double q, double targetProbability) {\n    if (q >= 0.5) {\n        return INT_MAX; // Never safe\n    }\n    \n    for (int z = 1; z < 100; ++z) {\n        if (attackSuccessProbability(q, z) < targetProbability) {\n            return z;\n        }\n    }\n    return 100;\n}\n\nint main() {\n    std::cout << \"Double-Spend Attack Success Probability\\n\" << std::endl;\n    std::cout << \"Attacker hashrate | 1 conf | 3 conf | 6 conf | 12 conf\" << std::endl;\n    std::cout << std::string(60, '-') << std::endl;\n    \n    std::cout << std::fixed << std::setprecision(4);\n    \n    double qValues[] = {0.10, 0.20, 0.30, 0.40, 0.45};\n    int zValues[] = {1, 3, 6, 12};\n    \n    for (double q : qValues) {\n        std::cout << \"      \" << std::setw(2) << (int)(q * 100) << \"%          |\";\n        for (int z : zValues) {\n            std::cout << \" \" << attackSuccessProbability(q, z) << \" |\";\n        }\n        std::cout << std::endl;\n    }\n    \n    std::cout << \"\\nRequired confirmations for 0.1% attack probability:\" << std::endl;\n    for (double q : {0.10, 0.20, 0.30}) {\n        int confs = requiredConfirmations(q, 0.001);\n        std::cout << \"  \" << (int)(q * 100) << \"% attacker: \" \n                  << confs << \" confirmations\" << std::endl;\n    }\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\n// AttackSuccessProbability calculates the probability of a successful double-spend attack.\n// Based on the analysis in Satoshi's whitepaper.\nfunc AttackSuccessProbability(q float64, z int) float64 {\n\tif q >= 0.5 {\n\t\treturn 1.0 // Attacker always wins with majority\n\t}\n\t\n\tp := 1.0 - q // Honest miners' fraction\n\tlambda := float64(z) * (q / p)\n\t\n\t// Poisson probability: sum from k=0 to z of (lambda^k * e^-lambda) / k!\n\tprob := 0.0\n\tfor k := 0; k <= z; k++ {\n\t\tprob += math.Pow(lambda, float64(k)) * math.Exp(-lambda) / float64(factorial(k))\n\t}\n\t\n\t// Probability attacker catches up: (q/p)^z\n\tcatchUpProb := math.Pow(q/p, float64(z))\n\t\n\treturn 1.0 - prob + catchUpProb\n}\n\nfunc factorial(n int) int {\n\tif n <= 1 {\n\t\treturn 1\n\t}\n\treturn n * factorial(n-1)\n}\n\n// AttackProbabilitySimple is a simplified version for small z\nfunc AttackProbabilitySimple(q float64, z int) float64 {\n\tif q >= 0.5 {\n\t\treturn 1.0\n\t}\n\treturn math.Pow(q/(1.0-q), float64(z))\n}\n\n// RequiredConfirmations finds the number of confirmations needed for a target attack probability\nfunc RequiredConfirmations(q float64, targetProb float64) int {\n\tfor z := 1; z < 1000; z++ {\n\t\tif AttackSuccessProbability(q, z) < targetProb {\n\t\t\treturn z\n\t\t}\n\t}\n\treturn 100\n}\n\n// CostOfAttack estimates the cost of a 51% attack\nfunc CostOfAttack(q float64, networkHashrateEh float64, electricityCost float64, hours float64) float64 {\n\tattackerHashrate := networkHashrateEh * (q / (1.0 - q))\n\t\n\t// Assume 25 J/TH efficiency\n\tjoulesPerTh := 25.0\n\tpowerWatts := attackerHashrate * 1e6 * joulesPerTh\n\tpowerKw := powerWatts / 1000.0\n\t\n\telectricity := powerKw * hours * electricityCost\n\thardwareCostPerTh := 50.0\n\thardware := attackerHashrate * 1e6 * hardwareCostPerTh\n\t\n\treturn electricity + hardware\n}\n\nfunc main() {\n\tfmt.Println(\"Double-Spend Attack Success Probability\\n\")\n\tfmt.Println(\"Attacker hashrate | 1 conf | 3 conf | 6 conf | 12 conf\")\n\tfmt.Println(\"------------------------------------------------------------\")\n\t\n\tqValues := []float64{0.10, 0.20, 0.30, 0.40, 0.45}\n\tzValues := []int{1, 3, 6, 12}\n\t\n\tfor _, q := range qValues {\n\t\tfmt.Printf(\"      %2.0f%%          |\", q*100)\n\t\tfor _, z := range zValues {\n\t\t\tprob := AttackSuccessProbability(q, z)\n\t\t\tfmt.Printf(\" %.4f |\", prob)\n\t\t}\n\t\tfmt.Println()\n\t}\n\t\n\tfmt.Println(\"\\nRequired confirmations for 0.1% attack probability:\")\n\tfor _, q := range []float64{0.10, 0.20, 0.30} {\n\t\tconfs := RequiredConfirmations(q, 0.001)\n\t\tfmt.Printf(\"  %.0f%% attacker: %d confirmations\\n\", q*100, confs)\n\t}\n\t\n\tfmt.Println(\"\\nEstimated attack cost (51% for 1 hour):\")\n\tcost := CostOfAttack(0.51, 700, 0.05, 1)\n\tfmt.Printf(\"  $%.2f billion (hardware + electricity)\\n\", cost/1e9)\n}\n```\n\n```javascript\n/**\n * Calculate the probability of a successful double-spend attack.\n * Based on the analysis in Satoshi's whitepaper.\n * \n * @param {number} q - Attacker's fraction of total hashrate (0.0 to 1.0)\n * @param {number} z - Number of confirmations to overcome\n * @returns {number} - Probability of successful attack (0.0 to 1.0)\n */\nfunction attackSuccessProbability(q, z) {\n    if (q >= 0.5) {\n        return 1.0; // Attacker always wins with majority\n    }\n    \n    const p = 1 - q; // Honest miners' fraction\n    const lambda = z * (q / p);\n    \n    let sum = 0;\n    let poissonTerm = Math.exp(-lambda);\n    \n    for (let k = 0; k <= z; k++) {\n        // Probability attacker catches up from k blocks behind\n        const catchUpProb = Math.pow(q / p, z - k);\n        sum += poissonTerm * (1 - catchUpProb);\n        poissonTerm *= lambda / (k + 1);\n    }\n    \n    return 1 - sum;\n}\n\n/**\n * Simpler approximation for attack probability.\n * @param {number} q - Attacker's hashrate fraction\n * @param {number} z - Number of confirmations\n * @returns {number} - Approximate probability\n */\nfunction attackProbabilitySimple(q, z) {\n    if (q >= 0.5) return 1.0;\n    const p = 1 - q;\n    return Math.pow(q / p, z);\n}\n\n/**\n * Calculate required confirmations for a given security level.\n * @param {number} q - Attacker's fraction of hashrate\n * @param {number} targetProbability - Maximum acceptable attack probability\n * @returns {number} - Number of confirmations needed\n */\nfunction requiredConfirmations(q, targetProbability) {\n    if (q >= 0.5) return Infinity;\n    \n    for (let z = 1; z < 100; z++) {\n        if (attackSuccessProbability(q, z) < targetProbability) {\n            return z;\n        }\n    }\n    return 100;\n}\n\n/**\n * Estimate the cost of running an attack.\n * @param {number} q - Attacker's target hashrate fraction\n * @param {number} networkHashrateEh - Network hashrate in EH/s\n * @param {number} electricityCost - Cost per kWh in dollars\n * @param {number} hours - Duration of attack\n * @returns {number} - Estimated cost in dollars\n */\nfunction costOfAttack(q, networkHashrateEh, electricityCost, hours) {\n    const attackerHashrate = networkHashrateEh * (q / (1 - q));\n    \n    // Assume 25 J/TH efficiency\n    const joulesPerTh = 25;\n    const powerWatts = attackerHashrate * 1e6 * joulesPerTh;\n    const powerKw = powerWatts / 1000;\n    \n    const electricity = powerKw * hours * electricityCost;\n    const hardwareCostPerTh = 50;\n    const hardware = attackerHashrate * 1e6 * hardwareCostPerTh;\n    \n    return electricity + hardware;\n}\n\n// Print attack probability table\nconsole.log(\"Double-Spend Attack Success Probability\\n\");\nconsole.log(\"Attacker hashrate | 1 conf | 3 conf | 6 conf | 12 conf\");\nconsole.log(\"-\".repeat(60));\n\nfor (const q of [0.10, 0.20, 0.30, 0.40, 0.45]) {\n    const probs = [1, 3, 6, 12].map(z => attackSuccessProbability(q, z).toFixed(4));\n    console.log(`      ${(q*100).toFixed(0)}%          | ${probs.join(' | ')}`);\n}\n\nconsole.log(\"\\nRequired confirmations for 0.1% attack probability:\");\nfor (const q of [0.10, 0.20, 0.30]) {\n    const confs = requiredConfirmations(q, 0.001);\n    console.log(`  ${(q*100).toFixed(0)}% attacker: ${confs} confirmations`);\n}\n\nconsole.log(\"\\nEstimated attack cost (51% for 1 hour):\");\nconst cost = costOfAttack(0.51, 700, 0.05, 1);\nconsole.log(`  $${(cost/1e9).toFixed(2)} billion (hardware + electricity)`);\n```\n:::\n\n### Cost Analysis\n\n**Renting Hashrate**\n\nAt 500 EH/s network hashrate, 51% = 250 EH/s\n\n```\nCost to rent 250 EH/s:\n- Hardware doesn't exist to rent at this scale\n- Would require owning majority of world's ASICs\n- Estimated cost: $10-20 billion in equipment alone\n- Plus electricity, facilities, etc.\n```\n\n**Opportunity Cost**\n\nIf you have 51% hashrate, honest mining is extremely profitable:\n\n```\n51% of block rewards:\n- 225 blocks/day Ã— 3.375 BTC Ã— 51% = 387 BTC/day\n- At $60,000/BTC = $23M per day\n- $8.5 billion per year\n\nWhy attack when honest mining is this lucrative?\n```\n\n### Historical Non-Attacks\n\nNo successful [51% attack](/docs/glossary#51-attack) on Bitcoin [mainnet](/docs/glossary#mainnet) has ever occurred. The economics don't work:\n\n- Cost exceeds potential gain\n- Attack destroys value of the asset you're attacking\n- Your own holdings lose value\n- Criminal liability is enormous\n\n### Detection\n\n51% attacks are visible:\n\n- Sudden hashrate spike from unknown source\n- Chain reorganizations (reorgs)\n- Confirmed transactions disappearing\n\n### Defenses\n\n- **Wait for confirmations**: More confirmations = harder to reverse\n- **6 confirmations**: Traditional standard (~1 hour)\n- **Large amounts**: Wait for more confirmations\n- **Economic finality**: Eventually, attack cost exceeds transaction value\n\n---\n\n## Selfish Mining\n\nA subtle attack where miners can gain unfair advantage with less than 50% hashrate.\n\n### How It Works\n\nNormal mining: Find a block â†’ immediately broadcast it\n\nSelfish mining:\n1. Find a block â†’ **keep it secret**\n2. Continue mining on your secret chain\n3. If honest miners catch up, release your block\n4. You get the reward, honest miners' work is wasted\n\n### The Strategy\n\n```\nScenario: Selfish miner has 30% hashrate\n\n1. Selfish miner finds block A\n   Secret chain: [A]\n   Public chain: []\n   \n2. Keep mining secretly\n   If selfish miner finds B before public finds anything:\n   Secret chain: [A, B]  â† 2 block lead\n   \n3. When public finds a block:\n   - If selfish lead â‰¥ 2: release one block, maintain lead\n   - If selfish lead = 1: race to propagate\n   - If selfish lead = 0: lost this round\n```\n\n### Profitability Threshold\n\nSelfish mining becomes profitable above ~33% hashrate (with optimal network position) or ~25% (with network advantages).\n\nBelow this threshold, the strategy loses money compared to honest mining.\n\n### Why It Rarely Happens\n\n1. **Threshold is high**: Need significant hashrate\n2. **Detection risk**: Unusual [block time](/docs/glossary#block-time) patterns\n3. **Pool transparency**: Large [pools](/docs/mining/pools) are monitored\n4. **Reputation damage**: Discovered selfish mining destroys trust\n5. **Coordination**: Requires all pool miners to participate\n\n### Defenses\n\n- **Uniform tie-breaking**: Nodes randomly choose between equal-height blocks\n- **Timestamp analysis**: Detect anomalous block timing\n- **Pool monitoring**: Watch for suspicious behavior\n\n---\n\n## Block Withholding Attack\n\nAn attack by pool miners against their own pool.\n\n### How It Works\n\n1. Miner joins a pool\n2. Submits partial [shares](/docs/glossary#share) (proving work)\n3. When finding a valid block, **doesn't submit it**\n4. Pool pays miner for shares but gets no blocks\n\n### Impact\n\n- Pool loses revenue (missing blocks)\n- Attacker earns from shares but sabotages pool\n- Other pool members subsidize the attacker\n\n### Motivation\n\n- Competitor pools attacking each other\n- Extortion\n- Spite\n\n### Defenses\n\n- **Statistical analysis**: Detect miners who never find blocks\n- **Stratum V2**: Better work validation\n- **Reputation systems**: Track miner history\n\n---\n\n## Fee Sniping\n\nMiners stealing high-fee transactions from other miners' blocks.\n\n### How It Works\n\n```\nBlock N contains a transaction with 10 BTC in fees (unusually high)\n\nAttacker sees Block N, thinks:\n\"If I mine an alternative Block N with that transaction, \nI get those 10 BTC instead.\"\n\nAttacker mines competing Block N' including the high-fee tx.\n```\n\n### Requirements\n\n- Very high-fee transaction (worth the orphan risk)\n- Significant hashrate (to win the race)\n- Quick reaction (see block, start mining alternative)\n\n### Why It's Rare\n\n- Need to out-mine honest miners extending Block N\n- Costs the [block reward](/docs/glossary#block-reward) if you lose\n- Not worth it for normal fees\n\n### Prevention\n\n- **nLockTime**: Transactions can specify earliest block\n- **[CLTV](/docs/glossary#cltv-checklocktimeverify)**: Similar lock-time mechanism\n- **Low fees**: Don't create tempting targets\n\n---\n\n## Transaction Pinning\n\nAn attack relevant to Layer 2 protocols like [Lightning](/docs/lightning).\n\n### How It Works\n\n1. Attacker creates a low-fee transaction spending the same output\n2. Transaction is large, making [CPFP](/docs/glossary#cpfp-child-pays-for-parent) expensive\n3. Victim's transaction can't confirm\n4. Time-sensitive protocols (Lightning) may fail\n\n### Impact on Lightning\n\nLightning [channels](/docs/glossary#channel) have time-locked transactions. If these can't confirm:\n\n- Attacker might steal funds\n- [Force-close](/docs/glossary#force-close) may fail\n- Victim loses money\n\n### Defenses\n\n- **Package relay**: Let related transactions propagate together\n- **Anchor outputs**: Pre-planned fee-bumping mechanisms\n- **v3 transactions**: New policy to limit pinning\n\n---\n\n## Time-Warp Attack\n\nExploiting timestamp manipulation over [difficulty](/docs/glossary#difficulty) adjustment periods.\n\n### How It Works\n\nDifficulty adjusts every 2016 blocks based on timestamps.\n\n```\nNormal: 2016 blocks in 2 weeks â†’ difficulty unchanged\n\nAttack:\n1. Set first block timestamp = minimum allowed\n2. Set last block timestamp = maximum allowed\n3. Period appears longer than 2 weeks\n4. Difficulty decreases artificially\n5. Mine faster, get more rewards\n```\n\n### Requirements\n\n- Majority hashrate (to control timestamps)\n- Patience (takes many difficulty periods)\n- Coordination (all block timestamps must be manipulated)\n\n### Why It's Theoretical\n\n- Requires 51% hashrate (major attack already)\n- Slow payoff (months to exploit)\n- Easily detected\n- Could be fixed with [soft fork](/docs/glossary#soft-fork)\n\n---\n\n## Eclipse Attack\n\nIsolating a node from the real network.\n\n### How It Works\n\n1. Attacker surrounds victim with malicious nodes\n2. Victim only connects to attacker's nodes\n3. Attacker feeds victim a fake chain\n4. Victim accepts invalid transactions\n\n### Impact\n\n- Victim might accept unconfirmed transactions\n- Victim might mine on wrong chain\n- Victim might accept double-spends\n\n### Defenses\n\n- **More connections**: Connect to many diverse [peers](/docs/glossary#peer)\n- **DNS seeds**: Use multiple bootstrap sources\n- **Manual peering**: Add known-good peers\n- **Outbound connections**: Prioritize connections you initiate\n\n---\n\n## Finney Attack\n\nNamed after [Hal Finney](/docs/history/people#hal-finney), this is a race between broadcasting blocks and transactions.\n\n### How It Works\n\n1. Attacker mines block containing tx spending to themselves\n2. Keep block secret\n3. Spend same coins at merchant (buy something)\n4. Immediately broadcast secret block\n5. Merchant's transaction is now invalid\n\n### Requirements\n\n- Find a block (significant hashrate)\n- Execute purchase very quickly (before someone else finds a block)\n- Merchant accepts 0-confirmation transactions\n\n### Defense\n\n- **Wait for confirmations**: Even 1 confirmation defeats this\n- **Don't accept 0-conf**: For significant amounts\n\n---\n\n## Goldfinger Attack\n\nAttack Bitcoin not for profit, but for destruction.\n\n### Motivation\n\n- Nation-state wanting to kill Bitcoin\n- Competitor (central bank?) wanting to discredit crypto\n- Ideological opposition\n\n### Method\n\n- Acquire massive hashrate regardless of cost\n- Use it to disrupt the network\n- Not trying to profit; trying to destroy\n\n### Defense\n\n- **Sheer scale**: 500+ EH/s is hard to match\n- **[Decentralization](/docs/fundamentals/decentralization)**: No single point of attack\n- **Adaptability**: Network can respond (emergency difficulty adjustment, algorithm change)\n- **Resilience**: Bitcoin has survived many attacks and attempts\n\n### Reality Check\n\nThis attack requires:\n\n- Billions of dollars\n- Global supply chain capture\n- Sustained attack (one-time disruption isn't fatal)\n- Facing legal consequences in every jurisdiction\n\n---\n\n## Summary\n\nBitcoin's mining attacks show why the security model works:\n\n| Attack | Requirement | Profitability | Likelihood |\n|--------|-------------|---------------|------------|\n| 51% Attack | >50% hashrate | Usually negative | Very low |\n| Selfish Mining | >25-33% hashrate | Marginal | Low |\n| Block Withholding | Pool participation | Negative-sum | Low |\n| Fee Sniping | High fees + hashrate | Rarely worthwhile | Very low |\n| Time-Warp | 51% + patience | Possible | Theoretical |\n| Eclipse | Network control | Situation-specific | Possible |\n\n**The key insight**: Bitcoin is protected by economics, not just cryptography. Attacks are possible but rarely profitable.\n\nMost attacks require:\n- Enormous capital expenditure\n- Destroying the value of your investment\n- Obvious detection\n- Criminal liability\n\nHonest mining is almost always more profitable than attacking.\n\n---\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - The security mechanism\n- [Mining Economics](/docs/mining/economics) - Why honest mining pays\n- [Difficulty Adjustment](/docs/mining/difficulty) - How network responds\n- [Consensus Mechanism](/docs/bitcoin/consensus) - How Bitcoin achieves agreement\n\n---\n\n## Resources\n\n- [Selfish Mining Paper](https://www.cs.cornell.edu/~ie53/publications/btcProcFC.pdf) - Original academic analysis\n- [Bitcoin Security Model](https://nakamotoinstitute.org/library/security-model/) - Complete overview\n",
    "filename": "attacks.md"
  },
  "/docs/mining/network-attacks": {
    "content": "# Network Attacks & Security\n\nBitcoin's P2P network faces various attack vectors. Understanding these attacks helps node operators secure their nodes and developers build resilient applications.\n\n## Attack Types\n\n### Eclipse Attacks\n\n**Eclipse attacks** isolate a node by controlling all its connections:\n\n```text\nAttack:\n1. Attacker controls many IP addresses\n2. Attacker connects to victim from all addresses\n3. Victim's connections are all to attacker\n4. Attacker controls what victim sees\n5. Victim sees fake blockchain state\n```\n\n**Mitigation**:\n- Connect to diverse IP ranges\n- Use multiple outbound connections\n- Verify block data independently\n- Use block-relay-only connections\n\n### Sybil Attacks\n\n**Sybil attacks** create many fake identities:\n\n```text\nAttack:\n1. Attacker creates many node identities\n2. Attacker controls large portion of network\n3. Attacker can influence network behavior\n4. Attacker can censor transactions\n```\n\n**Mitigation**:\n- Proof-of-work prevents fake blocks\n- Independent validation by all nodes\n- No trust in individual peers\n- Economic cost of attack\n\n### BGP Hijacking\n\n**BGP hijacking** redirects network traffic:\n\n```text\nAttack:\n1. Attacker announces false BGP routes\n2. Traffic redirected to attacker\n3. Attacker can intercept/modify data\n4. Affects large portions of network\n```\n\n**Mitigation**:\n- Use Tor or VPN\n- Connect to diverse geographic locations\n- Monitor for unusual routing\n- Use authenticated connections\n\n---\n\n## Code Examples\n\n### Detecting Eclipse Attack\n\n:::code-group\n```rust\nuse std::collections::HashSet;\nuse std::net::IpAddr;\n\nfn detect_eclipse_attack(connected_ips: Vec<IpAddr>) -> bool {\n    // Check IP diversity\n    let unique_ips: HashSet<IpAddr> = connected_ips.iter().cloned().collect();\n    \n    // Check for suspicious patterns\n    let same_subnet = connected_ips\n        .windows(2)\n        .all(|w| same_subnet(w[0], w[1]));\n    \n    // Eclipse attack if all IPs from same subnet\n    same_subnet && unique_ips.len() < 5\n}\n```\n\n```python\nfrom ipaddress import ip_network\nfrom collections import Counter\n\ndef detect_eclipse_attack(connected_ips):\n    \"\"\"Detect potential eclipse attack.\"\"\"\n    # Check IP diversity\n    unique_ips = set(connected_ips)\n    \n    # Check subnet distribution\n    subnets = [str(ip_network(ip + '/24', strict=False)) for ip in connected_ips]\n    subnet_counts = Counter(subnets)\n    \n    # Suspicious if too many from same subnet\n    max_subnet_count = max(subnet_counts.values())\n    return max_subnet_count > len(connected_ips) * 0.8\n```\n\n```cpp\n#include <set>\n#include <vector>\n#include <netinet/in.h>\n\nbool detect_eclipse_attack(const std::vector<in_addr>& connected_ips) {\n    std::set<in_addr> unique_ips(connected_ips.begin(), connected_ips.end());\n    \n    // Check subnet diversity\n    std::map<uint32_t, int> subnet_counts;\n    for (const auto& ip : connected_ips) {\n        uint32_t subnet = ntohl(ip.s_addr) & 0xFFFFFF00; // /24 subnet\n        subnet_counts[subnet]++;\n    }\n    \n    // Suspicious if too many from same subnet\n    int max_count = 0;\n    for (const auto& pair : subnet_counts) {\n        max_count = std::max(max_count, pair.second);\n    }\n    \n    return max_count > connected_ips.size() * 0.8;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"net\"\n)\n\nfunc detectEclipseAttack(connectedIPs []net.IP) bool {\n\t// Check IP diversity\n\tuniqueIPs := make(map[string]bool)\n\tsubnetCounts := make(map[string]int)\n\t\n\tfor _, ip := range connectedIPs {\n\t\tuniqueIPs[ip.String()] = true\n\t\tsubnet := getSubnet(ip)\n\t\tsubnetCounts[subnet]++\n\t}\n\t\n\t// Check if too many from same subnet\n\tmaxCount := 0\n\tfor _, count := range subnetCounts {\n\t\tif count > maxCount {\n\t\t\tmaxCount = count\n\t\t}\n\t}\n\t\n\treturn maxCount > len(connectedIPs)*8/10\n}\n\nfunc getSubnet(ip net.IP) string {\n\t// Get /24 subnet\n\tip = ip.To4()\n\treturn net.IP{ip[0], ip[1], ip[2], 0}.String()\n}\n```\n\n```javascript\nfunction detectEclipseAttack(connectedIPs) {\n    // Check IP diversity\n    const uniqueIPs = new Set(connectedIPs);\n    \n    // Check subnet distribution\n    const subnetCounts = {};\n    connectedIPs.forEach(ip => {\n        const subnet = getSubnet(ip);\n        subnetCounts[subnet] = (subnetCounts[subnet] || 0) + 1;\n    });\n    \n    // Suspicious if too many from same subnet\n    const maxCount = Math.max(...Object.values(subnetCounts));\n    return maxCount > connectedIPs.length * 0.8;\n}\n\nfunction getSubnet(ip) {\n    // Get /24 subnet\n    const parts = ip.split('.');\n    return `${parts[0]}.${parts[1]}.${parts[2]}.0`;\n}\n```\n:::\n\n---\n\n## Partition Attacks\n\n### Network Partition\n\nA **network partition** splits the network:\n\n```text\nPartition:\nNetwork A: Nodes 1-100\nNetwork B: Nodes 101-200\n\nResult:\n- Two separate blockchains\n- Eventually one wins (longest chain)\n- Transactions in losing partition invalidated\n```\n\n### Mitigation\n\n- **Multiple connections**: Reduces partition risk\n- **Geographic diversity**: Connect globally\n- **Wait for confirmations**: Don't trust 0-conf\n\n---\n\n## Denial of Service (DoS)\n\n### Transaction Flooding\n\nAttackers flood network with transactions:\n\n```text\nAttack:\n1. Create many low-fee transactions\n2. Fill mempool\n3. Legitimate transactions delayed\n4. Network congestion\n```\n\n**Mitigation**:\n- Fee-based prioritization\n- Mempool size limits\n- Transaction eviction policies\n\n### Connection Exhaustion\n\nAttackers exhaust node connections:\n\n```text\nAttack:\n1. Open many connections to node\n2. Exhaust connection limit\n3. Legitimate peers can't connect\n4. Node isolated\n```\n\n**Mitigation**:\n- Connection limits\n- Rate limiting\n- Ban malicious IPs\n\n---\n\n## Best Practices\n\n### For Node Operators\n\n1. **Diverse connections**: Connect to different IP ranges\n2. **Monitor connections**: Watch for suspicious patterns\n3. **Use firewall**: Limit exposure\n4. **Keep software updated**: Security patches\n\n### For Developers\n\n1. **Validate independently**: Don't trust peers\n2. **Handle network issues**: Graceful degradation\n3. **Implement timeouts**: Prevent hanging connections\n4. **Rate limit**: Prevent abuse\n\n---\n\n## Related Topics\n\n- [P2P Network Protocol](/docs/bitcoin/p2p-protocol) - Network communication\n- [Mining Attacks](/docs/mining/attacks) - Mining-specific attacks\n- [Node Types](/docs/development/node-types) - Node configurations\n\n---\n\n## Resources\n\n- [Bitcoin Network Security](https://en.bitcoin.it/wiki/Network_security)\n",
    "filename": "network-attacks.md"
  },
  "/docs/wallets": {
    "content": "# Bitcoin Wallets\n\n## Overview\n\nA Bitcoin wallet is a software application or device that allows users to store, send, and receive Bitcoin. Despite the name, a wallet doesn't actually \"store\" Bitcoin. Bitcoin exists only on the blockchain. Instead, a wallet stores the **[private keys](/docs/glossary#private-key)** needed to access and control Bitcoin [addresses](/docs/glossary#address).\n\n### Key Concepts\n\n- **Private Key**: Secret cryptographic key that proves ownership of Bitcoin\n- **Public Key**: Derived from private key, used to generate addresses\n- **Address**: Public identifier where Bitcoin can be received (like an account number)\n- **UTXO**: Unspent Transaction Output, the actual \"coins\" on the blockchain\n- **Seed Phrase**: Human-readable backup of private keys (12-24 words)\n\n---\n\n## Types of Wallets\n\n### By Storage Location\n\n#### Hot Wallets\n- **Online**: Connected to the internet\n- **Examples**: Mobile apps, web wallets, exchange wallets\n- **Pros**: Easy to use, quick access\n- **Cons**: More vulnerable to hacking\n\n#### Cold Wallets\n- **Offline**: Not connected to the internet\n- **Examples**: Hardware wallets, paper wallets\n- **Pros**: More secure, less vulnerable to attacks\n- **Cons**: Less convenient for frequent transactions\n\n### By Control\n\n#### Custodial Wallets\n- **Third-party control**: Exchange or service holds your keys\n- **Examples**: Coinbase, Binance wallets\n- **Pros**: Easy recovery, user-friendly\n- **Cons**: You don't control your keys (\"not your keys, not your coins\")\n\n#### Non-Custodial Wallets\n- **Self-custody**: You control your private keys\n- **Examples**: Electrum, Bitcoin Core, hardware wallets\n- **Pros**: Full control, more secure\n- **Cons**: You're responsible for key management\n\n### By Technology\n\n#### [Full Node](/docs/glossary#full-node) Wallets\n- **Bitcoin Core**: Downloads entire blockchain\n- **Pros**: Maximum privacy, validates all transactions\n- **Cons**: Requires significant storage and bandwidth\n\n#### [SPV](/docs/glossary#spv-simplified-payment-verification) (Simplified Payment Verification) Wallets\n- **Light clients**: Don't download full blockchain\n- **Pros**: Faster setup, less storage\n- **Cons**: Less privacy, relies on other nodes\n\n#### Hardware Wallets\n- **Physical devices**: Ledger, Trezor, Coldcard\n- **Pros**: Excellent security, keys never leave device\n- **Cons**: Cost, requires physical device\n\n---\n\n## How Wallets Work\n\n### Key Generation\n\n1. **Random Generation**: Private key is randomly generated (256 bits)\n2. **Public Key Derivation**: Public key derived using elliptic curve cryptography\n3. **Address Creation**: Address generated from public key using hash functions\n4. **Address Types**: [P2PKH](/docs/glossary#p2pkh-pay-to-pubkey-hash), [P2SH](/docs/glossary#p2sh-pay-to-script-hash), [P2WPKH](/docs/glossary#p2wpkh-pay-to-witness-pubkey-hash), [P2TR](/docs/glossary#p2tr-pay-to-taproot) (Taproot)\n\n### Transaction Process\n\n1. **UTXO Selection**: Wallet chooses which UTXOs to spend ([coin selection](/docs/glossary#coin-selection))\n2. **Transaction Creation**: Builds transaction with [inputs](/docs/glossary#input) and [outputs](/docs/glossary#output)\n3. **Signing**: Signs transaction with private key(s)\n4. **Broadcasting**: Sends transaction to Bitcoin network\n5. **Confirmation**: Transaction included in a block\n\n### Address Management\n\n- **HD Wallets**: Hierarchical Deterministic wallets generate addresses from a single seed\n- **Key Derivation**: Uses BIP32/BIP44 standards with [derivation paths](/docs/glossary#derivation-path)\n- **Address Reuse**: Generally discouraged for privacy\n- **Change Addresses**: New addresses created for change outputs\n\n---\n\n## Creating a Wallet\n\n### Software Wallet (Bitcoin Core)\n\n```bash\n# Install Bitcoin Core\n# Download from bitcoin.org\n\n# Start Bitcoin Core (will create wallet.dat)\nbitcoind -daemon\n\n# Create new wallet\nbitcoin-cli createwallet \"mywallet\"\n\n# Get new address\nbitcoin-cli getnewaddress\n\n# Get wallet info\nbitcoin-cli getwalletinfo\n```\n\n### Software Wallet (Electrum)\n\n1. **Download**: Get Electrum from electrum.org\n2. **Install**: Run installer for your platform\n3. **Create Wallet**: \n   - Choose \"Standard wallet\"\n   - Select \"Create a new seed\"\n   - Save seed phrase securely\n4. **Set Password**: Choose encryption password\n5. **Ready**: Wallet is created and ready to use\n\n### Hardware Wallet\n\n1. **Purchase**: Buy hardware wallet (Ledger, Trezor, etc.)\n2. **Initialize**: Follow device instructions\n3. **Generate Seed**: Device generates 24-word seed phrase\n4. **Backup Seed**: Write down seed phrase (never digital!)\n5. **Set PIN**: Create PIN for device access\n6. **Install Software**: Install companion app (Ledger Live, etc.)\n7. **Connect**: Connect device and create Bitcoin account\n\n### Programmatic Wallet Creation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey, PrivateKey,\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate key pair\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    // Create private key\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    \n    // Create public key and address (P2PKH)\n    let public_key = PublicKey::new(public_key);\n    let address = Address::p2pkh(&public_key, Network::Bitcoin);\n    \n    println!(\"Private Key (WIF): {}\", private_key);\n    println!(\"Address: {}\", address);\n}\n```\n\n```python\nimport secrets\nimport hashlib\nfrom ecdsa import SECP256k1, SigningKey\n\n# Generate random 256-bit private key\nprivate_key_bytes = secrets.token_bytes(32)\nprivate_key_hex = private_key_bytes.hex()\n\n# Derive public key using secp256k1\nsigning_key = SigningKey.from_string(private_key_bytes, curve=SECP256k1)\nverifying_key = signing_key.get_verifying_key()\npublic_key_bytes = b'\\x04' + verifying_key.to_string()  # Uncompressed\n\n# Generate P2PKH address\nsha256_hash = hashlib.sha256(public_key_bytes).digest()\nripemd160_hash = hashlib.new('ripemd160', sha256_hash).digest()\nversioned = b'\\x00' + ripemd160_hash  # 0x00 = mainnet\n\n# Double SHA256 for checksum\nchecksum = hashlib.sha256(hashlib.sha256(versioned).digest()).digest()[:4]\n\n# Base58Check encode\nimport base58\naddress = base58.b58encode(versioned + checksum).decode()\n\nprint(f\"Private Key: {private_key_hex}\")\nprint(f\"Address: {address}\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate random private key (256 bits)\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    // Derive public key\n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Generate P2PKH address\n    bc::wallet::ec_private private_key(secret, bc::wallet::ec_private::mainnet);\n    bc::wallet::payment_address address(public_key);\n    \n    std::cout << \"Private Key (WIF): \" << private_key.encoded() << std::endl;\n    std::cout << \"Address: \" << address.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc main() {\n\t// Generate key pair\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get private key (WIF format)\n\twif, err := btcutil.NewWIF(privateKey, &chaincfg.MainNetParams, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Generate address (P2PKH)\n\tpubKeyHash := btcutil.Hash160(privateKey.PubKey().SerializeCompressed())\n\taddr, err := btcutil.NewAddressPubKeyHash(pubKeyHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Private Key: %s\\n\", wif.String())\n\tfmt.Printf(\"Address: %s\\n\", addr.EncodeAddress())\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { randomBytes } = require('crypto');\n\n// Generate key pair\nconst keyPair = bitcoin.ECPair.makeRandom();\n\n// Get private key (WIF format)\nconst privateKey = keyPair.toWIF();\n\n// Generate address (P2PKH)\nconst { address } = bitcoin.payments.p2pkh({ \n  pubkey: keyPair.publicKey \n});\n\nconsole.log('Private Key:', privateKey);\nconsole.log('Address:', address);\n```\n:::\n\n---\n\n## Wallet Security Best Practices\n\n### Private Key Management\n\n- **Never share**: Never share your private keys or seed phrase\n- **Secure storage**: Store seed phrases offline, physically secure\n- **Multiple backups**: Create multiple backups in different locations\n- **No digital storage**: Never store seed phrases on computers or cloud\n\n### Security Measures\n\n- **Use hardware wallets**: For significant amounts\n- **Enable 2FA**: Where possible (for custodial wallets)\n- **Verify addresses**: Always verify receiving addresses\n- **Test transactions**: Send small amounts first\n- **Keep software updated**: Update wallet software regularly\n\n### Backup Strategies\n\n- **Seed phrase backup**: Write down seed phrase, store securely\n- **Multiple locations**: Keep backups in different physical locations\n- **Test recovery**: Verify you can recover wallet from seed phrase\n- **Encryption**: Encrypt backups if storing digitally (but prefer physical)\n\n---\n\n## Wallet Features\n\n### Basic Features\n\n- **Send Bitcoin**: Create and broadcast transactions\n- **Receive Bitcoin**: Generate addresses for receiving\n- **View Balance**: Check UTXO balance\n- **Transaction History**: View past transactions\n\n### Advanced Features\n\n- **[Multisig](/docs/glossary#multisig-multi-signature)**: Require multiple signatures\n- **Coin Control**: Manually select which UTXOs to spend\n- **Fee Estimation**: Calculate appropriate [fee rates](/docs/glossary#fee-rate)\n- **[RBF](/docs/glossary#rbf-replace-by-fee)**: Replace unconfirmed transactions\n- **[PSBT](/docs/glossary#psbt-partially-signed-bitcoin-transaction)**: Partially Signed Bitcoin Transactions\n\n---\n\n## Related Topics\n\n- [HD Wallets](/docs/wallets/hd-wallets) - Hierarchical deterministic wallet architecture\n- [Address Types](/docs/wallets/address-types) - Understanding different Bitcoin address formats\n- [Coin Selection](/docs/wallets/coin-selection) - How wallets choose UTXOs to spend\n- [Multisig](/docs/wallets/multisig) - Multi-signature wallet concepts\n- [Transaction Creation](/docs/wallets/transactions) - How to create and sign transactions\n- [Privacy Techniques](/docs/wallets/privacy) - CoinJoin, Payjoin, and privacy best practices\n- [Smart Contracts](/docs/wallets/smart-contracts) - Advanced scripting and contract patterns\n",
    "filename": "overview.md"
  },
  "/docs/wallets/hd-wallets": {
    "content": "# HD Wallets\n\nHierarchical Deterministic (HD) wallets generate all keys from a single master seed, enabling organized key management and simple backups. This is the foundation of modern Bitcoin wallet architecture.\n\n## Overview\n\nHD wallets, defined in [BIP32](/docs/glossary#bip-bitcoin-improvement-proposal), allow a wallet to derive an unlimited number of key pairs from a single master seed. Combined with BIP39 (mnemonic phrases) and BIP44 (account structure), this creates a powerful and standardized wallet system.\n\n**Key Benefits:**\n- Single backup (seed phrase) for all keys\n- Organized account and address structure\n- Watch-only wallets using extended public keys\n- Deterministic key generation across devices\n\n---\n\n## BIP39: Mnemonic Seed Phrases\n\nBIP39 defines how to generate human-readable seed phrases from random entropy.\n\n### Mnemonic Generation Process\n\n1. Generate random entropy (128-256 bits)\n2. Calculate checksum (first bits of SHA256 hash)\n3. Append checksum to entropy\n4. Split into 11-bit groups\n5. Map each group to a word from the 2048-word list\n\n| Entropy (bits) | Checksum (bits) | Words |\n|----------------|-----------------|-------|\n| 128 | 4 | 12 |\n| 160 | 5 | 15 |\n| 192 | 6 | 18 |\n| 224 | 7 | 21 |\n| 256 | 8 | 24 |\n\n### Generating a Mnemonic\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse bip39::{Mnemonic, Language};\n\nfn generate_mnemonic() -> Mnemonic {\n    // Generate a 24-word mnemonic (256 bits entropy)\n    Mnemonic::generate_in(Language::English, 24)\n        .expect(\"Failed to generate mnemonic\")\n}\n\nfn mnemonic_to_seed(mnemonic: &Mnemonic, passphrase: &str) -> [u8; 64] {\n    // Convert mnemonic to 512-bit seed using PBKDF2\n    mnemonic.to_seed(passphrase)\n}\n\nfn main() {\n    let mnemonic = generate_mnemonic();\n    println!(\"Mnemonic: {}\", mnemonic.to_string());\n    \n    // Optional passphrase (BIP39 calls this \"extension word\")\n    let seed = mnemonic_to_seed(&mnemonic, \"\");\n    println!(\"Seed: {}\", hex::encode(seed));\n}\n```\n\n```python\nfrom mnemonic import Mnemonic\nimport hashlib\nimport hmac\n\ndef generate_mnemonic(strength: int = 256) -> str:\n    \"\"\"Generate a BIP39 mnemonic phrase.\n    \n    Args:\n        strength: Entropy bits (128=12 words, 256=24 words)\n    \n    Returns:\n        Space-separated mnemonic words\n    \"\"\"\n    mnemo = Mnemonic(\"english\")\n    return mnemo.generate(strength=strength)\n\ndef mnemonic_to_seed(mnemonic: str, passphrase: str = \"\") -> bytes:\n    \"\"\"Convert mnemonic to 512-bit seed using PBKDF2.\n    \n    Args:\n        mnemonic: Space-separated mnemonic words\n        passphrase: Optional passphrase (BIP39 extension word)\n    \n    Returns:\n        64-byte seed\n    \"\"\"\n    mnemo = Mnemonic(\"english\")\n    return mnemo.to_seed(mnemonic, passphrase)\n\n# Generate 24-word mnemonic\nmnemonic = generate_mnemonic(256)\nprint(f\"Mnemonic: {mnemonic}\")\n\n# Convert to seed (no passphrase)\nseed = mnemonic_to_seed(mnemonic)\nprint(f\"Seed: {seed.hex()}\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n#include <string>\n\nint main() {\n    // Generate entropy (256 bits for 24 words)\n    bc::data_chunk entropy(32);\n    bc::pseudo_random_fill(entropy);\n    \n    // Create mnemonic from entropy\n    bc::wallet::word_list mnemonic = bc::wallet::create_mnemonic(entropy);\n    \n    std::cout << \"Mnemonic: \";\n    for (const auto& word : mnemonic) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n    \n    // Convert to seed (empty passphrase)\n    bc::long_hash seed = bc::wallet::decode_mnemonic(mnemonic);\n    std::cout << \"Seed: \" << bc::encode_base16(seed) << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bip39 = require('bip39');\n\nfunction generateMnemonic(strength = 256) {\n    // Generate mnemonic (128=12 words, 256=24 words)\n    return bip39.generateMnemonic(strength);\n}\n\nasync function mnemonicToSeed(mnemonic, passphrase = '') {\n    // Convert mnemonic to 512-bit seed using PBKDF2\n    return bip39.mnemonicToSeed(mnemonic, passphrase);\n}\n\n// Generate 24-word mnemonic\nconst mnemonic = generateMnemonic(256);\nconsole.log('Mnemonic:', mnemonic);\n\n// Convert to seed\nmnemonicToSeed(mnemonic).then(seed => {\n    console.log('Seed:', seed.toString('hex'));\n});\n\n// Note: When using bip32 for key derivation, use BIP32Factory:\n// const { BIP32Factory } = require('bip32');\n// const ecc = require('tiny-secp256k1');\n// const bip32 = BIP32Factory(ecc);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tyler-smith/go-bip39\"\n)\n\nfunc generateMnemonic(strength int) (string, error) {\n\t// Generate mnemonic (128=12 words, 256=24 words)\n\tentropy, err := bip39.NewEntropy(strength)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn bip39.NewMnemonic(entropy)\n}\n\nfunc mnemonicToSeed(mnemonic, passphrase string) ([]byte, error) {\n\t// Convert mnemonic to 512-bit seed using PBKDF2\n\treturn bip39.NewSeedWithErrorChecking(mnemonic, passphrase)\n}\n\nfunc main() {\n\t// Generate 24-word mnemonic\n\tmnemonic, err := generateMnemonic(256)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Mnemonic: %s\\n\", mnemonic)\n\n\t// Convert to seed (no passphrase)\n\tseed, err := mnemonicToSeed(mnemonic, \"\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Seed: %x\\n\", seed)\n}\n```\n:::\n\n---\n\n## BIP32: Key Derivation\n\nBIP32 defines how to derive child keys from parent keys using a hierarchical structure.\n\n### Extended Keys\n\nExtended keys contain additional metadata for derivation:\n\n- **Extended Private Key (xprv)**: Can derive child private and public keys\n- **Extended Public Key (xpub)**: Can only derive child public keys\n\n```\nxprv = [4 bytes version][1 byte depth][4 bytes fingerprint][4 bytes child index][32 bytes chain code][33 bytes key]\n```\n\n### Derivation Paths\n\nDerivation paths use slash-separated indices:\n\n```\nm / purpose' / coin_type' / account' / change / address_index\n```\n\n**Examples:**\n- `m/44'/0'/0'/0/0` - First receiving address (BIP44 legacy)\n- `m/84'/0'/0'/0/0` - First receiving address (BIP84 native SegWit)\n- `m/86'/0'/0'/0/0` - First receiving address (BIP86 Taproot)\n\nThe apostrophe (') indicates hardened derivation.\n\n### Hardened vs Normal Derivation\n\n| Type | Index Range | Security | Use Case |\n|------|-------------|----------|----------|\n| Normal | 0 to 2^31-1 | Child xpub can derive siblings | Receiving addresses |\n| Hardened | 2^31 to 2^32-1 | Child xpub cannot derive siblings | Account separation |\n\n**Security Note:** Always use hardened derivation for account-level keys. If a normal child private key is compromised along with the parent xpub, all sibling private keys can be derived.\n\n### Deriving Keys from Seed\n\n:::code-group\n```rust\nuse bitcoin::bip32::{Xpriv, Xpub, DerivationPath};\nuse bitcoin::Network;\nuse std::str::FromStr;\n\nfn derive_keys(seed: &[u8]) {\n    // Create master key from seed\n    let master = Xpriv::new_master(Network::Bitcoin, seed)\n        .expect(\"Failed to create master key\");\n    \n    println!(\"Master xprv: {}\", master);\n    \n    // Derive BIP84 path: m/84'/0'/0'/0/0\n    let secp = bitcoin::secp256k1::Secp256k1::new();\n    let path = DerivationPath::from_str(\"m/84'/0'/0'/0/0\").unwrap();\n    let derived = master.derive_priv(&secp, &path).unwrap();\n    \n    println!(\"Derived private key: {}\", derived);\n    \n    // Get public key\n    let xpub = Xpub::from_priv(&secp, &derived);\n    println!(\"Derived public key: {}\", xpub);\n}\n```\n\n```python\nfrom bip32 import BIP32\nfrom mnemonic import Mnemonic\n\ndef derive_keys(seed: bytes):\n    \"\"\"Derive keys using BIP32 hierarchical derivation.\"\"\"\n    # Create BIP32 instance from seed\n    bip32 = BIP32.from_seed(seed)\n    \n    # Get master extended private key\n    master_xprv = bip32.get_xpriv_from_path(\"m\")\n    print(f\"Master xprv: {master_xprv}\")\n    \n    # Derive BIP84 path: m/84'/0'/0'/0/0\n    # 84' = purpose (native SegWit)\n    # 0' = coin type (Bitcoin mainnet)\n    # 0' = account\n    # 0 = external chain (receiving)\n    # 0 = first address\n    path = \"m/84'/0'/0'/0/0\"\n    \n    derived_xprv = bip32.get_xpriv_from_path(path)\n    derived_xpub = bip32.get_xpub_from_path(path)\n    \n    print(f\"Derived xprv: {derived_xprv}\")\n    print(f\"Derived xpub: {derived_xpub}\")\n    \n    # Get raw private and public keys\n    privkey = bip32.get_privkey_from_path(path)\n    pubkey = bip32.get_pubkey_from_path(path)\n    \n    print(f\"Private key: {privkey.hex()}\")\n    print(f\"Public key: {pubkey.hex()}\")\n\n# Generate seed from mnemonic\nmnemo = Mnemonic(\"english\")\nmnemonic = mnemo.generate(256)\nseed = mnemo.to_seed(mnemonic)\n\nderive_keys(seed)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate seed from mnemonic\n    bc::data_chunk entropy(32);\n    bc::pseudo_random_fill(entropy);\n    bc::wallet::word_list mnemonic = bc::wallet::create_mnemonic(entropy);\n    bc::long_hash seed = bc::wallet::decode_mnemonic(mnemonic);\n    \n    // Create HD private key from seed\n    bc::wallet::hd_private master(seed, bc::wallet::hd_private::mainnet);\n    std::cout << \"Master xprv: \" << master.encoded() << std::endl;\n    \n    // Derive BIP84 path: m/84'/0'/0'/0/0\n    // Using hardened derivation for first 3 levels\n    auto purpose = master.derive_private(84 + bc::wallet::hd_first_hardened_key);\n    auto coin = purpose.derive_private(0 + bc::wallet::hd_first_hardened_key);\n    auto account = coin.derive_private(0 + bc::wallet::hd_first_hardened_key);\n    auto change = account.derive_private(0);  // Normal derivation\n    auto address = change.derive_private(0);  // Normal derivation\n    \n    std::cout << \"Derived xprv: \" << address.encoded() << std::endl;\n    \n    // Get public key\n    bc::wallet::hd_public xpub = address.to_public();\n    std::cout << \"Derived xpub: \" << xpub.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst { BIP32Factory } = require('bip32');\nconst ecc = require('tiny-secp256k1');\nconst bip39 = require('bip39');\n\n// Initialize bip32 with the elliptic curve library\nconst bip32 = BIP32Factory(ecc);\n\nasync function deriveKeys(mnemonic) {\n    // Convert mnemonic to seed\n    const seed = await bip39.mnemonicToSeed(mnemonic);\n    \n    // Create master key from seed\n    const master = bip32.fromSeed(seed);\n    console.log('Master xprv:', master.toBase58());\n    \n    // Derive BIP84 path: m/84'/0'/0'/0/0\n    // 84' = purpose (native SegWit)\n    // 0' = coin type (Bitcoin mainnet)\n    // 0' = account\n    // 0 = external chain (receiving)\n    // 0 = first address\n    const path = \"m/84'/0'/0'/0/0\";\n    const derived = master.derivePath(path);\n    \n    console.log('Derived xprv:', derived.toBase58());\n    console.log('Derived xpub:', derived.neutered().toBase58());\n    console.log('Private key:', derived.privateKey.toString('hex'));\n    console.log('Public key:', derived.publicKey.toString('hex'));\n}\n\nconst mnemonic = bip39.generateMnemonic(256);\nconsole.log('Mnemonic:', mnemonic);\nderiveKeys(mnemonic);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tyler-smith/go-bip32\"\n\t\"github.com/tyler-smith/go-bip39\"\n)\n\nfunc deriveKeys(mnemonic string) error {\n\t// Convert mnemonic to seed\n\tseed, err := bip39.NewSeedWithErrorChecking(mnemonic, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create master key from seed\n\tmaster, err := bip32.NewMasterKey(seed)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Printf(\"Master xprv: %s\\n\", master.B58Serialize())\n\n\t// Derive BIP84 path: m/84'/0'/0'/0/0\n\t// 84' = purpose (native SegWit)\n\t// 0' = coin type (Bitcoin mainnet)\n\t// 0' = account\n\t// 0 = external chain (receiving)\n\t// 0 = first address\n\tpurpose, err := master.NewChildKey(bip32.FirstHardenedChild + 84)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcoin, err := purpose.NewChildKey(bip32.FirstHardenedChild + 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\taccount, err := coin.NewChildKey(bip32.FirstHardenedChild + 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tchange, err := account.NewChildKey(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\taddress, err := change.NewChildKey(0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Derived xprv: %s\\n\", address.B58Serialize())\n\tfmt.Printf(\"Derived xpub: %s\\n\", address.PublicKey().B58Serialize())\n\tfmt.Printf(\"Private key: %x\\n\", address.Key)\n\tfmt.Printf(\"Public key: %x\\n\", address.PublicKey().Key)\n\n\treturn nil\n}\n\nfunc main() {\n\tmnemonic, _ := bip39.NewMnemonic(bip39.NewEntropy(256))\n\tfmt.Printf(\"Mnemonic: %s\\n\", mnemonic)\n\tderiveKeys(mnemonic)\n}\n```\n:::\n\n---\n\n## BIP44: Multi-Account Hierarchy\n\nBIP44 defines a standard account structure for HD wallets.\n\n### Path Structure\n\n```\nm / purpose' / coin_type' / account' / change / address_index\n```\n\n| Level | Hardened | Description |\n|-------|----------|-------------|\n| purpose | Yes | BIP number (44, 49, 84, 86) |\n| coin_type | Yes | Coin identifier (0 = Bitcoin) |\n| account | Yes | Account index (0, 1, 2...) |\n| change | No | 0 = external (receiving), 1 = internal (change) |\n| address_index | No | Address index within chain |\n\n### Purpose Values by Address Type\n\n| BIP | Purpose | Address Type | Prefix |\n|-----|---------|--------------|--------|\n| BIP44 | 44' | P2PKH (Legacy) | 1... |\n| BIP49 | 49' | P2SH-P2WPKH (Nested SegWit) | 3... |\n| BIP84 | 84' | P2WPKH (Native SegWit) | bc1q... |\n| BIP86 | 86' | P2TR (Taproot) | bc1p... |\n\n---\n\n## Watch-Only Wallets\n\nExtended public keys (xpubs) enable watch-only wallets that can:\n- Generate receiving addresses\n- Monitor incoming transactions\n- Calculate balances\n\n**Without** being able to spend funds (no private keys).\n\n### Creating a Watch-Only Wallet\n\n:::code-group\n```rust\nuse bitcoin::bip32::{Xpub, DerivationPath};\nuse bitcoin::Address;\nuse std::str::FromStr;\n\nfn generate_addresses_from_xpub(xpub: &str, count: u32) {\n    let secp = bitcoin::secp256k1::Secp256k1::new();\n    let xpub = Xpub::from_str(xpub).expect(\"Invalid xpub\");\n    \n    // Generate receiving addresses (change = 0)\n    for i in 0..count {\n        let path = DerivationPath::from_str(&format!(\"m/0/{}\", i)).unwrap();\n        let derived = xpub.derive_pub(&secp, &path).unwrap();\n        let address = Address::p2wpkh(&derived.public_key, bitcoin::Network::Bitcoin);\n        println!(\"Address {}: {}\", i, address);\n    }\n}\n```\n\n```python\nfrom bip32 import BIP32\nimport bech32\n\ndef generate_addresses_from_xpub(xpub: str, count: int = 5):\n    \"\"\"Generate receiving addresses from an extended public key.\"\"\"\n    bip32 = BIP32.from_xpub(xpub)\n    \n    for i in range(count):\n        # Derive child public key (0 = receiving chain)\n        pubkey = bip32.get_pubkey_from_path(f\"m/0/{i}\")\n        \n        # Generate P2WPKH address\n        import hashlib\n        sha256_hash = hashlib.sha256(pubkey).digest()\n        ripemd160_hash = hashlib.new('ripemd160', sha256_hash).digest()\n        \n        # Bech32 encode\n        converted = bech32.convertbits(list(ripemd160_hash), 8, 5)\n        address = bech32.bech32_encode(\"bc\", [0] + converted)\n        \n        print(f\"Address {i}: {address}\")\n\n# Example xpub (DO NOT USE - for demonstration only)\nxpub = \"xpub...\"\ngenerate_addresses_from_xpub(xpub, 5)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nvoid generate_addresses_from_xpub(const std::string& xpub_str, uint32_t count) {\n    bc::wallet::hd_public xpub(xpub_str);\n    \n    for (uint32_t i = 0; i < count; ++i) {\n        // Derive: xpub/0/i (receiving chain)\n        auto chain = xpub.derive_public(0);\n        auto derived = chain.derive_public(i);\n        \n        // Generate P2WPKH address\n        bc::wallet::payment_address address(\n            derived.point(),\n            bc::wallet::payment_address::mainnet_p2kh\n        );\n        \n        std::cout << \"Address \" << i << \": \" << address.encoded() << std::endl;\n    }\n}\n```\n\n```javascript\nconst { BIP32Factory } = require('bip32');\nconst ecc = require('tiny-secp256k1');\nconst bitcoin = require('bitcoinjs-lib');\n\n// Initialize bip32 with the elliptic curve library\nconst bip32 = BIP32Factory(ecc);\n\nfunction generateAddressesFromXpub(xpubString, count = 5) {\n    const xpub = bip32.fromBase58(xpubString);\n    \n    for (let i = 0; i < count; i++) {\n        // Derive: xpub/0/i (receiving chain)\n        const derived = xpub.derive(0).derive(i);\n        \n        // Generate P2WPKH address\n        const { address } = bitcoin.payments.p2wpkh({\n            pubkey: derived.publicKey,\n            network: bitcoin.networks.bitcoin\n        });\n        \n        console.log(`Address ${i}: ${address}`);\n    }\n}\n\n// Example usage with account xpub\nconst xpub = 'xpub...';\ngenerateAddressesFromXpub(xpub, 5);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/tyler-smith/go-bip32\"\n)\n\nfunc generateAddressesFromXpub(xpubString string, count int) error {\n\t// Parse extended public key\n\txpub, err := bip32.B58Deserialize(xpubString)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < count; i++ {\n\t\t// Derive: xpub/0/i (receiving chain)\n\t\tchange, err := xpub.NewChildKey(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\taddressKey, err := change.NewChildKey(uint32(i))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Generate P2WPKH address\n\t\tpubkeyHash := btcutil.Hash160(addressKey.Key)\n\t\taddr, err := btcutil.NewAddressWitnessPubKeyHash(pubkeyHash, &chaincfg.MainNetParams)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Printf(\"Address %d: %s\\n\", i, addr.EncodeAddress())\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage with account xpub\n\txpub := \"xpub...\" // Extended public key\n\tgenerateAddressesFromXpub(xpub, 5)\n}\n```\n:::\n\n---\n\n## Security Best Practices\n\n### Seed Phrase Storage\n\n- **Physical backup**: Write on paper or metal, store securely\n- **Never digital**: Don't store on computers, phones, or cloud\n- **Multiple copies**: Keep backups in separate locations\n- **Test recovery**: Verify you can restore from backup\n\n### Passphrase (25th Word)\n\nBIP39 supports an optional passphrase that:\n- Creates a completely different wallet\n- Provides plausible deniability\n- Adds another layer of security\n\n**Warning:** A forgotten passphrase means permanent loss of funds.\n\n### Extended Public Key Exposure\n\nExposing an xpub reveals:\n- All past and future addresses\n- Complete transaction history\n- Total balance\n\n**Never share xpubs publicly** unless intentional (e.g., donation addresses).\n\n---\n\n## Gap Limit\n\nThe gap limit determines how many unused addresses to scan before stopping. Default is typically 20.\n\n**Important for wallet recovery:** If you used addresses beyond the gap limit without using intermediate addresses, those funds may not appear in a recovered wallet.\n\n---\n\n## Summary\n\nHD wallets provide:\n\n- **Single backup**: One seed phrase backs up all keys\n- **Organized structure**: Hierarchical account and address management\n- **Watch-only capability**: Monitor without spending ability\n- **Standardization**: BIP32/39/44 ensure wallet interoperability\n- **Security**: Hardened derivation protects account-level keys\n\nUnderstanding HD wallets is essential for building modern Bitcoin wallet applications.\n\n---\n\n## Related Topics\n\n- [Bitcoin Wallets](/docs/wallets) - Introduction to Bitcoin wallets\n- [Address Types](/docs/wallets/address-types) - Understanding different Bitcoin address formats\n- [Key Management](/docs/bitcoin-development/keys) - Secure key generation and storage\n- [Cryptography](/docs/bitcoin/cryptography) - Elliptic curve cryptography fundamentals\n",
    "filename": "hd-wallets.md"
  },
  "/docs/wallets/address-types": {
    "content": "# Address Types\n\nBitcoin has evolved through several address formats, each offering different features, security properties, and transaction costs. Understanding these types is essential for wallet development.\n\n## Overview\n\n| Type | Prefix | Example Start | Introduced |\n|------|--------|---------------|------------|\n| P2PKH | `1` | `1BvBMSEYstW...` | 2009 (Genesis) |\n| P2SH | `3` | `3J98t1WpEZ7...` | 2012 (BIP16) |\n| P2WPKH | `bc1q` | `bc1qw508d6q...` | 2017 (BIP141) |\n| P2WSH | `bc1q` | `bc1qrp33g0q...` | 2017 (BIP141) |\n| P2TR | `bc1p` | `bc1p5cyxnux...` | 2021 (BIP341) |\n\n---\n\n## P2PKH (Pay-to-Public-Key-Hash)\n\nThe original Bitcoin address format, also known as \"legacy\" addresses.\n\n### Structure\n\n```\nscriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\nscriptSig: <signature> <publicKey>\n```\n\n### Address Generation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey, PrivateKey,\n};\n\nfn generate_p2pkh_address() -> (PrivateKey, Address) {\n    let secp = Secp256k1::new();\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    let public_key = PublicKey::new(public_key);\n    \n    // Create P2PKH address (starts with '1')\n    let address = Address::p2pkh(&public_key, Network::Bitcoin);\n    \n    (private_key, address)\n}\n\nfn main() {\n    let (privkey, address) = generate_p2pkh_address();\n    println!(\"Private Key (WIF): {}\", privkey);\n    println!(\"P2PKH Address: {}\", address);\n    // Output: 1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\n}\n```\n\n```python\nimport secrets\nimport hashlib\nimport base58\n\ndef generate_p2pkh_address():\n    \"\"\"Generate a P2PKH (legacy) Bitcoin address.\"\"\"\n    from ecdsa import SECP256k1, SigningKey\n    \n    # Generate private key\n    private_key = secrets.token_bytes(32)\n    \n    # Derive public key\n    signing_key = SigningKey.from_string(private_key, curve=SECP256k1)\n    verifying_key = signing_key.get_verifying_key()\n    \n    # Compressed public key (33 bytes)\n    x = verifying_key.point.x()\n    y = verifying_key.point.y()\n    prefix = b'\\x02' if y % 2 == 0 else b'\\x03'\n    public_key = prefix + x.to_bytes(32, 'big')\n    \n    # Hash160 = RIPEMD160(SHA256(pubkey))\n    sha256_hash = hashlib.sha256(public_key).digest()\n    ripemd160_hash = hashlib.new('ripemd160', sha256_hash).digest()\n    \n    # Add version byte (0x00 for mainnet)\n    versioned = b'\\x00' + ripemd160_hash\n    \n    # Double SHA256 checksum\n    checksum = hashlib.sha256(hashlib.sha256(versioned).digest()).digest()[:4]\n    \n    # Base58Check encode\n    address = base58.b58encode(versioned + checksum).decode()\n    \n    return private_key.hex(), address\n\nprivkey, address = generate_p2pkh_address()\nprint(f\"Private Key: {privkey}\")\nprint(f\"P2PKH Address: {address}\")  # Starts with '1'\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate random private key\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    // Derive compressed public key\n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Create P2PKH address\n    bc::wallet::payment_address address(public_key, \n        bc::wallet::payment_address::mainnet_p2kh);\n    \n    // Get WIF private key\n    bc::wallet::ec_private wif(secret, bc::wallet::ec_private::mainnet);\n    \n    std::cout << \"Private Key (WIF): \" << wif.encoded() << std::endl;\n    std::cout << \"P2PKH Address: \" << address.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\n\nfunction generateP2PKHAddress() {\n    // Generate key pair\n    const keyPair = ECPair.makeRandom();\n    \n    // Create P2PKH address\n    const { address } = bitcoin.payments.p2pkh({\n        pubkey: keyPair.publicKey,\n        network: bitcoin.networks.bitcoin\n    });\n    \n    return {\n        privateKey: keyPair.toWIF(),\n        address: address  // Starts with '1'\n    };\n}\n\nconst { privateKey, address } = generateP2PKHAddress();\nconsole.log('Private Key (WIF):', privateKey);\nconsole.log('P2PKH Address:', address);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc generateP2PKHAddress() (string, string) {\n\t// Generate key pair\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get WIF private key\n\twif, err := btcutil.NewWIF(privateKey, &chaincfg.MainNetParams, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create P2PKH address\n\tpubkeyHash := btcutil.Hash160(privateKey.PubKey().SerializeCompressed())\n\taddr, err := btcutil.NewAddressPubKeyHash(pubkeyHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn wif.String(), addr.EncodeAddress()\n}\n\nfunc main() {\n\tprivateKey, address := generateP2PKHAddress()\n\tfmt.Printf(\"Private Key (WIF): %s\\n\", privateKey)\n\tfmt.Printf(\"P2PKH Address: %s\\n\", address) // Starts with '1'\n}\n```\n:::\n\n### Characteristics\n\n- **Size**: 34 characters\n- **Input size**: ~148 vB\n- **Output size**: 34 vB\n- **Script type**: Standard pay-to-pubkey-hash\n\n---\n\n## P2SH (Pay-to-Script-Hash)\n\nIntroduced in BIP16, P2SH allows complex scripts to be represented by a simple hash.\n\n### Structure\n\n```\nscriptPubKey: OP_HASH160 <scriptHash> OP_EQUAL\nscriptSig: <data> <redeemScript>\n```\n\n### Common Uses\n\n- Multisig addresses (before SegWit)\n- Nested SegWit (P2SH-P2WPKH)\n- Time-locked scripts\n\n### Address Generation (P2SH-P2WPKH)\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey,\n};\n\nfn generate_p2sh_p2wpkh_address() -> Address {\n    let secp = Secp256k1::new();\n    let (_, public_key) = secp.generate_keypair(&mut OsRng);\n    let public_key = PublicKey::new(public_key);\n    \n    // Create P2SH-P2WPKH (nested SegWit, starts with '3')\n    Address::p2shwpkh(&public_key, Network::Bitcoin)\n        .expect(\"Failed to create address\")\n}\n\nfn main() {\n    let address = generate_p2sh_p2wpkh_address();\n    println!(\"P2SH-P2WPKH Address: {}\", address);\n    // Output: 3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\n}\n```\n\n```python\nimport hashlib\nimport base58\n\ndef generate_p2sh_p2wpkh_address(public_key: bytes) -> str:\n    \"\"\"Generate a P2SH-P2WPKH (nested SegWit) address.\"\"\"\n    # Create witness program (P2WPKH)\n    sha256_hash = hashlib.sha256(public_key).digest()\n    pubkey_hash = hashlib.new('ripemd160', sha256_hash).digest()\n    \n    # Witness script: OP_0 <20-byte-pubkey-hash>\n    witness_script = b'\\x00\\x14' + pubkey_hash\n    \n    # Hash the witness script for P2SH\n    script_hash = hashlib.new('ripemd160', \n        hashlib.sha256(witness_script).digest()).digest()\n    \n    # Add version byte (0x05 for P2SH mainnet)\n    versioned = b'\\x05' + script_hash\n    \n    # Checksum and encode\n    checksum = hashlib.sha256(hashlib.sha256(versioned).digest()).digest()[:4]\n    address = base58.b58encode(versioned + checksum).decode()\n    \n    return address  # Starts with '3'\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate key pair\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Create P2SH-P2WPKH address\n    // First create the witness program\n    bc::short_hash pubkey_hash = bc::bitcoin_short_hash(public_key);\n    \n    // Witness script: OP_0 <pubkey_hash>\n    bc::data_chunk witness_script;\n    witness_script.push_back(0x00);  // OP_0\n    witness_script.push_back(0x14);  // Push 20 bytes\n    witness_script.insert(witness_script.end(), \n        pubkey_hash.begin(), pubkey_hash.end());\n    \n    // Hash for P2SH\n    bc::short_hash script_hash = bc::bitcoin_short_hash(witness_script);\n    \n    bc::wallet::payment_address address(script_hash, \n        bc::wallet::payment_address::mainnet_p2sh);\n    \n    std::cout << \"P2SH-P2WPKH Address: \" << address.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\n\nfunction generateP2SHP2WPKHAddress() {\n    const keyPair = ECPair.makeRandom();\n    \n    // Create P2SH-P2WPKH (nested SegWit)\n    const p2wpkh = bitcoin.payments.p2wpkh({\n        pubkey: keyPair.publicKey,\n        network: bitcoin.networks.bitcoin\n    });\n    \n    const p2sh = bitcoin.payments.p2sh({\n        redeem: p2wpkh,\n        network: bitcoin.networks.bitcoin\n    });\n    \n    return {\n        privateKey: keyPair.toWIF(),\n        address: p2sh.address  // Starts with '3'\n    };\n}\n\nconst { privateKey, address } = generateP2SHP2WPKHAddress();\nconsole.log('P2SH-P2WPKH Address:', address);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc generateP2SHP2WPKHAddress() (string, string) {\n\t// Generate key pair\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get WIF private key\n\twif, err := btcutil.NewWIF(privateKey, &chaincfg.MainNetParams, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create P2WPKH witness program\n\tpubkeyHash := btcutil.Hash160(privateKey.PubKey().SerializeCompressed())\n\twitnessProgram := append([]byte{0x00, 0x14}, pubkeyHash...)\n\n\t// Create P2SH address from witness program\n\tscriptHash := btcutil.Hash160(witnessProgram)\n\taddr, err := btcutil.NewAddressScriptHashFromHash(scriptHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn wif.String(), addr.EncodeAddress()\n}\n\nfunc main() {\n\tprivateKey, address := generateP2SHP2WPKHAddress()\n\tfmt.Printf(\"Private Key (WIF): %s\\n\", privateKey)\n\tfmt.Printf(\"P2SH-P2WPKH Address: %s\\n\", address) // Starts with '3'\n}\n```\n:::\n\n### Characteristics\n\n- **Size**: 34 characters\n- **Input size**: ~91 vB (for P2SH-P2WPKH)\n- **Output size**: 32 vB\n- **Script type**: Pay-to-script-hash\n\n---\n\n## P2WPKH (Native SegWit)\n\nIntroduced with [SegWit](/docs/glossary#segwit-segregated-witness) in BIP141, P2WPKH provides significant fee savings.\n\n### Structure\n\n```\nscriptPubKey: OP_0 <20-byte-pubkey-hash>\nwitness: <signature> <publicKey>\n```\n\n### Address Generation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey,\n};\n\nfn generate_p2wpkh_address() -> Address {\n    let secp = Secp256k1::new();\n    let (_, public_key) = secp.generate_keypair(&mut OsRng);\n    let public_key = PublicKey::new(public_key);\n    \n    // Create P2WPKH (native SegWit, starts with 'bc1q')\n    Address::p2wpkh(&public_key, Network::Bitcoin)\n        .expect(\"Failed to create address\")\n}\n\nfn main() {\n    let address = generate_p2wpkh_address();\n    println!(\"P2WPKH Address: {}\", address);\n    // Output: bc1qw508d6qejxtdg4y5r3zarvary0c5xw7kv8f3t4\n}\n```\n\n```python\nimport hashlib\nimport bech32\n\ndef generate_p2wpkh_address(public_key: bytes, mainnet: bool = True) -> str:\n    \"\"\"Generate a P2WPKH (native SegWit) address.\"\"\"\n    # Hash160 of public key\n    sha256_hash = hashlib.sha256(public_key).digest()\n    pubkey_hash = hashlib.new('ripemd160', sha256_hash).digest()\n    \n    # Bech32 encode with witness version 0\n    hrp = \"bc\" if mainnet else \"tb\"\n    \n    # Convert to 5-bit groups\n    converted = bech32.convertbits(list(pubkey_hash), 8, 5)\n    \n    # Witness version 0 + converted data\n    address = bech32.bech32_encode(hrp, [0] + converted)\n    \n    return address  # Starts with 'bc1q'\n\n# Example with generated public key\nfrom ecdsa import SECP256k1, SigningKey\nimport secrets\n\nprivate_key = secrets.token_bytes(32)\nsigning_key = SigningKey.from_string(private_key, curve=SECP256k1)\nvk = signing_key.get_verifying_key()\n\n# Compressed public key\nx = vk.point.x()\ny = vk.point.y()\nprefix = b'\\x02' if y % 2 == 0 else b'\\x03'\npublic_key = prefix + x.to_bytes(32, 'big')\n\naddress = generate_p2wpkh_address(public_key)\nprint(f\"P2WPKH Address: {address}\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate key pair\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Hash160 of public key\n    bc::short_hash pubkey_hash = bc::bitcoin_short_hash(public_key);\n    \n    // Create witness program\n    bc::data_chunk witness_program;\n    witness_program.push_back(0x00);  // Witness version 0\n    witness_program.push_back(0x14);  // Push 20 bytes\n    witness_program.insert(witness_program.end(), \n        pubkey_hash.begin(), pubkey_hash.end());\n    \n    // Bech32 encode\n    std::string address = bc::wallet::encode_witness_address(\n        \"bc\", witness_program);\n    \n    std::cout << \"P2WPKH Address: \" << address << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\n\nfunction generateP2WPKHAddress() {\n    const keyPair = ECPair.makeRandom();\n    \n    // Create P2WPKH (native SegWit)\n    const { address } = bitcoin.payments.p2wpkh({\n        pubkey: keyPair.publicKey,\n        network: bitcoin.networks.bitcoin\n    });\n    \n    return {\n        privateKey: keyPair.toWIF(),\n        address: address  // Starts with 'bc1q'\n    };\n}\n\nconst { privateKey, address } = generateP2WPKHAddress();\nconsole.log('P2WPKH Address:', address);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc generateP2WPKHAddress() (string, string) {\n\t// Generate key pair\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get WIF private key\n\twif, err := btcutil.NewWIF(privateKey, &chaincfg.MainNetParams, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Create P2WPKH (native SegWit) address\n\tpubkeyHash := btcutil.Hash160(privateKey.PubKey().SerializeCompressed())\n\taddr, err := btcutil.NewAddressWitnessPubKeyHash(pubkeyHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn wif.String(), addr.EncodeAddress()\n}\n\nfunc main() {\n\tprivateKey, address := generateP2WPKHAddress()\n\tfmt.Printf(\"Private Key (WIF): %s\\n\", privateKey)\n\tfmt.Printf(\"P2WPKH Address: %s\\n\", address) // Starts with 'bc1q'\n}\n```\n:::\n\n### Characteristics\n\n- **Size**: 42 characters (bc1q + 39 chars)\n- **Input size**: ~68 vB\n- **Output size**: 31 vB\n- **Encoding**: Bech32\n\n---\n\n## P2WSH (Pay-to-Witness-Script-Hash)\n\nP2WSH is the SegWit version of P2SH, used for complex scripts like multisig.\n\n### Structure\n\n```\nscriptPubKey: OP_0 <32-byte-script-hash>\nwitness: <data...> <witnessScript>\n```\n\n### Characteristics\n\n- **Size**: 62 characters (bc1q + 59 chars)\n- **Input size**: Variable (depends on witness script)\n- **Output size**: 43 vB\n- **Encoding**: Bech32\n\n---\n\n## P2TR (Pay-to-Taproot)\n\nIntroduced in BIP341, [Taproot](/docs/glossary#taproot) provides the best combination of privacy, efficiency, and flexibility.\n\n### Structure\n\nKey path spend:\n```\nscriptPubKey: OP_1 <32-byte-tweaked-pubkey>\nwitness: <signature>\n```\n\nScript path spend:\n```\nwitness: <script input> <script> <control block>\n```\n\n### Address Generation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng, XOnlyPublicKey},\n    Address, Network,\n};\n\nfn generate_p2tr_address() -> Address {\n    let secp = Secp256k1::new();\n    let (secret_key, public_key) = secp.generate_keypair(&mut OsRng);\n    \n    // Convert to x-only public key for Taproot\n    let (xonly, _parity) = public_key.x_only_public_key();\n    \n    // Create P2TR address (starts with 'bc1p')\n    Address::p2tr(&secp, xonly, None, Network::Bitcoin)\n}\n\nfn main() {\n    let address = generate_p2tr_address();\n    println!(\"P2TR Address: {}\", address);\n    // Output: bc1p5cyxnuxmeuwuvkwfem96lqzszd02n6xdcjrs20cac6yqjjwudpxqkedrcr\n}\n```\n\n```python\nimport hashlib\nimport bech32\n\ndef generate_p2tr_address(internal_pubkey: bytes, mainnet: bool = True) -> str:\n    \"\"\"Generate a P2TR (Taproot) address from x-only public key.\n    \n    Args:\n        internal_pubkey: 32-byte x-only public key\n        mainnet: True for mainnet, False for testnet\n    \n    Returns:\n        Bech32m encoded Taproot address\n    \"\"\"\n    # For key-path only spend, tweak with empty merkle root\n    # tweaked_pubkey = internal_pubkey + H_TapTweak(internal_pubkey)\n    \n    # Simplified: using internal pubkey directly for demonstration\n    # In production, apply proper BIP341 tweaking\n    \n    hrp = \"bc\" if mainnet else \"tb\"\n    \n    # Convert to 5-bit groups for bech32m\n    converted = bech32.convertbits(list(internal_pubkey), 8, 5)\n    \n    # Witness version 1 + converted data (bech32m encoding)\n    address = bech32.bech32m_encode(hrp, [1] + converted)\n    \n    return address  # Starts with 'bc1p'\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n\nint main() {\n    // Generate key pair\n    bc::data_chunk seed(32);\n    bc::pseudo_random_fill(seed);\n    \n    bc::ec_secret secret;\n    std::copy(seed.begin(), seed.end(), secret.begin());\n    \n    bc::ec_compressed public_key;\n    bc::secret_to_public(public_key, secret);\n    \n    // Extract x-only public key (32 bytes, drop the prefix)\n    bc::data_chunk xonly_pubkey(public_key.begin() + 1, public_key.end());\n    \n    // Create witness program for Taproot\n    bc::data_chunk witness_program;\n    witness_program.push_back(0x01);  // Witness version 1\n    witness_program.push_back(0x20);  // Push 32 bytes\n    witness_program.insert(witness_program.end(), \n        xonly_pubkey.begin(), xonly_pubkey.end());\n    \n    // Bech32m encode (note: requires bech32m support)\n    std::string address = bc::wallet::encode_witness_address(\n        \"bc\", witness_program);\n    \n    std::cout << \"P2TR Address: \" << address << std::endl;\n    \n    return 0;\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\n\n// Initialize ECC library for Taproot\nbitcoin.initEccLib(ecc);\n\nfunction generateP2TRAddress() {\n    const keyPair = ECPair.makeRandom();\n    \n    // Get x-only public key (32 bytes)\n    const xOnlyPubkey = keyPair.publicKey.slice(1, 33);\n    \n    // Create P2TR address (key path only)\n    const { address } = bitcoin.payments.p2tr({\n        internalPubkey: xOnlyPubkey,\n        network: bitcoin.networks.bitcoin\n    });\n    \n    return {\n        privateKey: keyPair.toWIF(),\n        address: address  // Starts with 'bc1p'\n    };\n}\n\nconst { privateKey, address } = generateP2TRAddress();\nconsole.log('P2TR Address:', address);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc generateP2TRAddress() (string, string) {\n\t// Generate key pair\n\tprivateKey, err := btcec.NewPrivateKey()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get WIF private key\n\twif, err := btcutil.NewWIF(privateKey, &chaincfg.MainNetParams, true)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Get x-only public key (32 bytes, drop the prefix)\n\tpubkey := privateKey.PubKey()\n\txOnlyPubkey := pubkey.SerializeCompressed()[1:33]\n\n\t// Create P2TR address (key path only, simplified)\n\t// In production, apply proper BIP341 tweaking\n\taddr, err := btcutil.NewAddressTaproot(xOnlyPubkey, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn wif.String(), addr.EncodeAddress()\n}\n\nfunc main() {\n\tprivateKey, address := generateP2TRAddress()\n\tfmt.Printf(\"Private Key (WIF): %s\\n\", privateKey)\n\tfmt.Printf(\"P2TR Address: %s\\n\", address) // Starts with 'bc1p'\n}\n```\n:::\n\n### Characteristics\n\n- **Size**: 62 characters (bc1p + 59 chars)\n- **Input size**: ~58 vB (key path)\n- **Output size**: 43 vB\n- **Encoding**: Bech32m\n\n---\n\n## Comparison\n\n### Transaction Size and Fees\n\n| Type | Input (vB) | Output (vB) | Relative Cost |\n|------|------------|-------------|---------------|\n| P2PKH | 148 | 34 | 100% (baseline) |\n| P2SH-P2WPKH | 91 | 32 | 62% |\n| P2WPKH | 68 | 31 | 46% |\n| P2TR | 58 | 43 | 39% |\n\n### Feature Comparison\n\n| Feature | P2PKH | P2SH | P2WPKH | P2TR |\n|---------|-------|------|--------|------|\n| Multisig | No | Yes | Via P2WSH | Yes (MuSig) |\n| Fee efficiency | Low | Medium | High | Highest |\n| Privacy | Low | Medium | Medium | High |\n| Script flexibility | No | Yes | Limited | High |\n| Encoding | Base58 | Base58 | Bech32 | Bech32m |\n\n---\n\n## Best Practices\n\n### For New Wallets\n\n1. **Default to P2WPKH** for single-sig (best balance of compatibility and fees)\n2. **Use P2TR** when Taproot support is widespread\n3. **Avoid P2PKH** for new addresses (higher fees)\n\n### For Compatibility\n\n- Support receiving on all address types\n- Prefer SegWit (bc1q) for sending when possible\n- Some older services only support legacy addresses\n\n### Address Validation\n\nAlways validate addresses before sending:\n- Check length and prefix\n- Verify checksum (Base58Check or Bech32)\n- Confirm network (mainnet vs testnet)\n\n---\n\n## Summary\n\nBitcoin address types have evolved to provide:\n\n- **P2PKH**: Original format, highest fees\n- **P2SH**: Script flexibility, moderate fees\n- **P2WPKH**: Native SegWit, lower fees\n- **P2TR**: Taproot, lowest fees and best privacy\n\nChoose the appropriate type based on your use case, required features, and compatibility needs.\n\n---\n\n## Related Topics\n\n- [Bitcoin Wallets](/docs/wallets) - Introduction to Bitcoin wallets\n- [HD Wallets](/docs/wallets/hd-wallets) - Hierarchical deterministic key derivation\n- [Coin Selection](/docs/wallets/coin-selection) - How address types affect transaction fees\n- [Address Generation](/docs/bitcoin-development/addresses) - Developer guide to address generation\n",
    "filename": "address-types.md"
  },
  "/docs/wallets/transactions": {
    "content": "# Transaction Creation\n\nCreating Bitcoin transactions programmatically involves selecting inputs, creating outputs, calculating fees, signing, and broadcasting. This guide covers the complete process.\n\n## Transaction Structure\n\n### Basic Components\n\n```\nTransaction:\n  Version: 4 bytes\n  Input Count: VarInt\n  Inputs: Array of inputs\n  Output Count: VarInt\n  Outputs: Array of outputs\n  Locktime: 4 bytes\n  Witness: (if SegWit)\n```\n\n### Input Structure\n\n```\nInput:\n  Previous TXID: 32 bytes\n  Previous Output Index: 4 bytes\n  Script Length: VarInt\n  Script: Variable\n  Sequence: 4 bytes\n```\n\n### Output Structure\n\n```\nOutput:\n  Value: 8 bytes (satoshis)\n  Script Length: VarInt\n  Script: Variable (typically 22-34 bytes)\n```\n\n### Serializing a Transaction Output\n\n:::code-group\n```rust\nuse bech32::{self, FromBase32, ToBase32};\n\nstruct Output {\n    value: u64,\n    witness_version: u8,\n    witness_data: Vec<u8>,\n}\n\nimpl Output {\n    fn new() -> Self {\n        Self {\n            value: 0,\n            witness_version: 0,\n            witness_data: Vec::new(),\n        }\n    }\n\n    /// Create output from address and value in satoshis\n    fn from_options(addr: &str, value: u64) -> Result<Self, bech32::Error> {\n        let (hrp, data, variant) = bech32::decode(addr)?;\n        \n        let witness_version = data[0].to_u8();\n        let witness_program = Vec::<u8>::from_base32(&data[1..])?;\n        \n        Ok(Self {\n            value,\n            witness_version,\n            witness_data: witness_program,\n        })\n    }\n\n    /// Serialize output for transaction\n    fn serialize(&self) -> Vec<u8> {\n        let mut r = Vec::new();\n        \n        // Value: 8 bytes (little-endian)\n        r.extend_from_slice(&self.value.to_le_bytes());\n        \n        // Script length\n        let script_length = 1 + 1 + self.witness_data.len();\n        r.push(script_length as u8);\n        \n        // Witness version + data length + witness data\n        r.push(self.witness_version);\n        r.push(self.witness_data.len() as u8);\n        r.extend_from_slice(&self.witness_data);\n        \n        r\n    }\n}\n```\n\n```python\nfrom struct import pack\nfrom bech32py import bech32\n\nclass Output:\n    def __init__(self):\n        self.value = 0\n        self.witness_version = 0\n        self.witness_data = b\"\"\n\n    @classmethod\n    def from_options(cls, addr: str, value: int):\n        \"\"\"Create output from address and value in satoshis.\"\"\"\n        self = cls()\n        # Decode bech32 address to get witness version and program\n        hrp, data = bech32.decode(addr)\n        self.witness_version = data[0]\n        # Convert 5-bit values to 8-bit bytes\n        witness_program = bech32.convertbits(data[1:], 5, 8, False)\n        self.witness_data = bytes(witness_program)\n        self.value = value\n        return self\n\n    def serialize(self):\n        \"\"\"Serialize output for transaction.\"\"\"\n        r = b\"\"\n        # Value: 8 bytes (little-endian)\n        r += pack(\"<Q\", self.value)\n        # Script length\n        script_length = 1 + 1 + len(self.witness_data)\n        r += pack(\"<B\", script_length)\n        # Witness version + data length + witness data\n        r += pack(\"<B\", self.witness_version)\n        r += pack(\"<B\", len(self.witness_data))\n        r += self.witness_data\n        return r\n```\n\n```cpp\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <bech32.h>  // Assumes a bech32 library\n\nclass Output {\npublic:\n    uint64_t value = 0;\n    uint8_t witness_version = 0;\n    std::vector<uint8_t> witness_data;\n\n    Output() = default;\n\n    /**\n     * Create output from address and value in satoshis\n     */\n    static Output from_options(const std::string& addr, uint64_t value) {\n        Output self;\n        \n        // Decode bech32 address\n        auto [hrp, data] = bech32::decode(addr);\n        \n        self.witness_version = data[0];\n        // Convert 5-bit to 8-bit values\n        self.witness_data = bech32::convertbits(\n            std::vector<uint8_t>(data.begin() + 1, data.end()),\n            5, 8, false\n        );\n        self.value = value;\n        \n        return self;\n    }\n\n    /**\n     * Serialize output for transaction\n     */\n    std::vector<uint8_t> serialize() const {\n        std::vector<uint8_t> r;\n        \n        // Value: 8 bytes (little-endian)\n        for (int i = 0; i < 8; ++i) {\n            r.push_back(static_cast<uint8_t>((value >> (i * 8)) & 0xFF));\n        }\n        \n        // Script length\n        uint8_t script_length = 1 + 1 + static_cast<uint8_t>(witness_data.size());\n        r.push_back(script_length);\n        \n        // Witness version + data length + witness data\n        r.push_back(witness_version);\n        r.push_back(static_cast<uint8_t>(witness_data.size()));\n        r.insert(r.end(), witness_data.begin(), witness_data.end());\n        \n        return r;\n    }\n};\n```\n\n```javascript\nconst bech32 = require('@savingsatoshi/bech32js');\n\nclass Output {\n  constructor() {\n    this.value = 0;\n    this.witness_version = 0;\n    this.witness_data = Buffer.alloc(0);\n  }\n\n  static from_options(addr, value) {\n    const self = new this();\n    // Decode bech32 address\n    const decoded = bech32.bech32_decode(addr);\n    const words = decoded[1];\n    \n    self.witness_version = words[0];\n    // Convert 5-bit to 8-bit values\n    const witness_program = bech32.fromWords(words.slice(1));\n    self.witness_data = Buffer.from(witness_program);\n    self.value = value;\n    return self;\n  }\n\n  serialize() {\n    // Value: 8 bytes (little-endian)\n    const valueBuffer = Buffer.alloc(8);\n    const value = BigInt(this.value);\n    valueBuffer.writeUInt32LE(Number(value & 0xffffffffn), 0);\n    valueBuffer.writeUInt32LE(Number((value >> 32n) & 0xffffffffn), 4);\n    \n    // Script length\n    const script_length = 1 + 1 + this.witness_data.length;\n    \n    return Buffer.concat([\n      valueBuffer,\n      Buffer.from([script_length]),\n      Buffer.from([this.witness_version]),\n      Buffer.from([this.witness_data.length]),\n      this.witness_data\n    ]);\n  }\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil/bech32\"\n)\n\ntype Output struct {\n\tValue         uint64\n\tWitnessVersion uint8\n\tWitnessData   []byte\n}\n\nfunc NewOutput() *Output {\n\treturn &Output{\n\t\tValue:         0,\n\t\tWitnessVersion: 0,\n\t\tWitnessData:   []byte{},\n\t}\n}\n\n// FromOptions creates output from address and value in satoshis\nfunc FromOptions(addr string, value uint64) (*Output, error) {\n\thrp, data, err := bech32.Decode(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twitnessVersion := data[0]\n\twitnessProgram, err := bech32.ConvertBits(data[1:], 5, 8, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Output{\n\t\tValue:         value,\n\t\tWitnessVersion: witnessVersion,\n\t\tWitnessData:   witnessProgram,\n\t}, nil\n}\n\n// Serialize serializes output for transaction\nfunc (o *Output) Serialize() []byte {\n\tvar result []byte\n\n\t// Value: 8 bytes (little-endian)\n\tvalueBytes := make([]byte, 8)\n\tbinary.LittleEndian.PutUint64(valueBytes, o.Value)\n\tresult = append(result, valueBytes...)\n\n\t// Script length\n\tscriptLength := 1 + 1 + len(o.WitnessData)\n\tresult = append(result, byte(scriptLength))\n\n\t// Witness version + data length + witness data\n\tresult = append(result, o.WitnessVersion)\n\tresult = append(result, byte(len(o.WitnessData)))\n\tresult = append(result, o.WitnessData...)\n\n\treturn result\n}\n\nfunc main() {\n\toutput, err := FromOptions(\"bc1q...\", 50000)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tserialized := output.Serialize()\n\tfmt.Printf(\"Serialized output: %s\\n\", hex.EncodeToString(serialized))\n}\n```\n:::\n\n---\n\n## Step-by-Step Process\n\n### Step 1: Select UTXOs\n\nChoose which UTXOs to spend:\n\n```bash\n# List available UTXOs\nbitcoin-cli listunspent\n\n# Select UTXOs (coin selection algorithm)\n# Total value >= payment + fee\n```\n\n### Step 2: Create Raw Transaction\n\n```bash\n# Create transaction\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"abc123...\", \"vout\":0}]' \\\n  '{\"<destination_address>\": 0.001}'\n```\n\n**Parameters:**\n- **Inputs**: Array of UTXOs to spend\n- **Outputs**: Destination address and amount\n\n:::code-group\n```rust\nuse std::process::Command;\nuse serde_json::{json, Value};\n\nfn bcli(cmd: &str) -> Result<String, String> {\n    let args: Vec<&str> = cmd.split_whitespace().collect();\n    let output = Command::new(\"bitcoin-cli\")\n        .arg(\"-signet\")\n        .args(&args)\n        .output()\n        .map_err(|e| e.to_string())?;\n    \n    if output.status.success() {\n        Ok(String::from_utf8_lossy(&output.stdout).trim().to_string())\n    } else {\n        Err(String::from_utf8_lossy(&output.stderr).trim().to_string())\n    }\n}\n\n// Build inputs from selected UTXOs\nlet inputs: Vec<Value> = selected_utxos.iter()\n    .map(|utxo| json!({\"txid\": utxo.txid, \"vout\": utxo.vout}))\n    .collect();\n\n// Build outputs (payment + change)\nlet outputs = json!({\n    destination_address: payment_amount,\n    change_address: change_amount\n});\n\n// Create raw transaction\nlet inputs_json = serde_json::to_string(&inputs).unwrap();\nlet outputs_json = serde_json::to_string(&outputs).unwrap();\nlet unsigned_tx = bcli(&format!(\"createrawtransaction '{}' '{}'\", inputs_json, outputs_json))?;\n```\n\n```python\nimport json\nfrom subprocess import run\n\ndef bcli(cmd: str):\n    \"\"\"Execute bitcoin-cli command.\"\"\"\n    res = run(\n        [\"bitcoin-cli\", \"-signet\"] + cmd.split(\" \"),\n        capture_output=True, encoding=\"utf-8\"\n    )\n    if res.returncode == 0:\n        return res.stdout.strip()\n    raise Exception(res.stderr.strip())\n\n# Build inputs from selected UTXOs\ninputs = [{\"txid\": utxo[\"txid\"], \"vout\": utxo[\"vout\"]} for utxo in selected_utxos]\n\n# Build outputs (payment + change)\noutputs = {\n    destination_address: float(payment_amount),\n    change_address: float(change_amount)\n}\n\n# Create raw transaction\ninputs_json = json.dumps(inputs)\noutputs_json = json.dumps(outputs)\nunsigned_tx = bcli(f\"createrawtransaction {inputs_json} {outputs_json}\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <array>\n#include <stdexcept>\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\nstd::string bcli(const std::string& cmd) {\n    std::string full_cmd = \"bitcoin-cli -signet \" + cmd;\n    std::array<char, 128> buffer;\n    std::string result;\n    \n    FILE* pipe = popen(full_cmd.c_str(), \"r\");\n    if (!pipe) {\n        throw std::runtime_error(\"popen() failed\");\n    }\n    \n    while (fgets(buffer.data(), buffer.size(), pipe) != nullptr) {\n        result += buffer.data();\n    }\n    \n    int status = pclose(pipe);\n    if (status != 0) {\n        throw std::runtime_error(\"Command failed: \" + result);\n    }\n    \n    // Trim trailing newline\n    if (!result.empty() && result.back() == '\\n') {\n        result.pop_back();\n    }\n    return result;\n}\n\n// Build inputs from selected UTXOs\njson inputs = json::array();\nfor (const auto& utxo : selected_utxos) {\n    inputs.push_back({{\"txid\", utxo.txid}, {\"vout\", utxo.vout}});\n}\n\n// Build outputs (payment + change)\njson outputs = {\n    {destination_address, payment_amount},\n    {change_address, change_amount}\n};\n\n// Create raw transaction\nstd::string inputs_json = inputs.dump();\nstd::string outputs_json = outputs.dump();\nstd::string unsigned_tx = bcli(\"createrawtransaction '\" + inputs_json + \"' '\" + outputs_json + \"'\");\n```\n\n```javascript\nconst { execSync } = require('child_process');\n\nfunction bcli(cmd) {\n  const result = execSync(`bitcoin-cli -signet ${cmd}`, { encoding: 'utf-8' });\n  return result.trim();\n}\n\n// Build inputs from selected UTXOs\nconst inputs = selectedUtxos.map(utxo => ({\n  txid: utxo.txid,\n  vout: utxo.vout\n}));\n\n// Build outputs (payment + change)\nconst outputs = {\n  [destinationAddress]: paymentAmount,\n  [changeAddress]: changeAmount\n};\n\n// Create raw transaction\nconst inputsJson = JSON.stringify(inputs);\nconst outputsJson = JSON.stringify(outputs);\nconst unsignedTx = bcli(`createrawtransaction '${inputsJson}' '${outputsJson}'`);\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\ntype UTXO struct {\n\tTxid string `json:\"txid\"`\n\tVout int    `json:\"vout\"`\n}\n\nfunc bcli(cmd string) (string, error) {\n\t// Execute bitcoin-cli command\n\targs := append([]string{\"-signet\"}, cmd...)\n\toutput, err := exec.Command(\"bitcoin-cli\", args...).Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output), nil\n}\n\nfunc main() {\n\t// Build inputs from selected UTXOs\n\tselectedUtxos := []UTXO{\n\t\t{Txid: \"abc123...\", Vout: 0},\n\t\t{Txid: \"def456...\", Vout: 1},\n\t}\n\n\tinputs := make([]map[string]interface{}, len(selectedUtxos))\n\tfor i, utxo := range selectedUtxos {\n\t\tinputs[i] = map[string]interface{}{\n\t\t\t\"txid\": utxo.Txid,\n\t\t\t\"vout\": utxo.Vout,\n\t\t}\n\t}\n\n\t// Build outputs (payment + change)\n\toutputs := map[string]float64{\n\t\t\"destination_address\": 0.001,\n\t\t\"change_address\":      0.0005,\n\t}\n\n\t// Create raw transaction\n\tinputsJSON, _ := json.Marshal(inputs)\n\toutputsJSON, _ := json.Marshal(outputs)\n\n\tunsignedTx, err := bcli(fmt.Sprintf(\"createrawtransaction '%s' '%s'\", string(inputsJSON), string(outputsJSON)))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Unsigned transaction: %s\\n\", unsignedTx)\n}\n```\n:::\n\n### Step 3: Sign Transaction\n\n```bash\n# Sign transaction\nbitcoin-cli signrawtransactionwithwallet <hex>\n```\n\n**For Multisig:**\n```bash\n# Sign with specific key\nbitcoin-cli signrawtransactionwithkey <hex> \\\n  '[\"<private_key>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 4: Broadcast Transaction\n\n```bash\n# Broadcast to network\nbitcoin-cli sendrawtransaction <signed_hex>\n```\n\n:::code-group\n```rust\nuse serde_json::Value;\n\n// Sign the transaction\nlet sign_result = bcli(&format!(\"signrawtransactionwithwallet {}\", unsigned_tx))?;\nlet signed_data: Value = serde_json::from_str(&sign_result)?;\n\nif !signed_data[\"complete\"].as_bool().unwrap_or(false) {\n    return Err(\"Transaction signing incomplete\".into());\n}\n\nlet signed_tx = signed_data[\"hex\"].as_str().unwrap();\n\n// Broadcast transaction (0 = no maxfeerate protection)\nlet txid = bcli(&format!(\"sendrawtransaction {} 0\", signed_tx))?;\nprintln!(\"Transaction broadcast: {}\", txid);\n```\n\n```python\nimport json\n\n# Sign the transaction\nsign_result = bcli(f\"signrawtransactionwithwallet {unsigned_tx}\")\nsigned_data = json.loads(sign_result)\n\nif not signed_data.get(\"complete\"):\n    raise Exception(\"Transaction signing incomplete\")\n\nsigned_tx = signed_data[\"hex\"]\n\n# Broadcast transaction (0 = no maxfeerate protection)\ntxid = bcli(f\"sendrawtransaction {signed_tx} 0\")\nprint(f\"Transaction broadcast: {txid}\")\n```\n\n```cpp\n#include <nlohmann/json.hpp>\n\nusing json = nlohmann::json;\n\n// Sign the transaction\nstd::string sign_result = bcli(\"signrawtransactionwithwallet \" + unsigned_tx);\njson signed_data = json::parse(sign_result);\n\nif (!signed_data.value(\"complete\", false)) {\n    throw std::runtime_error(\"Transaction signing incomplete\");\n}\n\nstd::string signed_tx = signed_data[\"hex\"].get<std::string>();\n\n// Broadcast transaction (0 = no maxfeerate protection)\nstd::string txid = bcli(\"sendrawtransaction \" + signed_tx + \" 0\");\nstd::cout << \"Transaction broadcast: \" << txid << std::endl;\n```\n\n```javascript\n// Sign the transaction\nconst signResult = bcli(`signrawtransactionwithwallet ${unsignedTx}`);\nconst signedData = JSON.parse(signResult);\n\nif (!signedData.complete) {\n  throw new Error('Transaction signing incomplete');\n}\n\nconst signedTx = signedData.hex;\n\n// Broadcast transaction (0 = no maxfeerate protection)\nconst txid = bcli(`sendrawtransaction ${signedTx} 0`);\nconsole.log(`Transaction broadcast: ${txid}`);\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc bcli(cmd string) (string, error) {\n\targs := append([]string{\"-signet\"}, cmd...)\n\toutput, err := exec.Command(\"bitcoin-cli\", args...).Output()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(output), nil\n}\n\nfunc main() {\n\tunsignedTx := \"0100000001...\" // From previous step\n\n\t// Sign the transaction\n\tsignResult, err := bcli(fmt.Sprintf(\"signrawtransactionwithwallet %s\", unsignedTx))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar signedData map[string]interface{}\n\tif err := json.Unmarshal([]byte(signResult), &signedData); err != nil {\n\t\tpanic(err)\n\t}\n\n\tcomplete, _ := signedData[\"complete\"].(bool)\n\tif !complete {\n\t\tpanic(\"Transaction signing incomplete\")\n\t}\n\n\tsignedTx := signedData[\"hex\"].(string)\n\n\t// Broadcast transaction (0 = no maxfeerate protection)\n\ttxid, err := bcli(fmt.Sprintf(\"sendrawtransaction %s 0\", signedTx))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Transaction broadcast: %s\\n\", txid)\n}\n```\n:::\n\n---\n\n## Fee Calculation\n\n### Estimating Transaction Size\n\n**Base Transaction:**\n- Version: 4 bytes\n- Input count: 1-9 bytes\n- Output count: 1-9 bytes\n- Locktime: 4 bytes\n\n**Per Input:**\n- Previous output: 36 bytes\n- Script length: 1-9 bytes\n- Script: Variable (depends on script type)\n- Sequence: 4 bytes\n\n**Per Output:**\n- Value: 8 bytes\n- Script length: 1-9 bytes\n- Script: Variable (typically 22-34 bytes)\n\n### Virtual Size (SegWit)\n\n```\nWeight = (Base Size Ã— 3) + Total Size\nVirtual Size = Weight / 4\n```\n\n### Fee Calculation\n\n```\nFee = Transaction Size (vBytes) Ã— Fee Rate (sat/vB)\n```\n\n**Example:**\n```\nTransaction Size: 250 vBytes\nFee Rate: 10 sat/vB\nFee: 2,500 sats\n```\n\n---\n\n## Change Outputs\n\n### When to Create Change\n\nCreate change output if:\n- Input value > Payment + Fee + Dust Threshold\n- Change amount > Dust threshold (546 sats)\n\n### Change Output Creation\n\n```bash\n# Include change output\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '{\"<destination>\": 0.001, \"<change_address>\": 0.0005}'\n```\n\n---\n\n## Signing Process\n\n### Single Signature\n\n**P2PKH:**\n```\nScript: <signature> <public_key>\n```\n\n**P2WPKH:**\n```\nWitness: <signature> <public_key>\n```\n\n### Multisig Signing\n\n**Process:**\n1. Create transaction\n2. Sign with first key\n3. Sign with second key (using partially signed tx)\n4. Continue until M signatures collected\n5. Broadcast fully signed transaction\n\n---\n\n## Transaction Validation\n\n### Before Broadcasting\n\n1. **Check Inputs**: Verify UTXOs are still unspent\n2. **Verify Balance**: Ensure sufficient funds\n3. **Validate Fee**: Check fee meets minimum\n4. **Check Size**: Ensure transaction is valid size\n5. **Verify Signatures**: All signatures valid\n\n### Common Validation Errors\n\n- **Insufficient funds**: Not enough input value\n- **Invalid signature**: Signature doesn't match\n- **Double spend**: UTXO already spent\n- **Dust output**: Output below dust threshold\n- **Fee too low**: Fee below minimum\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Fee Estimation**: Accurate fee estimation is critical\n2. **UTXO Management**: Efficient coin selection\n3. **Error Handling**: Handle all error cases\n4. **Validation**: Validate before broadcasting\n5. **Testing**: Test on testnet first\n\n### For Users\n\n1. **Verify Address**: Double-check destination address\n2. **Check Fee**: Ensure reasonable fee\n3. **Wait for Confirmation**: Don't assume immediate confirmation\n4. **Backup**: Backup transaction if needed\n5. **Monitor**: Track transaction status\n\n---\n\n## Common Issues\n\n### Transaction Stuck\n\n**Problem**: Transaction not confirming\n\n**Solutions:**\n- Wait for confirmation\n- Use Replace-by-Fee (RBF) if enabled\n- Increase fee (if possible)\n- Wait for mempool to clear\n\n### Insufficient Fee\n\n**Problem**: Fee too low, transaction rejected\n\n**Solutions:**\n- Increase fee rate\n- Use higher priority\n- Wait for lower network activity\n\n### Invalid Transaction\n\n**Problem**: Transaction rejected by network\n\n**Causes:**\n- Invalid signature\n- Double spend\n- Dust output\n- Invalid script\n\n**Solution**: Fix issue and recreate transaction\n\n---\n\n## Advanced Topics\n\n### Replace-by-Fee (RBF)\n\n**Enable RBF:**\n```bash\n# Set sequence to enable RBF\n# Sequence < 0xFFFFFFFF - 1\n```\n\n**Replace Transaction:**\n```bash\n# Create replacement with higher fee\nbitcoin-cli createrawtransaction ... --replaceable\n```\n\n### Partially Signed Bitcoin Transactions (PSBT)\n\n**Create PSBT:**\n```bash\nbitcoin-cli walletcreatefundedpsbt \\\n  '[]' \\\n  '[{\"<address>\": <amount>}]'\n```\n\n**Sign PSBT:**\n```bash\nbitcoin-cli walletprocesspsbt <psbt>\n```\n\n**Finalize PSBT:**\n```bash\nbitcoin-cli finalizepsbt <psbt>\n```\n\n---\n\n## Summary\n\nTransaction creation involves:\n\n- **UTXO Selection**: Choose inputs to spend\n- **Output Creation**: Create payment and change outputs\n- **Fee Calculation**: Calculate appropriate fees\n- **Signing**: Sign with private keys\n- **Broadcasting**: Send to network\n- **Validation**: Verify transaction is valid\n\nUnderstanding transaction creation is essential for building Bitcoin wallets and applications.\n\n---\n\n## Related Topics\n\n- [Bitcoin Wallets](/docs/wallets) - Introduction to Bitcoin wallets\n- [Coin Selection](/docs/wallets/coin-selection) - How wallets choose UTXOs to spend\n- [Multisig](/docs/wallets/multisig) - Multi-signature transaction signing\n- [PSBT](/docs/bitcoin-development/psbt) - Partially Signed Bitcoin Transactions standard\n- [Mempool](/docs/mining/mempool) - Where unconfirmed transactions wait\n",
    "filename": "transactions.md"
  },
  "/docs/wallets/coin-selection": {
    "content": "# Coin Selection\n\nCoin selection is the process of choosing which UTXOs (Unspent Transaction Outputs) to spend when creating a Bitcoin transaction. This is a critical wallet function that affects transaction fees, privacy, and efficiency. For a deeper understanding of the UTXO model, see the [UTXO Model](/docs/fundamentals/utxos) documentation.\n\n## The Challenge\n\nGiven:\n- A set of available UTXOs\n- A payment amount to send\n- A target fee rate\n\nSelect UTXOs such that:\n- Total input value > total output value\n- Fee rate >= required minimum fee rate\n- Transaction is valid and efficient\n\n---\n\n## Transaction Requirements\n\n### Basic Structure\n\n```\nTransaction:\n  Inputs: Selected UTXOs\n  Outputs:\n    - Payment output (destination + amount)\n    - Change output (optional, back to wallet)\n  Fee: Inputs - Outputs\n```\n\n### Fee Rate Calculation\n\n```\nFee Rate = (Total Input Value - Total Output Value) / Virtual Transaction Size\n```\n\n**Virtual Transaction Size (vBytes):**\n- Defined in BIP 141 ([SegWit](/docs/glossary#segwit-segregated-witness))\n- Weight units / 4\n- Accounts for witness data differently\n\n### Effective Value\n\nThe **effective value** of a UTXO accounts for the cost to spend it:\n\n```\neffective_value = amount - (input_vbytes Ã— fee_rate)\n```\n\nThis is critical for coin selection: a small UTXO might have negative effective value at high fee rates.\n\n:::code-group\n```rust\n/// Calculate effective value of a coin at a given fee rate\n/// effective_value = amount - (input_vbytes * fee_rate)\nfn effective_value(coin: &Coin, fee_rate: Decimal) -> Decimal {\n    coin.amount - (input_vbytes(&coin.address) * fee_rate)\n}\n\n// Filter out coins with negative effective value\nlet useful_coins: Vec<Coin> = coins\n    .iter()\n    .filter(|c| effective_value(c, fee_rate) > Decimal::ZERO)\n    .cloned()\n    .collect();\n```\n\n```python\ndef effective_value(coin: dict, fee_rate: float) -> float:\n    \"\"\"Calculate effective value of a UTXO at a given fee rate.\n    \n    Args:\n        coin: UTXO with 'amount' and 'address' fields\n        fee_rate: Fee rate in BTC/vB\n    \n    Returns:\n        Effective value (can be negative for dust UTXOs)\n    \"\"\"\n    spend_cost = input_vbytes(coin['address']) * fee_rate\n    return coin['amount'] - spend_cost\n\n# Example: At 10 sat/vB, filter out negative effective value UTXOs\nfee_rate = 0.0000001  # 10 sat/vB in BTC/vB\nuseful_coins = [c for c in coins if effective_value(c, fee_rate) > 0]\n```\n\n```cpp\n#include <vector>\n#include <algorithm>\n\n/**\n * Calculate effective value of a coin at a given fee rate\n * effective_value = amount - (input_vbytes * fee_rate)\n */\ndouble effective_value(const Coin& coin, double fee_rate) {\n    return coin.amount - (input_vbytes(coin.address) * fee_rate);\n}\n\n// Filter out coins with negative effective value\nstd::vector<Coin> useful_coins;\nstd::copy_if(coins.begin(), coins.end(), std::back_inserter(useful_coins),\n    [fee_rate](const Coin& c) {\n        return effective_value(c, fee_rate) > 0;\n    });\n```\n\n```javascript\n/**\n * Calculate effective value of a coin at a given fee rate\n * effective_value = amount - (input_vbytes * fee_rate)\n * \n * @param {Object} coin - UTXO with 'amount' and 'address' fields\n * @param {number} feeRate - Fee rate in BTC/vB\n * @returns {number} Effective value (can be negative for dust UTXOs)\n */\nfunction effectiveValue(coin, feeRate) {\n    const spendCost = inputVbytes(coin.address) * feeRate;\n    return coin.amount - spendCost;\n}\n\n// Example: At 10 sat/vB, filter out negative effective value UTXOs\nconst feeRate = 0.0000001; // 10 sat/vB in BTC/vB\nconst usefulCoins = coins.filter(c => effectiveValue(c, feeRate) > 0);\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype Coin struct {\n\tAmount  float64\n\tAddress string\n}\n\n// EffectiveValue calculates effective value of a coin at a given fee rate\n// effective_value = amount - (input_vbytes * fee_rate)\nfunc EffectiveValue(coin Coin, feeRate float64) float64 {\n\tspendCost := float64(InputVbytes(coin.Address)) * feeRate\n\treturn coin.Amount - spendCost\n}\n\n// InputVbytes calculates virtual bytes for spending a UTXO based on address type\nfunc InputVbytes(address string) float64 {\n\tif strings.HasPrefix(address, \"bc1p\") || strings.HasPrefix(address, \"tb1p\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1p\") {\n\t\treturn 57.5 // Taproot (p2tr)\n\t} else if strings.HasPrefix(address, \"bc1q\") || strings.HasPrefix(address, \"tb1q\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1q\") {\n\t\treturn 68.0 // Native SegWit (p2wpkh)\n\t} else if strings.HasPrefix(address, \"2\") || strings.HasPrefix(address, \"3\") {\n\t\treturn 91.0 // Nested SegWit (p2sh-p2wpkh)\n\t}\n\treturn 148.0 // Legacy (p2pkh)\n}\n\n// OutputVbytes calculates virtual bytes for an output based on address type\nfunc OutputVbytes(address string) float64 {\n\tif strings.HasPrefix(address, \"bc1p\") || strings.HasPrefix(address, \"tb1p\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1p\") {\n\t\treturn 43.0 // Taproot\n\t} else if strings.HasPrefix(address, \"bc1q\") || strings.HasPrefix(address, \"tb1q\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1q\") {\n\t\treturn 31.0 // Native SegWit\n\t} else if strings.HasPrefix(address, \"2\") || strings.HasPrefix(address, \"3\") {\n\t\treturn 32.0 // P2SH\n\t}\n\treturn 34.0 // Legacy\n}\n\nfunc main() {\n\t// Example: At 10 sat/vB, filter out negative effective value UTXOs\n\tfeeRate := 0.0000001 // 10 sat/vB in BTC/vB\n\tcoins := []Coin{\n\t\t{Amount: 0.001, Address: \"bc1q...\"},\n\t\t{Amount: 0.0001, Address: \"1...\"},\n\t}\n\n\tvar usefulCoins []Coin\n\tfor _, coin := range coins {\n\t\tif EffectiveValue(coin, feeRate) > 0 {\n\t\t\tusefulCoins = append(usefulCoins, coin)\n\t\t}\n\t}\n\n\tfmt.Printf(\"Useful coins: %d\\n\", len(usefulCoins))\n}\n```\n:::\n\n---\n\n## UTXO Characteristics\n\n### Different Script Types\n\nUTXOs can have different script types, affecting transaction size:\n\n| Type | Address Prefix | Input Size |\n|------|---------------|------------|\n| P2PKH (Legacy) | `1...` | ~148 vB |\n| P2SH | `3...` | ~91 vB |\n| P2WPKH (SegWit) | `bc1q...` | ~68 vB |\n| P2TR ([Taproot](/docs/glossary#taproot)) | `bc1p...` | ~58 vB |\n\n:::code-group\n```rust\nfn input_vbytes(address: &str) -> Decimal {\n    if address.starts_with(\"bc1p\") || address.starts_with(\"tb1p\") {\n        dec!(57.5)   // Taproot (p2tr)\n    } else if address.starts_with(\"bc1q\") || address.starts_with(\"tb1q\") {\n        dec!(68)     // Native SegWit (p2wpkh)\n    } else if address.starts_with(\"2\") || address.starts_with(\"3\") {\n        dec!(91)     // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        dec!(148)    // Legacy (p2pkh)\n    }\n}\n\nfn output_vbytes(address: &str) -> Decimal {\n    if address.starts_with(\"bc1p\") || address.starts_with(\"tb1p\") {\n        dec!(43)     // Taproot\n    } else if address.starts_with(\"bc1q\") || address.starts_with(\"tb1q\") {\n        dec!(31)     // Native SegWit\n    } else if address.starts_with(\"2\") || address.starts_with(\"3\") {\n        dec!(32)     // P2SH\n    } else {\n        dec!(34)     // Legacy\n    }\n}\n```\n\n```python\ndef input_vbytes(address: str) -> float:\n    \"\"\"Calculate virtual bytes for spending a UTXO based on address type.\"\"\"\n    if address.startswith(('bc1p', 'tb1p', 'bcrt1p')):\n        return 57.5   # Taproot (p2tr)\n    elif address.startswith(('bc1q', 'tb1q', 'bcrt1q')):\n        return 68.0   # Native SegWit (p2wpkh)\n    elif address.startswith(('2', '3')):\n        return 91.0   # Nested SegWit (p2sh-p2wpkh)\n    else:\n        return 148.0  # Legacy (p2pkh)\n\ndef output_vbytes(address: str) -> float:\n    \"\"\"Calculate virtual bytes for an output based on address type.\"\"\"\n    if address.startswith(('bc1p', 'tb1p', 'bcrt1p')):\n        return 43.0   # Taproot\n    elif address.startswith(('bc1q', 'tb1q', 'bcrt1q')):\n        return 31.0   # Native SegWit\n    elif address.startswith(('2', '3')):\n        return 32.0   # P2SH\n    else:\n        return 34.0   # Legacy\n```\n\n```cpp\n#include <string>\n\n/**\n * Calculate virtual bytes for spending a UTXO based on address type.\n */\ndouble input_vbytes(const std::string& address) {\n    if (address.rfind(\"bc1p\", 0) == 0 || address.rfind(\"tb1p\", 0) == 0 || \n        address.rfind(\"bcrt1p\", 0) == 0) {\n        return 57.5;   // Taproot (p2tr)\n    } else if (address.rfind(\"bc1q\", 0) == 0 || address.rfind(\"tb1q\", 0) == 0 || \n               address.rfind(\"bcrt1q\", 0) == 0) {\n        return 68.0;   // Native SegWit (p2wpkh)\n    } else if (address[0] == '2' || address[0] == '3') {\n        return 91.0;   // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        return 148.0;  // Legacy (p2pkh)\n    }\n}\n\n/**\n * Calculate virtual bytes for an output based on address type.\n */\ndouble output_vbytes(const std::string& address) {\n    if (address.rfind(\"bc1p\", 0) == 0 || address.rfind(\"tb1p\", 0) == 0 || \n        address.rfind(\"bcrt1p\", 0) == 0) {\n        return 43.0;   // Taproot\n    } else if (address.rfind(\"bc1q\", 0) == 0 || address.rfind(\"tb1q\", 0) == 0 || \n               address.rfind(\"bcrt1q\", 0) == 0) {\n        return 31.0;   // Native SegWit\n    } else if (address[0] == '2' || address[0] == '3') {\n        return 32.0;   // P2SH\n    } else {\n        return 34.0;   // Legacy\n    }\n}\n```\n\n```javascript\n/**\n * Calculate virtual bytes for spending a UTXO based on address type.\n * @param {string} address - Bitcoin address\n * @returns {number} Virtual bytes required\n */\nfunction inputVbytes(address) {\n    if (address.startsWith('bc1p') || address.startsWith('tb1p') || \n        address.startsWith('bcrt1p')) {\n        return 57.5;   // Taproot (p2tr)\n    } else if (address.startsWith('bc1q') || address.startsWith('tb1q') || \n               address.startsWith('bcrt1q')) {\n        return 68.0;   // Native SegWit (p2wpkh)\n    } else if (address.startsWith('2') || address.startsWith('3')) {\n        return 91.0;   // Nested SegWit (p2sh-p2wpkh)\n    } else {\n        return 148.0;  // Legacy (p2pkh)\n    }\n}\n\n/**\n * Calculate virtual bytes for an output based on address type.\n * @param {string} address - Bitcoin address\n * @returns {number} Virtual bytes required\n */\nfunction outputVbytes(address) {\n    if (address.startsWith('bc1p') || address.startsWith('tb1p') || \n        address.startsWith('bcrt1p')) {\n        return 43.0;   // Taproot\n    } else if (address.startsWith('bc1q') || address.startsWith('tb1q') || \n               address.startsWith('bcrt1q')) {\n        return 31.0;   // Native SegWit\n    } else if (address.startsWith('2') || address.startsWith('3')) {\n        return 32.0;   // P2SH\n    } else {\n        return 34.0;   // Legacy\n    }\n}\n```\n:::\n\n### Example UTXOs\n\n```\nUTXO 1: P2WPKH, 1.5 BTC\nUTXO 2: P2TR, 0.8 BTC\nUTXO 3: P2PKH, 0.3 BTC\n```\n\n**Transaction Size Impact:**\n- Using UTXO 1: Smaller transaction (SegWit)\n- Using UTXO 3: Larger transaction (Legacy)\n- Same fee rate = different absolute fees\n\n---\n\n## Coin Selection Strategies\n\n### 1. Largest First (Greedy)\n\n**Algorithm:**\n1. Sort UTXOs by value (largest first)\n2. Select UTXOs until sum >= payment + estimated fee\n3. Create change output if needed\n\n:::code-group\n```rust\nfn select_largest_first(\n    coins: &[Coin],\n    target: Decimal,\n    fee_rate: Decimal\n) -> Result<(Vec<Coin>, Decimal), String> {\n    // Sort by amount descending\n    let mut sorted: Vec<Coin> = coins.to_vec();\n    sorted.sort_by(|a, b| b.amount.partial_cmp(&a.amount).unwrap());\n    \n    let mut selected: Vec<Coin> = Vec::new();\n    let mut total = Decimal::ZERO;\n    \n    for coin in sorted {\n        selected.push(coin.clone());\n        total += coin.amount;\n        \n        let estimated_fee = estimate_fee(selected.len(), fee_rate);\n        \n        if total >= target + estimated_fee {\n            return Ok((selected, total - target - estimated_fee));\n        }\n    }\n    \n    Err(\"Insufficient funds\".to_string())\n}\n```\n\n```python\ndef select_largest_first(coins, target_amount, fee_rate):\n    \"\"\"Select coins using largest-first greedy algorithm.\"\"\"\n    # Sort by amount descending\n    sorted_coins = sorted(coins, key=lambda c: c['amount'], reverse=True)\n    \n    selected = []\n    total = Decimal('0')\n    \n    for coin in sorted_coins:\n        selected.append(coin)\n        total += coin['amount']\n        \n        # Estimate fee based on selected inputs\n        estimated_fee = estimate_fee(len(selected), fee_rate)\n        \n        if total >= target_amount + estimated_fee:\n            return selected, total - target_amount - estimated_fee\n    \n    raise ValueError(\"Insufficient funds\")\n```\n\n```cpp\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <utility>\n\n/**\n * Select coins using largest-first greedy algorithm.\n * @return pair of (selected coins, change amount)\n */\nstd::pair<std::vector<Coin>, double> select_largest_first(\n    std::vector<Coin> coins,\n    double target_amount,\n    double fee_rate\n) {\n    // Sort by amount descending\n    std::sort(coins.begin(), coins.end(), [](const Coin& a, const Coin& b) {\n        return a.amount > b.amount;\n    });\n    \n    std::vector<Coin> selected;\n    double total = 0.0;\n    \n    for (const auto& coin : coins) {\n        selected.push_back(coin);\n        total += coin.amount;\n        \n        // Estimate fee based on selected inputs\n        double estimated_fee = estimate_fee(selected.size(), fee_rate);\n        \n        if (total >= target_amount + estimated_fee) {\n            return {selected, total - target_amount - estimated_fee};\n        }\n    }\n    \n    throw std::runtime_error(\"Insufficient funds\");\n}\n```\n\n```javascript\n/**\n * Select coins using largest-first greedy algorithm.\n * @param {Array} coins - Array of coin objects with 'amount' property\n * @param {number} targetAmount - Target amount to reach\n * @param {number} feeRate - Fee rate for estimation\n * @returns {Object} Object with 'selected' coins and 'change' amount\n */\nfunction selectLargestFirst(coins, targetAmount, feeRate) {\n    // Sort by amount descending\n    const sortedCoins = [...coins].sort((a, b) => b.amount - a.amount);\n    \n    const selected = [];\n    let total = 0;\n    \n    for (const coin of sortedCoins) {\n        selected.push(coin);\n        total += coin.amount;\n        \n        // Estimate fee based on selected inputs\n        const estimatedFee = estimateFee(selected.length, feeRate);\n        \n        if (total >= targetAmount + estimatedFee) {\n            return {\n                selected,\n                change: total - targetAmount - estimatedFee\n            };\n        }\n    }\n    \n    throw new Error('Insufficient funds');\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Coin struct {\n\tAmount  float64\n\tAddress string\n}\n\n// SelectLargestFirst selects coins using largest-first greedy algorithm\nfunc SelectLargestFirst(coins []Coin, targetAmount float64, feeRate float64) ([]Coin, float64, error) {\n\t// Sort by amount descending\n\tsortedCoins := make([]Coin, len(coins))\n\tcopy(sortedCoins, coins)\n\tsort.Slice(sortedCoins, func(i, j int) bool {\n\t\treturn sortedCoins[i].Amount > sortedCoins[j].Amount\n\t})\n\n\tvar selected []Coin\n\ttotal := 0.0\n\n\tfor _, coin := range sortedCoins {\n\t\tselected = append(selected, coin)\n\t\ttotal += coin.Amount\n\n\t\t// Estimate fee based on selected inputs (simplified)\n\t\testimatedFee := EstimateFee(len(selected), feeRate)\n\n\t\tif total >= targetAmount+estimatedFee {\n\t\t\tchange := total - targetAmount - estimatedFee\n\t\t\treturn selected, change, nil\n\t\t}\n\t}\n\n\treturn nil, 0, fmt.Errorf(\"insufficient funds\")\n}\n\n// EstimateFee estimates transaction fee (simplified)\nfunc EstimateFee(inputCount int, feeRate float64) float64 {\n\t// Simplified: assume 68 vB per input + 31 vB per output\n\tbaseSize := 10.0 // Base transaction size\n\tinputSize := float64(inputCount) * 68.0\n\toutputSize := 31.0 * 2 // Assume 2 outputs\n\ttotalVbytes := baseSize + inputSize + outputSize\n\treturn totalVbytes * feeRate\n}\n\nfunc main() {\n\tcoins := []Coin{\n\t\t{Amount: 0.5, Address: \"bc1q...\"},\n\t\t{Amount: 0.3, Address: \"bc1q...\"},\n\t\t{Amount: 0.1, Address: \"bc1q...\"},\n\t}\n\n\tselected, change, err := SelectLargestFirst(coins, 0.4, 0.0000001)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Selected %d coins, change: %.8f BTC\\n\", len(selected), change)\n}\n```\n:::\n\n**Pros:**\n- Simple to implement\n- Minimizes number of inputs\n- Fast execution\n\n**Cons:**\n- May overpay fees\n- Poor privacy (uses largest UTXOs)\n- May create dust change\n\n### 2. Smallest First\n\n**Algorithm:**\n1. Sort UTXOs by value (smallest first)\n2. Select UTXOs until sum >= payment + estimated fee\n3. Create change output if needed\n\n**Pros:**\n- Consolidates small UTXOs\n- Better privacy (uses smaller UTXOs)\n- Cleans up wallet\n\n**Cons:**\n- More inputs = larger transaction\n- Higher fees for many inputs\n- Slower (more inputs to sign)\n\n### 3. Exact Match\n\n**Algorithm:**\n1. Look for UTXO that exactly matches payment + fee\n2. If found, use it\n3. Otherwise, fall back to other strategy\n\n**Pros:**\n- No change output needed\n- Optimal for specific cases\n- Clean transaction\n\n**Cons:**\n- Rarely finds exact match\n- Usually requires fallback\n\n### 4. Branch and Bound\n\n**Algorithm:**\n1. Try all combinations of UTXOs\n2. Find combination that minimizes:\n   - Transaction size\n   - Change amount\n   - Number of inputs\n3. Select optimal combination\n\n**Pros:**\n- Optimal solution\n- Minimizes fees\n- Best privacy\n\n**Cons:**\n- Computationally expensive\n- Slow for many UTXOs\n- May not be practical\n\n### 5. Random Selection\n\n**Algorithm:**\n1. Randomly select UTXOs\n2. Continue until sum >= payment + fee\n3. Create change if needed\n\n**Pros:**\n- Good privacy\n- Unpredictable pattern\n- Simple implementation\n\n**Cons:**\n- May not be optimal\n- Could select inefficient combination\n\n---\n\n## Fee Calculation\n\n### Estimating Transaction Size\n\n**Base Size:**\n- Transaction header: 10 bytes\n- Input count: 1-9 bytes (varint)\n- Output count: 1-9 bytes (varint)\n\n**Input Size:**\n- Previous output: 36 bytes\n- Script length: 1-9 bytes (varint)\n- Script: Variable (depends on script type)\n- Sequence: 4 bytes\n\n**Output Size:**\n- Value: 8 bytes\n- Script length: 1-9 bytes (varint)\n- Script: Variable (typically 22-34 bytes)\n\n**Witness Size (SegWit):**\n- Witness data: Variable\n- Counted differently in weight calculation\n\n### Virtual Size Calculation\n\n```\nWeight = (Base Size Ã— 3) + Total Size\nVirtual Size = Weight / 4\n```\n\n:::code-group\n```rust\n/// Calculate the total virtual size of a transaction\n/// tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\nfn calculate_tx_vsize(inputs: &[Coin], output_addresses: &[&str]) -> Decimal {\n    let overhead = dec!(10.5);\n    \n    let input_size: Decimal = inputs.iter()\n        .map(|c| input_vbytes(&c.address))\n        .sum();\n    \n    let output_size: Decimal = output_addresses.iter()\n        .map(|addr| output_vbytes(addr))\n        .sum();\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    (overhead + input_size + output_size).ceil()\n}\n```\n\n```python\ndef calculate_tx_vsize(inputs: list, output_addresses: list) -> int:\n    \"\"\"Calculate virtual size of a transaction.\n    \n    Args:\n        inputs: List of UTXOs to spend\n        output_addresses: List of destination addresses\n    \n    Returns:\n        Virtual size in vbytes (rounded up)\n    \"\"\"\n    import math\n    \n    # Transaction overhead: ~10.5 vB\n    overhead = 10.5\n    \n    # Sum input sizes based on address types\n    input_size = sum(input_vbytes(coin['address']) for coin in inputs)\n    \n    # Sum output sizes based on address types\n    output_size = sum(output_vbytes(addr) for addr in output_addresses)\n    \n    # Round up to be safe\n    return math.ceil(overhead + input_size + output_size)\n```\n\n```cpp\n#include <vector>\n#include <string>\n#include <cmath>\n#include <numeric>\n\n/**\n * Calculate the total virtual size of a transaction\n * tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\n */\nint calculate_tx_vsize(\n    const std::vector<Coin>& inputs,\n    const std::vector<std::string>& output_addresses\n) {\n    // Transaction overhead: ~10.5 vB\n    double overhead = 10.5;\n    \n    // Sum input sizes based on address types\n    double input_size = std::accumulate(inputs.begin(), inputs.end(), 0.0,\n        [](double sum, const Coin& coin) {\n            return sum + input_vbytes(coin.address);\n        });\n    \n    // Sum output sizes based on address types\n    double output_size = std::accumulate(output_addresses.begin(), output_addresses.end(), 0.0,\n        [](double sum, const std::string& addr) {\n            return sum + output_vbytes(addr);\n        });\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    return static_cast<int>(std::ceil(overhead + input_size + output_size));\n}\n```\n\n```javascript\n/**\n * Calculate the total virtual size of a transaction\n * tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\n * \n * @param {Array} inputs - List of UTXOs to spend\n * @param {Array} outputAddresses - List of destination addresses\n * @returns {number} Virtual size in vbytes (rounded up)\n */\nfunction calculateTxVsize(inputs, outputAddresses) {\n    // Transaction overhead: ~10.5 vB\n    const overhead = 10.5;\n    \n    // Sum input sizes based on address types\n    const inputSize = inputs.reduce(\n        (sum, coin) => sum + inputVbytes(coin.address), 0\n    );\n    \n    // Sum output sizes based on address types\n    const outputSize = outputAddresses.reduce(\n        (sum, addr) => sum + outputVbytes(addr), 0\n    );\n    \n    // Ceiling the vsize to ensure we don't underestimate\n    return Math.ceil(overhead + inputSize + outputSize);\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strings\"\n)\n\ntype Coin struct {\n\tAmount  float64\n\tAddress string\n}\n\n// CalculateTxVsize calculates the total virtual size of a transaction\n// tx_vsize = 10.5 (overhead) + sum(input_vbytes) + sum(output_vbytes)\nfunc CalculateTxVsize(inputs []Coin, outputAddresses []string) int {\n\t// Transaction overhead: ~10.5 vB\n\toverhead := 10.5\n\n\t// Sum input sizes based on address types\n\tvar inputSize float64\n\tfor _, coin := range inputs {\n\t\tinputSize += InputVbytes(coin.Address)\n\t}\n\n\t// Sum output sizes based on address types\n\tvar outputSize float64\n\tfor _, addr := range outputAddresses {\n\t\toutputSize += OutputVbytes(addr)\n\t}\n\n\t// Ceiling the vsize to ensure we don't underestimate\n\treturn int(math.Ceil(overhead + inputSize + outputSize))\n}\n\n// InputVbytes calculates virtual bytes for spending a UTXO based on address type\nfunc InputVbytes(address string) float64 {\n\tif strings.HasPrefix(address, \"bc1p\") || strings.HasPrefix(address, \"tb1p\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1p\") {\n\t\treturn 57.5 // Taproot (p2tr)\n\t} else if strings.HasPrefix(address, \"bc1q\") || strings.HasPrefix(address, \"tb1q\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1q\") {\n\t\treturn 68.0 // Native SegWit (p2wpkh)\n\t} else if strings.HasPrefix(address, \"2\") || strings.HasPrefix(address, \"3\") {\n\t\treturn 91.0 // Nested SegWit (p2sh-p2wpkh)\n\t}\n\treturn 148.0 // Legacy (p2pkh)\n}\n\n// OutputVbytes calculates virtual bytes for an output based on address type\nfunc OutputVbytes(address string) float64 {\n\tif strings.HasPrefix(address, \"bc1p\") || strings.HasPrefix(address, \"tb1p\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1p\") {\n\t\treturn 43.0 // Taproot\n\t} else if strings.HasPrefix(address, \"bc1q\") || strings.HasPrefix(address, \"tb1q\") ||\n\t\tstrings.HasPrefix(address, \"bcrt1q\") {\n\t\treturn 31.0 // Native SegWit\n\t} else if strings.HasPrefix(address, \"2\") || strings.HasPrefix(address, \"3\") {\n\t\treturn 32.0 // P2SH\n\t}\n\treturn 34.0 // Legacy\n}\n\nfunc main() {\n\tinputs := []Coin{\n\t\t{Amount: 0.5, Address: \"bc1q...\"},\n\t\t{Amount: 0.3, Address: \"bc1q...\"},\n\t}\n\toutputs := []string{\"bc1q...\", \"bc1q...\"}\n\n\tvsize := CalculateTxVsize(inputs, outputs)\n\tfmt.Printf(\"Transaction vsize: %d vbytes\\n\", vsize)\n}\n```\n:::\n\n### Fee Calculation Example\n\n```\nPayment: 1.0 BTC\nFee Rate: 1 sat/vB\n\nSelected UTXOs:\n  - UTXO 1 (P2WPKH): 1.2 BTC\n  - UTXO 2 (P2TR): 0.5 BTC\n\nTransaction Size: 250 vBytes\nFee: 250 sats\nChange: 1.7 - 1.0 - 0.0000025 = 0.6999975 BTC\n```\n\n---\n\n## Change Output Creation\n\n### When to Create Change\n\nCreate change output if:\n- Selected UTXOs > Payment + Fee + Dust Threshold\n- Change amount > dust threshold (typically 546 sats)\n\n### Dust Threshold\n\nDust outputs are uneconomical to spend:\n- **Standard**: 546 sats\n- **Rationale**: Fee to spend would exceed value\n- **Policy**: Many nodes reject dust outputs\n\n### Change Output Optimization\n\n**Options:**\n1. **Create change**: If amount > dust threshold\n2. **Donate to miner**: If amount < dust threshold\n3. **Increase payment**: If change would be dust\n\n---\n\n## Implementation Considerations\n\n### Iterative Approach\n\n1. **Estimate fee**: Based on initial UTXO selection\n2. **Select UTXOs**: Using chosen strategy\n3. **Calculate actual fee**: Based on actual transaction size\n4. **Adjust if needed**: If fee doesn't meet target\n\n### Fee Rate Targets\n\n**Common Fee Rates:**\n- **Low priority**: 1-5 sat/vB\n- **Medium priority**: 5-10 sat/vB\n- **High priority**: 10-50 sat/vB\n- **Urgent**: 50+ sat/vB\n\n### Validation\n\nBefore finalizing transaction:\n1. **Verify inputs**: Ensure UTXOs are still unspent\n2. **Check balance**: Ensure sufficient funds\n3. **Validate fee**: Ensure fee rate meets target\n4. **Check size**: Ensure transaction is valid size\n\n---\n\n## Best Practices\n\n### For Wallet Developers\n\n1. **Use SegWit**: Prefer SegWit UTXOs (smaller size)\n2. **Minimize inputs**: Fewer inputs = smaller transaction\n3. **Optimize change**: Avoid dust change outputs\n4. **Privacy**: Consider privacy implications\n5. **Fee estimation**: Accurate fee estimation is critical\n\n### For Users\n\n1. **Consolidate UTXOs**: Periodically consolidate small UTXOs\n2. **Use SegWit**: Prefer SegWit addresses\n3. **Monitor fees**: Be aware of current fee rates\n4. **Batch payments**: Combine multiple payments when possible\n\n---\n\n## Common Issues\n\n### Insufficient Funds\n\n**Problem**: Selected UTXOs don't cover payment + fee\n\n**Solution**:\n- Select more UTXOs\n- Reduce payment amount\n- Wait for more funds\n\n### Fee Too Low\n\n**Problem**: Calculated fee rate below target\n\n**Solution**:\n- Select fewer UTXOs (if possible)\n- Increase fee manually\n- Use higher fee rate\n\n### Dust Change\n\n**Problem**: Change output would be dust\n\n**Solution**:\n- Donate to miner (include in fee)\n- Increase payment amount\n- Select different UTXOs\n\n---\n\n## Summary\n\nCoin selection is a critical wallet function:\n\n- **Multiple strategies**: Different approaches for different goals\n- **Fee optimization**: Balance between fees and efficiency\n- **Privacy considerations**: UTXO selection affects privacy\n- **Transaction sizing**: Different script types affect size\n- **Change management**: Handle change outputs appropriately\n\nUnderstanding coin selection helps build efficient and user-friendly Bitcoin wallets.\n\n---\n\n## Related Topics\n\n- [Bitcoin Wallets](/docs/wallets) - Introduction to Bitcoin wallets\n- [Transaction Creation](/docs/wallets/transactions) - How to create and sign transactions\n- [Address Types](/docs/wallets/address-types) - Understanding different Bitcoin address formats\n- [Mempool](/docs/mining/mempool) - How unconfirmed transactions are stored and prioritized\n",
    "filename": "coin-selection.md"
  },
  "/docs/wallets/privacy": {
    "content": "# Privacy Techniques\n\nBitcoin transactions are pseudonymous, not anonymous. Various techniques can improve privacy by breaking the linkability between transactions and making blockchain analysis more difficult.\n\n## Privacy Challenges\n\n### Blockchain Analysis\n\nAll transactions are public:\n\n```text\nPublic Information:\n- Transaction amounts\n- Input/output addresses\n- Transaction graph\n- Timing patterns\n```\n\n### Common-Input-Ownership Heuristic\n\nAnalysts assume all inputs to a transaction belong to the same entity:\n\n```text\nTransaction:\nInput 1: Address A\nInput 2: Address B\nInput 3: Address C\n\nAssumption: A, B, and C are all controlled by same person\n```\n\n---\n\n## Privacy Techniques\n\n### 1. CoinJoin\n\n**CoinJoin** combines multiple transactions into one:\n\n```text\nStandard Transaction:\nAlice â†’ Bob: 1 BTC\n\nCoinJoin Transaction:\nAlice + Charlie + Dave â†’ Bob + Eve + Frank: Mixed amounts\n```\n\n**Benefits**:\n- Breaks common-input-ownership heuristic\n- Hides individual transaction amounts\n- Makes analysis difficult\n\n**Implementations**:\n- **Wasabi Wallet**: WabiSabi protocol\n- **JoinMarket**: Maker-taker model\n- **Samourai Wallet**: Whirlpool\n\n### 2. Payjoin (P2EP)\n\n**Payjoin** involves both sender and receiver:\n\n```text\nStandard Transaction:\nAlice (inputs) â†’ Bob (output)\n\nPayjoin Transaction:\nAlice (inputs) + Bob (inputs) â†’ Alice (change) + Bob (output)\n```\n\n**Benefits**:\n- Breaks common-input-ownership\n- Looks like normal transaction\n- No coordination overhead\n\n### 3. Address Reuse Avoidance\n\n**Never reuse addresses**:\n\n```text\nBad:\n- Receive multiple payments to same address\n- Links all payments together\n- Reveals transaction history\n\nGood:\n- Generate new address for each payment\n- HD wallets do this automatically\n- Better privacy\n```\n\n### 4. Coin Selection\n\n**Privacy-aware coin selection**:\n\n```text\nStrategies:\n- Avoid linking transactions\n- Use smaller UTXOs when possible\n- Don't consolidate unnecessarily\n- Consider timing patterns\n```\n\n---\n\n## Code Examples\n\n### CoinJoin Implementation\n\n:::code-group\n```rust\nuse bitcoin::{Transaction, TxIn, TxOut};\n\nstruct CoinJoinParticipant {\n    inputs: Vec<TxIn>,\n    outputs: Vec<TxOut>,\n}\n\nfn create_coinjoin(participants: Vec<CoinJoinParticipant>) -> Transaction {\n    let mut tx = Transaction::default();\n    \n    // Collect all inputs\n    for participant in &participants {\n        tx.input.extend(participant.inputs.clone());\n    }\n    \n    // Collect all outputs (shuffled)\n    let mut all_outputs: Vec<TxOut> = participants\n        .iter()\n        .flat_map(|p| p.outputs.clone())\n        .collect();\n    \n    // Shuffle outputs for privacy\n    use rand::seq::SliceRandom;\n    let mut rng = rand::thread_rng();\n    all_outputs.shuffle(&mut rng);\n    \n    tx.output = all_outputs;\n    tx\n}\n```\n\n```python\nimport random\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut\n\ndef create_coinjoin(participants):\n    \"\"\"Create a CoinJoin transaction.\"\"\"\n    tx = CTransaction()\n    \n    # Collect all inputs\n    for participant in participants:\n        tx.vin.extend(participant.inputs)\n    \n    # Collect and shuffle outputs\n    all_outputs = []\n    for participant in participants:\n        all_outputs.extend(participant.outputs)\n    \n    random.shuffle(all_outputs)  # Shuffle for privacy\n    tx.vout = all_outputs\n    \n    return tx\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <algorithm>\n#include <random>\n\nbc::transaction create_coinjoin(\n    const std::vector<std::vector<bc::input>>& participant_inputs,\n    const std::vector<std::vector<bc::output>>& participant_outputs\n) {\n    bc::transaction tx;\n    \n    // Collect all inputs\n    for (const auto& inputs : participant_inputs) {\n        tx.inputs().insert(tx.inputs().end(), inputs.begin(), inputs.end());\n    }\n    \n    // Collect and shuffle outputs\n    std::vector<bc::output> all_outputs;\n    for (const auto& outputs : participant_outputs) {\n        all_outputs.insert(all_outputs.end(), outputs.begin(), outputs.end());\n    }\n    \n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(all_outputs.begin(), all_outputs.end(), g);\n    \n    tx.set_outputs(all_outputs);\n    return tx;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\nfunc createCoinJoin(\n\tparticipantInputs [][]*wire.TxIn,\n\tparticipantOutputs [][]*wire.TxOut,\n) *wire.MsgTx {\n\ttx := wire.NewMsgTx(wire.TxVersion)\n\t\n\t// Collect all inputs\n\tfor _, inputs := range participantInputs {\n\t\tfor _, input := range inputs {\n\t\t\ttx.AddTxIn(input)\n\t\t}\n\t}\n\t\n\t// Collect and shuffle outputs\n\tvar allOutputs []*wire.TxOut\n\tfor _, outputs := range participantOutputs {\n\t\tallOutputs = append(allOutputs, outputs...)\n\t}\n\t\n\trand.Shuffle(len(allOutputs), func(i, j int) {\n\t\tallOutputs[i], allOutputs[j] = allOutputs[j], allOutputs[i]\n\t})\n\t\n\tfor _, output := range allOutputs {\n\t\ttx.AddTxOut(output)\n\t}\n\t\n\treturn tx\n}\n```\n\n```javascript\nfunction createCoinJoin(participants) {\n    const tx = new bitcoin.Transaction();\n    \n    // Collect all inputs\n    participants.forEach(participant => {\n        participant.inputs.forEach(input => {\n            tx.addInput(input.hash, input.index);\n        });\n    });\n    \n    // Collect and shuffle outputs\n    const allOutputs = [];\n    participants.forEach(participant => {\n        allOutputs.push(...participant.outputs);\n    });\n    \n    // Shuffle for privacy\n    for (let i = allOutputs.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [allOutputs[i], allOutputs[j]] = [allOutputs[j], allOutputs[i]];\n    }\n    \n    allOutputs.forEach(output => {\n        tx.addOutput(output.address, output.value);\n    });\n    \n    return tx;\n}\n```\n:::\n\n---\n\n## Advanced Privacy\n\n### Silent Payments (BIP 352)\n\n**Silent Payments** enable reusable addresses without address reuse:\n\n```text\nTraditional:\n- Recipient shares address\n- Address reused â†’ Privacy loss\n\nSilent Payments:\n- Recipient shares static identifier\n- Sender derives unique address per payment\n- No address reuse\n- Better privacy\n```\n\n### Taproot Privacy\n\nTaproot provides better privacy:\n\n```text\nMultisig Transaction:\n- Key path: Looks like single-sig\n- Script path: Only reveals used condition\n- Other conditions hidden in MAST\n```\n\n---\n\n## Best Practices\n\n### For Users\n\n1. **Use HD wallets**: Automatic address generation\n2. **Avoid address reuse**: Generate new addresses\n3. **Consider CoinJoin**: For high privacy needs\n4. **Use Taproot**: Better privacy by default\n5. **Be careful with change**: Change outputs link transactions\n\n### For Developers\n\n1. **Implement address rotation**: Never reuse addresses\n2. **Support privacy features**: CoinJoin, Payjoin\n3. **Privacy-aware coin selection**: Don't link transactions\n4. **Educate users**: Explain privacy implications\n\n---\n\n## Limitations\n\n### What Privacy Techniques Can't Do\n\n1. **IP address**: Network layer still reveals IP\n2. **Timing analysis**: Patterns can reveal links\n3. **Amount analysis**: Large amounts are distinctive\n4. **Perfect anonymity**: Not achievable on public blockchain\n\n### Trade-offs\n\n- **Privacy vs. Convenience**: More privacy = more complexity\n- **Privacy vs. Cost**: CoinJoin has fees\n- **Privacy vs. Speed**: Some techniques add delays\n\n---\n\n## Related Topics\n\n- [Address Types](/docs/wallets/address-types) - Understanding addresses\n- [Coin Selection](/docs/wallets/coin-selection) - Privacy-aware selection\n- [Taproot](/docs/bitcoin/taproot) - Better privacy\n- [Lightning Network](/docs/lightning) - Off-chain privacy\n\n---\n\n## Resources\n\n- [BIP 352: Silent Payments](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki)\n- [Wasabi Wallet](https://wasabiwallet.io/) - CoinJoin implementation\n- [JoinMarket](https://joinmarket.me/) - CoinJoin marketplace\n",
    "filename": "privacy.md"
  },
  "/docs/wallets/multisig": {
    "content": "# Multisig\n\nMulti-signature (multisig) wallets require multiple signatures to spend funds. This provides enhanced security, shared custody, and flexible access control. A multisig wallet requires M-of-N signatures:\n\n- **M**: Minimum number of signatures required\n- **N**: Total number of possible signers\n- **Example**: 2-of-3 means 2 signatures from 3 possible keys\n\nCommon configurations: **2-of-2** (two parties must both sign, e.g. partnership), **2-of-3** (two of three parties must sign, e.g. backup key), **3-of-5** (three of five, e.g. corporate), or flexible **M-of-N**.\n\n---\n\n## Multisig Script Patterns\n\n### Legacy Multisig (P2SH)\n\n**Script Pattern:**\n```\nOP_M <pubkey1> <pubkey2> ... <pubkeyN> OP_N OP_CHECKMULTISIG\n```\n\n**Example (2-of-3):**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Spending Script:**\n```\nOP_0 <sig1> <sig2>\n```\n\n**Note**: OP_0 is a bug workaround (dummy value before signatures)\n\n### SegWit Multisig (P2WSH)\n\n**Redeem Script:**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Script Hash:**\n```\nOP_0 <scripthash>\n```\n\n**Spending:**\n- Witness: `<sig1> <sig2> <redeem_script>`\n- More efficient than legacy\n\n### Taproot Multisig (P2TR)\n\n**Modern Approach:**\n- Uses Taproot script trees\n- More efficient\n- Better privacy\n- More complex implementation\n\n---\n\n## Creating Multisig Wallets\n\n### Using Bitcoin Core\n\n```bash\n# Step 1: Generate keys (each party does this)\nbitcoin-cli getnewaddress\n\n# Step 2: Create 2-of-3 multisig address\nbitcoin-cli createmultisig 2 \\\n  '[\"<pubkey1>\", \"<pubkey2>\", \"<pubkey3>\"]'\n\n# Step 3: Fund the multisig address\nbitcoin-cli sendtoaddress <multisig_address> <amount>\n```\n\nThe `createmultisig` command returns:\n- **Address**: Multisig address to receive funds\n- **Redeem Script**: Script needed to spend\n- **Descriptor**: Modern descriptor format\n\n### Programmatic Multisig Creation\n\n:::code-group\n```rust\nuse bitcoin::{\n    secp256k1::{Secp256k1, rand::rngs::OsRng},\n    Address, Network, PublicKey, Script,\n    blockdata::script::Builder,\n    blockdata::opcodes::all::*,\n};\nuse bitcoin::hashes::{sha256, Hash};\n\nfn create_multisig_address(\n    required: usize,\n    pubkeys: &[PublicKey],\n    network: Network\n) -> Address {\n    let secp = Secp256k1::new();\n    \n    // Build the redeem script: OP_M <pubkeys...> OP_N OP_CHECKMULTISIG\n    let mut builder = Builder::new()\n        .push_int(required as i64);\n    \n    for pubkey in pubkeys {\n        builder = builder.push_key(pubkey);\n    }\n    \n    let redeem_script = builder\n        .push_int(pubkeys.len() as i64)\n        .push_opcode(OP_CHECKMULTISIG)\n        .into_script();\n    \n    // Create P2WSH address (SegWit multisig)\n    Address::p2wsh(&redeem_script, network)\n}\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate 3 key pairs\n    let mut pubkeys = Vec::new();\n    for _ in 0..3 {\n        let (_, public_key) = secp.generate_keypair(&mut OsRng);\n        pubkeys.push(PublicKey::new(public_key));\n    }\n    \n    // Create 2-of-3 multisig address\n    let address = create_multisig_address(2, &pubkeys, Network::Bitcoin);\n    println!(\"Multisig Address: {}\", address);\n}\n```\n\n```python\nimport hashlib\nfrom ecdsa import SECP256k1, SigningKey\n\ndef create_multisig_script(required: int, pubkeys: list[bytes]) -> bytes:\n    \"\"\"Create a multisig redeem script.\n    \n    Args:\n        required: Number of signatures required (M)\n        pubkeys: List of compressed public keys (N keys)\n    \n    Returns:\n        Redeem script bytes\n    \"\"\"\n    n = len(pubkeys)\n    \n    # Build script: OP_M <pubkeys> OP_N OP_CHECKMULTISIG\n    script = bytes([0x50 + required])  # OP_M (OP_1 = 0x51, etc.)\n    \n    for pubkey in pubkeys:\n        script += bytes([len(pubkey)]) + pubkey  # Push pubkey\n    \n    script += bytes([0x50 + n])  # OP_N\n    script += bytes([0xae])      # OP_CHECKMULTISIG\n    \n    return script\n\ndef script_to_p2wsh_address(script: bytes, mainnet: bool = True) -> str:\n    \"\"\"Convert redeem script to P2WSH address.\"\"\"\n    import bech32\n    \n    # SHA256 of the script\n    script_hash = hashlib.sha256(script).digest()\n    \n    # Witness version 0 + 32-byte script hash\n    hrp = \"bc\" if mainnet else \"tb\"\n    witness_program = [0] + list(script_hash)\n    \n    # Convert to 5-bit groups for bech32\n    converted = bech32.convertbits(witness_program, 8, 5)\n    return bech32.bech32_encode(hrp, converted)\n\n# Generate 3 key pairs\nprivate_keys = []\npublic_keys = []\n\nfor _ in range(3):\n    sk = SigningKey.generate(curve=SECP256k1)\n    vk = sk.get_verifying_key()\n    \n    # Compressed public key (33 bytes)\n    x = vk.point.x()\n    y = vk.point.y()\n    prefix = b'\\x02' if y % 2 == 0 else b'\\x03'\n    pubkey = prefix + x.to_bytes(32, 'big')\n    \n    private_keys.append(sk)\n    public_keys.append(pubkey)\n\n# Create 2-of-3 multisig\nredeem_script = create_multisig_script(2, public_keys)\naddress = script_to_p2wsh_address(redeem_script)\nprint(f\"Multisig Address: {address}\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n#include <iostream>\n#include <vector>\n\nbc::chain::script create_multisig_script(\n    uint8_t required,\n    const std::vector<bc::ec_compressed>& pubkeys\n) {\n    bc::machine::operation::list ops;\n    \n    // OP_M\n    ops.push_back(bc::machine::operation(\n        static_cast<bc::machine::opcode>(0x50 + required)));\n    \n    // Push each public key\n    for (const auto& pubkey : pubkeys) {\n        ops.push_back(bc::machine::operation(bc::to_chunk(pubkey)));\n    }\n    \n    // OP_N\n    ops.push_back(bc::machine::operation(\n        static_cast<bc::machine::opcode>(0x50 + pubkeys.size())));\n    \n    // OP_CHECKMULTISIG\n    ops.push_back(bc::machine::operation(bc::machine::opcode::checkmultisig));\n    \n    return bc::chain::script(ops);\n}\n\nint main() {\n    std::vector<bc::ec_compressed> pubkeys;\n    std::vector<bc::ec_secret> secrets;\n    \n    // Generate 3 key pairs\n    for (int i = 0; i < 3; ++i) {\n        bc::data_chunk seed(32);\n        bc::pseudo_random_fill(seed);\n        \n        bc::ec_secret secret;\n        std::copy(seed.begin(), seed.end(), secret.begin());\n        secrets.push_back(secret);\n        \n        bc::ec_compressed pubkey;\n        bc::secret_to_public(pubkey, secret);\n        pubkeys.push_back(pubkey);\n    }\n    \n    // Create 2-of-3 multisig redeem script\n    auto redeem_script = create_multisig_script(2, pubkeys);\n    \n    // Create P2WSH address\n    bc::short_hash script_hash = bc::sha256_hash(redeem_script.to_data(false));\n    bc::wallet::payment_address address(script_hash, \n        bc::wallet::payment_address::mainnet_p2sh);\n    \n    std::cout << \"Multisig Address: \" << address.encoded() << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createMultisigAddress(required int, pubkeys [][]byte, network *chaincfg.Params) (string, []byte, error) {\n\t// Sort pubkeys (BIP67 compliance)\n\tsort.Slice(pubkeys, func(i, j int) bool {\n\t\treturn hex.EncodeToString(pubkeys[i]) < hex.EncodeToString(pubkeys[j])\n\t})\n\n\t// Build the redeem script: OP_M <pubkeys> OP_N OP_CHECKMULTISIG\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(int64(required))\n\tfor _, pubkey := range pubkeys {\n\t\tbuilder.AddData(pubkey)\n\t}\n\tbuilder.AddInt64(int64(len(pubkeys)))\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\tredeemScript, err := builder.Script()\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\t// Create P2WSH address\n\tscriptHash := sha256.Sum256(redeemScript)\n\taddr, err := btcutil.NewAddressWitnessScriptHash(scriptHash[:], network)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\treturn addr.EncodeAddress(), redeemScript, nil\n}\n\nfunc main() {\n\t// Generate 3 key pairs (simplified - in real code you'd generate actual keys)\n\tpubkeys := make([][]byte, 3)\n\t// ... generate pubkeys ...\n\n\t// Create 2-of-3 multisig\n\taddr, redeemScript, err := createMultisigAddress(2, pubkeys, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Printf(\"Multisig Address: %s\\n\", addr)\n\tfmt.Printf(\"Redeem Script: %s\\n\", hex.EncodeToString(redeemScript))\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\nconst { ECPairFactory } = require('ecpair');\nconst ecc = require('tiny-secp256k1');\n\nconst ECPair = ECPairFactory(ecc);\n\nfunction createMultisigAddress(required, pubkeys, network = bitcoin.networks.bitcoin) {\n    // Create the P2MS (pay-to-multisig) redeem script\n    const p2ms = bitcoin.payments.p2ms({\n        m: required,\n        pubkeys: pubkeys,\n        network: network\n    });\n    \n    // Wrap in P2WSH for SegWit multisig\n    const p2wsh = bitcoin.payments.p2wsh({\n        redeem: p2ms,\n        network: network\n    });\n    \n    return {\n        address: p2wsh.address,\n        redeemScript: p2ms.output,\n        witnessScript: p2wsh.redeem.output\n    };\n}\n\n// Generate 3 key pairs\nconst keyPairs = [];\nconst pubkeys = [];\n\nfor (let i = 0; i < 3; i++) {\n    const keyPair = ECPair.makeRandom();\n    keyPairs.push(keyPair);\n    pubkeys.push(keyPair.publicKey);\n}\n\n// Sort pubkeys (BIP67 compliance)\npubkeys.sort(Buffer.compare);\n\n// Create 2-of-3 multisig\nconst multisig = createMultisigAddress(2, pubkeys);\nconsole.log('Multisig Address:', multisig.address);\nconsole.log('Redeem Script:', multisig.redeemScript.toString('hex'));\n```\n:::\n\n---\n\n## Spending from Multisig\n\n### Step 1: Create Transaction\n\n```bash\n# Create raw transaction\nbitcoin-cli createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '{\"<destination>\": <amount>}'\n```\n\n### Step 2: Sign with First Key\n\n```bash\n# Sign with key 1\nbitcoin-cli signrawtransactionwithkey <hex> \\\n  '[\"<privkey1>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 3: Sign with Second Key\n\n```bash\n# Sign with key 2 (using partially signed transaction)\nbitcoin-cli signrawtransactionwithkey <partially_signed_hex> \\\n  '[\"<privkey2>\"]' \\\n  '[{\"txid\":\"...\", \"vout\":0, \"scriptPubKey\":\"...\", \"redeemScript\":\"...\"}]'\n```\n\n### Step 4: Broadcast\n\n```bash\n# Broadcast fully signed transaction\nbitcoin-cli sendrawtransaction <fully_signed_hex>\n```\n\n---\n\n## Key Management\n\n### Key Storage\n\n**Best Practices:**\n- **Distributed**: Each party stores their own key\n- **Secure**: Use hardware wallets or secure storage\n- **Backup**: Backup keys securely\n- **Recovery**: Plan for key loss\n\n### Key Security\n\n**Options:**\n1. **Hardware Wallets**: Most secure\n2. **Paper Wallets**: Offline storage\n3. **Encrypted Storage**: Encrypted files\n4. **Custodial**: Third-party custody (less secure)\n\n---\n\n## Use Cases\n\n### 1. Shared Custody\n\n**Example**: Business partnership\n- **2-of-2**: Both partners must agree\n- **Use case**: Business funds\n- **Benefit**: No single point of failure\n\n### 2. Backup Security\n\n**Example**: Personal wallet with backup\n- **2-of-3**: You + Backup key + Hardware key\n- **Use case**: Personal funds with backup\n- **Benefit**: Can recover if one key lost\n\n### 3. Corporate Wallets\n\n**Example**: Company treasury\n- **3-of-5**: Three executives must sign\n- **Use case**: Corporate funds\n- **Benefit**: Distributed control\n\n### 4. Family Funds\n\n**Example**: Family savings\n- **2-of-4**: Two family members must agree\n- **Use case**: Shared family funds\n- **Benefit**: Prevents single person control\n\n---\n\n## Security Considerations\n\n### Advantages\n\n1. **No Single Point of Failure**: Multiple keys required\n2. **Distributed Trust**: No single party controls funds\n3. **Backup Options**: Can lose some keys\n4. **Flexible Access**: Different M-of-N configurations\n\n### Risks\n\n1. **Key Loss**: If too many keys lost, funds locked\n2. **Coordination**: Requires multiple parties\n3. **Complexity**: More complex than single-sig\n4. **Key Compromise**: If M keys compromised, funds at risk\n\n### Best Practices\n\n1. **Secure Key Storage**: Use hardware wallets\n2. **Backup Strategy**: Plan for key loss\n3. **Key Distribution**: Don't store all keys together\n4. **Regular Testing**: Test spending process\n5. **Documentation**: Document key locations and recovery\n\n---\n\n## Implementation Details\n\n### Script Execution\n\n**Multisig Script:**\n```\nOP_2 <pubkey1> <pubkey2> <pubkey3> OP_3 OP_CHECKMULTISIG\n```\n\n**Execution:**\n1. Push M (2)\n2. Push pubkeys (3)\n3. Push N (3)\n4. OP_CHECKMULTISIG:\n   - Pops N, then N pubkeys\n   - Pops M, then M signatures\n   - Verifies M signatures match M of N pubkeys\n   - Returns 1 if valid, 0 if invalid\n\n### Transaction Size\n\n**Multisig Transactions:**\n- **Larger**: More signatures = larger transaction\n- **2-of-3 P2SH**: ~250-300 bytes\n- **2-of-3 P2WSH**: ~200-250 bytes (witness)\n- **Fees**: Higher fees due to size\n\n---\n\n## Common Issues\n\n### Insufficient Signatures\n\n**Problem**: Not enough signatures to spend\n\n**Solution**:\n- Collect required number of signatures\n- Ensure all signers are available\n- Use backup keys if needed\n\n### Key Loss\n\n**Problem**: Too many keys lost\n\n**Solution**:\n- Use remaining keys (if M still available)\n- If M keys lost, funds are locked\n- Plan for key recovery\n\n### Coordination Challenges\n\n**Problem**: Difficult to coordinate multiple signers\n\n**Solution**:\n- Use signing services\n- Batch transactions\n- Plan signing sessions\n- Use hardware wallets for convenience\n\n---\n\n## Summary\n\nMultisig wallets provide:\n\n- **Enhanced Security**: Multiple keys required\n- **Shared Custody**: Distributed control\n- **Backup Options**: Can lose some keys\n- **Flexible Access**: Various M-of-N configurations\n- **Corporate Use**: Suitable for organizations\n\nUnderstanding multisig is essential for building secure Bitcoin wallets and managing funds with multiple parties.\n\n---\n\n## Related Topics\n\n- [Bitcoin Wallets](/docs/wallets) - Introduction to Bitcoin wallets\n- [Transaction Creation](/docs/wallets/transactions) - How to create and sign transactions\n- [PSBT](/docs/bitcoin-development/psbt) - Partially Signed Bitcoin Transactions for multisig coordination\n- [Bitcoin Script](/docs/bitcoin/script) - Understanding the scripting system behind multisig\n",
    "filename": "multisig.md"
  },
  "/docs/wallets/smart-contracts": {
    "content": "# Smart Contracts & Advanced Scripting\n\nBitcoin Script enables smart contracts through conditional spending. While intentionally limited (no loops, no complex state), Bitcoin's scripting system supports powerful contract patterns.\n\nBitcoin smart contracts are **spending conditions** encoded in Script:\n\n```text\nSmart Contract = Locking Script + Unlocking Script\n\nLocking Script: Defines conditions\nUnlocking Script: Proves conditions are met\n```\n\nSee this in action in [Stack Lab](/stack-lab).\n\nUnlike Ethereum, Bitcoin contracts are:\n- **Stateless**: No persistent contract state\n- **Deterministic**: Same inputs = same result\n- **Limited**: No loops, no external data\n- **Secure**: Simpler = fewer vulnerabilities\n\n---\n\n## Common Contract Patterns\n\n### 1. Multisig\n\nMultiple signatures required:\n\n```text\n2-of-3 Multisig:\n- Requires 2 of 3 keys to sign\n- More secure than single key\n- Common for shared custody\n```\n\n### 2. Timelocks\n\nTime-based conditions:\n\n```text\nEscrow Contract:\n- Funds locked until date\n- Can't be spent before\n- Useful for inheritance, vesting\n```\n\n### 3. Hash Locks\n\nReveal secret to spend:\n\n```text\nHash Lock:\n- Locked to hash of secret\n- Reveal secret to unlock\n- Used in atomic swaps, Lightning\n```\n\n### 4. Escrow\n\nThree-party contracts:\n\n```text\nEscrow:\n- Buyer sends funds\n- Seller provides goods\n- Escrow releases funds\n- Dispute resolution possible\n```\n\n---\n\n## Code Examples\n\n### Creating a Multisig Contract\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\n\nfn create_multisig_script(\n    pubkeys: &[[u8; 33]; 3],\n    threshold: u8,\n) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    script.push_int(threshold as i64);\n    for pubkey in pubkeys {\n        script.push_slice(pubkey);\n    }\n    script.push_int(pubkeys.len() as i64);\n    script.push_opcode(OP_CHECKMULTISIG);\n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_CHECKMULTISIG\n\ndef create_multisig_script(pubkeys, threshold):\n    \"\"\"Create multisig script.\"\"\"\n    return CScript([\n        threshold,\n        *pubkeys,\n        len(pubkeys),\n        OP_CHECKMULTISIG,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::script create_multisig_script(\n    const std::vector<bc::ec_compressed>& pubkeys,\n    uint8_t threshold\n) {\n    bc::script script;\n    script.push_operation(bc::opcode(threshold));\n    for (const auto& pubkey : pubkeys) {\n        script.push_data(bc::to_chunk(pubkey));\n    }\n    script.push_operation(bc::opcode(pubkeys.size()));\n    script.push_operation(bc::opcode::checkmultisig);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createMultisigScript(pubkeys [][]byte, threshold int) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(int64(threshold))\n\tfor _, pubkey := range pubkeys {\n\t\tbuilder.AddData(pubkey)\n\t}\n\tbuilder.AddInt64(int64(len(pubkeys)))\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createMultisigScript(pubkeys, threshold) {\n    return bitcoin.script.multisig.output.encode(threshold, pubkeys);\n}\n```\n:::\n\n### Creating an Escrow Contract\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\n\nfn create_escrow_script(\n    buyer_pubkey: &[u8; 33],\n    seller_pubkey: &[u8; 33],\n    escrow_pubkey: &[u8; 33],\n) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    // 2-of-3 multisig: buyer + seller, or buyer + escrow, or seller + escrow\n    script.push_int(2);\n    script.push_slice(buyer_pubkey);\n    script.push_slice(seller_pubkey);\n    script.push_slice(escrow_pubkey);\n    script.push_int(3);\n    script.push_opcode(OP_CHECKMULTISIG);\n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_CHECKMULTISIG\n\ndef create_escrow_script(buyer_pubkey, seller_pubkey, escrow_pubkey):\n    \"\"\"Create escrow contract script.\"\"\"\n    return CScript([\n        2,  # 2-of-3\n        buyer_pubkey,\n        seller_pubkey,\n        escrow_pubkey,\n        3,\n        OP_CHECKMULTISIG,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::script create_escrow_script(\n    const bc::ec_compressed& buyer_pubkey,\n    const bc::ec_compressed& seller_pubkey,\n    const bc::ec_compressed& escrow_pubkey\n) {\n    bc::script script;\n    script.push_operation(bc::opcode(2)); // 2-of-3\n    script.push_data(bc::to_chunk(buyer_pubkey));\n    script.push_data(bc::to_chunk(seller_pubkey));\n    script.push_data(bc::to_chunk(escrow_pubkey));\n    script.push_operation(bc::opcode(3));\n    script.push_operation(bc::opcode::checkmultisig);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createEscrowScript(buyerPubkey, sellerPubkey, escrowPubkey []byte) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(2) // 2-of-3\n\tbuilder.AddData(buyerPubkey)\n\tbuilder.AddData(sellerPubkey)\n\tbuilder.AddData(escrowPubkey)\n\tbuilder.AddInt64(3)\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createEscrowScript(buyerPubkey, sellerPubkey, escrowPubkey) {\n    return bitcoin.script.multisig.output.encode(2, [\n        buyerPubkey,\n        sellerPubkey,\n        escrowPubkey,\n    ]);\n}\n```\n:::\n\n---\n\n## Advanced Patterns\n\n### Vault Contracts\n\nTime-delayed recovery:\n\n```text\nVault Structure:\n1. Hot key: Can spend immediately (small amount)\n2. Cold key: Can spend after delay (large amount)\n3. Recovery key: Can spend after longer delay\n\nUse case: Theft protection\n```\n\n### Inheritance Contracts\n\nGradual fund release:\n\n```text\nInheritance:\n- Beneficiary can claim after date\n- Multiple beneficiaries possible\n- Time-locked release\n```\n\n### Atomic Swaps\n\nCross-chain exchanges:\n\n```text\nAtomic Swap:\n1. Lock funds with hash lock\n2. Reveal secret to claim\n3. Either both succeed or both fail\n```\n\n---\n\n## Taproot Contracts\n\nTaproot enables better contracts:\n\n```text\nBenefits:\n- Privacy: Complex contracts look like simple payments\n- Efficiency: Smaller transaction sizes\n- Flexibility: MAST hides unused conditions\n```\n\n---\n\n## Miniscript\n\n[Miniscript](/docs/bitcoin-development/miniscript) is a structured language for expressing spending *policies* that compiles to [Bitcoin Script](/docs/bitcoin/script). You describe *what* must hold (e.g., 2-of-3 keys, or \"key A and after block N\") and tools produce correct, analyzable Script. This simplifies multisig, [timelocks](/docs/bitcoin/timelocks), [vaults](/docs/wallets/smart-contracts), and [Taproot](/docs/bitcoin/taproot) script trees. See [Miniscript](/docs/bitcoin-development/miniscript) for the full specification and use in wallets and protocols.\n\n---\n\n## Covenants (Proposed)\n\n[Covenants](/docs/advanced/covenants) are a *proposed* type of contract that would restrict how [outputs](/docs/glossary#output) can be spent in *future* [transactions](/docs/bitcoin/transaction-lifecycle), for example, \"this [UTXO](/docs/glossary#utxo-unspent-transaction-output) may only be spent to addresses of type X\" or \"funds must pass through a timelocked recovery path.\" Proposals such as **OP_CAT**, **OP_CTV** (CheckTemplateVerify), and **SIGHASH_ANYPREVOUT** aim to enable covenant-like behavior. None are in [consensus](/docs/glossary#consensus) today; see [Covenants](/docs/advanced/covenants) for the design space and BIPs.\n\n---\n\n## Limitations\n\n### What Bitcoin Can't Do\n\n1. **Complex state**: No persistent contract state\n2. **Loops**: No iterative operations\n3. **External data**: No oracles (without DLCs)\n4. **Turing-complete**: Intentionally limited\n\n### Why Limitations Exist\n\n- **Security**: Simpler = fewer bugs\n- **DoS prevention**: No infinite loops\n- **Determinism**: Predictable execution\n- **Decentralization**: Easy to validate\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Use established patterns**: Don't reinvent the wheel\n2. **Test thoroughly**: Script bugs are costly\n3. **Consider Taproot**: Better privacy and efficiency\n4. **Document contracts**: Explain conditions clearly\n\n### For Users\n\n1. **Understand conditions**: Know when funds can be spent\n2. **Test on testnet**: Verify contracts work\n3. **Use reputable services**: Escrow, etc.\n4. **Backup keys**: Multisig requires key management\n\n---\n\n## Related Topics\n\n- [Bitcoin Script](/docs/bitcoin/script) - Script system\n- [OP Codes](/docs/bitcoin/op-codes) - Available operations\n- [Miniscript](/docs/bitcoin-development/miniscript) - Policy-to-script compiler\n- [Covenants](/docs/advanced/covenants) - Proposed output-spend constraints\n- [Timelocks](/docs/bitcoin/timelocks) - Time-based conditions\n- [Multisig](/docs/wallets/multisig) - Multi-signature wallets\n- [Atomic Swaps](/docs/advanced/atomic-swaps) - Cross-chain contracts\n\n---\n\n## Resources\n\n- [Bitcoin Script Patterns](https://en.bitcoin.it/wiki/Script)\n- [Miniscript](https://bitcoin.sipa.be/miniscript/) - Policy to script compiler\n",
    "filename": "smart-contracts.md"
  },
  "/docs/lightning": {
    "content": "# The Lightning Network\n\nThe Lightning Network is a second-layer payment protocol built on top of Bitcoin. It enables instant, low-cost payments by creating a network of bidirectional [payment channels](/docs/glossary#payment-channel) between nodes.\n\n## History\n\nThe Lightning Network was proposed in 2015 by Joseph Poon and Thaddeus Dryja in their whitepaper \"The Bitcoin Lightning Network: Scalable Off-Chain Instant Payments.\" The concept addresses Bitcoin's scalability limitations by moving most transactions off-chain while maintaining the security guarantees of the Bitcoin blockchain.\n\nThe first mainnet Lightning implementations launched in 2018, including LND (Lightning Labs), c-lightning/CLN (Blockstream), and Eclair (ACINQ).\n\n---\n\n## Key Concepts\n\n- **Payment Channels**: Two-party channels that allow unlimited off-chain transactions\n- **Off-Chain Transactions**: Payments settle instantly without blockchain confirmation\n- **HTLCs**: [Hash Time-Locked Contracts](/docs/glossary#htlc-hash-time-locked-contract) enable trustless multi-hop routing\n- **Onion Routing**: Privacy-preserving payment routing (similar to Tor)\n- **Instant Settlement**: Payments complete in milliseconds, not minutes\n\n---\n\n## How It Works\n\n1. **Open Channel**: Two parties lock Bitcoin in a 2-of-2 [multisig](/docs/glossary#multisig-multi-signature) address\n2. **Update Balance**: Parties exchange signed [commitment transactions](/docs/glossary#commitment-transaction) to update the channel balance\n3. **Route Payments**: Payments can route through multiple channels using HTLCs\n4. **Close Channel**: Final state is broadcast to the Bitcoin blockchain\n\n---\n\n## Scalability\n\nThe Lightning Network can theoretically handle millions of transactions per second because:\n\n- Most transactions never touch the blockchain\n- Channels can be reused for unlimited payments\n- Network capacity grows with each new channel\n- Fees are minimal (typically < 1 satoshi)\n\n---\n\n## Trade-offs\n\n| Aspect | On-Chain Bitcoin | Lightning Network |\n|--------|------------------|-------------------|\n| Speed | 10-60 minutes | Milliseconds |\n| Fees | Variable (1-100+ sats/vB) | Near zero |\n| Finality | Probabilistic | Instant (conditional) |\n| Capacity | ~7 TPS | Millions TPS |\n| Requirement | None | Channel liquidity |\n| Online | No | Yes (for receiving) |\n\n---\n\n## Getting Started with Lightning\n\nThis section covers practical setup and operations for running a Lightning node.\n\n### Prerequisites\n\n- **Bitcoin Node**: Fully synced Bitcoin Core node\n- **Lightning Implementation**: LND, CLN (Core Lightning), Eclair, or LDK-based\n- **Network**: Signet (recommended for testing) or mainnet\n\n### Bitcoin Node Configuration\n\nAdd to your `bitcoin.conf`:\n\n```ini\n# ZMQ Notifications (required for Lightning)\nzmqpubrawblock=tcp://127.0.0.1:28332\nzmqpubrawtx=tcp://127.0.0.1:28333\n\n# Recommended settings\ntxindex=1\nserver=1\n```\n\nBitcoin Core must be built with ZMQ support for Lightning to work.\n\n### Lightning Node Configuration (LND)\n\nCreate `lnd.conf`:\n\n```ini\n[Application Options]\ndebuglevel=info\nmaxpendingchannels=10\n\n[Bitcoin]\nbitcoin.active=1\nbitcoin.signet=1\nbitcoin.node=bitcoind\n\n[Bitcoind]\nbitcoind.rpchost=localhost\nbitcoind.rpcuser=your_rpc_user\nbitcoind.rpcpass=your_rpc_password\nbitcoind.zmqpubrawblock=tcp://127.0.0.1:28332\nbitcoind.zmqpubrawtx=tcp://127.0.0.1:28333\n```\n\nStart LND:\n\n```bash\nlnd --configfile=/path/to/lnd.conf\n```\n\n### Funding Your Node\n\nGet a deposit address from your Lightning node:\n\n```bash\nlncli newaddress p2wkh\n```\n\nSend Bitcoin to this address and wait for confirmation (typically 3-6 blocks for safety).\n\n---\n\n## Opening Channels\n\n### Connect to a Peer\n\n```bash\nlncli connect <pubkey>@<host>:<port>\n```\n\n### Open a Channel\n\n```bash\n# Open a channel with 100,000 satoshis capacity\nlncli openchannel --node_key=<pubkey> --local_amt=100000\n```\n\nThe channel opening process:\n\n1. Create funding transaction (2-of-2 multisig)\n2. Exchange initial commitment transactions\n3. Broadcast funding transaction\n4. Wait for confirmations (typically 3-6 blocks)\n5. Channel becomes active\n\n### Check Channel Status\n\n```bash\nlncli listchannels\nlncli pendingchannels\n```\n\n---\n\n## Creating and Paying Invoices\n\n### Create an Invoice\n\n```bash\n# Create invoice for 1000 satoshis\nlncli addinvoice --amt=1000 --memo=\"Coffee payment\"\n```\n\nThis returns a BOLT11 invoice string starting with `lnbc` (mainnet), `lntb` (testnet), or `lntbs` (signet).\n\n### Pay an Invoice\n\n```bash\nlncli payinvoice <bolt11_invoice>\n```\n\n### Track Payment Status\n\n```bash\nlncli listpayments\nlncli trackpayment <payment_hash>\n```\n\n---\n\n## Node Operations\n\n### Get Node Info\n\n```bash\nlncli getinfo\n```\n\n### Check Balances\n\n```bash\n# On-chain balance\nlncli walletbalance\n\n# Channel balance\nlncli channelbalance\n```\n\n### List Connected Peers\n\n```bash\nlncli listpeers\n```\n\n---\n\n## Troubleshooting\n\n### Channel Not Opening\n\n- Verify Bitcoin node is synced and ZMQ is configured\n- Check you have sufficient on-chain balance\n- Ensure peer is reachable and accepting channels\n\n### Payment Failing\n\n- **No route found**: Insufficient network connectivity\n- **Insufficient balance**: Not enough outbound liquidity\n- **HTLC timeout**: Route too long or node offline\n\n### Node Not Starting\n\n- Check Bitcoin RPC credentials\n- Verify ZMQ ports match configuration\n- Review LND logs: `tail -f ~/.lnd/logs/bitcoin/mainnet/lnd.log`\n\n---\n\n## Best Practices\n\n### Security\n\n- Back up your channel state and wallet seed\n- Use strong RPC credentials\n- Keep Lightning software updated\n- Consider running a [watchtower](/docs/lightning/watchtowers)\n\n### Channel Management\n\n- Open channels to well-connected nodes\n- Maintain balanced channels for routing\n- Monitor channel health regularly\n- Close inactive or problematic channels\n\n---\n\n## Next Steps\n\n- Learn about [Payment Channels](/docs/lightning/channels)\n- [Routing Fees](/docs/lightning/routing), [HTLCs](/docs/lightning/routing/htlc), and [Multi-Part Payments](/docs/lightning/routing/mpp)\n- Explore [Onion Routing](/docs/lightning/onion) for privacy\n- [Invoices (BOLT11)](/docs/lightning/invoices) and [BOLT12 & Offers](/docs/lightning/bolt12-offers) for payment requests and recurring payments\n\n---\n\n## Resources\n\n- [BOLT Specifications](https://github.com/lightning/bolts) - Protocol specifications\n- [LND Documentation](https://docs.lightning.engineering/)\n- [Core Lightning Documentation](https://docs.corelightning.org/)\n- [Lightning Network Whitepaper](https://lightning.network/lightning-network-paper.pdf)\n",
    "filename": "overview.md"
  },
  "/docs/lightning/channels": {
    "content": "# Lightning Payment Channels\n\nPayment channels are the fundamental building block of the Lightning Network. They enable off-chain transactions between two parties with on-chain settlement. A payment channel is a 2-of-2 [multisig](/docs/glossary#multisig-multi-signature) address that locks Bitcoin between two parties. The parties can update the channel balance off-chain without broadcasting to the Bitcoin network. Key properties:\n\n- **2-of-2 Multisig**: Both parties must sign to spend\n- **Off-Chain Updates**: Balance changes happen instantly without blockchain transactions\n- **On-Chain Settlement**: Final state broadcast to Bitcoin when closing\n- **Bidirectional**: Payments can flow in both directions\n\n---\n\n## Channel Lifecycle\n\n### 1. Channel Opening\n\n**Funding Transaction:**\n- Creates 2-of-2 multisig output\n- Locks Bitcoin from one or both parties\n- Broadcast to Bitcoin network\n- Wait for confirmation (typically 3-6 blocks)\n\n```text\nOpening Process:\n1. Alice and Bob agree to open channel\n2. Create funding transaction (2-of-2 multisig)\n3. Exchange initial commitment transactions\n4. Broadcast funding transaction\n5. Wait for confirmation\n6. Channel becomes active\n```\n\n### 2. Channel Active\n\n**Off-Chain Updates:**\n- Parties exchange signed [commitment transactions](/docs/glossary#commitment-transaction)\n- Each update reflects new balance distribution\n- No blockchain transaction needed\n- Instant and free\n\n```text\nUpdate Process:\n1. Alice wants to send 10,000 sats to Bob\n2. Create new commitment transaction:\n   - Old: Alice 50,000, Bob 50,000\n   - New: Alice 40,000, Bob 60,000\n3. Exchange signatures on new commitments\n4. Exchange revocation secrets for old state\n5. Balance updated (off-chain)\n```\n\n### 3. Channel Closing\n\n**Closing Options:**\n\n| Type | Description | Speed | Cost |\n|------|-------------|-------|------|\n| Cooperative | Both parties agree | Fast | Low |\n| Force Close | Unilateral broadcast | Slow (timelock) | Higher |\n| Breach/Penalty | Punish cheating attempt | Varies | Attacker loses all |\n\n---\n\n## Commitment Transactions\n\nEach commitment transaction represents the current channel state:\n\n```text\nInput: Funding transaction output (2-of-2 multisig)\nOutputs:\n  - Alice's balance (to_local or to_remote)\n  - Bob's balance (to_local or to_remote)\n  - Any pending HTLCs\n```\n\n### Asymmetric Commitments\n\nEach party holds a different version of the commitment transaction:\n\n- **Alice's version**: Her output has a timelock (revocable)\n- **Bob's version**: His output has a timelock (revocable)\n\nThis asymmetry enables the revocation mechanism.\n\n### Revocation Mechanism\n\nWhen the channel state updates:\n\n1. Create new commitment transactions\n2. Exchange signatures\n3. Exchange revocation secrets for old state\n4. Old commitments become toxic (broadcasting = penalty)\n\n---\n\n## Channel Balance Queries\n\n:::code-group\n```rust\nuse ldk_node::Node;\n\n/// Query channel balances using LDK\nfn get_channel_balances(node: &Node) -> (u64, u64) {\n    let channels = node.list_channels();\n    \n    let mut local_balance_msat: u64 = 0;\n    let mut remote_balance_msat: u64 = 0;\n    \n    for channel in channels {\n        local_balance_msat += channel.balance_msat;\n        // Remote balance = capacity - local - pending HTLCs\n        let capacity_msat = channel.channel_value_sats * 1000;\n        remote_balance_msat += capacity_msat.saturating_sub(channel.balance_msat);\n    }\n    \n    (local_balance_msat, remote_balance_msat)\n}\n```\n\n```python\nimport subprocess\nimport json\n\ndef get_channel_balances() -> dict:\n    \"\"\"Query channel balances using lncli.\"\"\"\n    result = subprocess.run(\n        [\"lncli\", \"channelbalance\"],\n        capture_output=True,\n        text=True,\n        check=True\n    )\n    balance = json.loads(result.stdout)\n    \n    return {\n        \"local_balance_sat\": int(balance.get(\"local_balance\", {}).get(\"sat\", 0)),\n        \"remote_balance_sat\": int(balance.get(\"remote_balance\", {}).get(\"sat\", 0)),\n        \"pending_open_local\": int(balance.get(\"pending_open_local_balance\", {}).get(\"sat\", 0)),\n    }\n\n# Example usage\nbalances = get_channel_balances()\nprint(f\"Local: {balances['local_balance_sat']} sats\")\nprint(f\"Remote: {balances['remote_balance_sat']} sats\")\n```\n\n```cpp\n#include <iostream>\n#include <cstdint>\n\nstruct ChannelBalance {\n    uint64_t local_balance_msat;\n    uint64_t remote_balance_msat;\n    uint64_t capacity_msat;\n    \n    double local_ratio() const {\n        if (capacity_msat == 0) return 0.0;\n        return static_cast<double>(local_balance_msat) / capacity_msat;\n    }\n    \n    bool is_balanced(double threshold = 0.2) const {\n        double ratio = local_ratio();\n        return ratio >= threshold && ratio <= (1.0 - threshold);\n    }\n};\n\nvoid print_channel_balance(const ChannelBalance& balance) {\n    std::cout << \"Local:  \" << balance.local_balance_msat / 1000 << \" sats\\n\";\n    std::cout << \"Remote: \" << balance.remote_balance_msat / 1000 << \" sats\\n\";\n    std::cout << \"Ratio:  \" << (balance.local_ratio() * 100) << \"% local\\n\";\n    std::cout << \"Balanced: \" << (balance.is_balanced() ? \"Yes\" : \"No\") << \"\\n\";\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os/exec\"\n)\n\ntype ChannelBalance struct {\n\tLocalBalance  BalanceInfo `json:\"local_balance\"`\n\tRemoteBalance BalanceInfo `json:\"remote_balance\"`\n}\n\ntype BalanceInfo struct {\n\tSat int64 `json:\"sat\"`\n}\n\nfunc getChannelBalances() (*ChannelBalance, error) {\n\t// Query channel balances using lncli\n\tcmd := exec.Command(\"lncli\", \"channelbalance\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar balance ChannelBalance\n\tif err := json.Unmarshal(output, &balance); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &balance, nil\n}\n\nfunc main() {\n\tbalance, err := getChannelBalances()\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\treturn\n\t}\n\n\tfmt.Printf(\"Local: %d sats\\n\", balance.LocalBalance.Sat)\n\tfmt.Printf(\"Remote: %d sats\\n\", balance.RemoteBalance.Sat)\n}\n```\n\n```javascript\nconst { exec } = require('child_process');\nconst util = require('util');\nconst execPromise = util.promisify(exec);\n\n/**\n * Query channel balances using lncli\n * @returns {Promise<{localBalance: bigint, remoteBalance: bigint}>}\n */\nasync function getChannelBalances() {\n    const { stdout } = await execPromise('lncli channelbalance --macaroonpath=/path/to/admin.macaroon');\n    const balance = JSON.parse(stdout);\n    \n    return {\n        localBalance: BigInt(balance.local_balance?.sat || 0),\n        remoteBalance: BigInt(balance.remote_balance?.sat || 0),\n        pendingOpen: BigInt(balance.pending_open_local_balance?.sat || 0),\n    };\n}\n\n// Example usage\ngetChannelBalances().then(balance => {\n    console.log(`Local: ${balance.localBalance} sats`);\n    console.log(`Remote: ${balance.remoteBalance} sats`);\n});\n```\n:::\n\n---\n\n## Channel Capacity and Liquidity\n\n### Total Capacity\n\nChannel capacity equals the funding amount:\n\n```text\nAlice funds: 100,000 sats\nBob funds: 0 sats (single-funded)\nTotal capacity: 100,000 sats\n```\n\n### Liquidity Direction\n\nFor routing payments, liquidity must exist in the payment direction:\n\n| Direction | Requirement |\n|-----------|-------------|\n| Alice â†’ Bob | Alice needs outbound liquidity |\n| Bob â†’ Alice | Bob needs outbound liquidity |\n\n### Inbound vs Outbound Liquidity\n\n- **Outbound**: Funds you can send (your channel balance)\n- **Inbound**: Funds you can receive (peer's channel balance)\n\nNew nodes often struggle with inbound liquidity since opening channels only provides outbound.\n\n### Liquidity Management\n\nTo receive payments or [route](/docs/lightning/routing) effectively, you need **inbound** [liquidity](/docs/lightning/channels#inbound-vs-outbound-liquidity). To send or route in the other direction, you need **outbound** [liquidity](/docs/lightning/channels#inbound-vs-outbound-liquidity). Common ways to adjust it:\n\n- **Circular rebalancing**: Pay yourself (e.g., between your own [channels](/docs/lightning/channels) or via a loop) to move [liquidity](/docs/lightning/channels#inbound-vs-outbound-liquidity) from one side to the other.\n- **Submarine swaps / liquidity marketplaces**: Use a service to swap [on-chain](/docs/glossary#on-chain) [BTC](/docs/glossary#btc) for [Lightning](/docs/lightning) [inbound](/docs/lightning/channels#inbound-vs-outbound-liquidity) (or the reverse), or to buy/sell [channel](/docs/lightning/channels) capacity.\n- **Liquidity ads (e.g., [BOLT 12](https://github.com/lightning/bolts) or implementation-specific)**: Some nodes advertise that they want to buy or sell [inbound](/docs/lightning/channels#inbound-vs-outbound-liquidity) or [outbound](/docs/lightning/channels#inbound-vs-outbound-liquidity) [liquidity](/docs/lightning/channels#inbound-vs-outbound-liquidity); you can open [channels](/docs/lightning/channels) or [splice](/docs/lightning/channels#channel-splicing) with them.\n- **[Splicing](/docs/lightning/channels#channel-splicing)**: Add or remove [on-chain](/docs/glossary#on-chain) capacity to an existing [channel](/docs/lightning/channels) to rebalance.\n\n---\n\n## Channel Splicing\n\n**Splicing** (as specified in the Lightning [BOLT](https://github.com/lightning/bolts) process) allows you to **add or remove [on-chain](/docs/glossary#on-chain) capacity** to or from an existing [channel](/docs/lightning/channels) **without closing** it. That way you can top up or withdraw [liquidity](/docs/lightning/channels#channel-capacity-and-liquidity) in a single [transaction](/docs/bitcoin/transaction-lifecycle) while keeping the same channel and [HTLC](/docs/lightning/routing/htlc) state.\n\n### How It Works\n\n- **Splice-in**: You add an extra [input](/docs/glossary#input) (and possibly [output](/docs/glossary#output)) to a new **funding [transaction](/docs/bitcoin/transaction-lifecycle)** that spends the existing 2-of-2 [multisig](/docs/glossary#multisig-multi-signature) [UTXO](/docs/glossary#utxo-unspent-transaction-output) and creates a **new** 2-of-2 with a larger (or smaller) amount. Both parties sign; the channel capacity is updated on [confirmation](/docs/glossary#confirmation).\n- **Splice-out**: Part of the channel [balance](/docs/lightning/channels#channel-capacity-and-liquidity) is sent to an [address](/docs/glossary#address) (yours or your peerâ€™s) in the splice [transaction](/docs/bitcoin/transaction-lifecycle), reducing the new 2-of-2 amount.\n\nSplicing is **dual-funded** in the sense that the splice [transaction](/docs/bitcoin/transaction-lifecycle) is cooperatively built; typically it also uses [anchor outputs](/docs/lightning/anchor-outputs) or similar so [fee bumping](/docs/glossary#fee-bumping) works.\n\n### Why Use Splicing\n\n- **Add liquidity**: Get more [inbound](/docs/lightning/channels#inbound-vs-outbound-liquidity) or [outbound](/docs/lightning/channels#inbound-vs-outbound-liquidity) without opening a new [channel](/docs/lightning/channels) and without [on-chain](/docs/glossary#on-chain) round-trips for a full close+reopen.\n- **Withdraw liquidity**: Reduce channel capacity and free [BTC](/docs/glossary#btc) on-chain without closing the [channel](/docs/lightning/channels) and losing your [routing](/docs/lightning/routing) relationship.\n\nSupport for splicing varies by implementation (e.g., [Core Lightning](https://github.com/ElementsProject/lightning), [LDK](https://github.com/lightningdevkit/rust-lightning)); check your nodeâ€™s documentation.\n\n---\n\n## Channel Types\n\n### Public Channels\n\n- Announced to the network gossip\n- Appear in the public channel graph\n- Can route payments for others\n- Required for earning routing fees\n\n### Private (Unannounced) Channels\n\n- Not broadcast to the network\n- Only known to the two parties\n- Can still be used with route hints\n- Better privacy for end users\n\n---\n\n## Channel Security\n\n### Revocation Keys\n\nEach commitment state has an associated revocation key. If a party broadcasts an old state, the counterparty can:\n\n1. Detect the old commitment on-chain\n2. Use the revocation secret to construct a penalty transaction\n3. Claim all funds in the channel\n\n### Timelocks\n\nForce-closed channels have timelocks (typically 144-2016 blocks) that give the counterparty time to detect and punish cheating attempts.\n\n### Watchtowers\n\nThird-party services that monitor the blockchain for breach attempts when your node is offline. See [Watchtowers](/docs/lightning/watchtowers) for details.\n\n---\n\n## Common Issues\n\n### Unbalanced Channels\n\n**Problem**: All funds on one side prevents bidirectional payments.\n\n**Solutions**:\n- Circular rebalancing (pay yourself through the network)\n- Submarine swaps (on-chain â†” off-chain)\n- Open additional channels\n- Use liquidity marketplaces\n\n### Stuck Channels\n\n**Problem**: Cannot cooperatively close (peer offline/unresponsive).\n\n**Solution**: Force close and wait for timelock expiry.\n\n### Insufficient Capacity\n\n**Problem**: Payment larger than available channel balance.\n\n**Solutions**:\n- Use [Multi-Part Payments (MPP)](/docs/lightning/routing/mpp)\n- Open larger channel\n- Find alternative route\n\n---\n\n## Summary\n\nPayment channels enable:\n\n- **Instant transactions**: No block confirmation needed\n- **Minimal fees**: Fraction of on-chain costs\n- **Privacy**: Off-chain activity not visible on blockchain\n- **Scalability**: Unlimited payments per channel\n- **Security**: Cryptographic enforcement via commitment/revocation\n\n---\n\n## Related Topics\n\n- [Routing Fees](/docs/lightning/routing), [HTLCs](/docs/lightning/routing/htlc), and [Multi-Part Payments](/docs/lightning/routing/mpp) - How payments route through channels\n- [Watchtowers](/docs/lightning/watchtowers) - Third-party channel monitoring\n- [Anchor Outputs](/docs/lightning/anchor-outputs) - Modern channel format for fee bumping and splicing\n",
    "filename": "channels.md"
  },
  "/docs/lightning/routing/htlc": {
    "content": "# Hash Time-Locked Contracts (HTLCs)\n\nHTLCs are the mechanism that enables payments to route through the Lightning Network. They ensure that payments can only be claimed with the correct [preimage](/docs/glossary#preimage), and expire after a certain time if unclaimed. An HTLC is a conditional payment that requires:\n\n1. **Hash Lock**: Knowledge of a secret (preimage) that hashes to a known value\n2. **Time Lock**: Expires after a certain block height ([CLTV](/docs/glossary#cltv-checklocktimeverify))\n\n```text\nHTLC Conditions:\n- If preimage is revealed before expiry â†’ Payment goes to recipient\n- If time lock expires â†’ Payment returns to sender\n```\n\n---\n\n## How HTLCs Work in Lightning\n\n### Payment Flow\n\n1. **Recipient generates preimage**: Random 32-byte secret, shares SHA256 hash\n2. **Sender creates HTLC chain**: Locks funds with hash and decreasing expiries\n3. **HTLCs propagate**: Each hop creates an HTLC to the next\n4. **Recipient reveals preimage**: Claims final HTLC\n5. **Preimage propagates back**: Each hop claims their incoming HTLC\n6. **Settlement complete**: All HTLCs resolved atomically\n\n### Example Route\n\n```text\nAlice â†’ Bob â†’ Carol â†’ Dave\n\nAlice creates HTLC to Bob:\n  - Amount: 1000 + 3 sats (fees)\n  - Hash: SHA256(preimage)\n  - Expiry: Block 850,040\n\nBob creates HTLC to Carol:\n  - Amount: 1000 + 1 sats (fees)  \n  - Hash: SHA256(preimage) [same]\n  - Expiry: Block 850,030 [earlier]\n\nCarol creates HTLC to Dave:\n  - Amount: 1000 sats\n  - Hash: SHA256(preimage) [same]\n  - Expiry: Block 850,020 [earliest]\n```\n\n### Why Decreasing Expiries?\n\nEach hop needs an **expiry delta** (CLTV delta) buffer to:\n\n- Have time to claim incoming HTLC after learning preimage\n- Handle blockchain congestion\n- Account for clock differences between nodes\n\n**Rule**: Outgoing HTLC expiry < Incoming HTLC expiry (by at least `cltv_expiry_delta`)\n\n---\n\n## HTLC Script Structure\n\nHTLCs in commitment transactions use this script pattern:\n\n```text\n# Offered HTLC (you're offering payment)\nOP_DUP OP_HASH160 <revocation_pubkey_hash> OP_EQUAL\nOP_IF\n    OP_CHECKSIG                           # Revocation path\nOP_ELSE\n    <remote_htlc_pubkey> OP_SWAP OP_SIZE 32 OP_EQUAL\n    OP_IF\n        OP_HASH160 <payment_hash> OP_EQUALVERIFY  # Success path\n        2 OP_SWAP <local_htlc_pubkey> 2 OP_CHECKMULTISIG\n    OP_ELSE\n        OP_DROP <cltv_expiry> OP_CHECKLOCKTIMEVERIFY OP_DROP\n        OP_CHECKSIG                       # Timeout path\n    OP_ENDIF\nOP_ENDIF\n```\n\n---\n\n## HTLC Verification\n\n:::code-group\n```rust\nuse sha2::{Sha256, Digest};\n\n/// Represents an HTLC\nstruct Htlc {\n    payment_hash: [u8; 32],\n    amount_msat: u64,\n    cltv_expiry: u32,\n}\n\nimpl Htlc {\n    /// Verify a preimage against this HTLC's payment hash\n    fn verify_preimage(&self, preimage: &[u8; 32]) -> bool {\n        let mut hasher = Sha256::new();\n        hasher.update(preimage);\n        let hash: [u8; 32] = hasher.finalize().into();\n        hash == self.payment_hash\n    }\n    \n    /// Check if HTLC has expired at given block height\n    fn is_expired(&self, current_height: u32) -> bool {\n        current_height >= self.cltv_expiry\n    }\n    \n    /// Calculate if we have enough time to safely forward\n    fn can_forward(&self, current_height: u32, min_delta: u32) -> bool {\n        self.cltv_expiry > current_height + min_delta\n    }\n}\n\nfn main() {\n    // Example: Create preimage and verify\n    let preimage: [u8; 32] = [0x42; 32];  // In practice, use secure random\n    \n    let mut hasher = Sha256::new();\n    hasher.update(&preimage);\n    let payment_hash: [u8; 32] = hasher.finalize().into();\n    \n    let htlc = Htlc {\n        payment_hash,\n        amount_msat: 1_000_000,\n        cltv_expiry: 850_000,\n    };\n    \n    assert!(htlc.verify_preimage(&preimage));\n    println!(\"Preimage verified successfully!\");\n}\n```\n\n```python\nimport hashlib\nimport secrets\nfrom dataclasses import dataclass\n\n@dataclass\nclass Htlc:\n    payment_hash: bytes  # 32 bytes\n    amount_msat: int\n    cltv_expiry: int\n    \n    def verify_preimage(self, preimage: bytes) -> bool:\n        \"\"\"Verify a preimage against this HTLC's payment hash.\"\"\"\n        computed_hash = hashlib.sha256(preimage).digest()\n        return computed_hash == self.payment_hash\n    \n    def is_expired(self, current_height: int) -> bool:\n        \"\"\"Check if HTLC has expired at given block height.\"\"\"\n        return current_height >= self.cltv_expiry\n    \n    def can_forward(self, current_height: int, min_delta: int = 40) -> bool:\n        \"\"\"Check if we have enough time to safely forward this HTLC.\"\"\"\n        return self.cltv_expiry > current_height + min_delta\n\n\ndef create_htlc(amount_msat: int, cltv_expiry: int) -> tuple[Htlc, bytes]:\n    \"\"\"Create an HTLC with a new random preimage.\"\"\"\n    preimage = secrets.token_bytes(32)\n    payment_hash = hashlib.sha256(preimage).digest()\n    \n    htlc = Htlc(\n        payment_hash=payment_hash,\n        amount_msat=amount_msat,\n        cltv_expiry=cltv_expiry\n    )\n    return htlc, preimage\n\n\n# Example usage\nhtlc, preimage = create_htlc(amount_msat=1_000_000, cltv_expiry=850_000)\n\n# Verify the preimage\nassert htlc.verify_preimage(preimage)\nprint(f\"Payment hash: {htlc.payment_hash.hex()}\")\nprint(f\"Preimage: {preimage.hex()}\")\nprint(\"Preimage verified successfully!\")\n```\n\n```cpp\n#include <iostream>\n#include <array>\n#include <cstdint>\n#include <cstring>\n#include <openssl/sha.h>\n\nstruct Htlc {\n    std::array<uint8_t, 32> payment_hash;\n    uint64_t amount_msat;\n    uint32_t cltv_expiry;\n    \n    // Verify a preimage against this HTLC's payment hash\n    bool verify_preimage(const std::array<uint8_t, 32>& preimage) const {\n        std::array<uint8_t, 32> computed_hash;\n        SHA256(preimage.data(), preimage.size(), computed_hash.data());\n        return payment_hash == computed_hash;\n    }\n    \n    // Check if HTLC has expired at given block height\n    bool is_expired(uint32_t current_height) const {\n        return current_height >= cltv_expiry;\n    }\n    \n    // Check if we have enough time to safely forward\n    bool can_forward(uint32_t current_height, uint32_t min_delta = 40) const {\n        return cltv_expiry > current_height + min_delta;\n    }\n};\n\n// Create payment hash from preimage\nstd::array<uint8_t, 32> hash_preimage(const std::array<uint8_t, 32>& preimage) {\n    std::array<uint8_t, 32> hash;\n    SHA256(preimage.data(), preimage.size(), hash.data());\n    return hash;\n}\n\nint main() {\n    // Create a test preimage\n    std::array<uint8_t, 32> preimage;\n    std::fill(preimage.begin(), preimage.end(), 0x42);\n    \n    // Create HTLC\n    Htlc htlc;\n    htlc.payment_hash = hash_preimage(preimage);\n    htlc.amount_msat = 1000000;\n    htlc.cltv_expiry = 850000;\n    \n    // Verify\n    if (htlc.verify_preimage(preimage)) {\n        std::cout << \"Preimage verified successfully!\" << std::endl;\n    }\n    \n    // Check expiry\n    uint32_t current_height = 849950;\n    std::cout << \"Expired: \" << (htlc.is_expired(current_height) ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Can forward: \" << (htlc.can_forward(current_height) ? \"Yes\" : \"No\") << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// HTLC represents a Hash Time-Locked Contract\ntype HTLC struct {\n\tPaymentHash [32]byte\n\tAmountMsat  uint64\n\tCLTVExpiry  uint32\n}\n\n// VerifyPreimage verifies a preimage against this HTLC's payment hash\nfunc (h *HTLC) VerifyPreimage(preimage [32]byte) bool {\n\thash := sha256.Sum256(preimage[:])\n\treturn hash == h.PaymentHash\n}\n\n// IsExpired checks if HTLC has expired at given block height\nfunc (h *HTLC) IsExpired(currentHeight uint32) bool {\n\treturn currentHeight >= h.CLTVExpiry\n}\n\n// CanForward checks if we have enough time to safely forward this HTLC\nfunc (h *HTLC) CanForward(currentHeight uint32, minDelta uint32) bool {\n\tif minDelta == 0 {\n\t\tminDelta = 40\n\t}\n\treturn h.CLTVExpiry > currentHeight+minDelta\n}\n\n// CreateHTLC creates an HTLC with a new random preimage\nfunc CreateHTLC(amountMsat uint64, cltvExpiry uint32) (*HTLC, [32]byte, error) {\n\tvar preimage [32]byte\n\tif _, err := rand.Read(preimage[:]); err != nil {\n\t\treturn nil, [32]byte{}, err\n\t}\n\n\tpaymentHash := sha256.Sum256(preimage[:])\n\thtlc := &HTLC{\n\t\tPaymentHash: paymentHash,\n\t\tAmountMsat:  amountMsat,\n\t\tCLTVExpiry:  cltvExpiry,\n\t}\n\n\treturn htlc, preimage, nil\n}\n\nfunc main() {\n\t// Example usage\n\thtlc, preimage, _ := CreateHTLC(1_000_000, 850_000)\n\n\tfmt.Printf(\"Payment hash: %s\\n\", hex.EncodeToString(htlc.PaymentHash[:]))\n\tfmt.Printf(\"Preimage: %s\\n\", hex.EncodeToString(preimage[:]))\n\tfmt.Printf(\"Verified: %v\\n\", htlc.VerifyPreimage(preimage))\n\n\tcurrentHeight := uint32(849_950)\n\tfmt.Printf(\"Expired: %v\\n\", htlc.IsExpired(currentHeight))\n\tfmt.Printf(\"Can forward: %v\\n\", htlc.CanForward(currentHeight, 40))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\nclass Htlc {\n    /**\n     * @param {Buffer} paymentHash - 32-byte payment hash\n     * @param {bigint} amountMsat - Amount in millisatoshis\n     * @param {number} cltvExpiry - Block height expiry\n     */\n    constructor(paymentHash, amountMsat, cltvExpiry) {\n        this.paymentHash = paymentHash;\n        this.amountMsat = amountMsat;\n        this.cltvExpiry = cltvExpiry;\n    }\n    \n    /**\n     * Verify a preimage against this HTLC's payment hash\n     * @param {Buffer} preimage - 32-byte preimage\n     * @returns {boolean}\n     */\n    verifyPreimage(preimage) {\n        const computedHash = crypto.createHash('sha256').update(preimage).digest();\n        return computedHash.equals(this.paymentHash);\n    }\n    \n    /**\n     * Check if HTLC has expired at given block height\n     * @param {number} currentHeight\n     * @returns {boolean}\n     */\n    isExpired(currentHeight) {\n        return currentHeight >= this.cltvExpiry;\n    }\n    \n    /**\n     * Check if we have enough time to safely forward this HTLC\n     * @param {number} currentHeight\n     * @param {number} minDelta - Minimum CLTV delta (default: 40)\n     * @returns {boolean}\n     */\n    canForward(currentHeight, minDelta = 40) {\n        return this.cltvExpiry > currentHeight + minDelta;\n    }\n}\n\n/**\n * Create an HTLC with a new random preimage\n * @param {bigint} amountMsat\n * @param {number} cltvExpiry\n * @returns {{htlc: Htlc, preimage: Buffer}}\n */\nfunction createHtlc(amountMsat, cltvExpiry) {\n    const preimage = crypto.randomBytes(32);\n    const paymentHash = crypto.createHash('sha256').update(preimage).digest();\n    \n    return {\n        htlc: new Htlc(paymentHash, amountMsat, cltvExpiry),\n        preimage\n    };\n}\n\n// Example usage\nconst { htlc, preimage } = createHtlc(1_000_000n, 850_000);\n\nconsole.log(`Payment hash: ${htlc.paymentHash.toString('hex')}`);\nconsole.log(`Preimage: ${preimage.toString('hex')}`);\nconsole.log(`Verified: ${htlc.verifyPreimage(preimage)}`);\n\nconst currentHeight = 849_950;\nconsole.log(`Expired: ${htlc.isExpired(currentHeight)}`);\nconsole.log(`Can forward: ${htlc.canForward(currentHeight)}`);\n```\n:::\n\n---\n\n## HTLC States\n\nAn HTLC in a channel transitions through these states:\n\n| State | Description | Outcome |\n|-------|-------------|---------|\n| Offered | Sent to peer, awaiting response | â†’ Accepted or Failed |\n| Accepted | Peer acknowledged, awaiting preimage | â†’ Settled or Failed |\n| Settled | Preimage revealed, funds transferred | Complete |\n| Failed | Timeout or error, funds returned | Complete |\n\n```text\nLifecycle:\nOffered â†’ Accepted â†’ Settled (success)\n    â†“         â†“\n  Failed   Failed (timeout/error)\n```\n\n---\n\n## HTLC Security Properties\n\n### Atomicity\n\nEither the entire payment succeeds or fails completely:\n\n- All HTLCs in the route share the same payment hash\n- Revealing the preimage settles all HTLCs\n- Timeout returns all funds to senders\n\n### Hash Lock Security\n\n- Preimage must be exactly 32 bytes\n- SHA256 is collision-resistant\n- Only the recipient knows the preimage initially\n\n### Time Lock Security\n\n- CLTV (CheckLockTimeVerify) enforced by Bitcoin consensus\n- Sufficient delta prevents race conditions\n- Allows time for breach detection\n\n---\n\n## Common Issues\n\n### HTLC Timeout\n\n**Problem**: HTLC expires before payment completes.\n\n**Causes**:\n- Route too long (accumulated CLTV deltas)\n- Slow intermediate nodes\n- Network congestion\n\n**Solutions**:\n- Increase `max_cltv_expiry` setting\n- Use shorter routes\n- Retry with different path\n\n### Stuck HTLCs\n\n**Problem**: HTLC neither settles nor fails.\n\n**Causes**:\n- Peer offline\n- Bug in implementation\n- Network partition\n\n**Solutions**:\n- Wait for CLTV expiry\n- Force close channel if necessary\n\n---\n\n## Summary\n\nHTLCs are the atomic building blocks of Lightning payments:\n\n- **Hash locks** ensure only the recipient can claim funds\n- **Time locks** enable safe routing through untrusted intermediaries\n- **Decreasing expiries** prevent routing attacks\n- **Atomicity** guarantees all-or-nothing settlement\n\n---\n\n## Related Topics\n\n- [Routing Fees](/docs/lightning/routing) - How routing fees work\n- [Multi-Part Payments](/docs/lightning/routing/mpp) - Splitting payments across routes\n- [Onion Routing](/docs/lightning/onion) - Privacy in payment routing\n",
    "filename": "htlc.md"
  },
  "/docs/lightning/routing": {
    "content": "# Lightning Routing Fees\n\nLightning routing fees are how nodes earn income for forwarding payments. Understanding fee calculation is essential for both routing nodes and payment senders.\n\n## Fee Structure\n\nLightning fees consist of two components:\n\n1. **Base Fee**: Fixed fee per HTLC (in millisatoshis)\n2. **Proportional Fee**: Percentage of payment amount (in parts per million)\n\n### Fee Formula\n\n```\nTotal Fee = Base Fee + (Payment Amount Ã— Proportional Fee / 1,000,000)\n```\n\n:::code-group\n```rust\n/// Calculate the fee for forwarding an amount through a channel\n/// Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\nfn calculate_fee(amount_msat: u64, base_fee_msat: u64, proportional_fee_ppm: u64) -> u64 {\n    base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nfn main() {\n    let fee = calculate_fee(100_000_000, 1000, 10);\n    println!(\"Total fee: {} msat\", fee);  // Output: 2000 msat\n}\n```\n\n```python\ndef calculate_fee(amount_msat: int, base_fee_msat: int, proportional_fee_ppm: int) -> int:\n    \"\"\"Calculate the routing fee for forwarding an amount.\n    \n    Args:\n        amount_msat: Amount to forward in millisatoshis\n        base_fee_msat: Fixed fee per HTLC in millisatoshis\n        proportional_fee_ppm: Proportional fee in parts per million\n    \n    Returns:\n        Total fee in millisatoshis (using integer division per BOLT 7)\n    \"\"\"\n    return base_fee_msat + (amount_msat * proportional_fee_ppm // 1_000_000)\n\n# Example: 100,000 sats with 1000 msat base + 10 ppm\nfee = calculate_fee(100_000_000, 1000, 10)\nprint(f\"Total fee: {fee} msat\")  # Output: 2000 msat\n```\n\n```cpp\n#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\n/**\n * Calculate the fee for forwarding an amount through a channel\n * Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n */\nuint64_t calculate_fee(uint64_t amount_msat, uint64_t base_fee_msat, uint64_t proportional_fee_ppm) {\n    return base_fee_msat + (amount_msat * proportional_fee_ppm / 1000000);\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nint main() {\n    uint64_t fee = calculate_fee(100000000, 1000, 10);\n    std::cout << \"Total fee: \" << fee << \" msat\" << std::endl;  // Output: 2000 msat\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\n// CalculateFee calculates the fee for forwarding an amount through a channel\n// Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\nfunc CalculateFee(amountMsat uint64, baseFeeMsat uint64, proportionalFeePpm uint64) uint64 {\n\treturn baseFeeMsat + (amountMsat * proportionalFeePpm / 1_000_000)\n}\n\nfunc main() {\n\t// Example: 100,000 sats with 1000 msat base + 10 ppm\n\tfee := CalculateFee(100_000_000, 1000, 10)\n\tfmt.Printf(\"Total fee: %d msat\\n\", fee) // Output: 2000 msat\n}\n```\n\n```javascript\n/**\n * Calculate the fee for forwarding an amount through a channel\n * Fee = base_fee_msat + (amount_msat * proportional_fee_ppm / 1_000_000)\n * \n * @param {BigInt} amountMsat - Amount to forward in millisatoshis\n * @param {BigInt} baseFeeMsat - Fixed fee per HTLC in millisatoshis\n * @param {BigInt} proportionalFeePpm - Proportional fee in parts per million\n * @returns {BigInt} Total fee in millisatoshis\n */\nfunction calculateFee(amountMsat, baseFeeMsat, proportionalFeePpm) {\n    return baseFeeMsat + (amountMsat * proportionalFeePpm / 1_000_000n);\n}\n\n// Example: 100,000 sats with 1000 msat base + 10 ppm\nconst fee = calculateFee(100_000_000n, 1000n, 10n);\nconsole.log(`Total fee: ${fee} msat`);  // Output: 2000 msat\n```\n:::\n\n### Example\n\nGiven:\n- Base fee: 1000 msat\n- Proportional fee: 10 ppm (parts per million)\n- Payment amount: 100,000 sats (100,000,000 msat)\n\nCalculation:\n```\nBase Fee = 1000 msat\nProportional Fee = 100,000,000 Ã— 10 / 1,000,000 = 1000 msat\nTotal Fee = 1000 + 1000 = 2000 msat (2 sats)\n```\n\n---\n\n## Routing Policy\n\nEach node advertises a **routing policy** that specifies:\n\n- `fee_base_msat`: Base fee in millisatoshis\n- `fee_proportional_millionths`: Proportional fee in parts per million\n- `cltv_delta`: Required expiry delta (in blocks)\n\n### Example Policy\n\n```json\n{\n  \"fee_base_msat\": 1000,\n  \"fee_proportional_millionths\": 10,\n  \"cltv_delta\": 40\n}\n```\n\nThis means:\n- 1000 msat base fee per HTLC\n- 10 ppm proportional fee\n- Requires 40 block expiry delta\n\n---\n\n## Fee Calculation Along a Route\n\nWhen calculating fees for a multi-hop route, fees accumulate:\n\n### Example Route\n\n```\nAlice â†’ Bob â†’ Carol â†’ Dave\nPayment: 100,000 sats\n\nBob's Policy:\n  Base: 1000 msat\n  Proportional: 10 ppm\n\nCarol's Policy:\n  Base: 2000 msat\n  Proportional: 500 ppm\n\nDave (final hop, no fee)\n```\n\n### Calculation\n\n**Step 1: Calculate fee to Carol (from Bob)**\n```\nBase: 1000 msat\nProportional: 100,000,000 Ã— 10 / 1,000,000 = 1000 msat\nTotal: 2000 msat\nAmount to Carol: 100,000,000 + 2000 = 100,002,000 msat\n```\n\n**Step 2: Calculate fee to Dave (from Carol)**\n```\nBase: 2000 msat\nProportional: 100,002,000 Ã— 500 / 1,000,000 = 50,001 msat\nTotal: 52,001 msat\nAmount to Dave: 100,002,000 + 52,001 = 100,054,001 msat\n```\n\n**Total Fee Paid**: 54,001 msat (54 sats)\n\n---\n\n## HTLC Amount Calculation\n\nFor each hop, the HTLC amount includes:\n- Original payment amount\n- All fees accumulated up to that point\n\n### Backward Calculation\n\nStarting from the final amount, work backwards:\n\n```\nFinal Amount (to Dave): 100,054,001 msat\n\nCarol's HTLC to Dave: 100,054,001 msat\n  (includes: 100,000,000 + 2000 + 52,001)\n\nBob's HTLC to Carol: 100,002,000 msat\n  (includes: 100,000,000 + 2000)\n\nAlice's HTLC to Bob: 100,000,000 msat\n  (original payment)\n```\n\n:::code-group\n```rust\n/// Represents a hop in the payment route\nstruct Hop {\n    channel_name: String,\n    cltv_delta: u32,\n    base_fee_msat: u64,\n    proportional_fee_ppm: u64,\n}\n\n/// Represents calculated HTLC values for a hop\nstruct HtlcHop {\n    channel_name: String,\n    htlc_amount_msat: u64,\n    htlc_expiry: u32,\n}\n\n/// Calculate HTLC values working backwards from destination\nfn calculate_route_backwards(\n    hops: &[Hop],\n    final_amount_msat: u64,\n    min_final_cltv: u32,\n    block_height: u32,\n) -> Vec&lt;HtlcHop&gt; {\n    let mut htlc_hops = Vec::with_capacity(hops.len());\n    \n    // Start with final hop values\n    let mut current_amount = final_amount_msat;\n    let mut current_expiry = block_height + min_final_cltv;\n    \n    // Process hops in reverse order\n    for i in (0..hops.len()).rev() {\n        let hop = &hops[i];\n        \n        htlc_hops.push(HtlcHop {\n            channel_name: hop.channel_name.clone(),\n            htlc_amount_msat: current_amount,\n            htlc_expiry: current_expiry,\n        });\n        \n        // Calculate values for previous hop\n        if i > 0 {\n            let fee = hop.base_fee_msat + \n                      (current_amount * hop.proportional_fee_ppm / 1_000_000);\n            current_amount += fee;\n            current_expiry += hop.cltv_delta;\n        }\n    }\n    \n    htlc_hops.reverse();\n    htlc_hops\n}\n```\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List\n\n@dataclass\nclass Hop:\n    channel_name: str\n    cltv_delta: int\n    base_fee_msat: int\n    proportional_fee_ppm: int\n\n@dataclass\nclass HtlcHop:\n    channel_name: str\n    htlc_amount_msat: int\n    htlc_expiry: int\n\ndef calculate_route_backwards(\n    hops: List[Hop],\n    final_amount_msat: int,\n    min_final_cltv: int,\n    block_height: int\n) -> List[HtlcHop]:\n    \"\"\"Calculate HTLC values for each hop, working backwards.\"\"\"\n    htlc_hops = []\n    \n    # Start with final hop values\n    current_amount = final_amount_msat\n    current_expiry = block_height + min_final_cltv\n    \n    # Process hops in reverse order\n    for i in range(len(hops) - 1, -1, -1):\n        hop = hops[i]\n        \n        # Store current values for this hop\n        htlc_hops.append(HtlcHop(\n            channel_name=hop.channel_name,\n            htlc_amount_msat=current_amount,\n            htlc_expiry=current_expiry\n        ))\n        \n        # Calculate values for previous hop (if not first hop)\n        if i > 0:\n            fee = hop.base_fee_msat + (current_amount * hop.proportional_fee_ppm // 1_000_000)\n            current_amount += fee\n            current_expiry += hop.cltv_delta\n    \n    return list(reversed(htlc_hops))\n```\n\n```cpp\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;cstdint&gt;\n#include &lt;algorithm&gt;\n\nstruct Hop {\n    std::string channel_name;\n    uint32_t cltv_delta;\n    uint64_t base_fee_msat;\n    uint64_t proportional_fee_ppm;\n};\n\nstruct HtlcHop {\n    std::string channel_name;\n    uint64_t htlc_amount_msat;\n    uint32_t htlc_expiry;\n};\n\n/**\n * Calculate HTLC values working backwards from destination\n */\nstd::vector&lt;HtlcHop&gt; calculate_route_backwards(\n    const std::vector&lt;Hop&gt;& hops,\n    uint64_t final_amount_msat,\n    uint32_t min_final_cltv,\n    uint32_t block_height\n) {\n    std::vector&lt;HtlcHop&gt; htlc_hops;\n    htlc_hops.reserve(hops.size());\n    \n    // Start with final hop values\n    uint64_t current_amount = final_amount_msat;\n    uint32_t current_expiry = block_height + min_final_cltv;\n    \n    // Process hops in reverse order\n    for (int i = static_cast&lt;int&gt;(hops.size()) - 1; i >= 0; --i) {\n        const Hop& hop = hops[i];\n        \n        htlc_hops.push_back({\n            hop.channel_name,\n            current_amount,\n            current_expiry\n        });\n        \n        // Calculate values for previous hop\n        if (i > 0) {\n            uint64_t fee = hop.base_fee_msat + \n                          (current_amount * hop.proportional_fee_ppm / 1000000);\n            current_amount += fee;\n            current_expiry += hop.cltv_delta;\n        }\n    }\n    \n    std::reverse(htlc_hops.begin(), htlc_hops.end());\n    return htlc_hops;\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Hop represents a hop in the payment route\ntype Hop struct {\n\tChannelName        string\n\tCLTVDelta          uint32\n\tBaseFeeMsat        uint64\n\tProportionalFeePpm uint64\n}\n\n// HTLCHop represents calculated HTLC values for a hop\ntype HTLCHop struct {\n\tChannelName    string\n\tHTLCAmountMsat uint64\n\tHTLCExpiry     uint32\n}\n\n// CalculateRouteBackwards calculates HTLC values working backwards from destination\nfunc CalculateRouteBackwards(hops []Hop, finalAmountMsat uint64, minFinalCltv uint32, blockHeight uint32) []HTLCHop {\n\thtlcHops := make([]HTLCHop, 0, len(hops))\n\t\n\t// Start with final hop values\n\tcurrentAmount := finalAmountMsat\n\tcurrentExpiry := blockHeight + minFinalCltv\n\t\n\t// Process hops in reverse order\n\tfor i := len(hops) - 1; i >= 0; i-- {\n\t\thop := hops[i]\n\t\t\n\t\thtlcHops = append(htlcHops, HTLCHop{\n\t\t\tChannelName:    hop.ChannelName,\n\t\t\tHTLCAmountMsat: currentAmount,\n\t\t\tHTLCExpiry:     currentExpiry,\n\t\t})\n\t\t\n\t\t// Calculate values for previous hop\n\t\tif i > 0 {\n\t\t\tfee := hop.BaseFeeMsat + (currentAmount * hop.ProportionalFeePpm / 1_000_000)\n\t\t\tcurrentAmount += fee\n\t\t\tcurrentExpiry += hop.CLTVDelta\n\t\t}\n\t}\n\t\n\t// Reverse to get forward order\n\tfor i, j := 0, len(htlcHops)-1; i < j; i, j = i+1, j-1 {\n\t\thtlcHops[i], htlcHops[j] = htlcHops[j], htlcHops[i]\n\t}\n\t\n\treturn htlcHops\n}\n```\n\n```javascript\n/**\n * Represents a hop in the payment route\n * @typedef {Object} Hop\n * @property {string} channelName\n * @property {number} cltvDelta\n * @property {BigInt} baseFeeMsat\n * @property {BigInt} proportionalFeePpm\n */\n\n/**\n * Represents calculated HTLC values for a hop\n * @typedef {Object} HtlcHop\n * @property {string} channelName\n * @property {BigInt} htlcAmountMsat\n * @property {number} htlcExpiry\n */\n\n/**\n * Calculate HTLC values working backwards from destination\n * @param {Hop[]} hops - Array of hops in the route\n * @param {BigInt} finalAmountMsat - Final payment amount\n * @param {number} minFinalCltv - Minimum CLTV for final hop\n * @param {number} blockHeight - Current block height\n * @returns {HtlcHop[]} Calculated HTLC values for each hop\n */\nfunction calculateRouteBackwards(hops, finalAmountMsat, minFinalCltv, blockHeight) {\n    const htlcHops = [];\n    \n    // Start with final hop values\n    let currentAmount = finalAmountMsat;\n    let currentExpiry = blockHeight + minFinalCltv;\n    \n    // Process hops in reverse order\n    for (let i = hops.length - 1; i >= 0; i--) {\n        const hop = hops[i];\n        \n        htlcHops.push({\n            channelName: hop.channelName,\n            htlcAmountMsat: currentAmount,\n            htlcExpiry: currentExpiry\n        });\n        \n        // Calculate values for previous hop\n        if (i > 0) {\n            const fee = hop.baseFeeMsat + \n                       (currentAmount * hop.proportionalFeePpm / 1_000_000n);\n            currentAmount += fee;\n            currentExpiry += hop.cltvDelta;\n        }\n    }\n    \n    return htlcHops.reverse();\n}\n```\n:::\n\n---\n\n## Integer Division\n\n**Important**: Lightning uses **integer division** for fee calculation (as per BOLT 7).\n\nThis means:\n- Round down (floor) any fractional results\n- No rounding up\n- Can lead to small discrepancies\n\n### Example\n\n```\nPayment: 1,000,000 msat\nProportional Fee: 3 ppm\n\nCalculation: 1,000,000 Ã— 3 / 1,000,000 = 3 msat âœ“\n\nBut if payment was 999,999 msat:\n999,999 Ã— 3 / 1,000,000 = 2.999997 msat\nInteger division: 2 msat (rounded down)\n```\n\n---\n\n## Fee Economics\n\n### For Routing Nodes\n\n**Revenue Sources:**\n- Base fees from each forwarded payment\n- Proportional fees based on payment size\n\n**Costs:**\n- Channel liquidity (locked capital)\n- Risk of failed payments\n- Operational costs (node maintenance)\n\n**Optimization:**\n- Set competitive but profitable fees\n- Balance liquidity across channels\n- Monitor network conditions\n\n### For Payment Senders\n\n**Considerations:**\n- Total fee across route\n- Payment success probability\n- Route length (more hops = more fees)\n\n**Optimization:**\n- Find routes with lower fees\n- Use direct channels when possible\n- Consider payment splitting (MPP)\n\n---\n\n## Fee Limits\n\n### Maximum Fees\n\nThere's no hard limit on fees, but:\n- Very high fees reduce payment success\n- Market forces keep fees reasonable\n- Nodes compete for routing business\n\n### Minimum Fees\n\nSome nodes set minimum fees to:\n- Cover operational costs\n- Discourage spam\n- Ensure profitability\n\n---\n\n## Fee Discovery\n\n### How Senders Find Fees\n\n1. **Network Graph**: Query network for channel policies\n2. **Route Calculation**: Calculate fees for potential routes\n3. **Fee Comparison**: Compare routes by total fee\n4. **Route Selection**: Choose route with acceptable fees\n\n### Fee Updates\n\nNodes can update their fees:\n- Change base fee\n- Change proportional fee\n- Update channel policies\n\nChanges take effect immediately for new payments.\n\n---\n\n## Best Practices\n\n### For Routing Nodes\n\n1. **Competitive Pricing**: Set fees that attract routing\n2. **Monitor Market**: Adjust fees based on network conditions\n3. **Balance Channels**: Maintain liquidity for routing\n4. **Transparent Policies**: Clearly advertise fee structure\n\n### For Payment Senders\n\n1. **Compare Routes**: Check fees across different routes\n2. **Direct Channels**: Use direct channels to avoid fees\n3. **Payment Size**: Larger payments pay more in proportional fees\n4. **Route Optimization**: Balance fees vs. success probability\n\n---\n\n## Common Issues\n\n### Fees Too High\n\n**Problem**: Route has very high fees\n\n**Solutions**:\n- Try different routes\n- Use direct channels\n- Split payment (MPP)\n- Wait for better routing conditions\n\n### Fees Not Calculated Correctly\n\n**Problem**: Fee calculation doesn't match expected\n\n**Solutions**:\n- Check integer division\n- Verify policy values\n- Account for all hops\n- Include base and proportional fees\n\n---\n\n## Summary\n\nLightning routing fees:\n\n- **Two components**: Base fee + proportional fee\n- **Accumulate**: Fees add up along the route\n- **Integer division**: Use floor division for calculations\n- **Economic incentive**: Rewards nodes for routing\n- **Market driven**: Competition keeps fees reasonable\n\nUnderstanding fees helps both routing nodes optimize revenue and payment senders minimize costs.\n\n---\n\n## Related Topics\n\n- [HTLCs](/docs/lightning/routing/htlc) - Hash Time-Locked Contracts that carry payments along the route\n- [Multi-Part Payments](/docs/lightning/routing/mpp) - Splitting payments across multiple routes\n- [Channels](/docs/lightning/channels) - How channels and liquidity affect routing\n- [Onion Routing](/docs/lightning/onion) - How routes are encoded for privacy\n",
    "filename": "fees.md"
  },
  "/docs/lightning/routing/mpp": {
    "content": "# Multi-Part Payments (MPP)\n\nMulti-Part Payments allow splitting a single payment across multiple routes. This enables larger payments and improves success rates by utilizing multiple channels.\nInstead of sending one large payment through a single route, MPP splits the payment into multiple smaller parts that can take different routes.\n\n### Example\n\n```\nSingle Payment (fails):\nAlice â†’ Bob â†’ Carol â†’ Dave\nAmount: 500,000 sats\nProblem: Carol's channel only has 200,000 sats capacity\n\nMPP Payment (succeeds):\nRoute 1: Alice â†’ Bob â†’ Carol â†’ Dave (200,000 sats)\nRoute 2: Alice â†’ Eve â†’ Dave (200,000 sats)\nRoute 3: Alice â†’ Fred â†’ George â†’ Dave (100,000 sats)\nTotal: 500,000 sats\n```\n\n---\n\n## Why Use MPP?\n\n### Benefits\n\n1. **Larger Payments**: Can send amounts larger than any single channel\n2. **Higher Success Rate**: Multiple routes increase chance of success\n3. **Better Liquidity Utilization**: Use multiple channels simultaneously\n4. **Fault Tolerance**: If one route fails, others can still succeed\n\n### Use Cases\n\n- **Large Payments**: Payments larger than channel capacity\n- **Unbalanced Channels**: When direct channels are one-sided\n- **Network Congestion**: When single routes are unreliable\n- **Optimization**: Split to minimize fees or maximize speed\n\n---\n\n## How MPP Works\n\n### Payment Splitting\n\n1. **Determine Split**: Divide payment into multiple parts\n2. **Find Routes**: Find routes for each part\n3. **Send Simultaneously**: Send all parts at once\n4. **Wait for All**: Wait for all parts to complete\n5. **Verify Completion**: Ensure all parts succeeded\n\n### Equal Splitting\n\nSimplest approach: divide payment equally among routes:\n\n```\nPayment: 120,000 sats\nRoutes: 3\n\nSplit: 120,000 / 3 = 40,000 sats per route\n```\n\n### Optimal Splitting\n\nMore advanced: split based on:\n- Channel capacities\n- Fee optimization\n- Success probability\n- Route quality\n\n---\n\n## TLV Encoding for MPP\n\nMPP payments include special TLV (Type-Length-Value) fields in the final hop of each route.\n\n### Payment Data TLV\n\n```\nType: 8\nLength: 40 bytes\n\nValue (40 bytes):\n  32 bytes: payment_secret (payment_address)\n  8 bytes: total_msat (total payment amount)\n```\n\n:::code-group\n```rust\n/// Encode TLV for MPP payment data\n/// Format: type (8 bytes) + length (8 bytes) + payment_secret (32 bytes) + total_msat (8 bytes)\nfn encode_mpp_tlv(payment_secret: &[u8; 32], total_msat: u64) -> String {\n    let mut result = String::with_capacity(112); // 16 + 16 + 64 + 16 = 112 hex chars\n    \n    // Type: 8 (uint64, big-endian)\n    for byte in &8u64.to_be_bytes() {\n        result.push_str(&format!(\"{:02x}\", byte));\n    }\n    \n    // Length: 40 (uint64, big-endian)\n    for byte in &40u64.to_be_bytes() {\n        result.push_str(&format!(\"{:02x}\", byte));\n    }\n    \n    // Payment secret: 32 bytes\n    for byte in payment_secret.iter() {\n        result.push_str(&format!(\"{:02x}\", byte));\n    }\n    \n    // Total msat: 8 bytes (uint64, big-endian)\n    for byte in &total_msat.to_be_bytes() {\n        result.push_str(&format!(\"{:02x}\", byte));\n    }\n    \n    result\n}\n\n// Example usage\nfn main() {\n    let payment_secret: [u8; 32] = hex::decode(\"b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066\")\n        .unwrap()\n        .try_into()\n        .unwrap();\n    let total_msat: u64 = 120_000;\n    let tlv = encode_mpp_tlv(&payment_secret, total_msat);\n    println!(\"TLV: {}\", tlv);\n}\n```\n\n```python\ndef encode_mpp_tlv(payment_secret: bytes, total_msat: int) -> str:\n    \"\"\"Encode TLV for MPP payment data.\n    \n    Args:\n        payment_secret: 32-byte payment secret from invoice\n        total_msat: Total payment amount in millisatoshis\n    \n    Returns:\n        Hex-encoded TLV string\n    \"\"\"\n    result = \"\"\n    \n    # Type: 8 (uint64, big-endian)\n    result += (8).to_bytes(8, 'big').hex()\n    \n    # Length: 40 (uint64, big-endian) \n    result += (40).to_bytes(8, 'big').hex()\n    \n    # Payment secret: 32 bytes\n    result += payment_secret.hex()\n    \n    # Total msat: 8 bytes (uint64, big-endian)\n    result += total_msat.to_bytes(8, 'big').hex()\n    \n    return result\n\n# Example usage\npayment_secret = bytes.fromhex(\"b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066\")\ntotal_msat = 120_000\ntlv = encode_mpp_tlv(payment_secret, total_msat)\nprint(f\"TLV: {tlv}\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <array>\n#include <cstdint>\n#include <iomanip>\n#include <sstream>\n\n/**\n * Encode TLV for MPP payment data\n * Format: type (8 bytes) + length (8 bytes) + payment_secret (32 bytes) + total_msat (8 bytes)\n */\nstd::string encode_mpp_tlv(const std::array<uint8_t, 32>& payment_secret, uint64_t total_msat) {\n    std::ostringstream result;\n    result << std::hex << std::setfill('0');\n    \n    // Type: 8 (uint64, big-endian)\n    for (int i = 7; i >= 0; --i) {\n        result << std::setw(2) << ((8ULL >> (i * 8)) & 0xFF);\n    }\n    \n    // Length: 40 (uint64, big-endian)\n    for (int i = 7; i >= 0; --i) {\n        result << std::setw(2) << ((40ULL >> (i * 8)) & 0xFF);\n    }\n    \n    // Payment secret: 32 bytes\n    for (const auto& byte : payment_secret) {\n        result << std::setw(2) << static_cast<int>(byte);\n    }\n    \n    // Total msat: 8 bytes (uint64, big-endian)\n    for (int i = 7; i >= 0; --i) {\n        result << std::setw(2) << ((total_msat >> (i * 8)) & 0xFF);\n    }\n    \n    return result.str();\n}\n\n// Example usage\nint main() {\n    std::array<uint8_t, 32> payment_secret = {\n        0xb3, 0xc3, 0x96, 0x51, 0x28, 0xb0, 0x5c, 0x96,\n        0xd7, 0x63, 0x48, 0x15, 0x8f, 0x8f, 0x3a, 0x1b,\n        0x92, 0xe2, 0x84, 0x71, 0x72, 0xf9, 0xad, 0xeb,\n        0xb4, 0x00, 0xa9, 0xe8, 0x3e, 0x62, 0xf0, 0x66\n    };\n    uint64_t total_msat = 120000;\n    std::string tlv = encode_mpp_tlv(payment_secret, total_msat);\n    std::cout << \"TLV: \" << tlv << std::endl;\n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// EncodeMppTlv encodes TLV for MPP payment data\n// Format: type (8 bytes) + length (8 bytes) + payment_secret (32 bytes) + total_msat (8 bytes)\nfunc EncodeMppTlv(paymentSecret [32]byte, totalMsat uint64) string {\n\tvar result []byte\n\n\t// Type: 8 (uint64, big-endian)\n\ttypeBytes := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(typeBytes, 8)\n\tresult = append(result, typeBytes...)\n\n\t// Length: 40 (uint64, big-endian)\n\tlengthBytes := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(lengthBytes, 40)\n\tresult = append(result, lengthBytes...)\n\n\t// Payment secret: 32 bytes\n\tresult = append(result, paymentSecret[:]...)\n\n\t// Total msat: 8 bytes (uint64, big-endian)\n\tmsatBytes := make([]byte, 8)\n\tbinary.BigEndian.PutUint64(msatBytes, totalMsat)\n\tresult = append(result, msatBytes...)\n\n\treturn hex.EncodeToString(result)\n}\n\nfunc main() {\n\t// Example usage\n\tpaymentSecret := [32]byte{0xb3, 0xc3, 0x96, 0x51, 0x28, 0xb0, 0x5c, 0x96,\n\t\t0xd7, 0x63, 0x48, 0x15, 0x8f, 0x8f, 0x3a, 0x1b,\n\t\t0x92, 0xe2, 0x84, 0x71, 0x72, 0xf9, 0xad, 0xeb,\n\t\t0xb4, 0x00, 0xa9, 0xe8, 0x3e, 0x62, 0xf0, 0x66}\n\ttotalMsat := uint64(120000)\n\ttlv := EncodeMppTlv(paymentSecret, totalMsat)\n\tfmt.Printf(\"TLV: %s\\n\", tlv)\n}\n```\n\n```javascript\n/**\n * Encode TLV for MPP payment data\n * Format: type (8 bytes) + length (8 bytes) + payment_secret (32 bytes) + total_msat (8 bytes)\n * \n * @param {Buffer} paymentSecret - 32-byte payment secret from invoice\n * @param {BigInt} totalMsat - Total payment amount in millisatoshis\n * @returns {string} Hex-encoded TLV string\n */\nfunction encodeMppTlv(paymentSecret, totalMsat) {\n    let result = '';\n    \n    // Type: 8 (uint64, big-endian)\n    const typeBuffer = Buffer.alloc(8);\n    typeBuffer.writeBigUInt64BE(8n);\n    result += typeBuffer.toString('hex');\n    \n    // Length: 40 (uint64, big-endian)\n    const lengthBuffer = Buffer.alloc(8);\n    lengthBuffer.writeBigUInt64BE(40n);\n    result += lengthBuffer.toString('hex');\n    \n    // Payment secret: 32 bytes\n    result += paymentSecret.toString('hex');\n    \n    // Total msat: 8 bytes (uint64, big-endian)\n    const msatBuffer = Buffer.alloc(8);\n    msatBuffer.writeBigUInt64BE(BigInt(totalMsat));\n    result += msatBuffer.toString('hex');\n    \n    return result;\n}\n\n// Example usage\nconst paymentSecret = Buffer.from('b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066', 'hex');\nconst totalMsat = 120000n;\nconst tlv = encodeMppTlv(paymentSecret, totalMsat);\nconsole.log(`TLV: ${tlv}`);\n```\n:::\n\n### Example\n\n```\nPayment Secret: b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066\nTotal Amount: 120,000 msat\n\nTLV Encoding:\nType: 0000000000000008 (8)\nLength: 0000000000000028 (40)\nValue: b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f0660000000000000078\n```\n\n### Where to Include\n\n- **Last hop of each path**: Include in final hop's TLV\n- **Same values**: All paths use same payment_secret and total_msat\n- **Other hops**: NULL TLV for non-final hops\n\n---\n\n## MPP Implementation\n\n### Step 1: Simple Route\n\nFor single-path payments, no MPP TLV is needed:\n\n```\nRoute: Alice â†’ Bob â†’ Carol â†’ Dave\nAmount: 100,000 sats\nTLV: NULL (no MPP field)\n```\n\n### Step 2: Multi-Path Payment\n\nFor multi-path payments, include TLV in last hop of each path:\n\n```\nPath 1: Alice â†’ Bob â†’ Carol â†’ Dave\n  Last hop (Carol â†’ Dave): Include MPP TLV\n  \nPath 2: Alice â†’ Eve â†’ Dave\n  Last hop (Eve â†’ Dave): Include MPP TLV\n  \nPath 3: Alice â†’ Fred â†’ George â†’ Dave\n  Last hop (George â†’ Dave): Include MPP TLV\n```\n\n### TLV Structure\n\nThe TLV uses simplified encoding (not full BOLT specification):\n\n```\nType [uint64]: 8\nLength [uint64]: 40\n\nValues [40 bytes]:\n  32 bytes: payment_secret (hex)\n  8 bytes: total_msat (uint64, big-endian)\n```\n\n---\n\n## Payment Secret\n\nThe payment secret (also called payment_address) is:\n- **32 bytes**: Random value generated by recipient\n- **Same for all parts**: All MPP parts use the same secret\n- **Verification**: Recipient verifies all parts use same secret\n- **Security**: Prevents payment mixing attacks\n\n---\n\n## Total Amount\n\nThe total_msat field specifies:\n- **Total payment**: Sum of all MPP parts\n- **Verification**: Recipient verifies sum matches invoice\n- **Same for all parts**: All parts include the same total\n- **8 bytes**: uint64 in big-endian format\n\n---\n\n## Example: 3-Path MPP\n\n### Invoice Details\n\n```\nInvoice Amount: 120,000 sats\nPayment Secret: b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f066\n```\n\n### Route Calculation\n\n```\nPath 0: Alice â†’ Bob â†’ Carol â†’ Dave\n  Amount per path: 40,000 sats\n  Fees: Calculate for each hop\n  \nPath 1: Alice â†’ Eve â†’ Dave\n  Amount per path: 40,000 sats\n  Fees: Calculate for each hop\n  \nPath 2: Alice â†’ Fred â†’ George â†’ Dave\n  Amount per path: 40,000 sats\n  Fees: Calculate for each hop\n```\n\n### TLV for Each Path\n\nAll three paths include the same TLV in their final hop:\n\n```\nTLV: 00000000000000080000000000000028b3c3965128b05c96d76348158f8f3a1b92e2847172f9adebb400a9e83e62f0660000000000000078\n```\n\n---\n\n## Verification\n\n### Recipient Verification\n\nThe recipient verifies:\n1. **All parts received**: All MPP parts arrived\n2. **Same secret**: All parts use same payment_secret\n3. **Correct total**: Sum of parts equals total_msat\n4. **Valid preimage**: All parts have valid preimages\n\n### Sender Verification\n\nThe sender verifies:\n1. **All parts sent**: All parts were sent\n2. **All succeeded**: All parts completed successfully\n3. **Correct amounts**: Sum equals invoice amount\n4. **Preimages match**: All preimages are the same\n\n---\n\n## Best Practices\n\n### For Senders\n\n1. **Equal Splitting**: Start with equal splits\n2. **Route Quality**: Use best available routes\n3. **Monitor Progress**: Track all parts\n4. **Handle Failures**: Retry failed parts if needed\n\n### For Recipients\n\n1. **Wait for All**: Don't settle until all parts arrive\n2. **Verify Totals**: Ensure sum matches invoice\n3. **Check Secrets**: Verify all parts use same secret\n4. **Timeout Handling**: Handle partial payments\n\n---\n\n## Common Issues\n\n### Partial Payment Received\n\n**Problem**: Only some MPP parts succeed\n\n**Solution**:\n- Wait for timeout\n- Request remaining parts\n- Or cancel and retry\n\n### TLV Encoding Errors\n\n**Problem**: TLV not encoded correctly\n\n**Solution**:\n- Verify type is 8\n- Check length is 40\n- Ensure correct byte order\n- Validate hex encoding\n\n### Amount Mismatch\n\n**Problem**: Sum of parts doesn't match total\n\n**Solution**:\n- Verify calculation\n- Check fee inclusion\n- Ensure correct splitting\n\n---\n\n## Summary\n\nMulti-Part Payments enable:\n\n- **Larger payments**: Split across multiple routes\n- **Better success rates**: Multiple paths increase reliability\n- **Liquidity utilization**: Use multiple channels\n- **TLV encoding**: Payment data in final hops\n- **Verification**: Recipient verifies all parts\n\nMPP is essential for handling large payments and improving Lightning Network usability.\n",
    "filename": "mpp.md"
  },
  "/docs/lightning/invoices": {
    "content": "# Lightning Invoices (BOLT11)\n\nLightning invoices are payment requests encoded in the BOLT11 format. They contain all the information a payer needs to send a payment, including the payment hash, amount, destination, and expiry.\n\n## Invoice Structure\n\nA BOLT11 invoice consists of three parts:\n\n1. **Human-Readable Part (HRP)**: Network prefix and amount\n2. **Data Part**: Encoded payment details\n3. **Signature**: Proves invoice authenticity\n\n```text\nExample Invoice:\nlnbc2500u1pvjluezsp5zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zygspp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdq5xysxxatsyp3k7enxv4jsxqzpu9qxpqysgq...\n\nBreakdown:\nâ”œâ”€â”€ lnbc          â† Network (mainnet Bitcoin)\nâ”œâ”€â”€ 2500u         â† Amount (2500 micro-BTC = 250,000 sats)\nâ”œâ”€â”€ 1             â† Separator\nâ”œâ”€â”€ pvjluez...    â† Bech32-encoded data\nâ””â”€â”€ 9qxpqysgq...  â† Signature\n```\n\n---\n\n## Human-Readable Part\n\n### Network Prefixes\n\n| Prefix | Network |\n|--------|---------|\n| `lnbc` | Bitcoin mainnet |\n| `lntb` | Bitcoin testnet |\n| `lntbs` | Bitcoin signet |\n| `lnbcrt` | Bitcoin regtest |\n\n### Amount Encoding\n\n| Suffix | Multiplier | Example |\n|--------|------------|---------|\n| (none) | 1 BTC | `lnbc1` = 1 BTC |\n| `m` | milli (0.001) | `lnbc100m` = 0.1 BTC |\n| `u` | micro (0.000001) | `lnbc2500u` = 0.0025 BTC |\n| `n` | nano (0.000000001) | `lnbc1000n` = 0.000001 BTC |\n| `p` | pico (0.000000000001) | `lnbc1000000p` = 0.000001 BTC |\n\nNote: Pico amounts must be multiples of 10 (minimum resolution is 1 millisatoshi).\n\n---\n\n## Data Part Fields\n\nThe data section uses tagged fields in TLV (Type-Length-Value) format:\n\n| Tag | Field | Description |\n|-----|-------|-------------|\n| `p` | Payment Hash | 52 chars, SHA256 of preimage |\n| `s` | Payment Secret | 52 chars, for MPP and probing protection |\n| `d` | Description | Human-readable purpose |\n| `h` | Description Hash | SHA256 of long description |\n| `n` | Payee Node ID | 53 chars, destination public key |\n| `x` | Expiry | Seconds until invoice expires (default: 3600) |\n| `c` | Min Final CLTV Expiry | Blocks for final hop (default: 18) |\n| `f` | Fallback Address | On-chain fallback |\n| `r` | Route Hints | Private channel routing info |\n| `9` | Feature Bits | Supported features |\n\n---\n\n## Parsing Invoices\n\n:::code-group\n```rust\nuse bech32::{self, FromBase32};\nuse sha2::{Sha256, Digest};\n\n/// Parsed BOLT11 invoice fields\n#[derive(Debug)]\nstruct ParsedInvoice {\n    network: String,\n    amount_msat: Option<u64>,\n    payment_hash: [u8; 32],\n    description: Option<String>,\n    expiry_seconds: u32,\n    timestamp: u64,\n}\n\n/// Parse the human-readable part of a BOLT11 invoice\nfn parse_hrp(hrp: &str) -> Result<(String, Option<u64>), &'static str> {\n    // Extract network prefix\n    let network = if hrp.starts_with(\"lnbc\") {\n        \"mainnet\"\n    } else if hrp.starts_with(\"lntb\") {\n        \"testnet\"\n    } else if hrp.starts_with(\"lntbs\") {\n        \"signet\"\n    } else {\n        return Err(\"Unknown network prefix\");\n    };\n    \n    // Extract amount (simplified)\n    let amount_str = hrp.trim_start_matches(\"lnbc\")\n                        .trim_start_matches(\"lntbs\")\n                        .trim_start_matches(\"lntb\");\n    \n    // Amount in millisatoshis: 1 BTC = 100,000,000,000 msat\n    let amount_msat = if amount_str.is_empty() {\n        None\n    } else {\n        // Parse amount with multiplier (to millisatoshis)\n        // m = milli (10^-3), u = micro (10^-6), n = nano (10^-9), p = pico (10^-12)\n        let (num_str, multiplier, is_pico) = if amount_str.ends_with('m') {\n            (&amount_str[..amount_str.len()-1], 100_000_000u64, false) // milli-BTC\n        } else if amount_str.ends_with('u') {\n            (&amount_str[..amount_str.len()-1], 100_000u64, false) // micro-BTC\n        } else if amount_str.ends_with('n') {\n            (&amount_str[..amount_str.len()-1], 100u64, false) // nano-BTC\n        } else if amount_str.ends_with('p') {\n            (&amount_str[..amount_str.len()-1], 1u64, true) // pico-BTC (0.1 msat)\n        } else {\n            (amount_str, 100_000_000_000u64, false) // whole BTC\n        };\n        \n        num_str.parse::<u64>().ok().map(|n| {\n            let value = n * multiplier;\n            // For pico, divide by 10 since 1p = 0.1 msat\n            if is_pico { value / 10 } else { value }\n        })\n    };\n    \n    Ok((network.to_string(), amount_msat))\n}\n\nfn main() {\n    // Example: Parse HRP\n    let (network, amount) = parse_hrp(\"lnbc2500u\").unwrap();\n    println!(\"Network: {}\", network);\n    println!(\"Amount: {:?} msat\", amount);\n}\n```\n\n```python\nimport re\nimport hashlib\nfrom dataclasses import dataclass\nfrom typing import Optional\nimport bech32\n\n@dataclass\nclass ParsedInvoice:\n    network: str\n    amount_msat: Optional[int]\n    payment_hash: bytes\n    description: Optional[str]\n    expiry_seconds: int\n    timestamp: int\n    payee_pubkey: Optional[bytes]\n\ndef parse_amount(hrp: str) -> Optional[int]:\n    \"\"\"Parse amount from human-readable part.\n    \n    Returns amount in millisatoshis.\n    1 BTC = 100,000,000 sat = 100,000,000,000 msat\n    \"\"\"\n    # Remove network prefix\n    amount_str = hrp.lstrip('lnbcrts')\n    \n    if not amount_str:\n        return None\n    \n    # Multipliers to convert to millisatoshis\n    # m = milli (10^-3), u = micro (10^-6), n = nano (10^-9), p = pico (10^-12)\n    multipliers = {\n        'm': 100_000_000,      # milli-BTC: 0.001 BTC = 100,000 sat = 100,000,000 msat\n        'u': 100_000,          # micro-BTC: 0.000001 BTC = 100 sat = 100,000 msat\n        'n': 100,              # nano-BTC: 0.000000001 BTC = 0.1 sat = 100 msat\n        'p': 1,                # pico-BTC: 0.1 msat (must be multiple of 10)\n    }\n    \n    if amount_str[-1] in multipliers:\n        value = int(amount_str[:-1]) * multipliers[amount_str[-1]]\n        # For pico, divide by 10 since 1p = 0.1 msat\n        if amount_str[-1] == 'p':\n            value = value // 10\n        return value\n    else:\n        return int(amount_str) * 100_000_000_000  # BTC to msat\n\ndef decode_invoice(invoice: str) -> ParsedInvoice:\n    \"\"\"Decode a BOLT11 invoice string.\"\"\"\n    invoice = invoice.lower()\n    \n    # Determine network\n    if invoice.startswith('lnbc'):\n        network = 'mainnet'\n    elif invoice.startswith('lntbs'):\n        network = 'signet'\n    elif invoice.startswith('lntb'):\n        network = 'testnet'\n    else:\n        raise ValueError(\"Unknown network prefix\")\n    \n    # Find separator (1)\n    sep_idx = invoice.rfind('1')\n    hrp = invoice[:sep_idx]\n    data = invoice[sep_idx+1:]\n    \n    # Parse amount from HRP\n    amount_msat = parse_amount(hrp)\n    \n    # Decode bech32 data\n    _, data_5bit = bech32.bech32_decode(invoice)\n    if data_5bit is None:\n        raise ValueError(\"Invalid bech32 encoding\")\n    \n    # Convert from 5-bit to 8-bit\n    data_bytes = bytes(bech32.convertbits(data_5bit, 5, 8, False))\n    \n    # First 7 bytes: timestamp (35 bits)\n    timestamp = int.from_bytes(data_bytes[:5], 'big') >> 5\n    \n    return ParsedInvoice(\n        network=network,\n        amount_msat=amount_msat,\n        payment_hash=bytes(32),  # Would parse from tagged fields\n        description=None,\n        expiry_seconds=3600,\n        timestamp=timestamp,\n        payee_pubkey=None\n    )\n\n# Example usage\ninvoice = \"lnbc2500u1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypqdq5xysxxatsyp3k7enxv4jsxqzpusp5zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3zygskqhwvl\"\nprint(f\"Amount: {parse_amount('lnbc2500u')} msat\")\n```\n\n```cpp\n#include <iostream>\n#include <string>\n#include <optional>\n#include <cstdint>\n#include <array>\n\nstruct ParsedInvoice {\n    std::string network;\n    std::optional<uint64_t> amount_msat;\n    std::array<uint8_t, 32> payment_hash;\n    std::string description;\n    uint32_t expiry_seconds;\n    uint64_t timestamp;\n};\n\n/**\n * Parse amount from human-readable part\n * Returns amount in millisatoshis.\n * 1 BTC = 100,000,000 sat = 100,000,000,000 msat\n */\nstd::optional<uint64_t> parse_amount(const std::string& hrp) {\n    // Find where the amount starts (after network prefix)\n    size_t start = 0;\n    if (hrp.substr(0, 6) == \"lnbcrt\") start = 6;\n    else if (hrp.substr(0, 5) == \"lntbs\") start = 5;\n    else if (hrp.substr(0, 4) == \"lnbc\") start = 4;\n    else if (hrp.substr(0, 4) == \"lntb\") start = 4;\n    else return std::nullopt;\n    \n    std::string amount_str = hrp.substr(start);\n    if (amount_str.empty()) return std::nullopt;\n    \n    // Determine multiplier (to millisatoshis)\n    // m = milli (10^-3), u = micro (10^-6), n = nano (10^-9), p = pico (10^-12)\n    uint64_t multiplier;\n    bool is_pico = false;\n    char suffix = amount_str.back();\n    \n    switch (suffix) {\n        case 'm': multiplier = 100000000ULL; break;     // milli-BTC: 100,000,000 msat\n        case 'u': multiplier = 100000ULL; break;        // micro-BTC: 100,000 msat\n        case 'n': multiplier = 100ULL; break;           // nano-BTC: 100 msat\n        case 'p': multiplier = 1ULL; is_pico = true; break; // pico-BTC: 0.1 msat\n        default:\n            multiplier = 100000000000ULL;                // whole BTC: 100,000,000,000 msat\n            return std::stoull(amount_str) * multiplier;\n    }\n    \n    std::string num_str = amount_str.substr(0, amount_str.length() - 1);\n    uint64_t value = std::stoull(num_str) * multiplier;\n    // For pico, divide by 10 since 1p = 0.1 msat\n    return is_pico ? value / 10 : value;\n}\n\n/**\n * Get network from invoice prefix\n */\nstd::string get_network(const std::string& invoice) {\n    if (invoice.substr(0, 5) == \"lntbs\") return \"signet\";\n    if (invoice.substr(0, 4) == \"lntb\") return \"testnet\";\n    if (invoice.substr(0, 4) == \"lnbc\") return \"mainnet\";\n    return \"unknown\";\n}\n\nint main() {\n    std::string hrp = \"lnbc2500u\";\n    auto amount = parse_amount(hrp);\n    \n    if (amount) {\n        std::cout << \"Amount: \" << *amount << \" msat\" << std::endl;\n        std::cout << \"Amount: \" << (*amount / 1000) << \" sats\" << std::endl;\n    }\n    \n    std::cout << \"Network: \" << get_network(\"lnbc2500u1...\") << std::endl;\n    \n    return 0;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// ParseAmount parses amount from human-readable part.\n// Returns amount in millisatoshis.\nfunc ParseAmount(hrp string) (*uint64, error) {\n\t// Remove network prefix\n\tamountStr := strings.TrimLeft(hrp, \"lnbcrts\")\n\t\n\t// Parse suffix (m, u, n, p)\n\tmultipliers := map[byte]uint64{\n\t\t'm': 100_000_000_000_000, // milli\n\t\t'u': 100_000_000_000,     // micro\n\t\t'n': 100_000_000,         // nano\n\t\t'p': 10_000_000,          // pico\n\t}\n\t\n\tif len(amountStr) > 0 {\n\t\tsuffix := amountStr[len(amountStr)-1]\n\t\tif multiplier, ok := multipliers[suffix]; ok {\n\t\t\tnumStr := amountStr[:len(amountStr)-1]\n\t\t\tnum, err := strconv.ParseUint(numStr, 10, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tvalue := num * multiplier\n\t\t\t// For pico, divide by 10 since 1p = 0.1 msat\n\t\t\tif suffix == 'p' {\n\t\t\t\tvalue = value / 10\n\t\t\t}\n\t\t\tresult := value\n\t\t\treturn &result, nil\n\t\t}\n\t}\n\t\n\t// No suffix = whole BTC\n\tnum, err := strconv.ParseUint(amountStr, 10, 64)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := num * 100_000_000_000\n\treturn &result, nil\n}\n\n// GetNetwork gets network from invoice string\nfunc GetNetwork(invoice string) string {\n\tinvoice = strings.ToLower(invoice)\n\tif strings.HasPrefix(invoice, \"lntbs\") {\n\t\treturn \"signet\"\n\t}\n\tif strings.HasPrefix(invoice, \"lntb\") {\n\t\treturn \"testnet\"\n\t}\n\tif strings.HasPrefix(invoice, \"lnbcrt\") {\n\t\treturn \"regtest\"\n\t}\n\tif strings.HasPrefix(invoice, \"lnbc\") {\n\t\treturn \"mainnet\"\n\t}\n\treturn \"unknown\"\n}\n\nfunc main() {\n\thrp := \"lnbc2500u\"\n\tamount, err := ParseAmount(hrp)\n\tif err == nil && amount != nil {\n\t\tfmt.Printf(\"Amount: %d msat\\n\", *amount)\n\t\tfmt.Printf(\"Amount: %d sats\\n\", *amount/1000)\n\t}\n\t\n\tfmt.Printf(\"Network: %s\\n\", GetNetwork(\"lnbc2500u1...\"))\n}\n```\n\n```javascript\n/**\n * @typedef {Object} ParsedInvoice\n * @property {string} network\n * @property {bigint|null} amountMsat\n * @property {Buffer} paymentHash\n * @property {string|null} description\n * @property {number} expirySeconds\n * @property {number} timestamp\n */\n\nconst bech32 = require('bech32');\n\n/**\n * Parse amount from human-readable part\n * Returns amount in millisatoshis.\n * 1 BTC = 100,000,000 sat = 100,000,000,000 msat\n * \n * @param {string} hrp\n * @returns {bigint|null}\n */\nfunction parseAmount(hrp) {\n    // Remove network prefix\n    let amountStr = hrp.replace(/^lnbc|^lntbs|^lntb|^lnbcrt/, '');\n    \n    if (!amountStr) return null;\n    \n    // Multipliers to convert to millisatoshis\n    // m = milli (10^-3), u = micro (10^-6), n = nano (10^-9), p = pico (10^-12)\n    const multipliers = {\n        'm': 100_000_000n,     // milli-BTC: 0.001 BTC = 100,000,000 msat\n        'u': 100_000n,         // micro-BTC: 0.000001 BTC = 100,000 msat\n        'n': 100n,             // nano-BTC: 0.000000001 BTC = 100 msat\n        'p': 1n,               // pico-BTC: 0.1 msat (must be multiple of 10)\n    };\n    \n    const suffix = amountStr.slice(-1);\n    if (multipliers[suffix]) {\n        const num = BigInt(amountStr.slice(0, -1));\n        let value = num * multipliers[suffix];\n        // For pico, divide by 10 since 1p = 0.1 msat\n        if (suffix === 'p') {\n            value = value / 10n;\n        }\n        return value;\n    }\n    \n    // No suffix = whole BTC (1 BTC = 100,000,000,000 msat)\n    return BigInt(amountStr) * 100_000_000_000n;\n}\n\n/**\n * Get network from invoice string\n * @param {string} invoice\n * @returns {string}\n */\nfunction getNetwork(invoice) {\n    invoice = invoice.toLowerCase();\n    if (invoice.startsWith('lntbs')) return 'signet';\n    if (invoice.startsWith('lntb')) return 'testnet';\n    if (invoice.startsWith('lnbcrt')) return 'regtest';\n    if (invoice.startsWith('lnbc')) return 'mainnet';\n    return 'unknown';\n}\n\n/**\n * Basic invoice parsing\n * @param {string} invoice\n * @returns {Object}\n */\nfunction parseInvoice(invoice) {\n    invoice = invoice.toLowerCase();\n    \n    // Find the separator\n    const sepIndex = invoice.lastIndexOf('1');\n    const hrp = invoice.slice(0, sepIndex);\n    \n    return {\n        network: getNetwork(invoice),\n        amountMsat: parseAmount(hrp),\n        hrp: hrp,\n    };\n}\n\n// Example usage\nconst invoice = 'lnbc2500u1pvjluezpp5qqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqqqsyqcyq5rqwzqfqypq...';\nconst parsed = parseInvoice(invoice);\n\nconsole.log(`Network: ${parsed.network}`);\nconsole.log(`Amount: ${parsed.amountMsat} msat`);\nconsole.log(`Amount: ${parsed.amountMsat / 1000n} sats`);\n```\n:::\n\n---\n\n## Creating Invoices\n\nUsing `lncli`:\n\n```bash\n# Create invoice for 10,000 sats with description\nlncli addinvoice --amt=10000 --memo=\"Payment for coffee\"\n\n# Create invoice with specific expiry (1 hour)\nlncli addinvoice --amt=50000 --memo=\"Service fee\" --expiry=3600\n\n# Create invoice with private route hints\nlncli addinvoice --amt=25000 --private\n\n# Create zero-amount invoice (payer chooses amount)\nlncli addinvoice --memo=\"Donation\"\n```\n\n---\n\n## Invoice Expiry\n\nInvoices have a default expiry of 1 hour (3600 seconds). After expiry:\n\n- Invoice should not be paid\n- Payment hash may be reused by recipient\n- Sender's wallet should reject expired invoices\n\nCommon expiry values:\n\n| Use Case | Expiry | Seconds |\n|----------|--------|---------|\n| Point of sale | 5-15 min | 300-900 |\n| E-commerce | 1 hour | 3600 |\n| Subscription | 24 hours | 86400 |\n| Donation | 7 days | 604800 |\n\n---\n\n## Route Hints\n\nPrivate channels require route hints to be payable:\n\n```text\nRoute Hint Structure:\nâ”œâ”€â”€ Node ID (33 bytes)\nâ”œâ”€â”€ Short Channel ID (8 bytes)\nâ”œâ”€â”€ Fee Base (4 bytes)\nâ”œâ”€â”€ Fee Proportional (4 bytes)\nâ””â”€â”€ CLTV Expiry Delta (2 bytes)\n```\n\nRoute hints tell the sender how to reach a node through private/unannounced channels.\n\n---\n\n## Payment Secret (s field)\n\nThe payment secret (added in BOLT11 amendment):\n\n- **32 bytes** of random data\n- Prevents payment probing attacks\n- Required for [Multi-Part Payments (MPP)](/docs/lightning/routing/mpp)\n- Proves payer has the actual invoice\n\n---\n\n## Feature Bits\n\nThe `9` field encodes supported features:\n\n| Bit | Feature |\n|-----|---------|\n| 8/9 | TLV onion payload |\n| 14/15 | Payment secret required |\n| 16/17 | Basic MPP |\n| 24/25 | Keysend |\n\n---\n\n## BOLT12 and Offers\n\n[BOLT12](/docs/lightning/bolt12-offers) extends the Lightning payment model with **offers** and **invoice requests**. Unlike BOLT11, where the payee creates an [invoice](/docs/lightning/invoices) when they want to be paid, BOLT12 **offers** are static, reusable descriptors that payers use to **request** an [invoice](/docs/lightning/invoices) from the payee. Benefits include:\n\n- **Reusable offers**: One offer can yield many [invoices](/docs/lightning/invoices) (e.g., subscriptions, donations, any-amount).\n- **Payee offline at creation**: The offer can be published (e.g., on a website); the payee only needs to be online when the payer sends an **invoice request** and the payee returns an [invoice](/docs/lightning/invoices).\n- **Keysend-style flows**: Structured alternative to [keysend](/docs/glossary#keysend) where the payee still controls the [payment hash](/docs/lightning/routing/htlc) and amount via the invoice they generate.\n\nSupport varies: [Core Lightning](https://github.com/ElementsProject/lightning) and [LDK](https://github.com/lightningdevkit/rust-lightning) have BOLT12 support; [LND](https://github.com/lightningnetwork/lnd) and others are adding it. See [BOLT12 & Offers](/docs/lightning/bolt12-offers) for details.\n\n---\n\n## Common Patterns\n\n### Reusable Invoices\n\nStandard BOLT11 [invoices](/docs/lightning/invoices) should only be paid once. For reusable or dynamic payments:\n\n- Use [Keysend](/docs/glossary#keysend) (no [invoice](/docs/lightning/invoices) needed)\n- Use LNURL-pay (dynamic [invoice](/docs/lightning/invoices) generation)\n- Use [BOLT12 & Offers](/docs/lightning/bolt12-offers) (when supported by your node and payees)\n\n### Fallback Addresses\n\nInclude on-chain fallback for large amounts:\n\n```bash\nlncli addinvoice --amt=1000000 --fallback_addr=bc1q...\n```\n\nIf Lightning payment fails, payer can use on-chain address.\n\n---\n\n## Validation Checklist\n\nWhen receiving an invoice, verify:\n\n1. **Network matches** your node (mainnet/testnet)\n2. **Not expired** (current time < timestamp + expiry)\n3. **Amount is acceptable** (if specified)\n4. **Features are supported** by your node\n5. **Signature is valid** (proves invoice authenticity)\n\n---\n\n## Summary\n\nBOLT11 invoices provide:\n\n- **Standardized format** for payment requests\n- **Amount encoding** from pico-BTC to whole BTC\n- **Expiry handling** to prevent stale payments\n- **Route hints** for private channel payments\n- **Payment secrets** for security and MPP support\n\n---\n\n## Related Topics\n\n- [BOLT12 & Offers](/docs/lightning/bolt12-offers) - Offers, invoice requests, and reusable payment flows\n- [Multi-Part Payments](/docs/lightning/routing/mpp) - Splitting large payments\n- [Channels](/docs/lightning/channels) - Where payments flow\n- [HTLCs](/docs/lightning/routing/htlc) - Payment mechanism\n\n---\n\n## Resources\n\n- [BOLT 11 Specification](https://github.com/lightning/bolts/blob/master/11-payment-encoding.md)\n- [Lightning Invoice Decoder](https://lightningdecoder.com/) - Online tool\n",
    "filename": "invoices.md"
  },
  "/docs/lightning/bolt12-offers": {
    "content": "# BOLT12 & Lightning Offers\n\n**BOLT12** is a Lightning protocol extension that introduces **offers** (and related structures such as **invoice requests** and **refunds**) as a more flexible alternative to [BOLT11](/docs/lightning/invoices) invoices. Offers allow payers to request an [invoice](/docs/lightning/invoices) from a payee without the payee having to be online first, support **reusable** payment identifiers, and enable use cases like recurring payments and better [keysend](/docs/glossary#keysend)-style flows.\n\n## BOLT11 vs BOLT12\n\n| Aspect | BOLT11 (Invoices) | BOLT12 (Offers) |\n|--------|-------------------|------------------|\n| **Creation** | Payee creates invoice when they want to be paid | Payee creates offer (can be static, reusable) |\n| **Amount** | Fixed at creation (or any for `amount=any`) | Can be fixed or \"any amount\" in the offer |\n| **Payee online** | Payee typically online to create invoice | Offer can be published; payee only needs to be online when *invoice* is requested |\n| **Reusability** | One invoice â‰ˆ one payment | One offer can yield many invoices (e.g., recurring) |\n| **Encoding** | Bech32 (`lnbc...`, `lntb...`) | Bech32 with `lno`/`lnr`/etc. prefixes |\n\nBOLT12 is specified in [BOLT 12](https://github.com/lightning/bolts/blob/master/12-offer-encoding.md) and related BOLTs. Support is implemented in [Core Lightning](https://github.com/ElementsProject/lightning) and [LDK](https://github.com/lightningdevkit/rust-lightning); [LND](https://github.com/lightningnetwork/lnd) and others are adding or have partial support.\n\n---\n\n## Offers\n\nAn **offer** is a signed, self-describing payment request that:\n\n- Identifies the **payee** (node [public key](/docs/bitcoin/cryptography))\n- May fix an **amount** or allow **any amount**\n- Can specify **metadata** (description, [chain](/docs/glossary#mainnet), etc.)\n- Can require **features** the payer must support\n- Does **not** include a [payment hash](/docs/lightning/routing/htlc) or [invoice](/docs/lightning/invoices); those are created only when the payee generates an invoice in response to an **invoice request**\n\n### Offer String (BOLT12)\n\nOffers are encoded as Bech32 strings with human-readable prefix `lno` (mainnet) or `lnt` (testnet/signet):\n\n```text\nlno1pg257enxv4ezqcneype82um50yq...  (simplified example)\n```\n\nThe payload is [TLV](https://github.com/lightning/bolts/blob/master/01-messaging.md#type-length-value-format)-encoded and includes chain, amount (optional), description, node id, and signature.\n\n---\n\n## Invoice Requests\n\nTo pay via an offer, the **payer** sends an **invoice request** to the payee. The invoice request:\n\n- References the offer (or its contents)\n- Can specify or refine the **amount** (if the offer allows any amount)\n- Can include **payer metadata** (e.g., for refunds or identification)\n- Is sent over the Lightning network to the payeeâ€™s node (or a [Blinded Path](https://github.com/lightning/bolts/blob/master/04-onion-routing.md#blinded-paths))\n\nThe **payee** responds with a BOLT12 **invoice** (or a BOLT11 invoice if thatâ€™s what was negotiated). That invoice is then paid like any other [Lightning](/docs/lightning) payment (e.g., [HTLC](/docs/lightning/routing/htlc) [routing](/docs/lightning/routing)).\n\n---\n\n## Keysend and Spontaneous Payments\n\n**Keysend** (BOLT11-era) allows sending to a node [public key](/docs/bitcoin/cryptography) without a pre-made [invoice](/docs/lightning/invoices): the payer chooses the [payment hash](/docs/lightning/routing/htlc) (and preimage) and the recipient must accept it. BOLT12 **offers** and **invoice requests** provide a more structured way to do â€œspontaneousâ€ or â€œpushâ€ payments: the payer fetches an invoice (or an â€œany amountâ€ invoice) from the payee via the offer protocol, so the payee controls the [payment hash](/docs/lightning/routing/htlc) and metadata. This can reduce probing and improve [privacy](/docs/wallets/privacy).\n\n---\n\n## Recurring and Subscription Payments\n\nBecause offers can be **reusable**, a payee can publish one offer that generates a new [invoice](/docs/lightning/invoices) for each payment. Examples:\n\n- **Subscriptions**: Same offer each period; payer sends an invoice request with the periodâ€™s amount (or the offer specifies it), payee returns an invoice, payer pays.\n- **Donations / any-amount**: Offer with â€œany amountâ€; payer sends desired amount in the invoice request; payee returns an invoice for that amount.\n\n---\n\n## Refunds\n\nBOLT12 defines **refund** flow: the payee can issue a **refund** (a kind of offer or invoice that pays *from* the payee *to* the payer). This is useful when the payee needs to return funds (e.g., cancelled order, overpayment). Refund semantics and encodings are part of the BOLT12 suite.\n\n---\n\n## Blinded Paths and Privacy\n\nTo request an [invoice](/docs/lightning/invoices) from an offer, the payer must reach the payee. BOLT12 can use **blinded paths** (onion-routed, [blinded](/docs/lightning/onion) identifiers) so that the payer does not need to know the payeeâ€™s direct node id or [IP](/docs/glossary#peer). The offer can contain a blinded path to the payee, improving [privacy](/docs/wallets/privacy).\n\n---\n\n## Current Support\n\n- **Core Lightning (CLN)**: Full BOLT12 support (offers, invoice requests, refunds).\n- **LDK**: Offer and invoice-request support for use in wallets and services.\n- **LND**: BOLT12 support is in progress or partial; check release notes.\n- **Eclair**: Check latest docs for BOLT12 status.\n\nWallets and merchants that support BOLT12 can publish offers (e.g., on the web, in apps) and accept payment once the payer requests an invoice and pays it.\n\n---\n\n## Related Topics\n\n- [Invoices (BOLT11)](/docs/lightning/invoices) - Classic Lightning invoices\n- [Lightning Channels](/docs/lightning/channels) - Channel mechanics\n- [Routing & HTLCs](/docs/lightning/routing) - How payments are routed\n- [Onion Routing](/docs/lightning/onion) - Privacy and blinded paths\n\n---\n\n## Resources\n\n- [BOLT 12: Offer Encoding](https://github.com/lightning/bolts/blob/master/12-offer-encoding.md)\n- [Core Lightning BOLT12](https://docs.corelightning.org/docs/home)\n- [LDK: Offers](https://lightningdevkit.org/)\n",
    "filename": "bolt12-offers.md"
  },
  "/docs/lightning/onion": {
    "content": "# Lightning Onion Routing\n\nLightning Network uses Sphinx onion routing to provide privacy and security for payments. Each hop in a route only knows the previous and next hop, not the full route or payment details. Onion routing encrypts data in layers, like an onion. Each hop peels off one layer, revealing only the information needed for that hop to forward the payment. Key properties:\n\n- **Privacy**: Each hop only knows immediate neighbors\n- **Integrity**: HMACs prevent tampering\n- **Source Hiding**: Sender identity is hidden from all hops\n- **Path Hiding**: Full route is never revealed\n\n---\n\n## Sphinx Protocol\n\nLightning uses the Sphinx protocol (adapted from Tor's design) for payment routing. It provides:\n\n- Compact fixed-size packets (1300 bytes)\n- Per-hop payload encryption\n- Replay attack protection\n- Forward secrecy\n\n### How It Works\n\n1. **Sender builds onion**: Encrypts routing data in layers (innermost first)\n2. **Each hop processes**: Peels off one layer, learns next hop\n3. **Final hop**: Receives payment details and claims HTLC\n4. **Response**: Preimage propagates back through same path\n\n```text\nOnion Packet Structure:\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ Version (1 byte)                    â”‚\nâ”‚ Public Key (33 bytes)               â”‚\nâ”‚ Encrypted Payload (1300 bytes)      â”‚\nâ”‚ HMAC (32 bytes)                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\nTotal: 1366 bytes\n```\n\n---\n\n## Onion Packet Components\n\n| Field | Size | Description |\n|-------|------|-------------|\n| Version | 1 byte | Protocol version (currently 0) |\n| Public Key | 33 bytes | Ephemeral public key for ECDH |\n| Payload | 1300 bytes | Encrypted per-hop data |\n| HMAC | 32 bytes | Authentication tag |\n\n### Per-Hop Payload (TLV Format)\n\nEach decrypted layer contains:\n\n- **Short Channel ID**: 8 bytes: Which channel to forward through\n- **Amount to Forward**: Variable: HTLC amount for next hop\n- **Outgoing CLTV**: 4 bytes: Expiry for outgoing HTLC\n- **Padding**: Variable: Random data to maintain fixed size\n\n---\n\n## Shared Secret Derivation\n\n:::code-group\n```rust\nuse secp256k1::{PublicKey, SecretKey, Secp256k1};\nuse sha2::{Sha256, Digest};\n\n/// Derive shared secret using ECDH\nfn derive_shared_secret(\n    ephemeral_secret: &SecretKey,\n    hop_pubkey: &PublicKey,\n) -> [u8; 32] {\n    let secp = Secp256k1::new();\n    \n    // Perform ECDH: multiply hop's public key by our secret\n    let shared_point = hop_pubkey.mul_tweak(&secp, &ephemeral_secret.into())\n        .expect(\"Valid multiplication\");\n    \n    // Hash the x-coordinate to get the shared secret\n    let mut hasher = Sha256::new();\n    hasher.update(&shared_point.serialize());\n    hasher.finalize().into()\n}\n\n/// Derive the blinding factor for key rotation\nfn derive_blinding_factor(\n    ephemeral_pubkey: &PublicKey,\n    shared_secret: &[u8; 32],\n) -> [u8; 32] {\n    let mut hasher = Sha256::new();\n    hasher.update(&ephemeral_pubkey.serialize());\n    hasher.update(shared_secret);\n    hasher.finalize().into()\n}\n```\n\n```python\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\nimport hashlib\n\ndef derive_shared_secret(ephemeral_private_key: ec.EllipticCurvePrivateKey, \n                         hop_public_key: ec.EllipticCurvePublicKey) -> bytes:\n    \"\"\"Derive shared secret using ECDH.\"\"\"\n    # Perform ECDH key exchange\n    shared_key = ephemeral_private_key.exchange(ec.ECDH(), hop_public_key)\n    \n    # Hash to get 32-byte shared secret\n    return hashlib.sha256(shared_key).digest()\n\ndef derive_blinding_factor(ephemeral_pubkey_bytes: bytes, \n                           shared_secret: bytes) -> bytes:\n    \"\"\"Derive blinding factor for ephemeral key rotation.\"\"\"\n    hasher = hashlib.sha256()\n    hasher.update(ephemeral_pubkey_bytes)\n    hasher.update(shared_secret)\n    return hasher.digest()\n\ndef derive_rho_key(shared_secret: bytes) -> bytes:\n    \"\"\"Derive the rho key for payload encryption (ChaCha20).\"\"\"\n    return hashlib.sha256(b\"rho\" + shared_secret).digest()\n\ndef derive_mu_key(shared_secret: bytes) -> bytes:\n    \"\"\"Derive the mu key for HMAC computation.\"\"\"\n    return hashlib.sha256(b\"mu\" + shared_secret).digest()\n```\n\n```cpp\n#include <array>\n#include <cstdint>\n#include <openssl/evp.h>\n#include <openssl/sha.h>\n#include <openssl/ec.h>\n\n/**\n * Derive shared secret using ECDH\n * In production, use a proper secp256k1 library\n */\nstd::array<uint8_t, 32> derive_shared_secret(\n    const std::array<uint8_t, 32>& ephemeral_secret,\n    const std::array<uint8_t, 33>& hop_pubkey\n) {\n    // This is simplified - real implementation uses secp256k1 ECDH\n    std::array<uint8_t, 32> shared_secret;\n    \n    // In practice: \n    // 1. Parse hop_pubkey as EC point\n    // 2. Multiply by ephemeral_secret\n    // 3. SHA256 hash the result\n    \n    // Placeholder for demonstration\n    SHA256_CTX ctx;\n    SHA256_Init(&ctx);\n    SHA256_Update(&ctx, ephemeral_secret.data(), 32);\n    SHA256_Update(&ctx, hop_pubkey.data(), 33);\n    SHA256_Final(shared_secret.data(), &ctx);\n    \n    return shared_secret;\n}\n\n/**\n * Derive key for specific purpose (rho, mu, etc.)\n */\nstd::array<uint8_t, 32> derive_key(\n    const char* purpose,\n    const std::array<uint8_t, 32>& shared_secret\n) {\n    std::array<uint8_t, 32> key;\n    SHA256_CTX ctx;\n    SHA256_Init(&ctx);\n    SHA256_Update(&ctx, purpose, strlen(purpose));\n    SHA256_Update(&ctx, shared_secret.data(), 32);\n    SHA256_Final(key.data(), &ctx);\n    return key;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math/big\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n)\n\n// DeriveSharedSecret derives shared secret using ECDH\nfunc DeriveSharedSecret(ephemeralPrivateKey *btcec.PrivateKey, hopPublicKey *btcec.PublicKey) [32]byte {\n\t// Perform ECDH: multiply hop's public key by our secret\n\tsharedPoint := new(btcec.PublicKey)\n\tsharedPoint.X, sharedPoint.Y = elliptic.P256().ScalarMult(hopPublicKey.X(), hopPublicKey.Y(), ephemeralPrivateKey.D().Bytes())\n\n\t// Hash the x-coordinate to get the shared secret\n\thash := sha256.Sum256(sharedPoint.SerializeCompressed())\n\treturn hash\n}\n\n// DeriveBlindingFactor derives the blinding factor for key rotation\nfunc DeriveBlindingFactor(ephemeralPubkey *btcec.PublicKey, sharedSecret [32]byte) [32]byte {\n\thasher := sha256.New()\n\thasher.Write(ephemeralPubkey.SerializeCompressed())\n\thasher.Write(sharedSecret[:])\n\tvar result [32]byte\n\tcopy(result[:], hasher.Sum(nil))\n\treturn result\n}\n\n// DeriveRhoKey derives encryption key (rho) for ChaCha20\nfunc DeriveRhoKey(sharedSecret [32]byte) [32]byte {\n\thasher := sha256.New()\n\thasher.Write([]byte(\"rho\"))\n\thasher.Write(sharedSecret[:])\n\tvar result [32]byte\n\tcopy(result[:], hasher.Sum(nil))\n\treturn result\n}\n\n// DeriveMuKey derives HMAC key (mu)\nfunc DeriveMuKey(sharedSecret [32]byte) [32]byte {\n\thasher := sha256.New()\n\thasher.Write([]byte(\"mu\"))\n\thasher.Write(sharedSecret[:])\n\tvar result [32]byte\n\tcopy(result[:], hasher.Sum(nil))\n\treturn result\n}\n\nfunc main() {\n\t// Example usage\n\tephemeralKey, _ := btcec.NewPrivateKey()\n\thopKey, _ := btcec.NewPrivateKey()\n\thopPubKey := hopKey.PubKey()\n\n\tsharedSecret := DeriveSharedSecret(ephemeralKey, hopPubKey)\n\tfmt.Printf(\"Shared secret: %s\\n\", hex.EncodeToString(sharedSecret[:]))\n\n\trhoKey := DeriveRhoKey(sharedSecret)\n\tfmt.Printf(\"Rho key: %s\\n\", hex.EncodeToString(rhoKey[:]))\n\n\tmuKey := DeriveMuKey(sharedSecret)\n\tfmt.Printf(\"Mu key: %s\\n\", hex.EncodeToString(muKey[:]))\n}\n```\n\n```javascript\nconst crypto = require('crypto');\n\n/**\n * Derive shared secret using ECDH\n * @param {Buffer} ephemeralPrivateKey - 32-byte private key\n * @param {Buffer} hopPublicKey - 33-byte compressed public key\n * @returns {Buffer} 32-byte shared secret\n */\nfunction deriveSharedSecret(ephemeralPrivateKey, hopPublicKey) {\n    // Create ECDH instance with secp256k1 curve\n    const ecdh = crypto.createECDH('secp256k1');\n    ecdh.setPrivateKey(ephemeralPrivateKey);\n    \n    // Compute shared secret\n    const sharedPoint = ecdh.computeSecret(hopPublicKey);\n    \n    // Hash to get 32-byte secret\n    return crypto.createHash('sha256').update(sharedPoint).digest();\n}\n\n/**\n * Derive blinding factor for ephemeral key rotation\n * @param {Buffer} ephemeralPubkey - 33-byte compressed public key\n * @param {Buffer} sharedSecret - 32-byte shared secret\n * @returns {Buffer} 32-byte blinding factor\n */\nfunction deriveBlindingFactor(ephemeralPubkey, sharedSecret) {\n    const hasher = crypto.createHash('sha256');\n    hasher.update(ephemeralPubkey);\n    hasher.update(sharedSecret);\n    return hasher.digest();\n}\n\n/**\n * Derive encryption key (rho) for ChaCha20\n * @param {Buffer} sharedSecret\n * @returns {Buffer}\n */\nfunction deriveRhoKey(sharedSecret) {\n    return crypto.createHash('sha256')\n        .update(Buffer.from('rho'))\n        .update(sharedSecret)\n        .digest();\n}\n\n/**\n * Derive HMAC key (mu)\n * @param {Buffer} sharedSecret\n * @returns {Buffer}\n */\nfunction deriveMuKey(sharedSecret) {\n    return crypto.createHash('sha256')\n        .update(Buffer.from('mu'))\n        .update(sharedSecret)\n        .digest();\n}\n```\n:::\n\n---\n\n## Encryption Process\n\n### Layer Construction (Sender)\n\nFor a 3-hop route (Alice â†’ Bob â†’ Carol â†’ Dave):\n\n1. Generate ephemeral keypair\n2. Compute shared secrets with all hops using ECDH\n3. Build payloads for each hop\n4. Encrypt from innermost (Dave) to outermost (Bob)\n5. Compute HMACs at each layer\n\n```text\nConstruction Order (inside-out):\n1. Create Dave's payload (final hop data)\n2. Encrypt with Dave's shared secret\n3. Prepend Carol's payload\n4. Encrypt with Carol's shared secret\n5. Prepend Bob's payload\n6. Encrypt with Bob's shared secret\n7. Add ephemeral public key\n```\n\n### Decryption (Each Hop)\n\nEach hop performs:\n\n1. Compute shared secret using ephemeral pubkey and node's private key\n2. Derive decryption key (rho) and HMAC key (mu)\n3. Verify HMAC\n4. Decrypt payload to get routing instructions\n5. Shift payload left (removes own data, pads end with zeros)\n6. Blind ephemeral public key for next hop\n7. Forward modified packet\n\n---\n\n## Privacy Guarantees\n\n### Information Visibility\n\n| Information | Sender | Intermediate | Final Hop |\n|-------------|--------|--------------|-----------|\n| Full route | Yes | No | No |\n| Sender identity | Yes | No | No |\n| Destination | Yes | No | Yes |\n| Payment amount | Yes | Partial | Yes |\n| Route position | Yes | No | Partial |\n\n### What Intermediaries Learn\n\nAn intermediate hop knows only:\n- Previous hop's node ID (who sent the packet)\n- Next hop's channel ID (where to forward)\n- Amount and CLTV for the forwarded HTLC\n- That they're neither first nor last (if route length > 2)\n\n### What Remains Hidden\n\n- Total route length\n- Sender's identity\n- Final destination\n- Total payment amount\n- Their position in the route\n\n---\n\n## Fixed Packet Size\n\nAll onion packets are exactly 1366 bytes regardless of route length:\n\n- Prevents traffic analysis based on packet size\n- Unused space filled with random padding\n- Maximum 20 hops supported\n\n---\n\n## Security Properties\n\n### Integrity\n\n- HMAC-SHA256 at each layer\n- Tampering detected immediately\n- Modified packets rejected\n\n### Forward Secrecy\n\n- Ephemeral keys used per-payment\n- Past payments cannot be decrypted if keys compromised later\n- No correlation between payments\n\n### Replay Protection\n\n- Each hop tracks seen shared secrets\n- Duplicate packets rejected\n- Prevents payment replay attacks\n\n---\n\n## Common Failure Modes\n\n### HMAC Mismatch\n\nPayment fails with `BADONION` error. Causes:\n- Packet corruption\n- Incorrect key derivation\n- Implementation bug\n\n### Invalid Onion Version\n\nIf version byte is not 0, packet is rejected.\n\n### Packet Too Short\n\nMalformed packets are rejected immediately.\n\n---\n\n## Summary\n\nOnion routing provides Lightning's privacy layer:\n\n- **Source privacy**: Sender hidden from all hops\n- **Path privacy**: Full route never revealed\n- **Amount privacy**: Intermediaries don't know total payment\n- **Fixed size**: Route length hidden\n- **Forward secrecy**: Past payments stay private\n\n---\n\n## Related Topics\n\n- [Routing & HTLCs](/docs/lightning/routing) - Payment routing mechanics\n- [Trampoline Routing](/docs/advanced/trampoline-routing) - Delegated pathfinding\n- [Invoices (BOLT11)](/docs/lightning/invoices) - Payment request format\n\n---\n\n## Resources\n\n- [BOLT 4: Onion Routing Protocol](https://github.com/lightning/bolts/blob/master/04-onion-routing.md)\n- [Sphinx Paper](https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf) - Original protocol\n",
    "filename": "onion.md"
  },
  "/docs/lightning/watchtowers": {
    "content": "# Watchtowers\n\nWatchtowers are third-party services that monitor the Bitcoin blockchain for channel breaches on your behalf. They provide security for Lightning nodes that cannot be online 24/7.\n\n## Why Watchtowers?\n\nLightning channels rely on both parties being able to detect and respond to cheating attempts. If your counterparty broadcasts an old [commitment transaction](/docs/glossary#commitment-transaction), you must respond with a penalty transaction before the timelock expires.\n\n**The Problem**: If your node is offline when a breach occurs, you cannot detect or respond to it.\n\n**The Solution**: Watchtowers monitor the blockchain for you and broadcast penalty transactions automatically.\n\n---\n\n## How Watchtowers Work\n\n### Registration\n\n1. Your node generates encrypted breach hints for each channel state\n2. You send these hints to a watchtower\n3. The watchtower stores them without knowing your channel details\n\n### Monitoring\n\n1. Watchtower monitors the blockchain for new transactions\n2. For each new transaction, it checks against stored hints\n3. If a hint matches, the watchtower can decrypt and broadcast the penalty\n\n### Penalty Execution\n\nWhen a breach is detected:\n\n1. Watchtower decrypts the penalty transaction\n2. Broadcasts it to the Bitcoin network\n3. Penalty transaction claims all channel funds\n4. Watchtower may take a fee from recovered funds\n\n```text\nNormal Flow:\nNode â†’ Watchtower: Encrypted breach hints (per state update)\nWatchtower â†’ Blockchain: Monitor for matching transactions\n\nBreach Detection:\nCounterparty â†’ Blockchain: Old commitment transaction\nWatchtower â†’ Blockchain: Penalty transaction (claims funds)\n```\n\n---\n\n## Breach Hint Structure\n\nBreach hints allow watchtowers to detect breaches without knowing channel details:\n\n```text\nBreach Hint:\nâ”œâ”€â”€ Locator (16 bytes): SHA256(breach_txid)[0:16]\nâ”œâ”€â”€ Encrypted Blob: AES-encrypted penalty transaction\nâ””â”€â”€ Session Info: Tower identification\n```\n\nThe locator is derived from the commitment transaction ID. When a watchtower sees a transaction matching a locator, it can decrypt and broadcast the penalty.\n\n---\n\n## Privacy Considerations\n\nWell-designed watchtower protocols preserve privacy:\n\n| Information | Known to Watchtower |\n|-------------|---------------------|\n| Channel partners | No (encrypted) |\n| Channel capacity | No (encrypted) |\n| Channel balance | No (encrypted) |\n| Number of updates | Yes (hint count) |\n| Breach occurred | Yes (if triggered) |\n\n### Encrypted Blobs\n\nThe penalty transaction is encrypted with a key derived from the commitment transaction:\n\n```text\nencryption_key = SHA256(breach_txid || session_key)\nencrypted_blob = AES_CTR(penalty_tx, encryption_key)\n```\n\nWatchtowers cannot read the blob until they see the actual breach transaction on-chain.\n\n---\n\n## Watchtower Implementations\n\n### LND Watchtower (wtclient/wtserver)\n\nLND includes built-in watchtower support:\n\n```bash\n# Enable watchtower client in lnd.conf\n[wtclient]\nwtclient.active=true\n\n# Connect to a watchtower\nlncli wtclient add <tower_pubkey>@<host>:<port>\n\n# List connected towers\nlncli wtclient towers\n\n# Check tower stats\nlncli wtclient stats\n```\n\n### Running Your Own Tower (LND)\n\n```bash\n# Enable watchtower server in lnd.conf\n[watchtower]\nwatchtower.active=true\nwatchtower.listen=0.0.0.0:9911\n\n# Get your tower's URI\nlncli tower info\n```\n\n### The Eye of Satoshi (TEOS)\n\nAn independent watchtower implementation:\n\n```bash\n# Install TEOS\ncargo install teos\n\n# Run the tower\nteosd --btc_network=mainnet\n\n# Register with TEOS from your node\n# (implementation specific)\n```\n\n---\n\n## Watchtower Economics\n\n### Costs\n\nFor tower operators:\n\n- **Storage**: ~200-500 bytes per channel state\n- **Bandwidth**: Monitoring blockchain and receiving hints\n- **Computation**: Checking transactions against hints\n\nFor users:\n\n- **Bandwidth**: Sending hints after each channel update\n- **Fees**: Some towers charge per-hint or percentage of recovered funds\n\n### Fee Models\n\n| Model | Description |\n|-------|-------------|\n| Free (altruistic) | Community-run, no fees |\n| Per-hint | Fixed fee per state update |\n| Recovery percentage | Tower keeps % of penalty funds |\n| Subscription | Monthly/yearly flat fee |\n\n---\n\n## Backup Strategies\n\nWatchtowers complement but don't replace proper backups:\n\n### What Watchtowers Protect Against\n\n- Counterparty broadcasting old state while you're offline\n- Short-term node downtime\n- Network connectivity issues\n\n### What Watchtowers Don't Protect Against\n\n- Loss of node data (seed, channel state)\n- Cooperative close disputes\n- Your own mistakes (broadcasting old state)\n\n### Recommended Setup\n\n1. **Multiple watchtowers**: Don't rely on a single tower\n2. **Static Channel Backups (SCB)**: For disaster recovery\n3. **Regular node backups**: Full database backups\n4. **Monitoring**: Alerts for extended downtime\n\n---\n\n## Watchtower Selection\n\nWhen choosing watchtowers, consider:\n\n### Reliability\n\n- Uptime track record\n- Geographic distribution\n- Infrastructure quality\n\n### Privacy\n\n- Protocol used (encrypted blobs?)\n- Data retention policy\n- Logging practices\n\n### Trust Model\n\n```text\nTrust Spectrum:\nâ”œâ”€â”€ Self-hosted (most trust, most effort)\nâ”œâ”€â”€ Friend's tower (trusted party)\nâ”œâ”€â”€ Community towers (reputation-based)\nâ””â”€â”€ Commercial towers (contractual)\n```\n\n---\n\n## Protocol Variants\n\n### BOLT Draft (Original)\n\nThe original watchtower proposal (never finalized as BOLT):\n\n- Simple locator-based matching\n- Single tower per channel\n- Basic encrypted blobs\n\n### TEOS Protocol\n\nEnhanced protocol with:\n\n- Appointment-based scheduling\n- Accountability proofs\n- Multiple tower support\n\n### VLS (Validating Lightning Signer)\n\nAlternative approach where signing is done remotely:\n\n- Signer validates all transactions\n- Can refuse to sign old states\n- Eliminates need for breach monitoring\n\n---\n\n## Common Issues\n\n### Tower Unreachable\n\n**Problem**: Cannot connect to watchtower.\n\n**Solutions**:\n- Check network connectivity\n- Verify tower address/port\n- Try alternative towers\n- Run your own tower\n\n### Hint Upload Failures\n\n**Problem**: Failed to send breach hints.\n\n**Solutions**:\n- Retry with backoff\n- Check tower capacity\n- Verify authentication\n\n### False Positives\n\n**Problem**: Tower broadcasts penalty for valid close.\n\n**Mitigation**:\n- Use encrypted blobs (tower can't read until breach)\n- Watchtower only acts on actual old commitment txids\n\n---\n\n## Setup Example (LND)\n\nComplete setup for watchtower protection:\n\n```bash\n# 1. Enable watchtower client\n# Add to lnd.conf:\n[wtclient]\nwtclient.active=true\n\n# 2. Restart LND\nsystemctl restart lnd\n\n# 3. Add public watchtowers\nlncli wtclient add 024...@tower1.example.com:9911\nlncli wtclient add 025...@tower2.example.com:9911\n\n# 4. Verify connection\nlncli wtclient towers\n\n# 5. Check statistics\nlncli wtclient stats\n```\n\n---\n\n## Summary\n\nWatchtowers provide:\n\n- **Offline protection**: Monitor blockchain when your node is down\n- **Automated response**: Broadcast penalties without manual intervention\n- **Privacy preservation**: Encrypted hints protect channel details\n- **Decentralized security**: Multiple towers reduce single points of failure\n\n---\n\n## Best Practices\n\n1. **Use multiple watchtowers** from different operators\n2. **Run your own tower** if possible for maximum privacy\n3. **Verify tower reliability** before trusting with real funds\n4. **Combine with backups** for complete protection\n5. **Monitor tower connections** to ensure they're active\n\n---\n\n## Related Topics\n\n- [Channels](/docs/lightning/channels) - Channel security and force close\n- [Anchor Outputs](/docs/lightning/anchor-outputs) - Fee bumping for penalties\n\n---\n\n## Resources\n\n- [BOLT Draft: Watchtower Protocol](https://github.com/lightning/bolts/pull/851)\n- [LND Watchtower Documentation](https://docs.lightning.engineering/lightning-network-tools/lnd/watchtower)\n- [The Eye of Satoshi](https://github.com/talaia-labs/rust-teos)\n",
    "filename": "watchtowers.md"
  },
  "/docs/lightning/anchor-outputs": {
    "content": "# Anchor Outputs\n\nAnchor outputs are a modern channel format that allows commitment transactions to have their fees adjusted after broadcast. This solves the fee estimation problem in Lightning channels.\n\n## The Fee Problem\n\nIn original Lightning channels, commitment transaction fees were set at channel creation:\n\n**Problems**:\n- Fees must be pre-committed before broadcast\n- Can't predict future fee rates accurately\n- High pre-set fees waste money during low congestion\n- Low pre-set fees may cause transactions to be stuck during high congestion\n\n**Critical Issue**: A force-close during a fee spike could leave your commitment transaction unconfirmed, potentially allowing your counterparty to claim funds via timelock expiry.\n\n---\n\n## How Anchor Outputs Work\n\nAnchor outputs solve this by:\n\n1. Setting commitment transaction fees to minimum (1 sat/vB)\n2. Adding small \"anchor\" outputs that either party can spend\n3. Using CPFP (Child Pays for Parent) to boost fees at broadcast time\n\n```text\nCommitment Transaction (with anchors):\nâ”œâ”€â”€ Input: Funding output\nâ”œâ”€â”€ Output 1: to_local (your balance)\nâ”œâ”€â”€ Output 2: to_remote (peer's balance)\nâ”œâ”€â”€ Output 3: Alice's anchor (330 sats)\nâ”œâ”€â”€ Output 4: Bob's anchor (330 sats)\nâ””â”€â”€ Fee: Minimum (1 sat/vB)\n\nFee Bumping:\nâ”œâ”€â”€ Child Transaction\nâ”‚   â”œâ”€â”€ Input: Anchor output (330 sats)\nâ”‚   â”œâ”€â”€ Input: Your UTXO (for fee payment)\nâ”‚   â””â”€â”€ Fee: Whatever needed for confirmation\n```\n\n---\n\n## Anchor Output Structure\n\nEach anchor output is exactly 330 satoshis with this script:\n\n```text\n<local_pubkey> OP_CHECKSIG OP_IFDUP OP_NOTIF\n    OP_16 OP_CHECKSEQUENCEVERIFY\nOP_ENDIF\n```\n\nThis means:\n- Owner can spend immediately with their signature\n- Anyone can spend after 16 blocks (cleanup)\n\n### Why 330 Satoshis?\n\n- Large enough to be non-dust\n- Small enough to not waste significant funds\n- Both parties get an anchor (660 sats total)\n\n---\n\n## CPFP Fee Bumping\n\nChild Pays for Parent (CPFP) allows boosting parent transaction fees:\n\n```text\n1. Broadcast commitment tx (low fee)\n2. Create child transaction spending anchor\n3. Child includes additional UTXO for fees\n4. Child pays high enough fee for both txs\n5. Miners include both in the same block\n```\n\n### Fee Calculation\n\nTotal fee for package:\n\n```text\npackage_fee = commitment_fee + child_fee\npackage_size = commitment_size + child_size\neffective_rate = package_fee / package_size\n```\n\nYou need the effective rate to meet current mempool minimums.\n\n---\n\n## Channel Types\n\nLightning supports multiple channel types negotiated at open:\n\n| Type | Feature Bit | Anchors | Zero-Fee HTLC |\n|------|-------------|---------|---------------|\n| Legacy | - | No | No |\n| Static Remote Key | 12/13 | No | No |\n| Anchors | 20/21 | Yes | No |\n| Anchors Zero Fee HTLC | 22/23 | Yes | Yes |\n\n### Zero-Fee HTLC Anchors\n\nThe latest format (anchors_zero_fee_htlc_tx) also removes fees from HTLC transactions:\n\n- HTLC-success and HTLC-timeout transactions use 0 fee\n- They can be fee-bumped via CPFP when broadcast\n- Maximum flexibility for fee management\n\n---\n\n## Reserve Requirements\n\nAnchor channels require keeping a UTXO reserve for fee bumping:\n\n```text\nRecommended reserve:\n- At least 1 UTXO per channel\n- Size: Enough for emergency fee bump (10,000+ sats)\n- Separate from channel funds (on-chain wallet)\n```\n\n**Warning**: Without reserve UTXOs, you cannot fee-bump your commitment transaction!\n\n---\n\n## Implementation (LND)\n\n### Opening Anchor Channels\n\n```bash\n# Open channel requesting anchors (default in modern LND)\nlncli openchannel --node_key=<pubkey> --local_amt=100000\n\n# Explicitly request anchors\nlncli openchannel --node_key=<pubkey> --local_amt=100000 --channel_type=anchors\n\n# Check channel type\nlncli listchannels | jq '.channels[].commitment_type'\n```\n\n### Fee Bumping a Force Close\n\n```bash\n# Initiate force close\nlncli closechannel --funding_txid=<txid> --output_index=<idx> --force\n\n# If commitment tx is stuck, bump fees\nlncli wallet bumpfee <commitment_txid>\n\n# Or manually create CPFP transaction\nlncli wallet bumpforceclosefee <channel_point>\n```\n\n### Managing Reserve UTXOs\n\n```bash\n# Check available UTXOs\nlncli listunspent\n\n# Ensure you have fee-bumping capacity\nlncli wallet estimatefee --conf_target=6\n```\n\n---\n\n## Migration\n\n### Upgrading Existing Channels\n\nExisting non-anchor channels cannot be upgraded in place. Options:\n\n1. **Close and reopen**: Cooperative close, then open new anchor channel\n2. **Splice** (when available): Modify channel on-chain to add anchors\n3. **Leave as-is**: Old channels still work, just without fee bumping\n\n### Checking Channel Types\n\n```bash\n# LND: List channels with commitment type\nlncli listchannels | jq '.channels[] | {chan_id, commitment_type}'\n\n# Look for:\n# - \"LEGACY\" - Old format, no anchors\n# - \"STATIC_REMOTE_KEY\" - Newer, still no anchors\n# - \"ANCHORS\" - Anchor outputs enabled\n# - \"SCRIPT_ENFORCED_LEASE\" - Liquidity lease channels\n```\n\n---\n\n## Trade-offs\n\n### Advantages\n\n- **Fee flexibility**: Adjust fees at broadcast time\n- **No stuck transactions**: Can always bump fees higher\n- **Lower dust exposure**: HTLC outputs can be smaller\n- **Safer force closes**: Respond to fee spikes effectively\n\n### Disadvantages\n\n- **Reserve requirement**: Must maintain on-chain UTXOs\n- **Slightly larger transactions**: Two extra outputs (660 sats)\n- **Complexity**: More transaction types to handle\n- **UTXO management**: Need to ensure reserves exist\n\n---\n\n## Common Issues\n\n### Cannot Bump Fees\n\n**Problem**: No UTXOs available for CPFP.\n\n**Solutions**:\n- Maintain dedicated fee-bump reserve\n- Fund on-chain wallet before force close\n- Use RBF on the child transaction if possible\n\n### Channel Open Rejected\n\n**Problem**: Peer doesn't support anchor channels.\n\n**Solutions**:\n- Use legacy channel type: `--channel_type=legacy`\n- Find peer running modern software\n- Accept the limitations of non-anchor channels\n\n### Anchor Spent by Others\n\n**Problem**: After 16 blocks, anyone can spend anchors.\n\n**Reality**: This is by design for cleanup. If you need to bump fees, do it within 16 blocks of broadcast.\n\n---\n\n## Best Practices\n\n1. **Maintain UTXO reserve**: Keep 50,000+ sats in on-chain wallet per channel\n2. **Monitor mempool**: Know current fee rates for emergencies\n3. **Use anchor channels**: Default for new channels\n4. **Automate fee bumping**: Configure automatic bump on stuck transactions\n5. **Test force close**: Verify fee bumping works on testnet first\n\n---\n\n## Example: Emergency Fee Bump\n\nScenario: Commitment transaction stuck, counterparty might cheat.\n\n```bash\n# 1. Check commitment tx status\nbitcoin-cli getmempoolentry <commitment_txid>\n\n# 2. If not in mempool or low fee, bump it\nlncli wallet bumpforceclosefee <channel_point> --conf_target=2\n\n# 3. Monitor for confirmation\nwatch -n 30 'bitcoin-cli getmempoolentry <commitment_txid>'\n\n# 4. Verify penalty protection (if breach)\nlncli pendingchannels | jq '.waiting_close_channels'\n```\n\n---\n\n## Summary\n\nAnchor outputs provide:\n\n- **Dynamic fees**: Adjust commitment tx fees at broadcast time\n- **CPFP support**: Bump fees using child transactions\n- **Stuck transaction prevention**: Always confirmable with enough fee\n- **Modern standard**: Default for new Lightning channels\n\n---\n\n## Related Topics\n\n- [Channels](/docs/lightning/channels) - Channel lifecycle and force close\n- [Watchtowers](/docs/lightning/watchtowers) - Automated breach response\n- [Zero-Conf Channels](/docs/advanced/zero-conf-channels) - Instant channel opening\n\n---\n\n## Resources\n\n- [BOLT 3: Anchor Outputs](https://github.com/lightning/bolts/blob/master/03-transactions.md#anchor-outputs)\n- [LND Anchor Channels Guide](https://docs.lightning.engineering/the-lightning-network/payment-channels/etymology#anchor-channel)\n",
    "filename": "anchor-outputs.md"
  },
  "/docs/development": {
    "content": "# Setup & Infrastructure\n\nThis section covers the setup and infrastructure needed for Bitcoin development: installing Bitcoin Core, testing and debugging, working with test networks, choosing libraries, understanding node architecture, and exploring Bitcoin Core internals.\n\n> **Hands-on learning:** Try Bitcoin RPC commands directly in the [Bitcoin CLI Terminal](/terminal). No node setup required.\n\n## Programming Languages in Bitcoin\n\n### C++ (Bitcoin Core)\n\nThe reference implementation of Bitcoin is written in C++.\n\n**Used for:**\n- Bitcoin Core development\n- Performance-critical applications\n- Protocol-level changes\n- Consensus code\n\n**Key libraries:**\n- **libbitcoin**: Full-featured Bitcoin library\n- **libsecp256k1**: Optimized elliptic curve library (used by Bitcoin Core)\n\n**When to use:**\n- Contributing to Bitcoin Core\n- Building nodes or mining software\n- Maximum performance requirements\n\n```cpp\n// Example: Creating a simple transaction hash\n#include <bitcoin/bitcoin.hpp>\n\nbc::hash_digest tx_hash = bc::bitcoin_hash(tx_data);\n```\n\n### Rust\n\nIncreasingly popular for Bitcoin development due to memory safety and performance.\n\n**Used for:**\n- Lightning implementations (LDK)\n- Wallet libraries\n- Cryptographic tools\n- New protocol implementations\n\n**Key libraries:**\n- **rust-bitcoin**: Core Bitcoin data structures\n- **rust-lightning (LDK)**: Lightning Development Kit\n- **bdk (Bitcoin Dev Kit)**: Modern wallet library\n- **rust-miniscript**: Policy to script compiler\n\n**When to use:**\n- New Bitcoin applications\n- Security-critical code\n- Modern wallet development\n- Lightning applications\n\n```rust\n// Example: Creating a Bitcoin address\nuse bitcoin::{Address, Network, PublicKey};\n\nlet address = Address::p2pkh(&public_key, Network::Bitcoin);\n```\n\n### Python\n\nExcellent for scripting, prototyping, and learning.\n\n**Used for:**\n- Rapid prototyping\n- Data analysis and research\n- Educational tools\n- Automation scripts\n- API integrations\n\n**Key libraries:**\n- **python-bitcoinlib**: Core Bitcoin library\n- **bip32**: HD wallet derivation\n- **ecdsa**: Elliptic curve operations\n- **requests**: API interactions\n\n**When to use:**\n- Learning Bitcoin internals\n- Quick scripts and tools\n- Data analysis\n- API wrappers\n\n```python\n# Example: Decode a raw transaction\nfrom bitcoin.core import CTransaction\n\ntx = CTransaction.deserialize(bytes.fromhex(raw_tx_hex))\nprint(f\"Transaction has {len(tx.vin)} inputs and {len(tx.vout)} outputs\")\n```\n\n### JavaScript/TypeScript\n\nDominant in web applications and increasingly in Bitcoin tooling.\n\n**Used for:**\n- Web wallets and applications\n- Browser extensions\n- Node.js backends\n- Frontend interfaces\n\n**Key libraries:**\n- **bitcoinjs-lib**: Bitcoin library\n- **bip39/bip32**: Mnemonic and HD derivation\n- **noble-secp256k1**: Cryptographic primitives\n- **bolt11**: Lightning invoice encoding\n\n**When to use:**\n- Web applications\n- Browser-based wallets\n- Full-stack development\n- Rapid development\n\n```typescript\n// Example: Generate a new address\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst keyPair = bitcoin.ECPair.makeRandom();\nconst { address } = bitcoin.payments.p2wpkh({ \n  pubkey: keyPair.publicKey \n});\n```\n\n### Go\n\nPopular for infrastructure and server applications.\n\n**Used for:**\n- Lightning implementations (lnd)\n- Server infrastructure\n- APIs and backends\n- DevOps tooling\n\n**Key libraries:**\n- **btcd**: Alternative full node implementation\n- **lnd**: Lightning Network Daemon\n- **btcutil**: Bitcoin utilities\n\n**When to use:**\n- Lightning node development\n- Backend services\n- Infrastructure tools\n- High-concurrency applications\n\n```go\n// Example: Connect to lnd\nimport \"github.com/lightningnetwork/lnd/lnrpc\"\n\nclient := lnrpc.NewLightningClient(conn)\ninfo, _ := client.GetInfo(ctx, &lnrpc.GetInfoRequest{})\n```\n\n---\n\n## Development Approaches\n\n### 1. Full Node Development\n\nWorking directly with Bitcoin Core or alternative implementations.\n\n**What you'll do:**\n- Run and configure full nodes\n- Use RPC interface for queries\n- Contribute to protocol development\n- Understand consensus rules\n\n**Getting started:**\n1. Install Bitcoin Core\n2. Sync the blockchain (or use testnet/signet)\n3. Enable RPC interface\n4. Explore `bitcoin-cli` commands\n\n```bash\n# Basic node setup\nbitcoind -daemon\nbitcoin-cli getblockchaininfo\nbitcoin-cli getmempoolinfo\n```\n\n### 2. Wallet Development\n\nBuilding applications that manage keys and create transactions.\n\n**What you'll do:**\n- Generate and manage keys\n- Create and sign transactions\n- Implement coin selection\n- Handle address types (P2PKH, P2WPKH, P2TR)\n\n**Key concepts:**\n- BIP32 ([HD wallets](/docs/glossary#hd-wallet-hierarchical-deterministic-wallet))\n- BIP39 ([Mnemonic/seed phrases](/docs/glossary#seed-phrase))\n- BIP44/49/84/86 ([Derivation paths](/docs/glossary#derivation-path))\n- [PSBT](/docs/glossary#psbt-partially-signed-bitcoin-transaction) (Partially Signed Bitcoin Transactions)\n\n**Getting started:**\n1. Choose a wallet library (BDK, bitcoinjs-lib, etc.) - see [Libraries & SDKs](/docs/development/libraries)\n2. Learn key derivation - see [Bitcoin Development](/docs/bitcoin-development) for key management\n3. Understand transaction structure - see [Transaction Construction](/docs/bitcoin-development/transactions)\n4. Implement on testnet first - see [Test Networks](/docs/development/testnets)\n\n### 3. Lightning Development\n\nBuilding on the Lightning Network for instant, low-fee payments.\n\n**What you'll do:**\n- Run Lightning nodes\n- Open and manage channels\n- Create payment applications\n- Handle invoices and payments\n\n**Approaches:**\n- **LND + API**: Run lnd, use REST/gRPC API\n- **LDK**: Embed [Lightning Network](/docs/glossary#lightning-network) in your application\n- **Core Lightning**: Plugin-based development\n- **Eclair**: JVM-based implementation\n\n**Getting started:**\n1. Set up a Lightning node (lnd, Core Lightning, or Eclair)\n2. Connect to testnet\n3. Open channels with test nodes\n4. Build a simple payment application\n\n### 4. Script and Smart Contract Development\n\nWorking with Bitcoin's scripting system.\n\n**What you'll do:**\n- Write Bitcoin scripts\n- Create custom spending conditions\n- Work with timelocks and hashlocks\n- Implement multisig schemes\n\n**Key concepts:**\n- [OP codes](/docs/glossary#opcode) and stack operations\n- [P2SH](/docs/glossary#p2sh-pay-to-script-hash) and [P2WSH](/docs/glossary#p2wsh-pay-to-witness-script-hash)\n- [Taproot](/docs/glossary#taproot) and Tapscript\n- [Miniscript](/docs/glossary#miniscript) for policy compilation\n\n**Getting started:**\n1. Learn basic OP codes\n2. Understand script execution\n3. Use miniscript for complex policies\n4. Test on signet\n\n---\n\n## Development Networks\n\n### [Mainnet](/docs/glossary#mainnet)\n\nThe real Bitcoin network. Use only for production applications.\n\n**Characteristics:**\n- Real value at stake\n- ~10 minute block times\n- Full transaction fees\n\n### [Testnet](/docs/glossary#testnet)\n\nLong-running test network. Coins have no value.\n\n**Characteristics:**\n- Free testnet coins from faucets\n- Can have unpredictable block times\n- Occasionally reset\n\n**Getting coins:**\n- [coinfaucet.eu/en/btc-testnet/](https://coinfaucet.eu/en/btc-testnet/)\n- [bitcoinfaucet.uo1.net/](https://bitcoinfaucet.uo1.net/)\n\n### [Signet](/docs/glossary#signet)\n\nMore controlled test network with consistent block production.\n\n**Characteristics:**\n- Predictable block times\n- Controlled by signers\n- Better for development\n\n**Getting coins:**\n- [signet.bc-2.jp/](https://signet.bc-2.jp/)\n- [alt.signetfaucet.com/](https://alt.signetfaucet.com/)\n\n### [Regtest](/docs/glossary#regtest)\n\nLocal, private test network. You control everything.\n\n**Characteristics:**\n- Instant block generation\n- Complete control\n- No external dependencies\n- Ideal for unit testing\n\n```bash\n# Start regtest\nbitcoind -regtest -daemon\n\n# Generate blocks (mine to your address)\nbitcoin-cli -regtest generatetoaddress 101 <your-address>\n```\n\n---\n\n## Essential Tools\n\n### Block Explorers\n\n- **[mempool.space](https://mempool.space)**: Beautiful, open-source explorer\n- **[blockstream.info](https://blockstream.info)**: Blockstream's explorer\n- **[blockchain.info](https://www.blockchain.com/explorer)**: Popular web explorer\n\n### Development Tools\n\n- **[Bitcoin Core](https://bitcoincore.org/)**: Reference implementation\n- **[Polar](https://lightningpolar.com/)**: One-click Lightning networks for testing\n- **[Sparrow Wallet](https://sparrowwallet.com/)**: Advanced wallet for testing\n- **[Electrum](https://electrum.org/)**: Lightweight wallet with console\n\n### APIs and Services\n\n- **[mempool.space API](https://mempool.space/docs/api)**: Block and transaction data\n- **[Blockstream Esplora](https://github.com/Blockstream/esplora)**: Self-hostable API\n- **[getblock.io](https://getblock.io/)**: Node-as-a-service\n\n### Documentation\n\n- **[Bitcoin Developer Reference](https://developer.bitcoin.org/)**: Official documentation\n- **[BIPs](https://github.com/bitcoin/bips)**: Bitcoin Improvement Proposals\n- **[BOLTs](https://github.com/lightning/bolts)**: Lightning specifications\n- **[Learning Bitcoin from the Command Line](https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line)**: Command line tutorial\n\n---\n\n## Development Workflow\n\n### 1. Start with Regtest\n\n```bash\n# Create a regtest environment\nbitcoind -regtest -daemon\nbitcoin-cli -regtest createwallet \"dev\"\nbitcoin-cli -regtest -generate 101\n```\n\n### 2. Move to Signet/Testnet\n\nOnce your code works locally, test on public networks:\n\n```bash\n# Connect to signet\nbitcoind -signet -daemon\nbitcoin-cli -signet getblockchaininfo\n```\n\n### 3. Security Review\n\nBefore mainnet:\n- Audit key management\n- Review transaction construction\n- Check fee calculations\n- Test edge cases\n\n### 4. Deploy to Mainnet\n\nOnly after thorough testing:\n- Start with small amounts\n- Monitor transactions\n- Have rollback plans\n\n---\n\n## Common Pitfalls\n\n### Security\n\n- **Never hardcode keys**: Use environment variables or secure storage\n- **Validate all inputs**: Especially amounts and addresses\n- **Use established libraries**: Don't roll your own crypto\n- **Test on testnet first**: Always\n\n### Transaction Construction\n\nFor detailed transaction construction guidance, see [Bitcoin Development](/docs/bitcoin-development):\n- **Calculate fees properly**: Too low = stuck, too high = waste\n- **Handle dust**: Outputs below ~546 sats may be unspendable\n- **Sign correctly**: Verify signatures before broadcasting\n- **Use PSBT**: For multi-party or hardware wallet signing\n\n### Network\n\n- **Handle reorgs**: Transactions can be reversed until deeply confirmed\n- **Wait for confirmations**: 6 blocks for high-value transactions\n- **Don't trust unconfirmed**: Zero-conf can be double-spent\n\n---\n\n## Summary\n\nBitcoin development offers many paths:\n\n| Language | Best For | Key Library |\n|----------|----------|-------------|\n| C++ | Bitcoin Core, performance | libbitcoin |\n| Rust | Modern apps, security | rust-bitcoin, BDK |\n| Python | Learning, scripting | python-bitcoinlib |\n| JavaScript | Web apps | bitcoinjs-lib |\n| Go | Lightning, infrastructure | btcd, lnd |\n\nStart small, use testnet, and build incrementally. The Bitcoin development community is welcoming; ask questions and contribute back.\n\n---\n\n## Related Topics\n\n### Infrastructure Topics (This Section)\n\n- [Installing Bitcoin](/docs/development/install-bitcoin) - Setup and installation guide\n- [Testing & Debugging](/docs/development/testing) - Testing strategies and debugging tools\n- [Test Networks](/docs/development/testnets) - Testnet, signet, and regtest\n- [Libraries & SDKs](/docs/development/libraries) - Language-specific Bitcoin libraries\n- [Node Types & Architecture](/docs/development/node-types) - Understanding different node configurations\n- [Bitcoin Core Internals](/docs/development/bitcoin-core-internals) - Reference implementation architecture\n\n### Practical Development\n\n- [Bitcoin Development](/docs/bitcoin-development) - Practical development tasks including PSBT, transaction construction, address generation, key management, blockchain monitoring, and more\n\n### Protocol & Other Topics\n\n- [RPC Guide](/docs/bitcoin/rpc) - Bitcoin Core RPC commands\n- [Wallet Development](/docs/wallets) - Building Bitcoin wallets\n- [Bitcoin Protocol](/docs/bitcoin) - Deep technical protocol documentation\n\n---\n\n## Resources\n\n- [Bitcoin Developer Mailing List](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n- [Bitcoin Stack Exchange](https://bitcoin.stackexchange.com/)\n- [Bitcoin Optech](https://bitcoinops.org/) - Technical newsletter\n- [Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)\n",
    "filename": "overview.md"
  },
  "/docs/development/install-bitcoin": {
    "content": "# Installing Bitcoin\n\nBitcoin Core is the reference implementation of the Bitcoin protocol. Understanding how to install and run it is fundamental for development, running a full node, or participating in the network.\n\n## Historical Context: The Original Bitcoin Client\n\nThe original Bitcoin software released by Satoshi Nakamoto in January 2009 was a single monolithic application that bundled three distinct functions:\n\n1. **Full Node** - Validating and relaying transactions and blocks\n2. **Wallet** - Managing keys, addresses, and creating transactions\n3. **Miner** - Using CPU to find valid blocks\n\nThis made sense for the early network when anyone could profitably mine with a regular computer, and the software needed to be accessible to newcomers. Running the client automatically made you a miner, a node operator, and gave you a wallet to receive block rewards.\n\n### The Separation of Concerns\n\nAs Bitcoin matured, these functions became increasingly specialized:\n\n**Mining** evolved from CPU â†’ GPU â†’ FPGA â†’ [ASIC](/docs/glossary#asic-application-specific-integrated-circuit), making the built-in miner obsolete for anything other than [testnet](/docs/glossary#testnet) or [regtest](/docs/glossary#regtest). Dedicated mining software like cgminer and modern pool protocols emerged to handle specialized hardware.\n\n**Wallets** diversified into hardware wallets, mobile wallets, and specialized desktop applications with better UX than the built-in wallet. Many users prefer lightweight wallets that don't require running a full node.\n\n**Full nodes** became the focus of Bitcoin Core development, emphasizing security, validation, and network participation over end-user features.\n\n> Bitcoin Core still includes wallet functionality (optional since v0.21.0) but removed the graphical miner long ago. The `generatetoaddress` RPC command remains for regtest mining.\n\n---\n\n## Installation Methods\n\n### Method 1: Download Pre-built Binaries (Recommended)\n\nDownload the latest release from [bitcoincore.org](https://bitcoincore.org/en/download/):\n\n```bash\n# Example for Linux x86_64 (check for latest version)\nwget https://bitcoincore.org/bin/bitcoin-core-27.0/bitcoin-27.0-x86_64-linux-gnu.tar.gz\ntar -xzf bitcoin-27.0-x86_64-linux-gnu.tar.gz\nsudo install -m 0755 -o root -g root -t /usr/local/bin bitcoin-27.0/bin/*\n```\n\n**Verify the download** (important for security):\n\n```bash\n# Download signatures and verify\nwget https://bitcoincore.org/bin/bitcoin-core-27.0/SHA256SUMS\nwget https://bitcoincore.org/bin/bitcoin-core-27.0/SHA256SUMS.asc\nsha256sum --ignore-missing --check SHA256SUMS\ngpg --verify SHA256SUMS.asc SHA256SUMS\n```\n\n### Method 2: Package Managers\n\n**macOS (Homebrew):**\n\n```bash\nbrew install bitcoin\n```\n\n**Ubuntu/Debian (PPA):**\n\n```bash\nsudo add-apt-repository ppa:bitcoin/bitcoin\nsudo apt-get update\nsudo apt-get install bitcoind bitcoin-qt\n```\n\n**Arch Linux:**\n\n```bash\nsudo pacman -S bitcoin-qt\n```\n\n### Method 3: Build from Source\n\nFor development or when you need the latest features:\n\n```bash\n# Install dependencies (Ubuntu/Debian)\nsudo apt-get install build-essential libtool autotools-dev automake pkg-config bsdmainutils python3\nsudo apt-get install libevent-dev libboost-dev libsqlite3-dev\n\n# Clone and build\ngit clone https://github.com/bitcoin/bitcoin.git\ncd bitcoin\n./autogen.sh\n./configure\nmake -j$(nproc)\nsudo make install\n```\n\n---\n\n## Components\n\nAfter installation, you have access to several executables:\n\n| Binary | Purpose |\n|--------|---------|\n| `bitcoind` | Headless daemon (server mode) |\n| `bitcoin-qt` | GUI application with wallet |\n| `bitcoin-cli` | Command-line RPC client |\n| `bitcoin-tx` | Transaction utility |\n| `bitcoin-util` | Utility commands |\n| `bitcoin-wallet` | Wallet utility (offline operations) |\n\n---\n\n## Basic Configuration\n\nCreate a configuration file at `~/.bitcoin/bitcoin.conf` (Linux/macOS) or `%APPDATA%\\Bitcoin\\bitcoin.conf` (Windows):\n\n```ini\n# Network (mainnet, testnet, signet, or regtest)\n# testnet=1\n# signet=1\n# regtest=1\n\n# Enable RPC server\nserver=1\nrpcuser=yourusername\nrpcpassword=yoursecurepassword\n\n# Prune blockchain to save disk space (in MB)\n# prune=1000\n\n# Transaction index (required for some applications)\n# txindex=1\n```\n\n---\n\n## Running Bitcoin Core\n\n### Start the Daemon\n\n```bash\n# Start in background\nbitcoind -daemon\n\n# Check status\nbitcoin-cli getblockchaininfo\n```\n\n### Initial Block Download (IBD)\n\nThe first sync downloads and validates the entire blockchain history:\n\n- **Size:** ~600+ GB (as of 2024)\n- **Time:** Hours to days depending on hardware\n- **Bandwidth:** Significant download required\n\n**Pruned mode** reduces storage requirements:\n\n```bash\nbitcoind -prune=1000 -daemon  # Keep only 1GB of blocks\n```\n\n### Useful Commands\n\n```bash\n# Network info\nbitcoin-cli getnetworkinfo\n\n# Blockchain status\nbitcoin-cli getblockchaininfo\n\n# Mempool status\nbitcoin-cli getmempoolinfo\n\n# Stop the node\nbitcoin-cli stop\n```\n\n---\n\n## Development Setup\n\nFor Bitcoin development, use regtest mode for instant block generation:\n\n```bash\n# Start regtest node\nbitcoind -regtest -daemon\n\n# Create a wallet\nbitcoin-cli -regtest createwallet \"dev\"\n\n# Generate blocks (mine to your own address)\nbitcoin-cli -regtest -generate 101\n\n# Check balance\nbitcoin-cli -regtest getbalance\n```\n\nSee [Test Networks](/docs/development/testnets) for more on regtest, testnet, and signet.\n\n---\n\n## Alternative Implementations\n\nWhile Bitcoin Core is the reference implementation, alternatives exist:\n\n| Implementation | Language | Notes |\n|---------------|----------|-------|\n| [Bitcoin Core](https://bitcoincore.org/) | C++ | Reference implementation |\n| [btcd](https://github.com/btcsuite/btcd) | Go | Full node (no wallet) |\n| [Bitcoin Knots](https://bitcoinknots.org/) | C++ | Bitcoin Core fork with extra features |\n| [libbitcoin](https://libbitcoin.info/) | C++ | Modular implementation |\n\n> Running alternative implementations helps decentralize development, but ensure they maintain consensus compatibility.\n\n---\n\n## System Requirements\n\n**Minimum (pruned):**\n- 2 GB RAM\n- 10 GB disk space\n- Broadband connection\n\n**Recommended (full node):**\n- 4+ GB RAM\n- 1 TB SSD\n- Unmetered broadband\n\n**For development:**\n- Any modern computer works with regtest\n- SSD recommended for faster sync\n\n---\n\n## Related Topics\n\n- [Test Networks](/docs/development/testnets) - Development environments\n- [RPC Commands](/docs/bitcoin/rpc) - Interacting with Bitcoin Core\n- [Libraries & SDKs](/docs/development/libraries) - Development tools\n- [Hardware Evolution](/docs/mining/hardware) - How mining separated from nodes\n\n---\n\n## Resources\n\n- [Bitcoin Core Documentation](https://bitcoin.org/en/full-node)\n- [Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)\n- [Learning Bitcoin from the Command Line](https://github.com/BlockchainCommons/Learning-Bitcoin-from-the-Command-Line)\n",
    "filename": "install-bitcoin.md"
  },
  "/docs/development/testing": {
    "content": "# Testing & Debugging Bitcoin Applications\n\nTesting Bitcoin applications requires special considerations due to the financial nature of the software and the complexity of the protocol. This guide covers testing strategies, debugging techniques, and best practices.\n\n## Testing Networks\n\n### Regtest (Recommended for Development)\n\nRegtest provides a completely controlled environment where you can instantly generate blocks.\n\n**Setup:**\n\n```bash\n# Start Bitcoin Core in regtest mode\nbitcoind -regtest -daemon\n\n# Create a wallet\nbitcoin-cli -regtest createwallet \"test\"\n\n# Generate initial blocks (need 100+ for spendable coins)\nbitcoin-cli -regtest -generate 101\n```\n\n**Advantages:**\n- Instant block generation\n- No network dependencies\n- Complete control over timing\n- Reproducible tests\n\n### Signet (Recommended for Integration Testing)\n\nSignet provides a more realistic testing environment with predictable block times.\n\n```bash\n# Start Bitcoin Core in signet mode\nbitcoind -signet -daemon\n\n# Check sync status\nbitcoin-cli -signet getblockchaininfo\n```\n\n### Testnet (Legacy Testing)\n\nTestnet mimics mainnet but with worthless coins.\n\n```bash\nbitcoind -testnet -daemon\nbitcoin-cli -testnet getblockchaininfo\n```\n\n---\n\n## Unit Testing Strategies\n\n### Testing Address Generation\n\n:::code-group\n```rust\n#[test]\nfn test_address_generation() {\n    let pubkey = PublicKey::from_str(\n        \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\n    ).unwrap();\n    let address = Address::p2wpkh(&pubkey, Network::Bitcoin).unwrap();\n    assert!(address.to_string().starts_with(\"bc1q\"));\n}\n```\n\n```python\ndef test_address_generation():\n    from bitcoin.wallet import P2PKHBitcoinAddress\n    pubkey = bytes.fromhex('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798')\n    addr = P2PKHBitcoinAddress.from_pubkey(pubkey)\n    assert str(addr).startswith('m') or str(addr).startswith('n')\n```\n\n```cpp\nBOOST_AUTO_TEST_CASE(test_address_generation) {\n    bc::ec_compressed pubkey;\n    bc::decode_base16(pubkey, \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\");\n    auto addr = bc::wallet::payment_address(pubkey);\n    BOOST_CHECK(addr.encoded().substr(0, 1) == \"1\");\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\t\"testing\"\n)\n\nfunc TestAddressGeneration(t *testing.T) {\n\tpubkeyHex := \"0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"\n\tpubkey, err := hex.DecodeString(pubkeyHex)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t\n\t// In a real implementation, you would use a Bitcoin library\n\t// to generate the address from the pubkey\n\t// This is a simplified example\n\t_ = pubkey\n\t\n\t// Example assertion (would use actual address generation)\n\t// addr := generateP2WPKHAddress(pubkey)\n\t// if !strings.HasPrefix(addr, \"bc1q\") {\n\t//     t.Errorf(\"Expected address to start with 'bc1q', got %s\", addr)\n\t// }\n}\n```\n\n```javascript\ntest('generates valid P2WPKH address', () => {\n  const pubkey = Buffer.from('0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', 'hex');\n  const { address } = bitcoin.payments.p2wpkh({ pubkey, network: bitcoin.networks.bitcoin });\n  expect(address).toMatch(/^bc1q/);\n});\n```\n:::\n\n### Testing Transaction Construction\n\n:::code-group\n```rust\n#[test]\nfn test_transaction() {\n    let tx = Transaction { version: 2, lock_time: LockTime::ZERO, input: vec![], output: vec![] };\n    assert_eq!(tx.version, 2);\n}\n```\n\n```python\ndef test_transaction_construction():\n    outpoint = COutPoint(bytes(32), 0)\n    txin = CTxIn(prevout=outpoint)\n    tx = CTransaction([txin], [])\n    \n    assert len(tx.vin) == 1\n    assert len(tx.vout) == 0\n```\n\n```cpp\nBOOST_AUTO_TEST_CASE(test_transaction) {\n    bc::chain::transaction tx;\n    tx.set_version(2);\n    BOOST_CHECK_EQUAL(tx.version(), 2u);\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"testing\"\n)\n\ntype Transaction struct {\n\tVersion int32\n\tInputs  []Input\n\tOutputs []Output\n}\n\ntype Input struct {\n\tPrevOutHash  []byte\n\tPrevOutIndex uint32\n}\n\ntype Output struct {\n\tValue  int64\n\tScript []byte\n}\n\nfunc TestTransactionConstruction(t *testing.T) {\n\ttx := Transaction{\n\t\tVersion: 2,\n\t\tInputs:  []Input{},\n\t\tOutputs: []Output{},\n\t}\n\t\n\tif tx.Version != 2 {\n\t\tt.Errorf(\"Expected version 2, got %d\", tx.Version)\n\t}\n}\n```\n\n```javascript\ntest('creates valid transaction structure', () => {\n  const psbt = new bitcoin.Psbt();\n  psbt.addInput({ hash: Buffer.alloc(32), index: 0, witnessUtxo: { script: Buffer.alloc(22), value: 100000 } });\n  expect(psbt.inputCount).toBe(1);\n});\n```\n:::\n\n---\n\n## Integration Testing\n\n### Testing with Regtest\n\n**Complete Test Flow:**\n\n```python\nimport subprocess\nimport time\nimport json\nimport unittest\n\nclass RegtestTestCase(unittest.TestCase):\n    \"\"\"Base test case for Bitcoin regtest integration tests.\"\"\"\n    \n    def setUp(self):\n        # Start bitcoind in regtest mode\n        subprocess.run(['bitcoind', '-regtest', '-daemon'])\n        time.sleep(2)  # Wait for startup\n        \n        # Create wallet and generate coins\n        self.cli('createwallet', 'test')\n        self.cli('-generate', '101')\n    \n    def tearDown(self):\n        # Stop bitcoind\n        self.cli('stop')\n    \n    def cli(self, *args):\n        \"\"\"Execute bitcoin-cli command and return parsed result.\"\"\"\n        result = subprocess.run(\n            ['bitcoin-cli', '-regtest'] + list(args),\n            capture_output=True,\n            text=True\n        )\n        if result.stdout:\n            try:\n                return json.loads(result.stdout)\n            except json.JSONDecodeError:\n                return result.stdout.strip()\n        return None\n    \n    def test_send_transaction(self):\n        # Get a new address\n        addr = self.cli('getnewaddress')\n        \n        # Send coins\n        txid = self.cli('sendtoaddress', addr, '1.0')\n        \n        # Verify transaction exists\n        tx = self.cli('gettransaction', txid)\n        self.assertIsNotNone(tx)\n        self.assertEqual(tx['amount'], 1.0)\n```\n\n### Testing Fee Estimation\n\n```python\ndef test_fee_estimation(self):\n    # Generate some blocks with transactions\n    for _ in range(10):\n        addr = self.cli('getnewaddress')\n        self.cli('sendtoaddress', addr, '0.1')\n        self.cli('-generate', '1')\n    \n    # Test fee estimation\n    fee_rate = self.cli('estimatesmartfee', '6')\n    \n    # Should return a valid fee rate\n    assert 'feerate' in fee_rate\n    assert fee_rate['feerate'] > 0\n```\n\n---\n\n## Debugging Techniques\n\n### Using bitcoin-cli for Debugging\n\n**Inspect Transaction:**\n\n```bash\n# Decode raw transaction\nbitcoin-cli decoderawtransaction <hex>\n\n# Get transaction details\nbitcoin-cli getrawtransaction <txid> true\n\n# Check mempool\nbitcoin-cli getmempoolentry <txid>\n```\n\n**Debug Scripts:**\n\n```bash\n# Test script execution (if using btcdeb)\nbtcdeb '[OP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG]'\n```\n\n### Analyzing Debug Logs\n\nBitcoin Core writes detailed logs to `debug.log`.\n\n**Location:**\n- Linux: `~/.bitcoin/debug.log`\n- macOS: `~/Library/Application Support/Bitcoin/debug.log`\n- Windows: `%APPDATA%\\Bitcoin\\debug.log`\n\n**Useful Log Categories:**\n\n```bash\n# Enable specific debug categories\nbitcoind -debug=net -debug=mempool -debug=validation\n\n# Or in bitcoin.conf\ndebug=net\ndebug=mempool\ndebug=validation\n```\n\n**Common Debug Categories:**\n- `net`: Network messages\n- `mempool`: Mempool operations\n- `validation`: Block validation\n- `rpc`: RPC calls\n- `estimatefee`: Fee estimation\n- `selectcoins`: Coin selection\n\n### Common Debugging Patterns\n\n**Transaction Not Confirming:**\n\n```bash\n# Check if in mempool\nbitcoin-cli getmempoolentry <txid>\n\n# Check mempool info\nbitcoin-cli getmempoolinfo\n\n# Check fee rate\nbitcoin-cli getmempoolentry <txid> | jq '.fees.base / .vsize'\n```\n\n**Script Verification Failed:**\n\n```bash\n# Decode and inspect the transaction\nbitcoin-cli decoderawtransaction <raw_tx>\n\n# Check the referenced output\nbitcoin-cli gettxout <prev_txid> <vout>\n```\n\n---\n\n## Testing Lightning Applications\n\n### Using Polar\n\nPolar provides a one-click Lightning Network for testing.\n\n**Setup:**\n1. Download from [lightningpolar.com](https://lightningpolar.com/)\n2. Create a new network\n3. Start nodes\n4. Open channels between nodes\n\n### LND Testing\n\n```python\nimport grpc\nimport lnrpc\nimport unittest\n\nclass LightningTestCase(unittest.TestCase):\n    \"\"\"Test case for LND Lightning Network integration tests.\"\"\"\n    \n    def setUp(self):\n        # Connect to LND\n        self.channel = grpc.insecure_channel('localhost:10009')\n        self.stub = lnrpc.LightningStub(self.channel)\n    \n    def tearDown(self):\n        self.channel.close()\n    \n    def test_create_invoice(self):\n        # Create invoice\n        request = lnrpc.Invoice(value=1000, memo=\"test\")\n        response = self.stub.AddInvoice(request)\n        \n        # Verify invoice created\n        self.assertIsNotNone(response.payment_request)\n        self.assertTrue(response.payment_request.startswith('ln'))\n```\n\n### Core Lightning Testing\n\n```python\nfrom pyln.client import LightningRpc\nimport unittest\n\nclass CLightningTestCase(unittest.TestCase):\n    \"\"\"Test case for Core Lightning integration tests.\"\"\"\n    \n    def setUp(self):\n        self.rpc = LightningRpc(\"/path/to/lightning-rpc\")\n    \n    def test_get_info(self):\n        info = self.rpc.getinfo()\n        self.assertIn('id', info)\n        self.assertIn('alias', info)\n```\n\n---\n\n## Mocking and Stubbing\n\n### Mocking RPC Calls\n\n```python\nfrom unittest.mock import Mock, patch\n\nclass TestWithMocks:\n    @patch('bitcoinrpc.RawProxy')\n    def test_get_balance(self, mock_proxy):\n        # Setup mock\n        mock_proxy.return_value.getbalance.return_value = 10.5\n        \n        # Test code that uses RPC\n        rpc = mock_proxy()\n        balance = rpc.getbalance()\n        \n        assert balance == 10.5\n        mock_proxy.return_value.getbalance.assert_called_once()\n```\n\n### Mocking Network Responses\n\n```python\nimport responses\nimport requests\n\nclass TestAPIIntegration:\n    @responses.activate\n    def test_fetch_block(self):\n        # Mock the API response\n        responses.add(\n            responses.GET,\n            'https://blockstream.info/api/block/000000...',\n            json={'height': 100000, 'tx_count': 50},\n            status=200\n        )\n        \n        # Test code\n        response = requests.get('https://blockstream.info/api/block/000000...')\n        data = response.json()\n        \n        assert data['height'] == 100000\n```\n\n---\n\n## Test Data Generation\n\n### Creating Test Transactions\n\n```python\ndef create_test_transaction(inputs, outputs):\n    \"\"\"Create a transaction for testing.\"\"\"\n    tx = CTransaction()\n    \n    for txid, vout in inputs:\n        outpoint = COutPoint(bytes.fromhex(txid)[::-1], vout)\n        tx.vin.append(CTxIn(outpoint))\n    \n    for address, amount in outputs:\n        script = address.to_scriptPubKey()\n        tx.vout.append(CTxOut(int(amount * 100000000), script))\n    \n    return tx\n```\n\n### Generating Test Keys\n\n```python\nimport secrets\nfrom bitcoin.wallet import CBitcoinSecret\n\ndef generate_test_keypair():\n    \"\"\"Generate a random keypair for testing.\"\"\"\n    # Generate random private key\n    private_key_bytes = secrets.token_bytes(32)\n    private_key = CBitcoinSecret.from_secret_bytes(private_key_bytes)\n    \n    # Derive public key\n    public_key = private_key.pub\n    \n    return private_key, public_key\n```\n\n---\n\n## Continuous Integration\n\n### GitHub Actions Example\n\n```yaml\nname: Bitcoin Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.10'\n    \n    - name: Install dependencies\n      run: |\n        pip install python-bitcoinlib pytest\n    \n    - name: Install Bitcoin Core\n      run: |\n        wget https://bitcoincore.org/bin/bitcoin-core-25.0/bitcoin-25.0-x86_64-linux-gnu.tar.gz\n        tar xzf bitcoin-25.0-x86_64-linux-gnu.tar.gz\n        sudo mv bitcoin-25.0/bin/* /usr/local/bin/\n    \n    - name: Run unit tests\n      run: pytest tests/unit/\n    \n    - name: Run integration tests\n      run: |\n        bitcoind -regtest -daemon\n        sleep 5\n        pytest tests/integration/\n        bitcoin-cli -regtest stop\n```\n\n---\n\n## Best Practices\n\n### Testing Checklist\n\n1. **Unit Tests**: Test individual functions in isolation\n2. **Integration Tests**: Test component interactions on regtest\n3. **End-to-End Tests**: Test full workflows on signet/testnet\n4. **Edge Cases**: Test boundary conditions and error handling\n5. **Security Tests**: Test for common vulnerabilities\n\n### Common Pitfalls\n\n**Don't:**\n- Test with real Bitcoin (mainnet)\n- Hardcode test data that could change\n- Skip error handling tests\n- Ignore race conditions in async code\n\n**Do:**\n- Use regtest for fast iteration\n- Test both success and failure paths\n- Mock external dependencies\n- Clean up test state between runs\n\n### Test Organization\n\n```\ntests/\nâ”œâ”€â”€ unit/\nâ”‚   â”œâ”€â”€ test_transactions.py\nâ”‚   â”œâ”€â”€ test_addresses.py\nâ”‚   â””â”€â”€ test_scripts.py\nâ”œâ”€â”€ integration/\nâ”‚   â”œâ”€â”€ test_wallet.py\nâ”‚   â”œâ”€â”€ test_mempool.py\nâ”‚   â””â”€â”€ test_mining.py\nâ”œâ”€â”€ fixtures/\nâ”‚   â”œâ”€â”€ transactions.json\nâ”‚   â””â”€â”€ blocks.json\nâ””â”€â”€ conftest.py\n```\n\n---\n\n## Related Topics\n\n- [Test Networks](/docs/development/testnets) - Regtest, Signet, and Testnet setup\n- [Getting Started](/docs/development) - Development environment setup\n- [Libraries & SDKs](/docs/development/libraries) - Testing utilities in each library",
    "filename": "testing.md"
  },
  "/docs/development/testnets": {
    "content": "# Signet & Testnet Deep Dive\n\nTest networks are essential for Bitcoin development. This guide covers the differences between testnet, signet, and regtest, along with setup instructions and best practices.\n\n## Network Comparison\n\n| Feature | Mainnet | Testnet | Signet | Regtest |\n|---------|---------|---------|--------|---------|\n| Real Value | Yes | No | No | No |\n| Block Time | ~10 min | Variable | ~10 min | Instant |\n| Difficulty | Dynamic | Dynamic | Fixed | Minimal |\n| Public | Yes | Yes | Yes | Local |\n| Controlled | No | No | Yes | Yes |\n| Best For | Production | Integration | Testing | Unit tests |\n\n---\n\n## Testnet (Testnet3)\n\n### Overview\n\nTestnet is the original Bitcoin test network. It mirrors mainnet but with worthless coins.\n\n### Configuration\n\n```ini\n# bitcoin.conf\ntestnet=1\n[test]\nrpcuser=user\nrpcpassword=password\nrpcport=18332\n```\n\n### Starting Testnet\n\n```bash\n# Start testnet node\nbitcoind -testnet -daemon\n\n# Use bitcoin-cli with testnet\nbitcoin-cli -testnet getblockchaininfo\n\n# Check sync status\nbitcoin-cli -testnet getblockcount\n```\n\n### Testnet Faucets\n\nGet free testnet coins:\n\n- [coinfaucet.eu](https://coinfaucet.eu/en/btc-testnet/)\n- [testnet-faucet.com](https://testnet-faucet.com/btc-testnet/)\n- [bitcoinfaucet.uo1.net](https://bitcoinfaucet.uo1.net/)\n\n### Testnet Explorers\n\n- [mempool.space/testnet](https://mempool.space/testnet)\n- [blockstream.info/testnet](https://blockstream.info/testnet)\n\n### Testnet Challenges\n\n```\nIssues with Testnet:\n- Block times can be erratic (difficulty resets)\n- Occasional \"block storms\" (many blocks quickly)\n- May have long periods with no blocks\n- Reorgs more common than mainnet\n```\n\n---\n\n## Signet\n\n### Overview\n\nSignet (BIP-325) provides a more controlled test environment. Blocks are signed by specific keys, ensuring predictable block production.\n\n### Benefits Over Testnet\n\n- **Predictable Blocks**: Consistent ~10 minute block times\n- **No Difficulty Resets**: Stable mining simulation\n- **Controlled Environment**: No surprise reorgs\n- **Better for Testing**: More mainnet-like behavior\n\n### Default Signet Configuration\n\n```ini\n# bitcoin.conf\nsignet=1\n[signet]\nrpcuser=user\nrpcpassword=password\nrpcport=38332\n```\n\n### Starting Signet\n\n```bash\n# Start signet node\nbitcoind -signet -daemon\n\n# Check status\nbitcoin-cli -signet getblockchaininfo\n\n# Get network info\nbitcoin-cli -signet getnetworkinfo\n```\n\n### Signet Faucets\n\n- [signet.bc-2.jp](https://signet.bc-2.jp/)\n- [alt.signetfaucet.com](https://alt.signetfaucet.com/)\n- [signetfaucet.bublina.eu.org](https://signetfaucet.bublina.eu.org/)\n\n### Signet Explorer\n\n- [mempool.space/signet](https://mempool.space/signet)\n\n### Custom Signet\n\nYou can create your own signet for private testing:\n\n```bash\n# Generate signing key\nbitcoin-cli -regtest createwallet \"signet_signer\"\nSIGNET_ADDR=$(bitcoin-cli -regtest getnewaddress)\nSIGNET_PUBKEY=$(bitcoin-cli -regtest getaddressinfo $SIGNET_ADDR | jq -r '.pubkey')\n\n# Create signet challenge script\n# OP_1 <pubkey> OP_1 OP_CHECKMULTISIG\nCHALLENGE=\"5121${SIGNET_PUBKEY}51ae\"\n```\n\n```ini\n# Custom signet bitcoin.conf\nsignet=1\nsignetchallenge=5121...your_challenge...51ae\n[signet]\nrpcport=38332\n```\n\n---\n\n## Regtest (Regression Test)\n\n### Overview\n\nRegtest is a local, private blockchain perfect for development and automated testing.\n\n### Configuration\n\n```ini\n# bitcoin.conf\nregtest=1\n[regtest]\nrpcuser=user\nrpcpassword=password\nrpcport=18443\n```\n\n### Starting Regtest\n\n```bash\n# Start regtest node\nbitcoind -regtest -daemon\n\n# Create wallet\nbitcoin-cli -regtest createwallet \"dev\"\n\n# Generate initial coins (need 100+ blocks for maturity)\nbitcoin-cli -regtest -generate 101\n\n# Check balance\nbitcoin-cli -regtest getbalance\n```\n\n### Instant Block Generation\n\n```bash\n# Generate blocks on demand\nbitcoin-cli -regtest -generate 1\n\n# Generate to specific address\nbitcoin-cli -regtest generatetoaddress 1 \"bcrt1q...\"\n\n# Generate multiple blocks\nbitcoin-cli -regtest -generate 10\n```\n\n### Regtest for Testing\n\n```python\nimport subprocess\nimport json\nimport time\n\nclass RegtestNode:\n    def __init__(self, datadir=None):\n        self.datadir = datadir or '/tmp/regtest'\n        \n    def start(self):\n        subprocess.run([\n            'bitcoind', '-regtest', '-daemon',\n            f'-datadir={self.datadir}',\n            '-rpcuser=test', '-rpcpassword=test'\n        ])\n        time.sleep(2)\n        \n    def stop(self):\n        self.cli('stop')\n        \n    def cli(self, *args):\n        result = subprocess.run(\n            ['bitcoin-cli', '-regtest', \n             f'-datadir={self.datadir}',\n             '-rpcuser=test', '-rpcpassword=test'] + list(args),\n            capture_output=True, text=True\n        )\n        if result.stdout:\n            try:\n                return json.loads(result.stdout)\n            except:\n                return result.stdout.strip()\n        return None\n    \n    def generate(self, blocks=1):\n        return self.cli('-generate', str(blocks))\n    \n    def get_new_address(self):\n        return self.cli('getnewaddress')\n    \n    def send(self, address, amount):\n        return self.cli('sendtoaddress', address, str(amount))\n\n# Usage\nnode = RegtestNode()\nnode.start()\nnode.cli('createwallet', 'test')\nnode.generate(101)  # Mine initial coins\naddr = node.get_new_address()\ntxid = node.send(addr, 1.0)\nnode.generate(1)  # Confirm transaction\nnode.stop()\n```\n\n---\n\n## Lightning Network Testing\n\n### Polar (Recommended)\n\nPolar provides a GUI for managing Lightning test networks.\n\n```bash\n# Download from https://lightningpolar.com/\n# Create network with:\n# - Bitcoin Core (regtest)\n# - LND / Core Lightning / Eclair nodes\n# - Automatic channel opening\n```\n\n### Manual LND Setup on Regtest\n\n```bash\n# Start Bitcoin Core regtest\nbitcoind -regtest -daemon -zmqpubrawblock=tcp://127.0.0.1:28332 -zmqpubrawtx=tcp://127.0.0.1:28333\n\n# Generate initial blocks\nbitcoin-cli -regtest -generate 101\n\n# Start LND\nlnd --bitcoin.active --bitcoin.regtest \\\n    --bitcoin.node=bitcoind \\\n    --bitcoind.rpcuser=user --bitcoind.rpcpass=password \\\n    --bitcoind.zmqpubrawblock=tcp://127.0.0.1:28332 \\\n    --bitcoind.zmqpubrawtx=tcp://127.0.0.1:28333\n\n# Create wallet and get address\nlncli --network=regtest create\nlncli --network=regtest newaddress p2wkh\n\n# Fund the wallet (from Bitcoin Core)\nbitcoin-cli -regtest sendtoaddress <lnd_address> 1\nbitcoin-cli -regtest -generate 6\n```\n\n### Core Lightning on Regtest\n\n```bash\n# Start lightningd\nlightningd --network=regtest \\\n    --bitcoin-rpcuser=user \\\n    --bitcoin-rpcpassword=password \\\n    --bitcoin-rpcport=18443\n\n# Get new address\nlightning-cli --network=regtest newaddr\n\n# Fund and open channel\nlightning-cli --network=regtest connect <node_id>@localhost:9735\nlightning-cli --network=regtest fundchannel <node_id> 100000\n```\n\n---\n\n## Automated Testing Setup\n\n### Docker Compose Example\n\n```yaml\n# docker-compose.yml\nversion: '3.8'\n\nservices:\n  bitcoind:\n    image: ruimarinho/bitcoin-core:latest\n    command:\n      - -regtest\n      - -rpcuser=test\n      - -rpcpassword=test\n      - -rpcallowip=0.0.0.0/0\n      - -rpcbind=0.0.0.0\n      - -zmqpubrawblock=tcp://0.0.0.0:28332\n      - -zmqpubrawtx=tcp://0.0.0.0:28333\n    ports:\n      - \"18443:18443\"\n      - \"28332:28332\"\n      - \"28333:28333\"\n    volumes:\n      - bitcoin_data:/home/bitcoin/.bitcoin\n\n  lnd:\n    image: lightninglabs/lnd:latest\n    depends_on:\n      - bitcoind\n    command:\n      - --bitcoin.active\n      - --bitcoin.regtest\n      - --bitcoin.node=bitcoind\n      - --bitcoind.rpchost=bitcoind\n      - --bitcoind.rpcuser=test\n      - --bitcoind.rpcpass=test\n      - --bitcoind.zmqpubrawblock=tcp://bitcoind:28332\n      - --bitcoind.zmqpubrawtx=tcp://bitcoind:28333\n    ports:\n      - \"10009:10009\"\n    volumes:\n      - lnd_data:/root/.lnd\n\nvolumes:\n  bitcoin_data:\n  lnd_data:\n```\n\n### CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\nname: Bitcoin Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      bitcoind:\n        image: ruimarinho/bitcoin-core:latest\n        options: >-\n          -regtest\n          -rpcuser=test\n          -rpcpassword=test\n          -rpcallowip=0.0.0.0/0\n        ports:\n          - 18443:18443\n    \n    steps:\n      - uses: actions/checkout@v3\n      \n      - name: Wait for Bitcoin Core\n        run: |\n          for i in {1..30}; do\n            if bitcoin-cli -regtest -rpcuser=test -rpcpassword=test getblockchaininfo; then\n              break\n            fi\n            sleep 1\n          done\n      \n      - name: Setup test environment\n        run: |\n          bitcoin-cli -regtest -rpcuser=test -rpcpassword=test createwallet test\n          bitcoin-cli -regtest -rpcuser=test -rpcpassword=test -generate 101\n      \n      - name: Run tests\n        run: npm test\n```\n\n---\n\n## Network-Specific Code\n\n### Selecting Network\n\n:::code-group\n```rust\nuse bitcoin::Network;\n\nfn get_network(network_type: &str) -> Network {\n    match network_type {\n        \"mainnet\" => Network::Bitcoin,\n        \"testnet\" | \"signet\" => Network::Testnet,\n        \"regtest\" => Network::Regtest,\n        _ => panic!(\"Unknown network\"),\n    }\n}\n```\n\n```python\nfrom bitcoin import SelectParams\n\ndef select_network(network_type):\n    networks = {'mainnet': 'mainnet', 'testnet': 'testnet', 'regtest': 'regtest'}\n    SelectParams(networks.get(network_type, 'testnet'))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::config::network get_network(const std::string& type) {\n    if (type == \"mainnet\") return bc::config::network::mainnet;\n    if (type == \"testnet\") return bc::config::network::testnet;\n    return bc::config::network::regtest;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc getNetwork(networkType string) *chaincfg.Params {\n\tswitch networkType {\n\tcase \"mainnet\":\n\t\treturn &chaincfg.MainNetParams\n\tcase \"testnet\":\n\t\treturn &chaincfg.TestNet3Params\n\tcase \"regtest\":\n\t\treturn &chaincfg.RegressionNetParams\n\tcase \"signet\":\n\t\treturn &chaincfg.SigNetParams\n\tdefault:\n\t\tpanic(\"Unknown network\")\n\t}\n}\n\nfunc main() {\n\tnetwork := getNetwork(\"testnet\")\n\tfmt.Printf(\"Network: %s\\n\", network.Name)\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction getNetwork(type) {\n  const networks = {\n    mainnet: bitcoin.networks.bitcoin,\n    testnet: bitcoin.networks.testnet,\n    regtest: bitcoin.networks.regtest,\n  };\n  return networks[type];\n}\n```\n:::\n\n### RPC Port Configuration\n\n| Network | RPC Port |\n|---------|----------|\n| Mainnet | 8332 |\n| Testnet | 18332 |\n| Signet | 38332 |\n| Regtest | 18443 |\n\n---\n\n## Testing Scenarios\n\n### Testing RBF (Replace-By-Fee)\n\n```bash\n# On regtest\n# 1. Create transaction with RBF enabled\nbitcoin-cli -regtest sendtoaddress <addr> 0.1 \"\" \"\" false true  # replaceable=true\n\n# 2. Get the txid\nTXID=$(bitcoin-cli -regtest listtransactions | jq -r '.[0].txid')\n\n# 3. Bump the fee\nbitcoin-cli -regtest bumpfee $TXID\n\n# 4. Mine block to confirm\nbitcoin-cli -regtest -generate 1\n```\n\n### Testing Time Locks\n\n```bash\n# Test CLTV (absolute timelock)\n# Create transaction locked until block 150\nbitcoin-cli -regtest createrawtransaction \\\n  '[{\"txid\":\"...\", \"vout\":0}]' \\\n  '[{\"<addr>\": 0.1}]' \\\n  150  # locktime\n\n# Won't be valid until block 150\nbitcoin-cli -regtest -generate 50  # Advance to block 150+\n```\n\n### Testing Mempool Behavior\n\n```python\ndef test_mempool_eviction(node):\n    # Fill mempool with low-fee transactions\n    low_fee_txs = []\n    for i in range(100):\n        addr = node.cli('getnewaddress')\n        txid = node.cli('sendtoaddress', addr, '0.001', '', '', False, False, 1)  # 1 sat/vB\n        low_fee_txs.append(txid)\n    \n    # Create high-fee transaction\n    addr = node.cli('getnewaddress')\n    high_fee_tx = node.cli('sendtoaddress', addr, '0.001', '', '', False, False, 100)  # 100 sat/vB\n    \n    # Verify high-fee tx is in mempool\n    mempool = node.cli('getrawmempool')\n    assert high_fee_tx in mempool\n    \n    # Some low-fee txs may be evicted if mempool is full\n```\n\n---\n\n## Best Practices\n\n### Development Workflow\n\n```\n1. Unit Tests â†’ Regtest\n   - Fast iteration\n   - Complete control\n   - Automated testing\n\n2. Integration Tests â†’ Signet\n   - More realistic environment\n   - Predictable timing\n   - Public network testing\n\n3. Final Testing â†’ Testnet\n   - Closest to mainnet\n   - Real network conditions\n   - Edge case discovery\n\n4. Production â†’ Mainnet\n   - Start with small amounts\n   - Monitor closely\n   - Gradual rollout\n```\n\n### Common Mistakes\n\n```\nDON'T:\nâœ— Test with mainnet funds\nâœ— Assume testnet behavior matches mainnet exactly\nâœ— Ignore network-specific address formats\nâœ— Hardcode RPC ports\n\nDO:\nâœ“ Use appropriate network for each test stage\nâœ“ Handle network differences in code\nâœ“ Validate addresses for correct network\nâœ“ Configure networks via environment variables\n```\n\n---\n\n## Summary\n\nEach test network serves a purpose:\n\n- **Regtest**: Local development and unit testing\n- **Signet**: Predictable integration testing\n- **Testnet**: Real-world simulation before mainnet\n\nStart with regtest for fast iteration, move to signet for integration testing, and use testnet for final validation before deploying to mainnet.\n\n---\n\n## Related Topics\n\n- [Testing & Debugging](/docs/development/testing) - Testing strategies and techniques\n- [Getting Started](/docs/development) - Development setup guide\n- [RPC Commands](/docs/bitcoin/rpc) - Bitcoin Core RPC interface\n",
    "filename": "testnets.md"
  },
  "/docs/development/libraries": {
    "content": "# Libraries & SDKs Reference\n\nThis guide compares major Bitcoin libraries across languages and provides practical examples for common development tasks.\n\n> Library Versions\n> Code examples in this documentation are tested with the following library versions:\n> - **bitcoinjs-lib**: v6.x (uses factory pattern for bip32/ecpair)\n> - **bip32**: v4.x (requires `tiny-secp256k1` via `BIP32Factory`)\n> - **rust-bitcoin**: v0.31.x\n> - **BDK**: v0.29.x\n> - **python-bitcoinlib**: v0.12.x\n> - **bip32utils**: v0.3.x (use `BIP32Key.fromSeed()` for seed-based derivation)\n\nWhen using different versions, consult each library's migration guides for API changes.\n\n## Library Overview\n\n### By Language\n\n| Language | Library | Best For | Maintenance |\n|----------|---------|----------|-------------|\n| JavaScript | bitcoinjs-lib | Web apps, general use | Active |\n| Rust | rust-bitcoin | Core development | Active |\n| Rust | BDK | Wallet development | Active |\n| Python | python-bitcoinlib | Scripts, learning | Moderate |\n| Go | btcd/btcutil | Infrastructure | Active |\n| C++ | libbitcoin | Performance-critical | Active |\n\n### Feature Comparison\n\n| Feature | bitcoinjs-lib | rust-bitcoin | BDK | python-bitcoinlib |\n|---------|--------------|--------------|-----|-------------------|\n| Transaction Building | âœ“ | âœ“ | âœ“ | âœ“ |\n| [PSBT](/docs/glossary#psbt-partially-signed-bitcoin-transaction) Support | âœ“ | âœ“ | âœ“ | Partial |\n| [Taproot](/docs/glossary#taproot) | âœ“ | âœ“ | âœ“ | Limited |\n| [HD Wallets](/docs/glossary#hd-wallet-hierarchical-deterministic-wallet) | Via bip32/bip39 | Via bip32 | âœ“ | Via bip32utils |\n| [Coin Selection](/docs/glossary#coin-selection) | Manual | Manual | âœ“ | Manual |\n| Blockchain Sync | No | No | âœ“ | No |\n\n---\n\n## JavaScript/TypeScript\n\n### bitcoinjs-lib\n\nThe most popular JavaScript Bitcoin library.\n\n**Installation:**\n\n```bash\nnpm install bitcoinjs-lib\nnpm install ecpair tiny-secp256k1  # For signing\nnpm install bip32 bip39            # For HD wallets\n```\n\n**Basic Usage:**\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\nimport ECPairFactory from 'ecpair';\nimport * as ecc from 'tiny-secp256k1';\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nconst ECPair = ECPairFactory(ecc);\nconst bip32 = BIP32Factory(ecc);\n\n// Generate mnemonic and derive keys\nconst mnemonic = bip39.generateMnemonic(256);\nconst seed = await bip39.mnemonicToSeed(mnemonic);\nconst root = bip32.fromSeed(seed);\n\n// BIP84 derivation (Native SegWit)\nconst child = root.derivePath(\"m/84'/0'/0'/0/0\");\n\n// Create address\nconst { address } = bitcoin.payments.p2wpkh({\n  pubkey: child.publicKey,\n  network: bitcoin.networks.bitcoin,\n});\nconsole.log('Address:', address);\n```\n\n**Transaction Building:**\n\n```typescript\nconst psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\n\n// Add input\npsbt.addInput({\n  hash: 'txid_hex',\n  index: 0,\n  witnessUtxo: {\n    script: Buffer.from('0014...', 'hex'),\n    value: 100000,\n  },\n});\n\n// Add output\npsbt.addOutput({\n  address: 'bc1q...',\n  value: 50000,\n});\n\n// Sign\npsbt.signInput(0, ECPair.fromPrivateKey(child.privateKey!));\npsbt.finalizeAllInputs();\n\n// Get raw transaction\nconst tx = psbt.extractTransaction();\nconsole.log('Raw TX:', tx.toHex());\n```\n\n### noble-secp256k1\n\nLightweight cryptographic library for schnorr/ECDSA.\n\n```typescript\nimport * as secp from '@noble/secp256k1';\n\n// Generate key pair\nconst privateKey = secp.utils.randomPrivateKey();\nconst publicKey = secp.getPublicKey(privateKey);\n\n// Sign message (Schnorr for Taproot)\nconst message = new Uint8Array(32); // Your message hash\nconst signature = await secp.schnorr.sign(message, privateKey);\n\n// Verify\nconst isValid = await secp.schnorr.verify(signature, message, publicKey);\n```\n\n---\n\n## Rust\n\n### rust-bitcoin\n\nLow-level Bitcoin library for Rust.\n\n**Cargo.toml:**\n\n```toml\n[dependencies]\nbitcoin = \"0.31\"\nsecp256k1 = { version = \"0.28\", features = [\"global-context\"] }\n```\n\n**Basic Usage:**\n\n```rust\nuse bitcoin::{\n    Address, Network, PrivateKey, PublicKey,\n    secp256k1::{Secp256k1, SecretKey},\n};\n\nfn main() {\n    let secp = Secp256k1::new();\n    \n    // Generate key pair\n    let secret_key = SecretKey::new(&mut rand::thread_rng());\n    let private_key = PrivateKey::new(secret_key, Network::Bitcoin);\n    let public_key = PublicKey::from_private_key(&secp, &private_key);\n    \n    // Create addresses\n    let p2wpkh = Address::p2wpkh(&public_key, Network::Bitcoin).unwrap();\n    println!(\"P2WPKH: {}\", p2wpkh);\n}\n```\n\n**Transaction Building:**\n\n```rust\nuse bitcoin::{\n    Transaction, TxIn, TxOut, OutPoint, Sequence,\n    absolute::LockTime, Amount, ScriptBuf,\n    sighash::{SighashCache, EcdsaSighashType},\n};\n\nfn create_transaction(\n    prev_txid: Txid,\n    prev_vout: u32,\n    recipient: Address,\n    amount: Amount,\n) -> Transaction {\n    let tx = Transaction {\n        version: 2,\n        lock_time: LockTime::ZERO,\n        input: vec![TxIn {\n            previous_output: OutPoint::new(prev_txid, prev_vout),\n            script_sig: ScriptBuf::new(),\n            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n            witness: bitcoin::Witness::default(),\n        }],\n        output: vec![TxOut {\n            value: amount,\n            script_pubkey: recipient.script_pubkey(),\n        }],\n    };\n    \n    tx\n}\n```\n\n### BDK (Bitcoin Dev Kit)\n\nHigh-level wallet library built on rust-bitcoin.\n\n**Cargo.toml:**\n\n```toml\n[dependencies]\nbdk = \"0.29\"\n```\n\n**Wallet Creation:**\n\n```rust\nuse bdk::{\n    Wallet, SignOptions,\n    database::MemoryDatabase,\n    bitcoin::Network,\n    keys::{DerivableKey, GeneratableKey, bip39::{Mnemonic, Language}},\n    template::Bip84,\n};\n\nfn create_wallet() -> Result<Wallet<MemoryDatabase>, Box<dyn std::error::Error>> {\n    // Generate mnemonic\n    let mnemonic = Mnemonic::generate((bdk::keys::bip39::WordCount::Words24, Language::English))?;\n    \n    // Create wallet with BIP84 descriptors\n    let wallet = Wallet::new(\n        Bip84(mnemonic.clone(), None),\n        Some(Bip84(mnemonic, None)),\n        Network::Bitcoin,\n        MemoryDatabase::default(),\n    )?;\n    \n    Ok(wallet)\n}\n```\n\n**Transaction Building with BDK:**\n\n```rust\nuse bdk::{FeeRate, wallet::AddressIndex};\n\nfn send_transaction(\n    wallet: &Wallet<MemoryDatabase>,\n    recipient: &str,\n    amount: u64,\n) -> Result<Transaction, Box<dyn std::error::Error>> {\n    let recipient = Address::from_str(recipient)?;\n    \n    // Build transaction\n    let mut builder = wallet.build_tx();\n    builder\n        .add_recipient(recipient.script_pubkey(), amount)\n        .fee_rate(FeeRate::from_sat_per_vb(5.0))\n        .enable_rbf();\n    \n    let (mut psbt, _details) = builder.finish()?;\n    \n    // Sign\n    wallet.sign(&mut psbt, SignOptions::default())?;\n    \n    // Extract final transaction\n    let tx = psbt.extract_tx();\n    Ok(tx)\n}\n```\n\n### LDK (Lightning Dev Kit)\n\nEmbed Lightning in your Rust application.\n\n```rust\nuse lightning::chain::keysinterface::KeysManager;\nuse lightning::ln::channelmanager::ChannelManager;\n\n// LDK requires more setup - see lightning.dev for full examples\n// Key components:\n// - ChannelManager: Manages channels\n// - PeerManager: Handles peer connections  \n// - ChainMonitor: Monitors on-chain events\n```\n\n---\n\n## Python\n\n### python-bitcoinlib\n\n```bash\npip install python-bitcoinlib\n```\n\n**Basic Usage:**\n\n```python\nfrom bitcoin import SelectParams\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint, COIN\nfrom bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG\nfrom bitcoin.wallet import CBitcoinAddress, CBitcoinSecret\n\n# Select network\nSelectParams('mainnet')  # or 'testnet', 'regtest'\n\n# Create address from private key\nsecret = CBitcoinSecret.from_secret_bytes(bytes(32))  # Use real entropy!\naddress = CBitcoinAddress.from_pubkey(secret.pub)\nprint(f\"Address: {address}\")\n```\n\n**Transaction Building:**\n\n```python\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\nfrom bitcoin.core.script import SignatureHash, SIGHASH_ALL\n\ndef create_transaction(prev_txid, prev_vout, recipient, amount, private_key):\n    # Create input\n    outpoint = COutPoint(bytes.fromhex(prev_txid)[::-1], prev_vout)\n    txin = CTxIn(outpoint)\n    \n    # Create output\n    recipient_addr = CBitcoinAddress(recipient)\n    txout = CTxOut(amount, recipient_addr.to_scriptPubKey())\n    \n    # Create unsigned transaction\n    tx = CTransaction([txin], [txout])\n    \n    # Sign\n    sighash = SignatureHash(\n        recipient_addr.to_scriptPubKey(),\n        tx, 0, SIGHASH_ALL\n    )\n    sig = private_key.sign(sighash) + bytes([SIGHASH_ALL])\n    \n    # Add signature to input\n    txin.scriptSig = CScript([sig, private_key.pub])\n    \n    return CTransaction([txin], [txout])\n```\n\n### bip32utils\n\nFor HD wallet derivation in Python.\n\n```python\nfrom bip32utils import BIP32Key\nfrom mnemonic import Mnemonic\n\n# Generate mnemonic\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)\nseed = mnemo.to_seed(words)\n\n# Create master key\nmaster = BIP32Key.fromEntropy(seed)\n\n# Derive BIP84 path\naccount = master.ChildKey(84 + 0x80000000)  # purpose (hardened)\naccount = account.ChildKey(0 + 0x80000000)   # coin_type (hardened)\naccount = account.ChildKey(0 + 0x80000000)   # account (hardened)\nexternal = account.ChildKey(0)                # change\naddress_key = external.ChildKey(0)            # address_index\n\nprint(f\"Address: {address_key.Address()}\")\n```\n\n---\n\n## Go\n\n### btcd/btcutil\n\n```go\nimport (\n    \"github.com/btcsuite/btcd/btcec/v2\"\n    \"github.com/btcsuite/btcd/btcutil\"\n    \"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc generateAddress() {\n    // Generate private key\n    privateKey, _ := btcec.NewPrivateKey()\n    \n    // Get public key\n    publicKey := privateKey.PubKey()\n    \n    // Create P2WPKH address\n    pubKeyHash := btcutil.Hash160(publicKey.SerializeCompressed())\n    addr, _ := btcutil.NewAddressWitnessPubKeyHash(\n        pubKeyHash,\n        &chaincfg.MainNetParams,\n    )\n    \n    fmt.Println(\"Address:\", addr.String())\n}\n```\n\n### lnd/lnrpc\n\nFor Lightning Network in Go.\n\n```go\nimport (\n    \"github.com/lightningnetwork/lnd/lnrpc\"\n    \"google.golang.org/grpc\"\n)\n\nfunc connectToLND() {\n    // Connect to LND\n    conn, _ := grpc.Dial(\"localhost:10009\", grpc.WithInsecure())\n    client := lnrpc.NewLightningClient(conn)\n    \n    // Get node info\n    info, _ := client.GetInfo(context.Background(), &lnrpc.GetInfoRequest{})\n    fmt.Println(\"Node pubkey:\", info.IdentityPubkey)\n    \n    // Create invoice\n    invoice, _ := client.AddInvoice(context.Background(), &lnrpc.Invoice{\n        Value: 1000,\n        Memo:  \"Test payment\",\n    })\n    fmt.Println(\"Payment request:\", invoice.PaymentRequest)\n}\n```\n\n---\n\n## Common Tasks\n\n### Generate Address (All Languages)\n\n```typescript\n// JavaScript\nconst { address } = bitcoin.payments.p2wpkh({ pubkey: publicKey });\n```\n\n```rust\n// Rust\nlet address = Address::p2wpkh(&public_key, Network::Bitcoin)?;\n```\n\n```python\n# Python\naddress = CBitcoinAddress.from_pubkey(public_key)\n```\n\n```go\n// Go\naddr, _ := btcutil.NewAddressWitnessPubKeyHash(pubKeyHash, &chaincfg.MainNetParams)\n```\n\n### Parse Transaction\n\n```typescript\n// JavaScript\nconst tx = bitcoin.Transaction.fromHex(rawTxHex);\nconsole.log('TXID:', tx.getId());\nconsole.log('Inputs:', tx.ins.length);\nconsole.log('Outputs:', tx.outs.length);\n```\n\n```rust\n// Rust\nlet tx: Transaction = deserialize(&hex::decode(raw_tx_hex)?)?;\nprintln!(\"TXID: {}\", tx.txid());\n```\n\n```python\n# Python\ntx = CTransaction.deserialize(bytes.fromhex(raw_tx_hex))\nprint(f\"TXID: {tx.GetTxid().hex()}\")\n```\n\n### Validate Address\n\n```typescript\n// JavaScript\nfunction isValidAddress(address: string): boolean {\n  try {\n    bitcoin.address.toOutputScript(address, bitcoin.networks.bitcoin);\n    return true;\n  } catch {\n    return false;\n  }\n}\n```\n\n```rust\n// Rust\nfn is_valid_address(addr_str: &str) -> bool {\n    Address::from_str(addr_str)\n        .map(|a| a.is_valid_for_network(Network::Bitcoin))\n        .unwrap_or(false)\n}\n```\n\n```python\n# Python\ndef is_valid_address(address):\n    try:\n        CBitcoinAddress(address)\n        return True\n    except:\n        return False\n```\n\n---\n\n## Choosing a Library\n\n### Decision Matrix\n\n| Use Case | Recommended |\n|----------|-------------|\n| Web wallet | bitcoinjs-lib |\n| Mobile app (React Native) | bitcoinjs-lib |\n| Backend service | rust-bitcoin or btcd |\n| Wallet application | BDK |\n| Lightning integration | LDK (Rust) or lnd (Go) |\n| Scripting/automation | python-bitcoinlib |\n| Learning/education | python-bitcoinlib |\n| High-performance | rust-bitcoin or libbitcoin |\n\n### Considerations\n\n**bitcoinjs-lib:**\n- Pros: Wide adoption, good docs, browser support\n- Cons: JavaScript ecosystem complexity\n\n**rust-bitcoin:**\n- Pros: Type safety, performance, active development\n- Cons: Steeper learning curve\n\n**BDK:**\n- Pros: Full wallet features, handles complexity\n- Cons: Rust knowledge required\n\n**python-bitcoinlib:**\n- Pros: Easy to learn, great for scripts\n- Cons: Slower, less complete Taproot support\n\n---\n\n## Summary\n\nEach library has its strengths:\n\n- **bitcoinjs-lib**: Best for web and cross-platform\n- **rust-bitcoin/BDK**: Best for production applications\n- **python-bitcoinlib**: Best for learning and scripting\n- **btcd**: Best for Go infrastructure\n\nChoose based on your language preference, use case, and required features. For production wallets, consider BDK for its completeness; for web apps, bitcoinjs-lib remains the standard choice.\n\n---\n\n## Related Topics\n\n- [Getting Started](/docs/development) - Development environment setup\n- [Transaction Construction](/docs/bitcoin-development/transactions) - Using libraries for transactions\n- [PSBT](/docs/bitcoin-development/psbt) - Library support for PSBTs\n- [Testing & Debugging](/docs/development/testing) - Library testing utilities\n",
    "filename": "libraries.md"
  },
  "/docs/development/node-types": {
    "content": "# Node Types & Architecture\n\nBitcoin nodes come in different types, each with different capabilities, resource requirements, and trust models. Understanding node types helps you choose the right setup for your needs.\n\n## Node Types\n\n### Full Nodes\n\n**Full nodes** download and validate the entire blockchain:\n\n```text\nCharacteristics:\n- Downloads ~600GB+ blockchain data\n- Validates all transactions and blocks\n- Maintains complete UTXO set\n- Maximum security and privacy\n- Requires significant resources\n```\n\n**Use cases**:\n- Maximum security\n- Privacy-sensitive applications\n- Contributing to network\n- Development and testing\n\n### Pruned Nodes\n\n**Pruned nodes** validate everything but don't store full history:\n\n```text\nCharacteristics:\n- Validates all blocks\n- Stores only recent blocks (~2GB)\n- Maintains UTXO set\n- Good security, lower storage\n- Can't serve historical data\n```\n\n**Use cases**:\n- Limited storage space\n- Still want full validation\n- Don't need historical data\n\n### Archival Nodes\n\n**Archival nodes** store complete blockchain history:\n\n```text\nCharacteristics:\n- Full blockchain storage\n- Can serve historical data\n- Maximum storage requirements\n- Useful for research/analysis\n```\n\n**Use cases**:\n- Blockchain analysis\n- Historical data access\n- Research purposes\n- Public services\n\n### SPV (Simplified Payment Verification) Nodes\n\n**SPV nodes** download only block headers:\n\n```text\nCharacteristics:\n- Downloads ~80 bytes per block\n- Minimal storage (~50MB)\n- Relies on full nodes\n- Less privacy\n- Faster sync\n```\n\n**Use cases**:\n- Mobile wallets\n- Lightweight clients\n- Limited resources\n- Quick setup\n\n### AssumeUTXO (Faster Initial Sync)\n\n**AssumeUTXO** (in [Bitcoin Core](https://github.com/bitcoin/bitcoin) 26+) allows a new node to **start from a snapshot** of the [UTXO set](/docs/glossary#utxo-set) at a recent [block](/docs/glossary#block) height instead of verifying every [block](/docs/bitcoin/blocks) from the [genesis](/docs/glossary#genesis-block). The node downloads a signed snapshot (from a built-in or external source), loads the UTXO set, and then syncs only the **remaining** blocks to the chain tip. This can reduce **initial sync time** from days to hours. The node still performs full [consensus](/docs/glossary#consensus) validation for all blocks it downloads; the trust is only that the snapshot is correct at that height, and the [BIP](/docs/history/bips) process and built-in defaults are designed to minimize risk. Useful for [pruned](/docs/development/node-types#pruned-nodes) and [full](/docs/development/node-types#full-nodes) nodes that want to reach [tip](/docs/glossary#block-height) quickly, then optionally verify history in the background.\n\n### Block-Relay-Only Connections\n\n**Block-relay-only** is a connection mode where the node does **not** exchange [transaction](/docs/bitcoin/transaction-lifecycle) ([inv](/docs/bitcoin/p2p-protocol), [mempool](/docs/mining/mempool)) data with that [peer](/docs/glossary#peer), only blocks and [compact blocks](/docs/bitcoin/blocks#compact-block-relay-bip-152). This reduces [privacy](/docs/wallets/privacy) leakage (peers cannot directly tie your [transactions](/docs/bitcoin/transaction-lifecycle) to your IP) and bandwidth. Bitcoin Core uses some block-relay-only [outbound](/docs/bitcoin/p2p-protocol) connections by default.\n\n---\n\n## Code Examples\n\n### Checking Node Type\n\n:::code-group\n```rust\nuse serde_json::json;\nuse reqwest;\n\nasync fn get_node_info() -> Result<serde_json::Value, Box<dyn std::error::Error>> {\n    let client = reqwest::Client::new();\n    let response = client\n        .post(\"http://localhost:8332\")\n        .json(&json!({\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"getblockchaininfo\"\n        }))\n        .send()\n        .await?;\n    \n    let info: serde_json::Value = response.json().await?;\n    Ok(info[\"result\"].clone())\n}\n```\n\n```python\nimport requests\nimport json\n\ndef get_node_info():\n    \"\"\"Get node information via RPC.\"\"\"\n    response = requests.post(\n        \"http://localhost:8332\",\n        json={\n            \"jsonrpc\": \"2.0\",\n            \"id\": 1,\n            \"method\": \"getblockchaininfo\"\n        }\n    )\n    return response.json()[\"result\"]\n```\n\n```cpp\n#include <curl/curl.h>\n#include <json/json.h>\n#include <string>\n\nJson::Value get_node_info() {\n    CURL* curl = curl_easy_init();\n    std::string response_data;\n    \n    std::string json_data = R\"({\n        \"jsonrpc\": \"2.0\",\n        \"id\": 1,\n        \"method\": \"getblockchaininfo\"\n    })\";\n    \n    curl_easy_setopt(curl, CURLOPT_URL, \"http://localhost:8332\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_data);\n    curl_easy_perform(curl);\n    \n    Json::Value root;\n    Json::Reader reader;\n    reader.parse(response_data, root);\n    \n    return root[\"result\"];\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype RPCRequest struct {\n\tJSONRPC string        `json:\"jsonrpc\"`\n\tID      int           `json:\"id\"`\n\tMethod  string        `json:\"method\"`\n\tParams  []interface{} `json:\"params,omitempty\"`\n}\n\nfunc getNodeInfo() (map[string]interface{}, error) {\n\treq := RPCRequest{\n\t\tJSONRPC: \"2.0\",\n\t\tID:      1,\n\t\tMethod:  \"getblockchaininfo\",\n\t}\n\t\n\tjsonData, _ := json.Marshal(req)\n\tresp, err := http.Post(\n\t\t\"http://localhost:8332\",\n\t\t\"application/json\",\n\t\tbytes.NewBuffer(jsonData),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close()\n\t\n\tbody, _ := io.ReadAll(resp.Body)\n\tvar result map[string]interface{}\n\tjson.Unmarshal(body, &result)\n\t\n\treturn result[\"result\"].(map[string]interface{}), nil\n}\n```\n\n```javascript\nasync function getNodeInfo() {\n    const response = await fetch('http://localhost:8332', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n            jsonrpc: '2.0',\n            id: 1,\n            method: 'getblockchaininfo',\n        }),\n    });\n    const data = await response.json();\n    return data.result;\n}\n```\n:::\n\n---\n\n## Comparison\n\n| Feature | Full Node | Pruned Node | SPV Node |\n|---------|-----------|-------------|----------|\n| **Storage** | ~600GB+ | ~2GB | ~50MB |\n| **Validation** | Complete | Complete | Partial |\n| **Privacy** | Maximum | Maximum | Reduced |\n| **Sync Time** | Days | Days | Minutes |\n| **Bandwidth** | High | High | Low |\n| **Security** | Maximum | Maximum | Reduced |\n\n---\n\n## Choosing a Node Type\n\n### Use Full Node If:\n\n- You need maximum security\n- Privacy is critical\n- You're developing Bitcoin software\n- You want to contribute to network\n\n### Use Pruned Node If:\n\n- Storage is limited\n- You still want full validation\n- You don't need historical data\n\n### Use SPV Node If:\n\n- You're on mobile device\n- Storage is very limited\n- You accept reduced privacy\n- You need quick setup\n\n---\n\n## Related Topics\n\n- [Bitcoin Core Internals](/docs/development/bitcoin-core-internals) - Node implementation\n- [P2P Network Protocol](/docs/bitcoin/p2p-protocol) - Network communication\n- [Installing Bitcoin](/docs/development/install-bitcoin) - Setup guide\n\n---\n\n## Resources\n\n- [Bitcoin Core Documentation](https://bitcoincore.org/en/doc/)\n- [Running a Full Node](https://bitcoin.org/en/full-node)\n",
    "filename": "node-types.md"
  },
  "/docs/development/bitcoin-core-internals": {
    "content": "# Bitcoin Core Internals\n\nBitcoin Core is the reference implementation of Bitcoin. Understanding its internal architecture helps developers contribute to Bitcoin Core, build compatible software, and debug issues.\n\n## Architecture Overview\n\n### Core Components\n\n```text\nBitcoin Core:\nâ”œâ”€â”€ Consensus Engine\nâ”‚   â”œâ”€â”€ Validation\nâ”‚   â”œâ”€â”€ Block processing\nâ”‚   â””â”€â”€ Chain state\nâ”œâ”€â”€ Network Layer\nâ”‚   â”œâ”€â”€ P2P protocol\nâ”‚   â”œâ”€â”€ Peer management\nâ”‚   â””â”€â”€ Message handling\nâ”œâ”€â”€ Wallet System\nâ”‚   â”œâ”€â”€ Key management\nâ”‚   â”œâ”€â”€ Transaction creation\nâ”‚   â””â”€â”€ UTXO tracking\nâ””â”€â”€ RPC Interface\n    â”œâ”€â”€ JSON-RPC API\n    â”œâ”€â”€ REST API\n    â”œâ”€â”€ Command handling\n    â””â”€â”€ Response formatting\n```\n\n### Main Runtime Components\n\nAt runtime, the node coordinates several major components (names may differ across versions):\n\n| Component | Role |\n|-----------|------|\n| **ChainstateManager** | Manages one or two chainstates (e.g. normal IBD and optional [AssumeUTXO](/docs/development/node-types#assumeutxo-faster-initial-sync) snapshot). Interface for activating and validating the best chain. |\n| **BlockManager** | Keeps the tree of blocks on disk (via LevelDB index), resolves the most-work tip, and manages `blk*.dat` and `rev*.dat` files. |\n| **CTxMemPool** | Validates and stores unconfirmed [transactions](/docs/bitcoin/transaction-lifecycle) that may be included in the next [block](/docs/bitcoin/blocks). Applies fee-based prioritization and eviction. |\n| **PeerManager** | Handles [P2P](/docs/bitcoin/p2p-protocol) message processing, block and transaction fetch, and peer behavior (disconnect, misbehaviour). |\n| **CConnman** | Manages network connections: opening sockets, sending/receiving bytes, and coordinating net threads. |\n| **AddrMan** | Stores and serves peersâ€™ network addresses (from DNS seeds, peers, and config). |\n| **Interfaces::Chain** | Abstraction used by wallet and other clients to read chain state, submit transactions, get fee estimates, and receive notifications. Enables [multiprocess](https://github.com/bitcoin/bitcoin/blob/master/doc/design/multiprocess.md) (node, wallet, GUI in separate processes). |\n\n---\n\n## Key Subsystems\n\n### 1. Consensus Engine\n\nValidates transactions and blocks:\n\n```text\nResponsibilities:\n- Verify transaction validity\n- Check block validity\n- Maintain chain state\n- Enforce consensus rules\n```\n\n### 2. UTXO Set\n\nTracks unspent transaction outputs:\n\n```text\nStructure:\n- Database: LevelDB\n- Index: Transaction outputs\n- Updates: On each block\n- Size: ~5-10GB\n```\n\n### 3. Mempool\n\nManages unconfirmed transactions:\n\n```text\nFeatures:\n- Transaction storage\n- Fee-based prioritization\n- Eviction policies\n- Size limits\n```\n\n### 4. Block Storage\n\nStores blockchain data:\n\n```text\nFormats:\n- blk*.dat: Raw block data\n- rev*.dat: Undo data\n- Chainstate: UTXO set\n```\n\n---\n\n## Threading Model\n\nBitcoin Core is multi-threaded. The main `bitcoind` thread starts and shuts down the process and spawns worker threads. Key groups:\n\n**Main and init**\n\n- **Main (`bitcoind`)**: Startup, shutdown, and spawning other threads.\n- **Init/load (`b-initload`)**: Block import, reindex, loading mempool, and starting optional indexers (without blocking node startup).\n\n**Validation and RPC**\n\n- **Script check (`b-scriptch.x`)**: Parallel threads that verify [Script](/docs/bitcoin/script) in block [transactions](/docs/bitcoin/transaction-lifecycle).\n- **HTTP (`b-http`, `b-httpworker.x`)**: Listens for and serves [JSON-RPC](/docs/bitcoin/rpc) and [REST](https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md) requests.\n- **Indexers (`b-txindex`, etc.)**: One thread per optional index (txindex, blockfilterindex, coinstatsindex) for background syncing.\n- **Scheduler (`b-scheduler`)**: Background tasks (e.g. dumping wallet, addrman, validation callbacks).\n\n**Network**\n\n- **Message handler (`b-msghand`)**: Most [P2P](/docs/bitcoin/p2p-protocol) and validation logic (sending/receiving messages, block/tx handling).\n- **Socket handler (`b-net`)**: Sends and receives raw bytes on the P2P port (default 8333).\n- **Connections (`b-opencon`, `b-addcon`)**: Opens new outbound connections and connections to added nodes.\n- **DNS seed (`b-dnsseed`)**: Fetches peer addresses from DNS seeds.\n- **I2P (`b-i2paccept`)**: Accepts incoming I2P connections when I2P is enabled.\n\nUnderstanding these threads helps when debugging, profiling, or contributing to [Bitcoin Core](https://github.com/bitcoin/bitcoin). The [developer notes](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#threads) and [Bitcoin Core Academy](https://bitcoincore.academy/threads.html) describe them in more detail.\n\n---\n\n## Database Systems\n\n### LevelDB\n\nUsed for:\n\n- **Chainstate** (`chainstate/`): [UTXO set](/docs/glossary#utxo-set) and related metadata.\n- **Block index** (`blocks/index/`): Block metadata and header tree (most-work chain, orphans). Not affected by `-blocksdir`.\n- **Wallets** (`wallets/`): Each wallet is a SQLite DB; the chainstate is in LevelDB, wallet logic uses both.\n- **Optional indexes** (in `indexes/`, created only if enabled):\n  - **txindex** (`-txindex=1`): Look up [transactions](/docs/bitcoin/transaction-lifecycle) by txid.\n  - **blockfilterindex=basic**: [BIP 158](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki) compact block filters for [light clients](/docs/development/node-types#spv-simplified-payment-verification-nodes).\n  - **coinstatsindex** (`-coinstatsindex=1`): Aggregated coin statistics used by `gettxoutsetinfo` and similar.\n\n### Flat Files\n\nUsed for:\n\n- **Blocks** (`blocks/blk*.dat`): Raw block data in network format (128 MiB per file).\n- **Undo** (`blocks/rev*.dat`): Block undo data for reorganisations.\n\n### Data Directory Layout\n\nThe data directory (default: `~/.bitcoin` on Linux, `~/Library/Application Support/Bitcoin` on macOS, `%LOCALAPPDATA%\\Bitcoin` on Windows) is chain-specific. For [testnet](/docs/development/testnets), [signet](/docs/development/testnets#signet), or [regtest](/docs/development/testnets#regtest), subdirs `testnet3/`, `signet/`, or `regtest/` are used.\n\nBesides `blocks/`, `chainstate/`, and `indexes/`, important files include:\n\n- `peers.dat`: Peer address database.\n- `mempool.dat`: Mempool dump (optional, on shutdown).\n- `banlist.json`: Banned peers.\n- `debug.log`: Log output (configurable).\n- `bitcoin.conf`: User configuration (must be created manually).\n\nSee the [Bitcoin Core files documentation](https://github.com/bitcoin/bitcoin/blob/master/doc/files.md) for the full layout, wallet structure, and installed binaries.\n\n---\n\n## Binaries and Libraries\n\nBitcoin Core builds several executables:\n\n| Binary | Purpose |\n|--------|---------|\n| **bitcoind** | Headless node and built-in wallet. |\n| **bitcoin-qt** | Node and wallet with GUI. |\n| **bitcoin-cli** | [RPC](/docs/bitcoin/rpc) client (calls `bitcoind` or `bitcoin-qt`). |\n| **bitcoin-wallet** | Standalone wallet tool (create, upgrade, migrate descriptors). |\n| **bitcoin-tx** | Create and modify raw transactions. |\n| **bitcoin-util** | Utilities (e.g. chainstate, hashing). |\n\nThe consensus and validation logic can be built as **libbitcoinkernel** (shared library), so other software can link against it without running a full node process. The [multiprocess design](https://github.com/bitcoin/bitcoin/blob/master/doc/design/multiprocess.md) allows `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` to run in separate processes communicating over IPC, improving isolation and enabling use cases like running the GUI without a local node.\n\n---\n\n## Code Structure\n\n### Key Directories\n\n```text\nsrc/\nâ”œâ”€â”€ consensus/     - Consensus rules and params\nâ”œâ”€â”€ kernel/        - Libbitcoinkernel (consensus + validation core)\nâ”œâ”€â”€ node/          - Node logic (chain, mempool, init)\nâ”œâ”€â”€ net_processing/- P2P message handling and peer logic\nâ”œâ”€â”€ net/           - Network connections and transport\nâ”œâ”€â”€ wallet/        - Wallet logic\nâ”œâ”€â”€ rpc/           - JSON-RPC and REST\nâ”œâ”€â”€ script/        - Script execution\nâ”œâ”€â”€ validation/    - Block and transaction validation\nâ””â”€â”€ interfaces/    - Abstract interfaces (Chain, Node, Wallet) for multiprocess and testing\n```\n\nThe layout evolves; see the [repository](https://github.com/bitcoin/bitcoin) and [Bitcoin Core Academy â€“ Source organization](https://bitcoincore.academy/source-organization.html) for up-to-date structure.\n\n---\n\n## Related Topics\n\n- [Node Types](/docs/development/node-types) - Different node configurations\n- [RPC Commands](/docs/bitcoin/rpc) - JSON-RPC API\n- [P2P Network Protocol](/docs/bitcoin/p2p-protocol) - Network communication\n- [Installing Bitcoin](/docs/development/install-bitcoin) - Build and run Bitcoin Core\n\n---\n\n## Resources\n\n- [Bitcoin Core GitHub](https://github.com/bitcoin/bitcoin)\n- [Bitcoin Core doc/](https://github.com/bitcoin/bitcoin/tree/master/doc) â€“ Developer notes, [files.md](https://github.com/bitcoin/bitcoin/blob/master/doc/files.md) (data directory), [REST](https://github.com/bitcoin/bitcoin/blob/master/doc/REST-interface.md), [multiprocess](https://github.com/bitcoin/bitcoin/blob/master/doc/design/multiprocess.md), [assumeutxo](https://github.com/bitcoin/bitcoin/blob/master/doc/design/assumeutxo.md)\n- [Bitcoin Core Academy](https://bitcoincore.academy/) â€“ Architecture, components, threads, source organization\n- [Doxygen (doxygen.bitcoincore.org)](https://doxygen.bitcoincore.org/) â€“ Code reference\n",
    "filename": "bitcoin-core-internals.md"
  },
  "/docs/bitcoin-development": {
    "content": "# Bitcoin Development\n\nThis section covers practical Bitcoin development tasks, the building blocks you'll use when creating Bitcoin applications. These guides focus on hands-on implementation: constructing transactions, managing keys, generating addresses, working with PSBTs, monitoring the blockchain, and more.\n\n---\n\n## Core Development Tasks\n\n### [Key Management](/docs/bitcoin-development/keys)\n\nSecurely generate, store, and manage Bitcoin private keys. Learn about key derivation, encryption, and hardware wallet integration.\n\n**Key topics:**\n- Private key generation\n- Key derivation (BIP32)\n- Secure storage practices\n- Hardware wallet protocols\n\n### [Address Generation](/docs/bitcoin-development/addresses)\n\nGenerate and validate Bitcoin addresses for different address types (P2PKH, P2SH, P2WPKH, P2WSH, P2TR). Understand encoding, validation, and best practices.\n\n**Key topics:**\n- Address types and encoding\n- Bech32 and Base58 encoding\n- Address validation\n- Derivation paths\n\n### [Transaction Construction](/docs/bitcoin-development/transactions)\n\nBuild Bitcoin transactions from scratch, understanding inputs, outputs, fees, and signing. Learn the complete process from UTXO selection to broadcasting.\n\n**Key topics:**\n- Transaction structure and serialization\n- Fee calculation strategies\n- Coin selection algorithms\n- Signing and validation\n\n### [PSBT](/docs/bitcoin-development/psbt)\n\nPartially Signed Bitcoin Transactions (BIP-174) provide a standardized format for passing unsigned or partially signed transactions between different software and hardware. Essential for multi-party signing, hardware wallet integration, and air-gapped setups.\n\n**Key topics:**\n- PSBT structure and workflow\n- Creating and combining PSBTs\n- Hardware wallet integration\n- Multi-signature coordination\n\n---\n\n## Monitoring & Integration\n\n### [Blockchain Monitoring](/docs/bitcoin-development/blockchain-monitoring)\n\nMonitor the Bitcoin blockchain programmatically, track transactions, watch addresses, and respond to network events in real-time.\n\n**Key topics:**\n- Block and transaction monitoring\n- Address watching\n- Mempool tracking\n- WebSocket and API integration\n\n### [Price Tracking](/docs/bitcoin-development/price-tracking)\n\nIntegrate Bitcoin price data into your applications using various APIs and services. Track prices, historical data, and market metrics.\n\n**Key topics:**\n- Price API integration\n- Historical data retrieval\n- Real-time price feeds\n- Market data aggregation\n\n---\n\n## Advanced Topics\n\n### [Pool Mining](/docs/bitcoin-development/pool-mining)\n\nDevelop mining pool software, understand pool protocols, and build mining-related applications.\n\n**Key topics:**\n- Mining pool protocols\n- Stratum protocol\n- Share validation\n- Pool architecture\n\n### [Bitcoin Script Patterns](/docs/bitcoin-development/script-patterns)\n\nCommon Bitcoin script patterns and templates for building smart contracts and advanced spending conditions.\n\n**Key topics:**\n- Script templates\n- Common patterns (multisig, timelocks, etc.)\n- Script optimization\n- Miniscript integration\n\n### [Miniscript](/docs/bitcoin-development/miniscript)\n\nStructured policy language that compiles to Bitcoin Script. Express spending conditions in high-level policies and get correct, analyzable scripts for multisig, timelocks, vaults, and Taproot.\n\n**Key topics:**\n- Policy vs. script\n- Fragments and composition\n- Correctness and safety\n- Tapscript support\n\n---\n\n## Development Workflow\n\n### Typical Development Flow\n\n1. **Setup**: Install Bitcoin Core and configure your [development environment](/docs/development)\n2. **Keys & Addresses**: Generate keys and addresses for your application\n3. **Transaction Building**: Construct transactions using UTXOs\n4. **Signing**: Sign transactions (directly or using PSBTs)\n5. **Monitoring**: Track transactions and blockchain state\n6. **Testing**: Use [test networks](/docs/development/testnets) before mainnet\n\n### Integration Points\n\nThese development tasks integrate with:\n\n- **[Setup & Infrastructure](/docs/development)**: Setup, testing, libraries\n- **[Wallet Development](/docs/wallets)**: HD wallets, coin selection, multisig\n- **[Bitcoin Protocol](/docs/bitcoin)**: Script system, transaction structure, RPC\n- **[Mining](/docs/mining)**: Block construction, mempool, fees\n\n---\n\n## Common Patterns\n\n### Transaction Creation Pattern\n\n```python\n# 1. Select UTXOs\nutxos = select_utxos(amount_needed, fee_rate)\n\n# 2. Create transaction\ntx = create_transaction(utxos, recipient_address, amount)\n\n# 3. Sign transaction\nsigned_tx = sign_transaction(tx, private_keys)\n\n# 4. Broadcast\ntxid = broadcast_transaction(signed_tx)\n```\n\n### PSBT Workflow Pattern\n\n```python\n# 1. Create unsigned PSBT\npsbt = create_psbt(inputs, outputs)\n\n# 2. Pass to signer (hardware wallet, etc.)\nsigned_psbt = hardware_wallet.sign(psbt)\n\n# 3. Combine signatures\nfinal_psbt = combine_psbts([psbt1, psbt2, psbt3])\n\n# 4. Extract and broadcast\nfinal_tx = finalize_psbt(final_psbt)\nbroadcast(final_tx)\n```\n\n---\n\n## Best Practices\n\n### Security\n\n- **Never hardcode keys**: Use secure storage and environment variables\n- **Validate all inputs**: Especially addresses and amounts\n- **Use established libraries**: Don't roll your own cryptographic code\n- **Test thoroughly**: Always test on testnet/signet before mainnet\n\n### Transaction Construction\n\n- **Calculate fees properly**: Too low = stuck, too high = waste\n- **Handle dust outputs**: Outputs below ~546 sats may be unspendable\n- **Verify before broadcasting**: Double-check all transaction details\n- **Use PSBT for complex scenarios**: Multi-party or hardware wallet signing\n\n### Monitoring\n\n- **Handle reorgs**: Transactions can be reversed until deeply confirmed\n- **Wait for confirmations**: 6 blocks for high-value transactions\n- **Don't trust unconfirmed**: Zero-conf can be double-spent\n- **Monitor mempool**: Track transaction propagation and fee rates\n\n---\n\n## Related Topics\n\n- [Setup & Infrastructure](/docs/development) - Setup, testing, libraries, node architecture\n- [Wallet Development](/docs/wallets) - HD wallets, coin selection, multisig\n- [Bitcoin Protocol](/docs/bitcoin) - Script system, RPC, transaction structure\n- [UTXO Model](/docs/fundamentals/utxos) - Understanding UTXOs for transaction building\n\n---\n\n## Resources\n\n- [Bitcoin Developer Reference](https://developer.bitcoin.org/) - Official documentation\n- [BIPs](https://github.com/bitcoin/bips) - Bitcoin Improvement Proposals\n- [Bitcoin Optech](https://bitcoinops.org/) - Technical newsletter and guides\n- [Bitcoin Stack Exchange](https://bitcoin.stackexchange.com/) - Q&A community\n",
    "filename": "overview.md"
  },
  "/docs/bitcoin-development/keys": {
    "content": "# Key Management & Security\n\nSecure key management is the foundation of Bitcoin security. This guide covers [HD wallets](/docs/glossary#hd-wallet-hierarchical-deterministic-wallet), [seed phrases](/docs/glossary#seed-phrase), derivation paths, and best practices for handling private keys.\n\n## HD Wallets (BIP32)\n\nHierarchical Deterministic (HD) wallets generate an entire tree of keys from a single seed. This enables:\n\n- **Backup Simplicity**: One seed backs up all keys\n- **Key Organization**: Structured derivation paths\n- **Privacy**: Fresh addresses without new backups\n- **Watch-Only Wallets**: Share xpubs without exposing keys\n\n### Key Derivation\n\n```\nMaster Seed\n    â””â”€â”€ Master Key (m)\n        â”œâ”€â”€ Account 0 (m/44'/0'/0')\n        â”‚   â”œâ”€â”€ External Chain (m/44'/0'/0'/0)\n        â”‚   â”‚   â”œâ”€â”€ Address 0 (m/44'/0'/0'/0/0)\n        â”‚   â”‚   â”œâ”€â”€ Address 1 (m/44'/0'/0'/0/1)\n        â”‚   â”‚   â””â”€â”€ ...\n        â”‚   â””â”€â”€ Internal Chain (m/44'/0'/0'/1)\n        â”‚       â”œâ”€â”€ Change 0 (m/44'/0'/0'/1/0)\n        â”‚       â””â”€â”€ ...\n        â””â”€â”€ Account 1 (m/44'/0'/1')\n            â””â”€â”€ ...\n```\n\n### HD Wallet Implementation\n\n:::code-group\n```rust\nuse bitcoin::bip32::{Xpriv, DerivationPath};\nuse bitcoin::secp256k1::Secp256k1;\n\nfn derive_key(seed: &[u8]) -> Xpriv {\n    let secp = Secp256k1::new();\n    let master = Xpriv::new_master(bitcoin::Network::Bitcoin, seed).unwrap();\n    let path = DerivationPath::from_str(\"m/84'/0'/0'/0/0\").unwrap();\n    master.derive_priv(&secp, &path).unwrap()\n}\n```\n\n```python\nfrom mnemonic import Mnemonic\nfrom bip32utils import BIP32Key\n\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)  # 24 words\nseed = mnemo.to_seed(words)\nmaster = BIP32Key.fromSeed(seed)\n# Derive m/84'/0'/0'/0/0\nkey = master.ChildKey(84 + 0x80000000).ChildKey(0x80000000).ChildKey(0x80000000).ChildKey(0).ChildKey(0)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::wallet::hd_private derive_key(const bc::data_chunk& seed) {\n    bc::wallet::hd_private master(seed);\n    return master.derive_private(84 + bc::wallet::hd_first_hardened_key)\n                 .derive_private(bc::wallet::hd_first_hardened_key)\n                 .derive_private(bc::wallet::hd_first_hardened_key)\n                 .derive_private(0).derive_private(0);\n}\n```\n\n```javascript\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nconst mnemonic = bip39.generateMnemonic(256);\nconst seed = await bip39.mnemonicToSeed(mnemonic);\nconst root = bip32.fromSeed(seed);\nconst child = root.derivePath(\"m/84'/0'/0'/0/0\");\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tyler-smith/go-bip32\"\n\t\"github.com/tyler-smith/go-bip39\"\n)\n\nfunc deriveKey(seed []byte) (*bip32.Key, error) {\n\tmaster, err := bip32.NewMasterKey(seed)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Derive m/84'/0'/0'/0/0\n\tchild, err := master.NewChildKey(bip32.FirstHardenedChild + 84)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchild, err = child.NewChildKey(bip32.FirstHardenedChild + 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchild, err = child.NewChildKey(bip32.FirstHardenedChild + 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchild, err = child.NewChildKey(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchild, err = child.NewChildKey(0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\treturn child, nil\n}\n\nfunc main() {\n\tmnemonic, _ := bip39.NewMnemonic(bip39.NewEntropy(256))\n\tseed, _ := bip39.NewSeedWithErrorChecking(mnemonic, \"\")\n\t\n\tkey, err := deriveKey(seed)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\n\tfmt.Printf(\"Derived key: %x\\n\", key.Key)\n}\n```\n:::\n\n---\n\n## Seed Phrases (BIP39)\n\n### Mnemonic Generation and Validation\n\n:::code-group\n```rust\nuse bip39::{Mnemonic, Language};\n\nlet mnemonic = Mnemonic::generate_in(Language::English, 24);\nlet is_valid = Mnemonic::parse(&mnemonic.to_string()).is_ok();\nlet seed = mnemonic.to_seed(\"optional_passphrase\");\n```\n\n```python\nfrom mnemonic import Mnemonic\n\nmnemo = Mnemonic(\"english\")\nwords = mnemo.generate(256)  # 24 words\nis_valid = mnemo.check(words)\nseed = mnemo.to_seed(words, passphrase=\"optional\")\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nauto entropy = bc::data_chunk(32);\nbc::pseudo_random_fill(entropy);\nauto words = bc::wallet::create_mnemonic(entropy);\nbool is_valid = bc::wallet::validate_mnemonic(words);\nauto seed = bc::wallet::decode_mnemonic(words);\n```\n\n```javascript\nimport * as bip39 from 'bip39';\n\nconst mnemonic = bip39.generateMnemonic(256);\nconst isValid = bip39.validateMnemonic(mnemonic);\nconst seed = await bip39.mnemonicToSeed(mnemonic, 'optional_passphrase');\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tyler-smith/go-bip39\"\n)\n\nfunc main() {\n\t// Generate mnemonic (128=12 words, 256=24 words)\n\tentropy, err := bip39.NewEntropy(256)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\n\tmnemonic, err := bip39.NewMnemonic(entropy)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\n\t// Validate mnemonic\n\tisValid := bip39.IsMnemonicValid(mnemonic)\n\t\n\t// Convert to seed with optional passphrase\n\tseed, err := bip39.NewSeedWithErrorChecking(mnemonic, \"optional_passphrase\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t\n\tfmt.Printf(\"Mnemonic: %s\\n\", mnemonic)\n\tfmt.Printf(\"Valid: %v\\n\", isValid)\n\tfmt.Printf(\"Seed: %x\\n\", seed)\n}\n```\n:::\n\n### Security Considerations\n\n```typescript\n// NEVER do this\nconst badMnemonic = \"abandon \".repeat(12).trim(); // Predictable!\n\n// ALWAYS use cryptographically secure random\nimport { randomBytes } from 'crypto';\nconst entropy = randomBytes(32); // 256 bits\nconst secureMnemonic = bip39.entropyToMnemonic(entropy);\n```\n\n---\n\n## Derivation Paths\n\n### Standard Paths (BIPs)\n\n| BIP | Path | Purpose | Address Type |\n|-----|------|---------|--------------|\n| BIP44 | m/44'/0'/0' | Legacy | P2PKH (1...) |\n| BIP49 | m/49'/0'/0' | Nested SegWit | P2SH-P2WPKH (3...) |\n| BIP84 | m/84'/0'/0' | Native SegWit | P2WPKH (bc1q...) |\n| BIP86 | m/86'/0'/0' | Taproot | P2TR (bc1p...) |\n\n### Path Components\n\n```\nm / purpose' / coin_type' / account' / change / address_index\n\nm           - Master key\npurpose'    - BIP number (44, 49, 84, 86)\ncoin_type'  - 0 for Bitcoin, 1 for testnet\naccount'    - Account number (0, 1, 2...)\nchange      - 0 for receiving, 1 for change\naddress_index - Sequential index (0, 1, 2...)\n\n' = hardened derivation\n```\n\n### Deriving Multiple Address Types\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction deriveAllAddressTypes(root: BIP32Interface) {\n  const network = bitcoin.networks.bitcoin;\n  \n  // BIP44 - Legacy\n  const bip44 = root.derivePath(\"m/44'/0'/0'/0/0\");\n  const p2pkh = bitcoin.payments.p2pkh({ \n    pubkey: bip44.publicKey, \n    network \n  });\n  \n  // BIP49 - Nested SegWit\n  const bip49 = root.derivePath(\"m/49'/0'/0'/0/0\");\n  const p2shp2wpkh = bitcoin.payments.p2sh({\n    redeem: bitcoin.payments.p2wpkh({ \n      pubkey: bip49.publicKey, \n      network \n    }),\n    network\n  });\n  \n  // BIP84 - Native SegWit\n  const bip84 = root.derivePath(\"m/84'/0'/0'/0/0\");\n  const p2wpkh = bitcoin.payments.p2wpkh({ \n    pubkey: bip84.publicKey, \n    network \n  });\n  \n  // BIP86 - Taproot\n  const bip86 = root.derivePath(\"m/86'/0'/0'/0/0\");\n  const p2tr = bitcoin.payments.p2tr({\n    internalPubkey: bip86.publicKey.slice(1, 33),\n    network\n  });\n  \n  return {\n    legacy: p2pkh.address,\n    nestedSegwit: p2shp2wpkh.address,\n    nativeSegwit: p2wpkh.address,\n    taproot: p2tr.address\n  };\n}\n```\n\n---\n\n## Extended Keys (xpub/xprv)\n\n### Exporting Extended Keys\n\n```typescript\n// Export extended private key (KEEP SECRET!)\nconst xprv = root.toBase58();\n// xprv9s21ZrQH143K...\n\n// Export extended public key (safe to share for watch-only)\nconst xpub = root.neutered().toBase58();\n// xpub661MyMwAqRbc...\n```\n\n### Version Bytes\n\n| Prefix | Network | Key Type | Address Type |\n|--------|---------|----------|--------------|\n| xpub/xprv | Mainnet | Standard | P2PKH |\n| ypub/yprv | Mainnet | BIP49 | P2SH-P2WPKH |\n| zpub/zprv | Mainnet | BIP84 | P2WPKH |\n| tpub/tprv | Testnet | Standard | Any |\n\n### Converting Between Formats\n\n```typescript\nimport bs58check from 'bs58check';\n\nfunction convertXpubToZpub(xpub: string): string {\n  const data = bs58check.decode(xpub);\n  // Replace version bytes (first 4 bytes)\n  // xpub: 0x0488B21E -> zpub: 0x04B24746\n  const zpubVersion = Buffer.from([0x04, 0xB2, 0x47, 0x46]);\n  const converted = Buffer.concat([zpubVersion, data.slice(4)]);\n  return bs58check.encode(converted);\n}\n```\n\n---\n\n## Secure Key Storage\n\n### In-Memory Security\n\n```typescript\nimport { randomBytes } from 'crypto';\n\nclass SecureKeyStore {\n  private encryptedKey: Buffer | null = null;\n  private iv: Buffer | null = null;\n  \n  async store(privateKey: Buffer, password: string): Promise<void> {\n    const crypto = await import('crypto');\n    \n    // Derive encryption key from password\n    const salt = randomBytes(16);\n    const key = crypto.scryptSync(password, salt, 32);\n    \n    // Encrypt private key\n    this.iv = randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-256-gcm', key, this.iv);\n    \n    this.encryptedKey = Buffer.concat([\n      salt,\n      cipher.update(privateKey),\n      cipher.final(),\n      cipher.getAuthTag()\n    ]);\n    \n    // Clear original from memory\n    privateKey.fill(0);\n  }\n  \n  async retrieve(password: string): Promise<Buffer> {\n    if (!this.encryptedKey || !this.iv) {\n      throw new Error('No key stored');\n    }\n    \n    const crypto = await import('crypto');\n    const salt = this.encryptedKey.slice(0, 16);\n    const key = crypto.scryptSync(password, salt, 32);\n    \n    const authTag = this.encryptedKey.slice(-16);\n    const encrypted = this.encryptedKey.slice(16, -16);\n    \n    const decipher = crypto.createDecipheriv('aes-256-gcm', key, this.iv);\n    decipher.setAuthTag(authTag);\n    \n    return Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final()\n    ]);\n  }\n  \n  clear(): void {\n    if (this.encryptedKey) {\n      this.encryptedKey.fill(0);\n      this.encryptedKey = null;\n    }\n    if (this.iv) {\n      this.iv.fill(0);\n      this.iv = null;\n    }\n  }\n}\n```\n\n### Hardware Wallet Integration\n\n```typescript\n// Example: Ledger integration concept\ninterface HardwareWallet {\n  getPublicKey(path: string): Promise<Buffer>;\n  signTransaction(path: string, txHash: Buffer): Promise<Buffer>;\n}\n\nclass LedgerWallet implements HardwareWallet {\n  async getPublicKey(path: string): Promise<Buffer> {\n    // Connect to Ledger and get public key\n    // Private key never leaves device\n    const transport = await TransportWebUSB.create();\n    const btc = new AppBtc({ transport });\n    const result = await btc.getWalletPublicKey(path);\n    return Buffer.from(result.publicKey, 'hex');\n  }\n  \n  async signTransaction(path: string, txHash: Buffer): Promise<Buffer> {\n    // Sign on device - private key stays secure\n    const transport = await TransportWebUSB.create();\n    const btc = new AppBtc({ transport });\n    // ... signing logic\n    return signature;\n  }\n}\n```\n\n---\n\n## Multi-Signature Setup\n\n### Creating Multisig Wallet\n\n```typescript\nimport * as bitcoin from 'bitcoinjs-lib';\n\ninterface MultisigConfig {\n  m: number;  // Required signatures\n  n: number;  // Total keys\n  pubkeys: Buffer[];\n}\n\nfunction createMultisigWallet(config: MultisigConfig) {\n  const { m, pubkeys } = config;\n  \n  // Sort pubkeys (BIP67)\n  const sortedPubkeys = [...pubkeys].sort((a, b) => a.compare(b));\n  \n  // Create P2WSH multisig\n  const multisig = bitcoin.payments.p2ms({\n    m: m,\n    pubkeys: sortedPubkeys,\n  });\n  \n  const p2wsh = bitcoin.payments.p2wsh({\n    redeem: multisig,\n  });\n  \n  return {\n    address: p2wsh.address,\n    redeemScript: multisig.output,\n    witnessScript: p2wsh.redeem?.output,\n  };\n}\n\n// Example: 2-of-3 multisig\nconst wallet = createMultisigWallet({\n  m: 2,\n  n: 3,\n  pubkeys: [pubkey1, pubkey2, pubkey3],\n});\n```\n\n### Multisig Key Distribution\n\n```\nRecommended 2-of-3 Setup:\n\nKey 1: Personal device (phone/computer)\nKey 2: Hardware wallet (Coldcard, Ledger, etc.)\nKey 3: Secure backup (safety deposit box, trusted party)\n\nBenefits:\n- Lose one key? Still have access\n- One key compromised? Funds still safe\n- No single point of failure\n```\n\n---\n\n## Backup Strategies\n\n### Seed Phrase Backup\n\n```\nDO:\nâœ“ Write on paper/metal (fire/water resistant)\nâœ“ Store in multiple secure locations\nâœ“ Consider splitting (e.g., 2-of-3 Shamir)\nâœ“ Test recovery before storing funds\n\nDON'T:\nâœ— Store digitally (photos, cloud, email)\nâœ— Share with anyone\nâœ— Store all copies in one location\nâœ— Use brain wallet (memorized passphrase only)\n```\n\n### Shamir's Secret Sharing\n\n```typescript\nimport * as secrets from 'secrets.js-grempe';\n\nfunction splitSeed(seed: string, shares: number, threshold: number): string[] {\n  // Convert seed to hex\n  const seedHex = Buffer.from(seed).toString('hex');\n  \n  // Split into shares\n  const shareArray = secrets.share(seedHex, shares, threshold);\n  \n  return shareArray;\n}\n\nfunction recoverSeed(shares: string[]): string {\n  // Combine shares\n  const seedHex = secrets.combine(shares);\n  \n  return Buffer.from(seedHex, 'hex').toString();\n}\n\n// Example: 2-of-3 split\nconst shares = splitSeed(mnemonic, 3, 2);\n// Give shares[0] to location A\n// Give shares[1] to location B  \n// Give shares[2] to location C\n// Any 2 shares can recover the seed\n```\n\n---\n\n## Security Best Practices\n\n### Key Generation\n\n```typescript\n// SECURE: Use crypto.getRandomValues or crypto.randomBytes\nimport { randomBytes } from 'crypto';\nconst entropy = randomBytes(32);\n\n// INSECURE: Never use Math.random()\nconst badEntropy = Math.random(); // NEVER DO THIS\n\n// INSECURE: Never use predictable data\nconst predictable = Date.now(); // NEVER DO THIS\n```\n\n### Memory Handling\n\n```typescript\nfunction secureSign(privateKey: Buffer, message: Buffer): Buffer {\n  try {\n    // Sign the message\n    const signature = secp256k1.sign(message, privateKey);\n    return signature;\n  } finally {\n    // Always clear sensitive data\n    privateKey.fill(0);\n  }\n}\n```\n\n### Environment Security\n\n```typescript\n// Check for common security issues\nfunction securityCheck(): string[] {\n  const warnings: string[] = [];\n  \n  // Check if running in browser\n  if (typeof window !== 'undefined') {\n    warnings.push('Browser environment - keys may be exposed to extensions');\n  }\n  \n  // Check for debugger\n  if (typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {\n    warnings.push('Development mode - ensure production security');\n  }\n  \n  return warnings;\n}\n```\n\n---\n\n## Recovery Procedures\n\n### From Mnemonic\n\n```typescript\nasync function recoverWallet(mnemonic: string, passphrase = ''): Promise<WalletData> {\n  // Validate mnemonic\n  if (!bip39.validateMnemonic(mnemonic)) {\n    throw new Error('Invalid mnemonic');\n  }\n  \n  // Generate seed\n  const seed = await bip39.mnemonicToSeed(mnemonic, passphrase);\n  const root = bip32.fromSeed(seed);\n  \n  // Derive standard paths\n  const addresses = {\n    bip44: deriveAddresses(root, \"m/44'/0'/0'\"),\n    bip49: deriveAddresses(root, \"m/49'/0'/0'\"),\n    bip84: deriveAddresses(root, \"m/84'/0'/0'\"),\n    bip86: deriveAddresses(root, \"m/86'/0'/0'\"),\n  };\n  \n  return { root, addresses };\n}\n\nfunction deriveAddresses(root: BIP32Interface, basePath: string, count = 20) {\n  const addresses = [];\n  for (let i = 0; i < count; i++) {\n    const child = root.derivePath(`${basePath}/0/${i}`);\n    addresses.push(deriveAddress(child));\n  }\n  return addresses;\n}\n```\n\n### Gap Limit Scanning\n\n```typescript\nasync function scanForUsedAddresses(\n  xpub: string,\n  gapLimit = 20\n): Promise<string[]> {\n  const root = bip32.fromBase58(xpub);\n  const usedAddresses: string[] = [];\n  let consecutiveUnused = 0;\n  let index = 0;\n  \n  while (consecutiveUnused < gapLimit) {\n    const child = root.derivePath(`0/${index}`);\n    const address = deriveAddress(child);\n    \n    const hasHistory = await checkAddressHistory(address);\n    \n    if (hasHistory) {\n      usedAddresses.push(address);\n      consecutiveUnused = 0;\n    } else {\n      consecutiveUnused++;\n    }\n    \n    index++;\n  }\n  \n  return usedAddresses;\n}\n```\n\n---\n\n## Summary\n\nSecure key management requires:\n\n- **HD Wallets**: Use BIP32/39/44/49/84/86 standards\n- **Secure Generation**: Cryptographically secure randomness\n- **Proper Storage**: Encrypted storage, hardware wallets\n- **Backup Strategy**: Multiple secure backups\n- **Recovery Testing**: Test recovery before storing significant funds\n\nNever expose private keys, use hardware wallets for significant amounts, and always have tested backup procedures.\n\n---\n\n## Related Topics\n\n- [Address Generation](/docs/bitcoin-development/addresses) - Creating addresses from keys\n- [HD Wallets](/docs/wallets/hd-wallets) - Hierarchical deterministic wallet concepts\n- [Multisig](/docs/wallets/multisig) - Multi-signature security setups\n- [Cryptography](/docs/bitcoin/cryptography) - Underlying cryptographic primitives\n",
    "filename": "keys.md"
  },
  "/docs/bitcoin-development/addresses": {
    "content": "# Address Generation & Validation\n\nBitcoin addresses are human-readable encodings of output scripts. Understanding how to generate, validate, and work with different address types is fundamental to Bitcoin development.\n\n## Address Types Overview\n\n### Legacy Addresses (P2PKH)\n\n**Format**: Starts with `1` (mainnet) or `m`/`n` (testnet)\n\n```\n1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\n```\n\n**Script**: Pay-to-Public-Key-Hash\n```\nOP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG\n```\n\n### Script Hash Addresses (P2SH)\n\n**Format**: Starts with `3` (mainnet) or `2` (testnet)\n\n```\n3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy\n```\n\n**Script**: Pay-to-Script-Hash (can contain any script)\n```\nOP_HASH160 <script_hash> OP_EQUAL\n```\n\n### Native SegWit (P2WPKH)\n\n**Format**: Starts with `bc1q` (mainnet) or `tb1q` (testnet)\n\n```\nbc1qar0srrr7xfkvy5l643lydnw9re59gtzzwf5mdq\n```\n\n**Script**: Pay-to-Witness-Public-Key-Hash\n```\nOP_0 <20-byte-pubkey-hash>\n```\n\n### Native SegWit Script (P2WSH)\n\n**Format**: Starts with `bc1q` but longer (mainnet)\n\n```\nbc1qrp33g0q5c5txsp9arysrx4k6zdkfs4nce4xj0gdcccefvpysxf3qccfmv3\n```\n\n**Script**: Pay-to-Witness-Script-Hash\n```\nOP_0 <32-byte-script-hash>\n```\n\n### Taproot (P2TR)\n\n**Format**: Starts with `bc1p` (mainnet) or `tb1p` (testnet)\n\n```\nbc1p5d7rjq7g6rdk2yhzks9smlaqtedr4dekq08ge8ztwac72sfr9rusxg3297\n```\n\n**Script**: Pay-to-Taproot\n```\nOP_1 <32-byte-x-only-pubkey>\n```\n\n---\n\n## Address Comparison\n\n| Type | Prefix | Size | Encoding | Fee Efficiency |\n|------|--------|------|----------|----------------|\n| P2PKH | 1 | 25 bytes | Base58Check | Lowest |\n| P2SH | 3 | 23 bytes | Base58Check | Low |\n| P2WPKH | bc1q | 22 bytes | Bech32 | High |\n| P2WSH | bc1q | 34 bytes | Bech32 | Medium |\n| P2TR | bc1p | 34 bytes | Bech32m | Highest |\n\n---\n\n## Generating Addresses\n\n### From Public Key to P2WPKH (Native SegWit)\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network, PublicKey, CompressedPublicKey};\nuse bitcoin::secp256k1::{Secp256k1, SecretKey};\n\nfn generate_address(secret_key: &SecretKey) -> Address {\n    let secp = Secp256k1::new();\n    let public_key = PublicKey::from_private_key(&secp, &secret_key.into());\n    let compressed = CompressedPublicKey::try_from(public_key).unwrap();\n    Address::p2wpkh(&compressed, Network::Bitcoin)\n}\n```\n\n```python\nimport hashlib\nimport bech32\n\ndef pubkey_to_p2wpkh(pubkey_bytes, mainnet=True):\n    sha256_hash = hashlib.sha256(pubkey_bytes).digest()\n    ripemd160 = hashlib.new('ripemd160')\n    ripemd160.update(sha256_hash)\n    pubkey_hash = ripemd160.digest()\n    \n    hrp = 'bc' if mainnet else 'tb'\n    converted = bech32.convertbits(pubkey_hash, 8, 5)\n    return bech32.bech32_encode(hrp, [0] + converted)\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::wallet::payment_address generate_address(const bc::ec_secret& secret) {\n    bc::ec_compressed pubkey;\n    bc::secret_to_public(pubkey, secret);\n    return bc::wallet::payment_address(\n        bc::wallet::ec_public(pubkey), \n        bc::wallet::payment_address::mainnet_p2wpkh\n    );\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst p2wpkh = bitcoin.payments.p2wpkh({ \n  pubkey: publicKey,\n  network: bitcoin.networks.bitcoin \n});\nconsole.log(p2wpkh.address); // bc1q...\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc pubkeyToP2WPKH(pubkeyBytes []byte, mainnet bool) (string, error) {\n\tpubkey, err := btcec.ParsePubKey(pubkeyBytes)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tpubkeyHash := btcutil.Hash160(pubkey.SerializeCompressed())\n\t\n\tparams := &chaincfg.MainNetParams\n\tif !mainnet {\n\t\tparams = &chaincfg.TestNet3Params\n\t}\n\n\taddr, err := btcutil.NewAddressWitnessPubKeyHash(pubkeyHash, params)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn addr.EncodeAddress(), nil\n}\n\nfunc main() {\n\t// Example usage\n\tpubkey, _ := btcec.NewPrivateKey()\n\tpubkeyBytes := pubkey.PubKey().SerializeCompressed()\n\t\n\taddr, _ := pubkeyToP2WPKH(pubkeyBytes, true)\n\tfmt.Println(addr) // bc1q...\n}\n```\n:::\n\n---\n\n## Validating Addresses\n\n:::code-group\n```rust\nuse bitcoin::{Address, Network};\nuse std::str::FromStr;\n\nfn validate_address(addr_str: &str) -> Result<String, String> {\n    match Address::from_str(addr_str) {\n        Ok(addr) => Ok(match addr.address_type() {\n            Some(bitcoin::AddressType::P2pkh) => \"P2PKH\",\n            Some(bitcoin::AddressType::P2wpkh) => \"P2WPKH\",\n            Some(bitcoin::AddressType::P2tr) => \"P2TR\",\n            _ => \"Other\",\n        }.to_string()),\n        Err(e) => Err(format!(\"Invalid: {}\", e))\n    }\n}\n```\n\n```python\nimport hashlib, base58, bech32\n\ndef validate_address(address):\n    if address.startswith('bc1') or address.startswith('tb1'):\n        hrp, data = bech32.bech32_decode(address)\n        if hrp: return True, \"P2WPKH\" if len(data) == 21 else \"P2WSH\"\n        hrp, data = bech32.bech32m_decode(address)\n        if hrp: return True, \"P2TR\"\n    else:\n        try:\n            decoded = base58.b58decode_check(address)\n            return True, \"P2PKH\" if decoded[0] == 0 else \"P2SH\"\n        except: pass\n    return False, \"Invalid\"\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbool validate_address(const std::string& address) {\n    bc::wallet::payment_address addr(address);\n    return addr.is_valid();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction validateAddress(address, network = bitcoin.networks.bitcoin) {\n  try {\n    bitcoin.address.toOutputScript(address, network);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n)\n\nfunc validateAddress(address string) (bool, string) {\n\taddr, err := btcutil.DecodeAddress(address, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\t// Try testnet\n\t\taddr, err = btcutil.DecodeAddress(address, &chaincfg.TestNet3Params)\n\t\tif err != nil {\n\t\t\treturn false, \"Invalid\"\n\t\t}\n\t}\n\n\tswitch addr.(type) {\n\tcase *btcutil.AddressPubKeyHash:\n\t\treturn true, \"P2PKH\"\n\tcase *btcutil.AddressScriptHash:\n\t\treturn true, \"P2SH\"\n\tcase *btcutil.AddressWitnessPubKeyHash:\n\t\treturn true, \"P2WPKH\"\n\tcase *btcutil.AddressWitnessScriptHash:\n\t\treturn true, \"P2WSH\"\n\tcase *btcutil.AddressTaproot:\n\t\treturn true, \"P2TR\"\n\tdefault:\n\t\treturn true, \"Other\"\n\t}\n}\n\nfunc main() {\n\tvalid, addrType := validateAddress(\"1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2\")\n\tfmt.Printf(\"Valid: %v, Type: %s\\n\", valid, addrType)\n}\n```\n:::\n\n---\n\n## Bech32 Encoding Details\n\n### Bech32 vs Bech32m\n\n```\nBech32 (BIP-173):\n- Used for SegWit v0 (P2WPKH, P2WSH)\n- Checksum constant: 1\n\nBech32m (BIP-350):\n- Used for SegWit v1+ (Taproot)\n- Checksum constant: 0x2bc830a3\n```\n\n### Why Bech32m?\n\nBech32 had a weakness where certain error patterns could go undetected. Bech32m fixes this for future witness versions.\n\n---\n\n## From Script to Address\n\n:::code-group\n```rust\nuse bitcoin::{Address, Script, Network};\n\nfn script_to_address(script: &Script) -> Option<Address> {\n    Address::from_script(script, Network::Bitcoin).ok()\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript\nfrom bitcoin.wallet import CBitcoinAddress\n\ndef script_to_address(script):\n    return str(CBitcoinAddress.from_scriptPubKey(script))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string script_to_address(const bc::chain::script& script) {\n    return bc::wallet::payment_address(script).encoded();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction scriptToAddress(script, network = bitcoin.networks.bitcoin) {\n  return bitcoin.address.fromOutputScript(script, network);\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc scriptToAddress(script []byte) (string, error) {\n\taddr, err := btcutil.NewAddressScriptHash(script, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn addr.EncodeAddress(), nil\n}\n\nfunc main() {\n\t// Example: Convert a script to address\n\tscript, _ := txscript.NewScriptBuilder().\n\t\tAddOp(txscript.OP_DUP).\n\t\tAddOp(txscript.OP_HASH160).\n\t\tAddData([]byte(\"example_pubkey_hash\")).\n\t\tAddOp(txscript.OP_EQUALVERIFY).\n\t\tAddOp(txscript.OP_CHECKSIG).\n\t\tScript()\n\n\taddr, _ := scriptToAddress(script)\n\tfmt.Println(addr)\n}\n```\n:::\n\n---\n\n## Address Derivation Paths\n\n### BIP Standards\n\n| BIP | Path | Address Type | Example |\n|-----|------|--------------|---------|\n| BIP44 | m/44'/0'/0' | P2PKH | 1... |\n| BIP49 | m/49'/0'/0' | P2SH-P2WPKH | 3... |\n| BIP84 | m/84'/0'/0' | P2WPKH | bc1q... |\n| BIP86 | m/86'/0'/0' | P2TR | bc1p... |\n\n### Deriving Addresses from Seed\n\n:::code-group\n```rust\nuse bdk::keys::bip39::Mnemonic;\nuse bitcoin::bip32::{Xpriv, DerivationPath};\n\nfn derive_address(mnemonic: &str) -> Address {\n    let mnemonic = Mnemonic::parse(mnemonic).unwrap();\n    let seed = mnemonic.to_seed(\"\");\n    let master = Xpriv::new_master(Network::Bitcoin, &seed).unwrap();\n    let path = DerivationPath::from_str(\"m/84'/0'/0'/0/0\").unwrap();\n    let derived = master.derive_priv(&secp, &path).unwrap();\n    // Convert to address...\n}\n```\n\n```python\nfrom mnemonic import Mnemonic\nfrom bip32utils import BIP32Key\n\ndef derive_address(words):\n    seed = Mnemonic(\"english\").to_seed(words)\n    master = BIP32Key.fromEntropy(seed)\n    # Derive m/84'/0'/0'/0/0\n    key = master.ChildKey(84 + 0x80000000).ChildKey(0x80000000).ChildKey(0x80000000).ChildKey(0).ChildKey(0)\n    return key.Address()\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string derive_address(const std::string& mnemonic) {\n    auto seed = bc::wallet::decode_mnemonic(bc::split(mnemonic));\n    bc::wallet::hd_private master(seed);\n    auto derived = master.derive_private(84 + bc::wallet::hd_first_hardened_key)\n                        .derive_private(bc::wallet::hd_first_hardened_key)\n                        .derive_private(bc::wallet::hd_first_hardened_key)\n                        .derive_private(0).derive_private(0);\n    return bc::wallet::payment_address(derived).encoded();\n}\n```\n\n```javascript\nimport { BIP32Factory } from 'bip32';\nimport * as bip39 from 'bip39';\n\nasync function deriveAddress(mnemonic) {\n  const seed = await bip39.mnemonicToSeed(mnemonic);\n  const root = bip32.fromSeed(seed);\n  const child = root.derivePath(\"m/84'/0'/0'/0/0\");\n  return bitcoin.payments.p2wpkh({ pubkey: child.publicKey }).address;\n}\n```\n:::\n\n---\n\n## Multi-Signature Addresses\n\n### Creating 2-of-3 Multisig\n\n:::code-group\n```rust\nuse bitcoin::{PublicKey, Script, Address};\nuse bitcoin::blockdata::script::Builder;\n\nfn create_multisig(m: usize, pubkeys: &[PublicKey]) -> Address {\n    let script = Builder::new()\n        .push_int(m as i64)\n        .push_keys(pubkeys)\n        .push_int(pubkeys.len() as i64)\n        .push_opcode(opcodes::all::OP_CHECKMULTISIG)\n        .into_script();\n    Address::p2wsh(&script, Network::Bitcoin)\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_2, OP_3, OP_CHECKMULTISIG\nfrom bitcoin.wallet import P2SHBitcoinAddress\n\ndef create_multisig(m, pubkeys):\n    script = CScript([m] + pubkeys + [len(pubkeys), OP_CHECKMULTISIG])\n    return str(P2SHBitcoinAddress.from_redeemScript(script))\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nstd::string create_multisig(uint8_t m, const std::vector<bc::ec_compressed>& pubkeys) {\n    bc::chain::script script = bc::chain::script::to_pay_multisig_pattern(m, pubkeys);\n    return bc::wallet::payment_address(script).encoded();\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction createMultisig(m, pubkeys) {\n  const multisig = bitcoin.payments.p2ms({ m, pubkeys });\n  const p2wsh = bitcoin.payments.p2wsh({ redeem: multisig });\n  return p2wsh.address; // bc1q... (P2WSH)\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcec/v2\"\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createMultisig(m int, pubkeys [][]byte) (string, error) {\n\t// Create multisig script\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddInt64(int64(m))\n\tfor _, pubkey := range pubkeys {\n\t\tbuilder.AddData(pubkey)\n\t}\n\tbuilder.AddInt64(int64(len(pubkeys)))\n\tbuilder.AddOp(txscript.OP_CHECKMULTISIG)\n\tscript, err := builder.Script()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create P2WSH address\n\tscriptHash := btcutil.Hash160(script)\n\taddr, err := btcutil.NewAddressWitnessScriptHash(scriptHash, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn addr.EncodeAddress(), nil\n}\n\nfunc main() {\n\t// Example: 2-of-3 multisig\n\tpubkeys := make([][]byte, 3)\n\tfor i := 0; i < 3; i++ {\n\t\tprivkey, _ := btcec.NewPrivateKey()\n\t\tpubkeys[i] = privkey.PubKey().SerializeCompressed()\n\t}\n\n\taddr, _ := createMultisig(2, pubkeys)\n\tfmt.Println(addr) // bc1q... (P2WSH)\n}\n```\n:::\n\n---\n\n## Common Mistakes\n\n### Address Validation Pitfalls\n\n- **BAD**: Only checking prefix (`address.startsWith('bc1')`)\n- **GOOD**: Full validation with checksum verification using library functions\n\n### Network Mismatch\n\nAlways use consistent network parameters. Never mix mainnet keys with testnet addresses.\n\n### Checksum Errors\n\nAlways validate checksums before using an address - all libraries provide validation functions.\n\n---\n\n## Best Practices\n\n### Address Generation\n\n1. **Use Established Libraries**: Don't implement encoding yourself\n2. **Validate After Generation**: Always verify the generated address\n3. **Use Appropriate Types**: Prefer SegWit/Taproot for lower fees\n4. **Test on Testnet**: Verify address generation works correctly\n\n### Address Handling\n\n1. **Case Sensitivity**: Bech32 is case-insensitive, Base58 is case-sensitive\n2. **Display Formatting**: Consider QR codes for long addresses\n3. **Copy Protection**: Use checksums to detect copy errors\n4. **Network Verification**: Always verify mainnet vs testnet\n\n### Security\n\n1. **Never Reuse Addresses**: Generate new addresses for each transaction\n2. **Verify Derivation Paths**: Ensure consistent paths across wallet imports\n3. **Backup Seeds**: Addresses can be regenerated from seeds\n\n---\n\n## Summary\n\nUnderstanding Bitcoin addresses requires knowledge of:\n\n- **Encoding Schemes**: Base58Check, Bech32, Bech32m\n- **Script Types**: P2PKH, P2SH, P2WPKH, P2WSH, P2TR\n- **Derivation**: BIP32/39/44/49/84/86 standards\n- **Validation**: Checksum verification and format checking\n\nModern applications should default to Bech32m (Taproot) addresses for the best fee efficiency and privacy features.\n\n---\n\n## Related Topics\n\n- [Key Management](/docs/bitcoin-development/keys) - Managing private and public keys\n- [Address Types](/docs/wallets/address-types) - Detailed address type comparison\n- [HD Wallets](/docs/wallets/hd-wallets) - Derivation paths and wallet structure\n- [Transaction Construction](/docs/bitcoin-development/transactions) - Using addresses in transactions\n",
    "filename": "addresses.md"
  },
  "/docs/bitcoin-development/transactions": {
    "content": "# Transaction Construction\n\nBuilding Bitcoin transactions from scratch requires understanding inputs, outputs, fees, and signing. This guide covers the complete process from [UTXO](/docs/fundamentals/utxos) selection to broadcasting.\n\n## Transaction Lifecycle\n\nUnderstanding the complete lifecycle of a transaction helps contextualize the construction process:\n\n1. **Creation**: User constructs a transaction specifying inputs ([UTXOs](/docs/fundamentals/utxos) to spend) and outputs (recipient addresses and amounts)\n2. **Signing**: User signs the transaction with their private key, proving ownership of the inputs\n3. **Broadcasting**: Signed transaction is sent to the network\n4. **Mempool**: Transaction waits in the [mempool](/docs/glossary#mempool) (memory pool) of unconfirmed transactions\n5. **Selection**: A miner selects the transaction (typically prioritizing higher fees)\n6. **Inclusion**: Transaction is included in a candidate block\n7. **Mining**: Miner finds valid proof-of-work for the block\n8. **Propagation**: New block spreads across the network\n9. **Confirmation**: Each subsequent block adds another confirmation, increasing security\n\nA transaction with 6 confirmations is generally considered irreversible.\n\n---\n\n## Transaction Structure\n\n![Raw Bitcoin Transaction Bytes](/images/docs/raw-bitcoin-transacation-byte.jpg)\n\n### Components\n\n```\nTransaction\nâ”œâ”€â”€ Version (4 bytes)\nâ”œâ”€â”€ Marker & Flag (SegWit only, 2 bytes)\nâ”œâ”€â”€ Input Count (varint)\nâ”œâ”€â”€ Inputs\nâ”‚   â”œâ”€â”€ Previous TXID (32 bytes)\nâ”‚   â”œâ”€â”€ Output Index (4 bytes)\nâ”‚   â”œâ”€â”€ Script Length (varint)\nâ”‚   â”œâ”€â”€ ScriptSig (variable)\nâ”‚   â””â”€â”€ Sequence (4 bytes)\nâ”œâ”€â”€ Output Count (varint)\nâ”œâ”€â”€ Outputs\nâ”‚   â”œâ”€â”€ Value (8 bytes)\nâ”‚   â”œâ”€â”€ Script Length (varint)\nâ”‚   â””â”€â”€ ScriptPubKey (variable)\nâ”œâ”€â”€ Witness (SegWit only)\nâ”‚   â””â”€â”€ Witness data per input\nâ””â”€â”€ Locktime (4 bytes)\n```\n\n**Byte Order:** Most numeric fields (version, value, locktime, sequence, output index) are encoded in [little endian](/docs/glossary#little-endian). However, transaction IDs (TXIDs) and block hashes are typically *displayed* in big endian (reversed) for readability, even though they're stored internally in little endian. When working with raw transaction data, the `[::-1]` reversal in Python (or equivalent) converts between these formats.\n\n### Size Calculations\n\nVirtual size (vbytes) = (base_size Ã— 3 + total_size) / 4\n\n---\n\n## Building Transactions\n\n![Transaction Binary Map](/images/docs/tx-binary-map.png)\n\n:::code-group\n```rust\nuse bitcoin::{Transaction, TxIn, TxOut, OutPoint, Sequence, Amount, ScriptBuf};\nuse bitcoin::absolute::LockTime;\n\nfn create_transaction(prev_txid: Txid, recipient: ScriptBuf, change: ScriptBuf) -> Transaction {\n    Transaction {\n        version: 2,\n        lock_time: LockTime::ZERO,\n        input: vec![TxIn {\n            previous_output: OutPoint::new(prev_txid, 0),\n            script_sig: ScriptBuf::new(),\n            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n            witness: bitcoin::Witness::default(),\n        }],\n        output: vec![\n            TxOut { value: Amount::from_sat(50000), script_pubkey: recipient },\n            TxOut { value: Amount::from_sat(49000), script_pubkey: change },\n        ],\n    }\n}\n```\n\n```python\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\n\ndef create_transaction(prev_txid, recipient_script, change_script):\n    outpoint = COutPoint(bytes.fromhex(prev_txid)[::-1], 0)\n    txin = CTxIn(outpoint)\n    txout = CTxOut(50000, recipient_script)\n    change = CTxOut(49000, change_script)\n    return CTransaction([txin], [txout, change])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::chain::transaction create_transaction(const bc::hash_digest& prev_txid,\n                                          const bc::chain::script& recipient,\n                                          const bc::chain::script& change) {\n    bc::chain::input input;\n    input.set_previous_output({prev_txid, 0});\n    input.set_sequence(0xfffffffd); // RBF enabled\n    \n    bc::chain::transaction tx;\n    tx.set_version(2);\n    tx.inputs().push_back(input);\n    tx.outputs().push_back({50000, recipient});\n    tx.outputs().push_back({49000, change});\n    return tx;\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nfunction createTransaction(prevTxid, recipientAddr, changeAddr) {\n  const psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\n  \n  psbt.addInput({\n    hash: prevTxid,\n    index: 0,\n    witnessUtxo: { script: Buffer.from('0014...', 'hex'), value: 100000 },\n  });\n  \n  psbt.addOutput({ address: recipientAddr, value: 50000 });\n  psbt.addOutput({ address: changeAddr, value: 49000 });\n  \n  // Sign and finalize...\n  return psbt;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\nfunc createTransaction(prevTxid string, recipientAddr string, changeAddr string) (*wire.MsgTx, error) {\n\ttx := wire.NewMsgTx(wire.TxVersion)\n\n\t// Add input\n\tprevTxHash, err := wire.NewHashFromStr(prevTxid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxIn := wire.NewTxIn(wire.NewOutPoint(prevTxHash, 0), nil, nil)\n\ttxIn.Sequence = wire.MaxTxInSequenceNum - 2 // Enable RBF\n\ttx.AddTxIn(txIn)\n\n\t// Add recipient output\n\trecipientAddrDecoded, err := btcutil.DecodeAddress(recipientAddr, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trecipientScript, err := txscript.PayToAddrScript(recipientAddrDecoded)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttx.AddTxOut(wire.NewTxOut(50000, recipientScript))\n\n\t// Add change output\n\tchangeAddrDecoded, err := btcutil.DecodeAddress(changeAddr, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tchangeScript, err := txscript.PayToAddrScript(changeAddrDecoded)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttx.AddTxOut(wire.NewTxOut(49000, changeScript))\n\n\treturn tx, nil\n}\n\nfunc main() {\n\ttx, err := createTransaction(\"prev_txid\", \"bc1q...\", \"bc1q...\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Transaction created with %d inputs and %d outputs\\n\", len(tx.TxIn), len(tx.TxOut))\n}\n```\n:::\n\n---\n\n## Input Selection\n\n### Coin Selection Algorithms\n\n#### Largest First\n\n```typescript\nfunction largestFirst(utxos: UTXO[], target: number): UTXO[] {\n  // Sort by value descending\n  const sorted = [...utxos].sort((a, b) => b.value - a.value);\n  \n  const selected: UTXO[] = [];\n  let total = 0;\n  \n  for (const utxo of sorted) {\n    selected.push(utxo);\n    total += utxo.value;\n    if (total >= target) break;\n  }\n  \n  return total >= target ? selected : [];\n}\n```\n\n#### Branch and Bound (Exact Match)\n\n```typescript\nfunction branchAndBound(utxos: UTXO[], target: number, maxTries = 100000): UTXO[] | null {\n  let tries = 0;\n  let bestSelection: UTXO[] | null = null;\n  let bestWaste = Infinity;\n  \n  function search(index: number, selected: UTXO[], total: number): void {\n    if (tries++ > maxTries) return;\n    \n    // Found exact match\n    if (total === target) {\n      bestSelection = [...selected];\n      bestWaste = 0;\n      return;\n    }\n    \n    // Over target, calculate waste\n    if (total > target) {\n      const waste = total - target;\n      if (waste < bestWaste) {\n        bestSelection = [...selected];\n        bestWaste = waste;\n      }\n      return;\n    }\n    \n    // Try including next UTXO\n    if (index < utxos.length) {\n      // Include\n      selected.push(utxos[index]);\n      search(index + 1, selected, total + utxos[index].value);\n      selected.pop();\n      \n      // Exclude\n      search(index + 1, selected, total);\n    }\n  }\n  \n  search(0, [], 0);\n  return bestSelection;\n}\n```\n\n#### Knapsack\n\n```typescript\nfunction knapsack(utxos: UTXO[], target: number): UTXO[] {\n  const n = utxos.length;\n  const dp: boolean[][] = Array(n + 1).fill(null)\n    .map(() => Array(target + 1).fill(false));\n  \n  // Base case: sum of 0 is always achievable\n  for (let i = 0; i <= n; i++) dp[i][0] = true;\n  \n  // Fill the table\n  for (let i = 1; i <= n; i++) {\n    for (let j = 1; j <= target; j++) {\n      dp[i][j] = dp[i - 1][j]; // Don't include\n      if (j >= utxos[i - 1].value) {\n        dp[i][j] = dp[i][j] || dp[i - 1][j - utxos[i - 1].value];\n      }\n    }\n  }\n  \n  // Backtrack to find solution\n  if (!dp[n][target]) return largestFirst(utxos, target); // Fallback\n  \n  const selected: UTXO[] = [];\n  let remaining = target;\n  for (let i = n; i > 0 && remaining > 0; i--) {\n    if (!dp[i - 1][remaining]) {\n      selected.push(utxos[i - 1]);\n      remaining -= utxos[i - 1].value;\n    }\n  }\n  \n  return selected;\n}\n```\n\n---\n\n## Fee Estimation\n\n### Fee Rate Sources\n\n```typescript\nasync function getFeeRate(): Promise<number> {\n  // Option 1: mempool.space API\n  const response = await fetch('https://mempool.space/api/v1/fees/recommended');\n  const fees = await response.json();\n  \n  return {\n    fast: fees.fastestFee,      // Next block\n    medium: fees.halfHourFee,   // ~30 min\n    slow: fees.hourFee,         // ~1 hour\n    economy: fees.economyFee,   // Low priority\n  };\n}\n\n// Option 2: Bitcoin Core RPC\nasync function getFeeRateFromNode(rpc: BitcoinRPC, blocks: number): Promise<number> {\n  const result = await rpc.call('estimatesmartfee', [blocks]);\n  if (result.feerate) {\n    // Convert BTC/kB to sat/vB\n    return Math.ceil(result.feerate * 100000);\n  }\n  throw new Error('Fee estimation failed');\n}\n```\n\n### Calculating Transaction Fee\n\n```typescript\ninterface TransactionSizes {\n  P2PKH_INPUT: 148,\n  P2WPKH_INPUT: 68,\n  P2TR_INPUT: 57.5,\n  P2PKH_OUTPUT: 34,\n  P2WPKH_OUTPUT: 31,\n  P2TR_OUTPUT: 43,\n  OVERHEAD: 10.5,\n}\n\nfunction estimateFee(\n  inputs: { type: string }[],\n  outputs: { type: string }[],\n  feeRate: number\n): number {\n  let vSize = TransactionSizes.OVERHEAD;\n  \n  for (const input of inputs) {\n    switch (input.type) {\n      case 'P2PKH': vSize += TransactionSizes.P2PKH_INPUT; break;\n      case 'P2WPKH': vSize += TransactionSizes.P2WPKH_INPUT; break;\n      case 'P2TR': vSize += TransactionSizes.P2TR_INPUT; break;\n    }\n  }\n  \n  for (const output of outputs) {\n    switch (output.type) {\n      case 'P2PKH': vSize += TransactionSizes.P2PKH_OUTPUT; break;\n      case 'P2WPKH': vSize += TransactionSizes.P2WPKH_OUTPUT; break;\n      case 'P2TR': vSize += TransactionSizes.P2TR_OUTPUT; break;\n    }\n  }\n  \n  return Math.ceil(vSize * feeRate);\n}\n```\n\n---\n\n## Replace-By-Fee (RBF)\n\n### Enabling RBF\n\n```typescript\nfunction createRBFTransaction(psbt: Psbt) {\n  // Set sequence to enable RBF (< 0xFFFFFFFE)\n  psbt.setInputSequence(0, 0xFFFFFFFD);\n  \n  // Alternative: Use the constant\n  psbt.setInputSequence(0, bitcoin.Transaction.DEFAULT_SEQUENCE - 2);\n}\n```\n\n### Creating Replacement Transaction\n\n```typescript\nfunction bumpFee(originalTx: Transaction, newFeeRate: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Copy inputs from original transaction\n  for (const input of originalTx.ins) {\n    psbt.addInput({\n      hash: input.hash,\n      index: input.index,\n      sequence: 0xFFFFFFFD, // RBF enabled\n      // Add witness UTXO data...\n    });\n  }\n  \n  // Recalculate outputs with higher fee\n  const originalFee = calculateFee(originalTx);\n  const newVSize = originalTx.virtualSize();\n  const newFee = newVSize * newFeeRate;\n  const additionalFee = newFee - originalFee;\n  \n  // Reduce change output by additional fee\n  for (let i = 0; i < originalTx.outs.length; i++) {\n    const output = originalTx.outs[i];\n    if (isChangeOutput(output)) {\n      psbt.addOutput({\n        script: output.script,\n        value: output.value - additionalFee,\n      });\n    } else {\n      psbt.addOutput({\n        script: output.script,\n        value: output.value,\n      });\n    }\n  }\n  \n  return psbt;\n}\n```\n\n---\n\n## Child-Pays-For-Parent (CPFP)\n\n### Creating CPFP Transaction\n\n```typescript\nfunction createCPFPTransaction(\n  stuckTx: Transaction,\n  stuckTxFee: number,\n  targetFeeRate: number\n): Psbt {\n  // Find our output in the stuck transaction\n  const ourOutput = findOurOutput(stuckTx);\n  \n  // Calculate required fee for both transactions\n  const stuckTxVSize = stuckTx.virtualSize();\n  const childVSize = 110; // Estimate for simple spend\n  const totalVSize = stuckTxVSize + childVSize;\n  const totalFeeNeeded = totalVSize * targetFeeRate;\n  const childFee = totalFeeNeeded - stuckTxFee;\n  \n  // Create child transaction\n  const psbt = new bitcoin.Psbt();\n  \n  psbt.addInput({\n    hash: stuckTx.getId(),\n    index: ourOutput.index,\n    witnessUtxo: {\n      script: ourOutput.script,\n      value: ourOutput.value,\n    },\n  });\n  \n  psbt.addOutput({\n    address: newAddress,\n    value: ourOutput.value - childFee,\n  });\n  \n  return psbt;\n}\n```\n\n---\n\n## Transaction Batching\n\n### Batch Multiple Payments\n\n```typescript\ninterface Payment {\n  address: string;\n  amount: number;\n}\n\nfunction createBatchTransaction(\n  utxos: UTXO[],\n  payments: Payment[],\n  feeRate: number,\n  changeAddress: string\n): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Calculate total needed\n  const totalPayments = payments.reduce((sum, p) => sum + p.amount, 0);\n  \n  // Select inputs\n  const estimatedFee = estimateBatchFee(utxos.length, payments.length + 1, feeRate);\n  const target = totalPayments + estimatedFee;\n  const selectedUtxos = selectCoins(utxos, target);\n  \n  // Add inputs\n  let totalInput = 0;\n  for (const utxo of selectedUtxos) {\n    psbt.addInput({\n      hash: utxo.txid,\n      index: utxo.vout,\n      witnessUtxo: {\n        script: utxo.script,\n        value: utxo.value,\n      },\n    });\n    totalInput += utxo.value;\n  }\n  \n  // Add payment outputs\n  for (const payment of payments) {\n    psbt.addOutput({\n      address: payment.address,\n      value: payment.amount,\n    });\n  }\n  \n  // Add change output\n  const actualFee = estimateBatchFee(selectedUtxos.length, payments.length + 1, feeRate);\n  const change = totalInput - totalPayments - actualFee;\n  \n  if (change > 546) {\n    psbt.addOutput({\n      address: changeAddress,\n      value: change,\n    });\n  }\n  \n  return psbt;\n}\n```\n\n### Benefits of Batching\n\n```\nSingle transaction to 10 recipients:\n- 1 input, 11 outputs (including change)\n- ~380 vbytes\n- 1 fee payment\n\n10 separate transactions:\n- 10 inputs, 20 outputs total\n- ~1,100 vbytes total\n- 10 fee payments\n```\n\n---\n\n## Time Locks\n\n### Absolute Time Lock (nLockTime)\n\n```typescript\nfunction createTimeLocked(lockTime: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Set locktime (block height or Unix timestamp)\n  psbt.setLocktime(lockTime);\n  \n  // Must set sequence < 0xFFFFFFFF to enable locktime\n  psbt.addInput({\n    hash: utxo.txid,\n    index: utxo.vout,\n    sequence: 0xFFFFFFFE,\n    witnessUtxo: {\n      script: utxo.script,\n      value: utxo.value,\n    },\n  });\n  \n  psbt.addOutput({\n    address: recipient,\n    value: amount,\n  });\n  \n  return psbt;\n}\n\n// Lock until specific block\ncreateTimeLocked(850000); // Block 850,000\n\n// Lock until specific time (Unix timestamp > 500,000,000)\ncreateTimeLocked(1735689600); // Jan 1, 2025\n```\n\n### Relative Time Lock (CSV)\n\n```typescript\nfunction createCSVLocked(blocks: number): Psbt {\n  const psbt = new bitcoin.Psbt();\n  \n  // Set sequence for relative timelock\n  // Blocks: blocks (up to 65535)\n  // Time: blocks | 0x00400000 (in 512-second units)\n  psbt.addInput({\n    hash: utxo.txid,\n    index: utxo.vout,\n    sequence: blocks, // e.g., 144 for ~1 day\n    witnessUtxo: {\n      script: utxo.script,\n      value: utxo.value,\n    },\n  });\n  \n  return psbt;\n}\n```\n\n---\n\n## Broadcasting Transactions\n\n:::code-group\n```rust\nuse reqwest;\n\nasync fn broadcast_transaction(tx_hex: &str) -> Result<String, Box<dyn std::error::Error>> {\n    let response = reqwest::Client::new()\n        .post(\"https://mempool.space/api/tx\")\n        .body(tx_hex.to_string())\n        .send().await?;\n    Ok(response.text().await?)\n}\n```\n\n```python\nimport requests\n\ndef broadcast_transaction(tx_hex):\n    response = requests.post('https://mempool.space/api/tx', data=tx_hex)\n    if response.status_code != 200:\n        raise Exception(f\"Broadcast failed: {response.text}\")\n    return response.text  # Returns txid\n```\n\n```cpp\n#include <curl/curl.h>\n\nstd::string broadcast_transaction(const std::string& tx_hex) {\n    CURL* curl = curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://mempool.space/api/tx\");\n    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, tx_hex.c_str());\n    // ... handle response\n    curl_easy_cleanup(curl);\n    return txid;\n}\n```\n\n```javascript\nasync function broadcastTransaction(txHex) {\n  const response = await fetch('https://mempool.space/api/tx', {\n    method: 'POST',\n    body: txHex,\n  });\n  if (!response.ok) throw new Error(await response.text());\n  return await response.text(); // Returns txid\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc broadcastTransaction(txHex string) (string, error) {\n\turl := \"https://mempool.space/api/tx\"\n\tresp, err := http.Post(url, \"text/plain\", bytes.NewBufferString(txHex))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer resp.Body.Close()\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tbody, _ := io.ReadAll(resp.Body)\n\t\treturn \"\", fmt.Errorf(\"broadcast failed: %s\", string(body))\n\t}\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn string(body), nil // Returns txid\n}\n\nfunc main() {\n\t// Example: broadcast a transaction\n\ttxHex := \"0100000001...\" // Transaction hex\n\ttxid, err := broadcastTransaction(txHex)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Transaction broadcast: %s\\n\", txid)\n}\n```\n:::\n\n---\n\n## Error Handling\n\n### Common Errors\n\n```typescript\nasync function safebroadcast(txHex: string): Promise<string> {\n  try {\n    return await broadcastTransaction(txHex);\n  } catch (error) {\n    const message = error.message.toLowerCase();\n    \n    if (message.includes('insufficient fee')) {\n      throw new Error('Fee too low. Increase fee rate and retry.');\n    }\n    if (message.includes('dust')) {\n      throw new Error('Output amount too small (below dust limit).');\n    }\n    if (message.includes('missing inputs') || message.includes('bad-txns-inputs-missingorspent')) {\n      throw new Error('Input already spent or does not exist.');\n    }\n    if (message.includes('txn-mempool-conflict')) {\n      throw new Error('Conflicting transaction in mempool. May need RBF.');\n    }\n    if (message.includes('non-final')) {\n      throw new Error('Transaction timelock not yet satisfied.');\n    }\n    \n    throw error;\n  }\n}\n```\n\n---\n\n## Best Practices\n\n### Transaction Construction\n\n1. **Validate All Inputs**: Verify UTXOs exist and are unspent\n2. **Calculate Fees Carefully**: Use appropriate fee rate for urgency\n3. **Handle Dust**: Don't create outputs below dust limit (~546 sats)\n4. **Use RBF**: Enable RBF for flexibility (unless specific reason not to)\n5. **Verify Before Signing**: Double-check amounts and addresses\n\n### Security\n\n1. **Test on Testnet**: Always test transaction logic on testnet first\n2. **Validate Addresses**: Verify recipient addresses are valid\n3. **Check Change Amounts**: Ensure change is calculated correctly\n4. **Review Before Broadcast**: Final review of all transaction details\n\n### Optimization\n\n1. **Batch When Possible**: Combine multiple payments into one transaction\n2. **Use SegWit/Taproot**: Lower fees for SegWit and Taproot inputs/outputs\n3. **Consolidate UTXOs**: During low-fee periods, consolidate small UTXOs\n4. **Avoid Unnecessary Outputs**: Minimize output count when possible\n\n---\n\n## Summary\n\nTransaction construction involves:\n\n- **Building**: Creating inputs, outputs, and metadata\n- **Coin Selection**: Choosing optimal UTXOs to spend\n- **Fee Estimation**: Calculating appropriate fees\n- **Signing**: Adding valid signatures\n- **Broadcasting**: Submitting to the network\n\nUnderstanding these fundamentals enables building robust Bitcoin applications that handle funds safely and efficiently.\n\n---\n\n## Related Topics\n\n- [PSBT](/docs/bitcoin-development/psbt) - Partially Signed Bitcoin Transactions\n- [Coin Selection](/docs/wallets/coin-selection) - UTXO selection algorithms\n- [Address Generation](/docs/bitcoin-development/addresses) - Creating recipient addresses\n- [Mempool](/docs/mining/mempool) - Transaction propagation and fees\n",
    "filename": "transactions.md"
  },
  "/docs/bitcoin-development/psbt": {
    "content": "# Partially Signed Bitcoin Transactions (PSBT)\n\nPSBTs (BIP-174) provide a standardized format for passing unsigned or partially signed transactions between different software and hardware. They're essential for multi-party signing, hardware wallet integration, and air-gapped setups. Before PSBT, passing transactions between wallets was ad-hoc: each wallet had its own format, hardware wallets needed custom integrations, multi-signature coordination was complex, and there was no standard way to include signing metadata. PSBT provides: **Standardized Format** (all wallets speak the same language), **Metadata Inclusion** (UTXOs, scripts, derivation paths), **Partial Signatures** (multiple parties can sign independently), and **Hardware Wallet Support** (works with air-gapped devices).\n\n---\n\n## PSBT Structure\n\n### Components\n\n```\nPSBT\nâ”œâ”€â”€ Global Data\nâ”‚   â”œâ”€â”€ Unsigned Transaction\nâ”‚   â””â”€â”€ Extended Public Keys (optional)\nâ”œâ”€â”€ Input Data (per input)\nâ”‚   â”œâ”€â”€ Non-Witness UTXO\nâ”‚   â”œâ”€â”€ Witness UTXO\nâ”‚   â”œâ”€â”€ Partial Signatures\nâ”‚   â”œâ”€â”€ Sighash Type\nâ”‚   â”œâ”€â”€ Redeem Script\nâ”‚   â”œâ”€â”€ Witness Script\nâ”‚   â””â”€â”€ BIP32 Derivation Paths\nâ””â”€â”€ Output Data (per output)\n    â”œâ”€â”€ Redeem Script\n    â”œâ”€â”€ Witness Script\n    â””â”€â”€ BIP32 Derivation Paths\n```\n\n### Roles in PSBT Workflow\n\n1. **Creator**: Creates the unsigned transaction\n2. **Updater**: Adds UTXO information and scripts\n3. **Signer**: Adds signatures\n4. **Combiner**: Merges multiple PSBTs\n5. **Finalizer**: Completes the transaction\n6. **Extractor**: Extracts the final transaction\n\n---\n\n## Creating PSBTs\n\n### Using Bitcoin Core\n\n```bash\n# Create a PSBT\nbitcoin-cli walletcreatefundedpsbt \\\n  '[]' \\\n  '[{\"bc1q...address...\": 0.5}]' \\\n  0 \\\n  '{\"includeWatching\": true}'\n\n# Result: {\"psbt\": \"cHNidP8BAH0CAAAA...\", \"fee\": 0.00001410, \"changepos\": 1}\n```\n\n### Creating PSBTs in Code\n\n:::code-group\n```rust\nuse bitcoin::psbt::Psbt;\nuse bitcoin::{Transaction, TxIn, TxOut, OutPoint, Sequence};\n\nlet tx = Transaction {\n    version: 2,\n    lock_time: bitcoin::absolute::LockTime::ZERO,\n    input: vec![TxIn {\n        previous_output: OutPoint::new(prev_txid, 0),\n        script_sig: bitcoin::ScriptBuf::new(),\n        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,\n        witness: bitcoin::Witness::default(),\n    }],\n    output: vec![TxOut { value: Amount::from_sat(50000), script_pubkey: recipient_script }],\n};\nlet mut psbt = Psbt::from_unsigned_tx(tx)?;\npsbt.inputs[0].witness_utxo = Some(TxOut { value: Amount::from_sat(100000), script_pubkey: input_script });\n```\n\n```python\nfrom bitcoin.psbt import PSBT\nfrom bitcoin.core import CTransaction, CTxIn, CTxOut, COutPoint\n\ntx = CTransaction([CTxIn(COutPoint(prev_txid, 0))], [CTxOut(50000, recipient_script)])\npsbt = PSBT(tx)\npsbt.inputs[0].witness_utxo = CTxOut(100000, input_script)\npsbt_bytes = psbt.serialize()\n```\n\n```cpp\n// libbitcoin has limited PSBT support\n// Consider using bitcoin-cli or implementing BIP-174 manually\n// See: https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/btcutil\"\n\t\"github.com/btcsuite/btcd/chaincfg\"\n\t\"github.com/btcsuite/btcd/txscript\"\n\t\"github.com/btcsuite/btcd/wire\"\n)\n\nfunc createPSBT(prevTxid string, recipientAddr string, inputValue int64) (*wire.MsgTx, error) {\n\t// Create transaction\n\ttx := wire.NewMsgTx(wire.TxVersion)\n\n\t// Add input\n\tprevTxHash, err := wire.NewHashFromStr(prevTxid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxIn := wire.NewTxIn(wire.NewOutPoint(prevTxHash, 0), nil, nil)\n\ttx.AddTxIn(txIn)\n\n\t// Add output\n\taddr, err := btcutil.DecodeAddress(recipientAddr, &chaincfg.MainNetParams)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tscript, err := txscript.PayToAddrScript(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttxOut := wire.NewTxOut(50000, script)\n\ttx.AddTxOut(txOut)\n\n\t// In a real implementation, you would serialize this as a PSBT\n\t// using BIP-174 format\n\treturn tx, nil\n}\n\nfunc main() {\n\ttx, err := createPSBT(\"previous_txid_here\", \"bc1q...\", 100000)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Transaction created with %d inputs and %d outputs\\n\", len(tx.TxIn), len(tx.TxOut))\n}\n```\n\n```javascript\nimport * as bitcoin from 'bitcoinjs-lib';\n\nconst psbt = new bitcoin.Psbt({ network: bitcoin.networks.bitcoin });\npsbt.addInput({\n  hash: 'previous_txid_here',\n  index: 0,\n  witnessUtxo: { script: Buffer.from('0014...', 'hex'), value: 100000 },\n});\npsbt.addOutput({ address: 'bc1q...', value: 50000 });\nconst psbtBase64 = psbt.toBase64();\n```\n:::\n\n---\n\n## Signing PSBTs\n\n### Single Signature\n\n```typescript\n// Using bitcoinjs-lib\nimport ECPairFactory from 'ecpair';\nimport * as ecc from 'tiny-secp256k1';\n\nconst ECPair = ECPairFactory(ecc);\n\n// Parse PSBT\nconst psbt = Psbt.fromBase64(psbtBase64);\n\n// Create key pair\nconst keyPair = ECPair.fromWIF(privateKeyWIF);\n\n// Sign input 0\npsbt.signInput(0, keyPair);\n\n// Check if fully signed\nif (psbt.validateSignaturesOfInput(0, validator)) {\n  // Finalize the input\n  psbt.finalizeInput(0);\n}\n\n// Export signed PSBT\nconst signedPsbt = psbt.toBase64();\n```\n\n### Hardware Wallet Signing\n\n```typescript\n// Example with Ledger\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\nimport AppBtc from '@ledgerhq/hw-app-btc';\n\nasync function signWithLedger(psbtBase64: string) {\n  // Connect to Ledger\n  const transport = await TransportWebUSB.create();\n  const btc = new AppBtc({ transport });\n  \n  // Parse PSBT\n  const psbt = Psbt.fromBase64(psbtBase64);\n  \n  // Get the serialized PSBT for Ledger\n  const psbtHex = psbt.toHex();\n  \n  // Sign with Ledger (simplified)\n  // Actual implementation depends on Ledger app version\n  const signature = await btc.signMessage(\n    \"84'/0'/0'/0/0\",\n    psbtHex\n  );\n  \n  return signature;\n}\n```\n\n### Multi-Signature Signing\n\n```typescript\n// Create PSBT for 2-of-3 multisig\nconst psbt = new Psbt();\n\npsbt.addInput({\n  hash: txid,\n  index: 0,\n  witnessUtxo: {\n    script: p2wshScript,\n    value: 100000,\n  },\n  witnessScript: multisigScript, // The actual multisig script\n});\n\npsbt.addOutput({\n  address: 'bc1q...',\n  value: 50000,\n});\n\n// First signer signs\npsbt.signInput(0, keyPair1);\n\n// Export partially signed PSBT\nconst partiallySignedPsbt = psbt.toBase64();\n\n// --- Send to second signer ---\n\n// Second signer imports and signs\nconst psbt2 = Psbt.fromBase64(partiallySignedPsbt);\npsbt2.signInput(0, keyPair2);\n\n// Now we have 2-of-3 signatures, can finalize\npsbt2.finalizeInput(0);\n\n// Extract final transaction\nconst finalTx = psbt2.extractTransaction();\nconsole.log(finalTx.toHex());\n```\n\n---\n\n## Combining PSBTs\n\nWhen multiple parties sign the same PSBT independently:\n\n```typescript\n// Party A signs\nconst psbtA = Psbt.fromBase64(originalPsbt);\npsbtA.signInput(0, keyPairA);\nconst signedA = psbtA.toBase64();\n\n// Party B signs (independently)\nconst psbtB = Psbt.fromBase64(originalPsbt);\npsbtB.signInput(0, keyPairB);\nconst signedB = psbtB.toBase64();\n\n// Combine the PSBTs\nconst combined = Psbt.fromBase64(signedA);\nconst psbtBParsed = Psbt.fromBase64(signedB);\n\ncombined.combine(psbtBParsed);\n\n// Now combined has both signatures\ncombined.finalizeAllInputs();\nconst finalTx = combined.extractTransaction();\n```\n\n### Using Bitcoin Core\n\n```bash\n# Combine multiple PSBTs\nbitcoin-cli combinepsbt '[\"psbt1_base64\", \"psbt2_base64\"]'\n```\n\n---\n\n## Finalizing PSBTs\n\n### Manual Finalization\n\n```typescript\nconst psbt = Psbt.fromBase64(signedPsbt);\n\n// Finalize each input\nfor (let i = 0; i < psbt.inputCount; i++) {\n  try {\n    psbt.finalizeInput(i);\n  } catch (e) {\n    console.error(`Failed to finalize input ${i}:`, e);\n  }\n}\n\n// Check if all inputs are finalized\nif (psbt.data.inputs.every(input => input.finalScriptSig || input.finalScriptWitness)) {\n  const tx = psbt.extractTransaction();\n  console.log('Final transaction:', tx.toHex());\n}\n```\n\n### Custom Finalizers\n\nFor complex scripts, you may need custom finalizers:\n\n```typescript\npsbt.finalizeInput(0, (inputIndex, input, script) => {\n  // Custom finalization logic for complex scripts\n  const payment = bitcoin.payments.p2wsh({\n    redeem: {\n      input: bitcoin.script.compile([\n        input.partialSig[0].signature,\n        input.partialSig[1].signature,\n        bitcoin.opcodes.OP_TRUE, // For example, a conditional branch\n      ]),\n      output: input.witnessScript,\n    },\n  });\n  \n  return {\n    finalScriptSig: Buffer.from([]),\n    finalScriptWitness: payment.witness,\n  };\n});\n```\n\n---\n\n## PSBT Workflow Examples\n\n### Air-Gapped Signing\n\n```\n1. Online Computer (Creator/Updater)\n   â””â”€â”€ Creates PSBT with all UTXO data\n   â””â”€â”€ Exports to QR code or file\n   \n2. Air-Gapped Computer (Signer)\n   â””â”€â”€ Imports PSBT\n   â””â”€â”€ Reviews transaction details\n   â””â”€â”€ Signs with private key\n   â””â”€â”€ Exports signed PSBT\n   \n3. Online Computer (Finalizer/Extractor)\n   â””â”€â”€ Imports signed PSBT\n   â””â”€â”€ Finalizes transaction\n   â””â”€â”€ Broadcasts to network\n```\n\n### CoinJoin with PSBT\n\n```typescript\n// Coordinator creates base transaction\nconst psbt = new Psbt();\n\n// Add inputs from multiple participants\nparticipants.forEach(participant => {\n  psbt.addInput({\n    hash: participant.utxo.txid,\n    index: participant.utxo.vout,\n    witnessUtxo: participant.utxo.witnessUtxo,\n    bip32Derivation: participant.derivation,\n  });\n});\n\n// Add outputs (equal amounts for anonymity)\nparticipants.forEach(participant => {\n  psbt.addOutput({\n    address: participant.outputAddress,\n    value: COINJOIN_AMOUNT,\n  });\n});\n\n// Shuffle outputs for privacy\n// ... shuffle logic ...\n\n// Distribute to participants for signing\nconst psbtBase64 = psbt.toBase64();\n\n// Each participant signs their input\n// Coordinator combines and broadcasts\n```\n\n---\n\n## PSBT Version 2 (BIP-370)\n\nPSBT v2 introduces improvements for interactive protocols:\n\n### Key Differences\n\n| Feature | PSBT v0 | PSBT v2 |\n|---------|---------|---------|\n| Transaction Storage | Global | Reconstructed from fields |\n| Modifiable | No | Yes (with restrictions) |\n| Lock Time | Fixed | Per-input |\n| Use Case | Simple signing | Interactive protocols |\n\n### When to Use PSBT v2\n\n- CoinJoin protocols\n- Payjoin\n- Multi-round signing protocols\n- Interactive transaction construction\n\n---\n\n## Error Handling\n\n### Common PSBT Errors\n\n```typescript\ntry {\n  const psbt = Psbt.fromBase64(psbtString);\n} catch (e) {\n  if (e.message.includes('Invalid PSBT magic')) {\n    console.error('Not a valid PSBT');\n  } else if (e.message.includes('Duplicate key')) {\n    console.error('PSBT contains duplicate data');\n  }\n}\n\n// Validation before signing\ntry {\n  psbt.signInput(0, keyPair);\n} catch (e) {\n  if (e.message.includes('No inputs found')) {\n    console.error('PSBT has no inputs');\n  } else if (e.message.includes('Need UTXO')) {\n    console.error('Missing UTXO data for input');\n  }\n}\n```\n\n### Validation Checks\n\n```typescript\nfunction validatePsbt(psbt: Psbt): boolean {\n  // Check all inputs have required data\n  for (let i = 0; i < psbt.inputCount; i++) {\n    const input = psbt.data.inputs[i];\n    \n    // Need either witness UTXO or non-witness UTXO\n    if (!input.witnessUtxo && !input.nonWitnessUtxo) {\n      console.error(`Input ${i} missing UTXO data`);\n      return false;\n    }\n    \n    // For non-SegWit, need full previous transaction\n    if (input.nonWitnessUtxo && !input.witnessUtxo) {\n      // Verify the UTXO matches the referenced output\n      const prevTx = bitcoin.Transaction.fromBuffer(input.nonWitnessUtxo);\n      const prevOut = psbt.txInputs[i];\n      if (prevTx.getId() !== prevOut.hash.reverse().toString('hex')) {\n        console.error(`Input ${i} UTXO doesn't match`);\n        return false;\n      }\n    }\n  }\n  \n  return true;\n}\n```\n\n---\n\n## Best Practices\n\n### For PSBT Creators\n\n1. **Include All Metadata**: Add derivation paths, scripts, and UTXOs\n2. **Use Deterministic Inputs**: Order inputs consistently\n3. **Set Appropriate Sighash**: Default to SIGHASH_ALL\n4. **Validate Before Export**: Check PSBT is well-formed\n\n### For PSBT Signers\n\n1. **Verify Outputs**: Always review destination and amounts\n2. **Check Change Address**: Verify change goes to your wallet\n3. **Inspect Fee**: Ensure fee is reasonable\n4. **Validate Scripts**: For complex scripts, verify the spending conditions\n\n### For Hardware Wallet Integration\n\n1. **Include BIP32 Paths**: Hardware wallets need derivation info\n2. **Use Standard Paths**: Stick to BIP44/49/84/86 paths\n3. **Test on Testnet**: Always test the integration first\n4. **Handle Rejections**: User may reject on device\n\n---\n\n## Summary\n\nPSBTs provide a standardized way to:\n\n- **Create** unsigned transactions with full metadata\n- **Update** with UTXO and script information\n- **Sign** with one or multiple parties\n- **Combine** signatures from different sources\n- **Finalize** and extract broadcast-ready transactions\n\nUnderstanding PSBTs is essential for modern Bitcoin development, especially when working with hardware wallets, multi-signature setups, or any multi-party transaction construction.\n\n---\n\n## Related Topics\n\n- [Transaction Construction](/docs/bitcoin-development/transactions) - Building transactions from scratch\n- [Key Management](/docs/bitcoin-development/keys) - Managing signing keys\n- [Address Generation](/docs/bitcoin-development/addresses) - Creating and validating addresses\n- [Multisig](/docs/wallets/multisig) - Multi-signature wallet setups\n",
    "filename": "psbt.md"
  },
  "/docs/bitcoin-development/blockchain-monitoring": {
    "content": "# Blockchain Monitoring\n\nReal-time blockchain monitoring allows you to detect new blocks instantly, track mining pools, analyze transactions, and monitor network activity.\n\n> **Explore the blockchain live!** Try RPC commands like `getblockchaininfo` and `getmempoolinfo` in the [Bitcoin CLI Terminal](/terminal).\n\n## ZMQ Notifications\n\n**ZeroMQ (ZMQ)** provides real-time notifications for blockchain events without polling. It's much more efficient than repeatedly calling RPC commands.\n\n### Benefits\n\n- **Instant notifications**: No polling delays\n- **Lower resource usage**: No constant RPC calls\n- **Better reliability**: Catches blocks even after node restarts\n- **Real-time monitoring**: Perfect for applications\n\n### Configuration\n\nAdd to your `bitcoin.conf`:\n\n```ini\n# ZMQ Notifications\nzmqpubhashblock=tcp://127.0.0.1:28332\nzmqpubhashtx=tcp://127.0.0.1:28333\nzmqpubrawblock=tcp://127.0.0.1:28334\nzmqpubrawtx=tcp://127.0.0.1:28335\n```\n\n**Important**: Bitcoin Core must be built **with ZMQ enabled**.\n\n### Verification\n\n```bash\n# Check if ZMQ is enabled in Bitcoin logs\ngrep -i zmq ~/.bitcoin/debug.log\n\n# Check Bitcoin help for ZMQ options\nbitcoind -h | grep zmq\n```\n\n---\n\n## Block Detection\n\n### Real-Time Block Monitoring with ZMQ\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\nuse zmq;\n\nfn monitor_blocks() -> Result<(), Box<dyn std::error::Error>> {\n    let context = zmq::Context::new();\n    let socket = context.socket(zmq::SUB)?;\n    socket.connect(\"tcp://127.0.0.1:28332\")?;\n    socket.set_subscribe(b\"hashblock\")?;\n\n    loop {\n        let msg = socket.recv_bytes(0)?;\n        let block_hash = hex::encode(&msg[1..]);\n        println!(\"New block: {}\", block_hash);\n    }\n}\n```\n\n```python\nimport zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://127.0.0.1:28332\")\nsocket.setsockopt_string(zmq.SUBSCRIBE, \"hashblock\")\n\nwhile True:\n    message = socket.recv()\n    block_hash = message[1:].hex()\n    print(f\"New block: {block_hash}\")\n```\n\n```cpp\n#include <zmq.hpp>\n#include <iostream>\n#include <iomanip>\n\nvoid monitor_blocks() {\n    zmq::context_t context(1);\n    zmq::socket_t socket(context, ZMQ_SUB);\n    socket.connect(\"tcp://127.0.0.1:28332\");\n    socket.setsockopt(ZMQ_SUBSCRIBE, \"hashblock\", 9);\n    \n    while (true) {\n        zmq::message_t message;\n        socket.recv(&message);\n        // Skip topic prefix, convert to hex\n        auto* data = static_cast<unsigned char*>(message.data());\n        std::cout << \"New block: \";\n        for (size_t i = 9; i < message.size(); ++i)\n            std::cout << std::hex << std::setfill('0') << std::setw(2) << (int)data[i];\n        std::cout << std::endl;\n    }\n}\n```\n\n```javascript\nconst zmq = require('zeromq');\n\nasync function monitorBlocks() {\n  const socket = new zmq.Subscriber();\n  socket.connect('tcp://127.0.0.1:28332');\n  socket.subscribe('hashblock');\n\n  for await (const [topic, msg] of socket) {\n    const blockHash = msg.toString('hex');\n    console.log(`New block: ${blockHash}`);\n  }\n}\nmonitorBlocks();\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/pebbe/zmq4\"\n)\n\nfunc monitorBlocks() error {\n\tsocket, err := zmq4.NewSocket(zmq4.SUB)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer socket.Close()\n\n\terr = socket.Connect(\"tcp://127.0.0.1:28332\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = socket.SetSubscribe(\"hashblock\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tparts, err := socket.RecvMessageBytes(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// parts[0] is topic, parts[1] is block hash\n\t\tblockHash := parts[1]\n\t\thashHex := \"\"\n\t\tfor i := len(blockHash) - 1; i >= 0; i-- {\n\t\t\thashHex += fmt.Sprintf(\"%02x\", blockHash[i])\n\t\t}\n\t\tfmt.Printf(\"New block: %s\\n\", hashHex)\n\t}\n}\n\nfunc main() {\n\tif err := monitorBlocks(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n:::\n\n### Using Polling (Fallback)\n\n:::code-group\n```rust\nuse std::{thread, time::Duration};\n\nfn poll_blocks(rpc: &bitcoincore_rpc::Client) {\n    let mut last_block = rpc.get_block_count().unwrap();\n    loop {\n        let current = rpc.get_block_count().unwrap();\n        if current > last_block {\n            println!(\"New block: {}\", current);\n            last_block = current;\n        }\n        thread::sleep(Duration::from_secs(10));\n    }\n}\n```\n\n```python\nimport time\nfrom bitcoinrpc import BitcoinRPC\n\nrpc = BitcoinRPC(...)\nlast_block = rpc.getblockcount()\n\nwhile True:\n    current_block = rpc.getblockcount()\n    if current_block > last_block:\n        print(f\"New block: {current_block}\")\n        last_block = current_block\n    time.sleep(10)\n```\n\n```cpp\n#include <thread>\n#include <chrono>\n\nvoid poll_blocks(BitcoinRPC& rpc) {\n    int last_block = rpc.getblockcount();\n    while (true) {\n        int current = rpc.getblockcount();\n        if (current > last_block) {\n            std::cout << \"New block: \" << current << std::endl;\n            last_block = current;\n        }\n        std::this_thread::sleep_for(std::chrono::seconds(10));\n    }\n}\n```\n\n```javascript\nasync function pollBlocks(rpc) {\n  let lastBlock = await rpc.getBlockCount();\n  while (true) {\n    const current = await rpc.getBlockCount();\n    if (current > lastBlock) {\n      console.log(`New block: ${current}`);\n      lastBlock = current;\n    }\n    await new Promise(r => setTimeout(r, 10000));\n  }\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/btcsuite/btcd/rpcclient\"\n)\n\nfunc pollBlocks(client *rpcclient.Client) error {\n\tlastBlock, err := client.GetBlockCount()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tcurrent, err := client.GetBlockCount()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif current > lastBlock {\n\t\t\tfmt.Printf(\"New block: %d\\n\", current)\n\t\t\tlastBlock = current\n\t\t}\n\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}\n\nfunc main() {\n\t// Connect to Bitcoin Core RPC\n\tconnCfg := &rpcclient.ConnConfig{\n\t\tHost:         \"127.0.0.1:8332\",\n\t\tUser:         \"rpcuser\",\n\t\tPass:         \"rpcpassword\",\n\t\tHTTPPostMode: true,\n\t\tDisableTLS:   true,\n\t}\n\n\tclient, err := rpcclient.New(connCfg, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Shutdown()\n\n\tif err := pollBlocks(client); err != nil {\n\t\tpanic(err)\n\t}\n}\n```\n:::\n\n### Block Information\n\n**Get Block Details:**\n\n```python\n# Get block by hash\nblock = rpc.getblock(block_hash)\n\n# Get block by height\nblock_hash = rpc.getblockhash(height)\nblock = rpc.getblock(block_hash)\n```\n\n**Key Information:**\n- Block height\n- Block hash\n- Previous block hash\n- Merkle root\n- Timestamp\n- Transaction count\n- Block size\n\n---\n\n## Mining Pool Identification\n\n### Coinbase Transaction Analysis\n\nMining pools often embed their name or identifier in the coinbase transaction.\n\n**Extract Pool Information:**\n\n```python\ndef identify_pool(block):\n    coinbase_tx = block['tx'][0]\n    coinbase_hex = rpc.getrawtransaction(coinbase_tx)\n    \n    # Parse coinbase script\n    # Look for pool identifiers\n    # Common patterns:\n    # - Pool names in ASCII\n    # - Pool URLs\n    # - Pool signatures\n    \n    return pool_name\n```\n\n---\n\n## OP_RETURN Analysis\n\n### Extracting OP_RETURN Data\n\n:::code-group\n```rust\nfn extract_op_return(tx: &bitcoin::Transaction) -> Vec<Vec<u8>> {\n    tx.output.iter()\n        .filter_map(|out| {\n            if out.script_pubkey.is_op_return() {\n                out.script_pubkey.instructions()\n                    .skip(1)  // Skip OP_RETURN\n                    .filter_map(|inst| inst.ok()?.push_bytes().map(|b| b.as_bytes().to_vec()))\n                    .next()\n            } else { None }\n        })\n        .collect()\n}\n```\n\n```python\ndef extract_op_return(tx):\n    op_returns = []\n    for output in tx['vout']:\n        asm = output['scriptPubKey']['asm']\n        if asm.startswith('OP_RETURN'):\n            data = asm.split(' ')[1] if len(asm.split(' ')) > 1 else ''\n            op_returns.append(bytes.fromhex(data))\n    return op_returns\n```\n\n```cpp\nstd::vector<std::string> extract_op_return(const json& tx) {\n    std::vector<std::string> op_returns;\n    for (const auto& output : tx[\"vout\"]) {\n        std::string asm_str = output[\"scriptPubKey\"][\"asm\"];\n        if (asm_str.find(\"OP_RETURN\") == 0) {\n            size_t pos = asm_str.find(' ');\n            if (pos != std::string::npos)\n                op_returns.push_back(asm_str.substr(pos + 1));\n        }\n    }\n    return op_returns;\n}\n```\n\n```javascript\nfunction extractOpReturn(tx) {\n  return tx.vout\n    .filter(out => out.scriptPubKey.asm.startsWith('OP_RETURN'))\n    .map(out => {\n      const parts = out.scriptPubKey.asm.split(' ');\n      return parts.length > 1 ? Buffer.from(parts[1], 'hex') : Buffer.alloc(0);\n    });\n}\n```\n:::\n\n### Use Cases\n\n- **Timestamping**: Document timestamps\n- **Asset Protocols**: Counterparty, Omni Layer\n- **Messages**: Encoded messages\n- **Metadata**: Transaction metadata\n\n---\n\n## Transaction Monitoring\n\n### Mempool Monitoring with ZMQ\n\n:::code-group\n```rust\n// In Cargo.toml: hex = \"0.4\"\nuse hex;\n\nfn monitor_mempool() -> Result<(), Box<dyn std::error::Error>> {\n    let context = zmq::Context::new();\n    let socket = context.socket(zmq::SUB)?;\n    socket.connect(\"tcp://127.0.0.1:28333\")?;\n    socket.set_subscribe(b\"hashtx\")?;\n\n    loop {\n        let msg = socket.recv_bytes(0)?;\n        let tx_hash = hex::encode(&msg[1..]);\n        println!(\"New transaction: {}\", tx_hash);\n    }\n}\n```\n\n```python\ncontext = zmq.Context()\nsocket = context.socket(zmq.SUB)\nsocket.connect(\"tcp://127.0.0.1:28333\")\nsocket.setsockopt_string(zmq.SUBSCRIBE, \"hashtx\")\n\nwhile True:\n    message = socket.recv()\n    tx_hash = message[1:].hex()\n    print(f\"New transaction: {tx_hash}\")\n```\n\n```cpp\nvoid monitor_mempool() {\n    zmq::context_t context(1);\n    zmq::socket_t socket(context, ZMQ_SUB);\n    socket.connect(\"tcp://127.0.0.1:28333\");\n    socket.setsockopt(ZMQ_SUBSCRIBE, \"hashtx\", 6);\n    \n    while (true) {\n        zmq::message_t message;\n        socket.recv(&message);\n        // Convert to hex and print\n        std::cout << \"New transaction received\" << std::endl;\n    }\n}\n```\n\n```javascript\nconst zmq = require('zeromq');\n\nasync function monitorMempool() {\n  const socket = new zmq.Subscriber();\n  socket.connect('tcp://127.0.0.1:28333');\n  socket.subscribe('hashtx');\n\n  for await (const [topic, msg] of socket) {\n    console.log(`New transaction: ${msg.toString('hex')}`);\n  }\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/pebbe/zmq4\"\n)\n\nfunc monitorMempool() error {\n\tsocket, err := zmq4.NewSocket(zmq4.SUB)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer socket.Close()\n\n\terr = socket.Connect(\"tcp://127.0.0.1:28333\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = socket.SetSubscribe(\"hashtx\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor {\n\t\tparts, err := socket.RecvMessageBytes(0)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// parts[0] is topic, parts[1] is transaction hash\n\t\ttxHash := parts[1]\n\t\thashHex := hex.EncodeToString(txHash)\n\t\tfmt.Printf(\"New transaction: %s\\n\", hashHex)\n\t}\n}\n\nfunc main() {\n\tif err := monitorMempool(); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n:::\n\n### Transaction Analysis\n\n:::code-group\n```rust\nlet tx = rpc.get_raw_transaction_info(&txid, None)?;\n// Access: tx.vin, tx.vout, tx.size, tx.vsize\n```\n\n```python\ntx = rpc.getrawtransaction(tx_hash, True)\n# Access: tx['vin'], tx['vout'], tx['size'], tx['vsize']\n```\n\n```cpp\njson tx = rpc.getrawtransaction(tx_hash, true);\n// Access: tx[\"vin\"], tx[\"vout\"], tx[\"size\"], tx[\"vsize\"]\n```\n\n```javascript\nconst tx = await rpc.getRawTransaction(txHash, true);\n// Access: tx.vin, tx.vout, tx.size, tx.vsize\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/btcsuite/btcd/rpcclient\"\n)\n\nfunc getTransactionInfo(client *rpcclient.Client, txHash string) error {\n\ttx, err := client.GetRawTransactionVerbose(txHash)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Printf(\"Transaction ID: %s\\n\", tx.Txid)\n\tfmt.Printf(\"Size: %d bytes\\n\", tx.Size)\n\tfmt.Printf(\"Virtual Size: %d vbytes\\n\", tx.Vsize)\n\tfmt.Printf(\"Inputs: %d\\n\", len(tx.Vin))\n\tfmt.Printf(\"Outputs: %d\\n\", len(tx.Vout))\n\n\treturn nil\n}\n\nfunc main() {\n\tconnCfg := &rpcclient.ConnConfig{\n\t\tHost:         \"127.0.0.1:8332\",\n\t\tUser:         \"rpcuser\",\n\t\tPass:         \"rpcpassword\",\n\t\tHTTPPostMode: true,\n\t\tDisableTLS:   true,\n\t}\n\n\tclient, err := rpcclient.New(connCfg, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Shutdown()\n\n\t// Example usage\n\t_ = getTransactionInfo(client, \"example_tx_hash\")\n}\n```\n:::\n\n---\n\n## Statistics and Logging\n\n### Block Statistics\n\n**Track Block Metrics:**\n\n```python\ndef log_block_stats(block):\n    stats = {\n        'height': block['height'],\n        'hash': block['hash'],\n        'tx_count': len(block['tx']),\n        'size': block['size'],\n        'pool': identify_pool(block),\n        'timestamp': block['time']\n    }\n    \n    # Log to CSV or database\n    log_to_csv(stats)\n```\n\n### CSV Logging\n\n**Log to CSV:**\n\n```python\nimport csv\n\ndef log_to_csv(stats):\n    with open('blocks.csv', 'a') as f:\n        writer = csv.DictWriter(f, fieldnames=stats.keys())\n        writer.writerow(stats)\n```\n\n---\n\n## Error Handling\n\n### ZMQ Connection Failures\n\n**Handle ZMQ Errors:**\n\n```python\ntry:\n    socket = context.socket(zmq.SUB)\n    socket.connect(\"tcp://127.0.0.1:28332\")\nexcept zmq.ZMQError as e:\n    print(f\"ZMQ connection failed: {e}\")\n    # Fall back to polling\n    use_polling_fallback()\n```\n\n### RPC Failures\n\n**Handle RPC Errors:**\n\n```python\ntry:\n    block = rpc.getblock(block_hash)\nexcept Exception as e:\n    print(f\"RPC error: {e}\")\n    # Retry or log error\n```\n\n---\n\n## Best Practices\n\n### For Monitoring Applications\n\n1. **Use ZMQ First**: Try ZMQ, fall back to polling\n2. **Error Handling**: Handle all error cases\n3. **Logging**: Log important events\n4. **Rate Limiting**: Don't overwhelm RPC\n5. **Caching**: Cache frequently accessed data\n\n### For Performance\n\n1. **Async Operations**: Use async/await for I/O\n2. **Batch Operations**: Batch RPC calls when possible\n3. **Connection Pooling**: Reuse connections\n4. **Efficient Parsing**: Parse only needed data\n\n---\n\n## Related Topics\n\n- [RPC Commands](/docs/bitcoin/rpc) - Bitcoin Core RPC interface\n- [Mempool](/docs/mining/mempool) - Transaction mempool details\n- [Block Construction](/docs/mining/block-construction) - How miners build blocks\n- [Getting Started](/docs/development) - Development setup guide\n",
    "filename": "blockchain-monitoring.md"
  },
  "/docs/bitcoin-development/pool-mining": {
    "content": "# Pool Mining Setup and Monitoring\n\nPool mining allows you to contribute [hash rate](/docs/glossary#hash-rate) to a [mining pool](/docs/glossary#mining-pool) and receive proportional rewards. This guide covers setup, monitoring, and optimization.\n\n## Mining Architecture\n\n### Components\n\n1. **Bitcoin Node**: Provides blockchain data via RPC\n2. **Mining Software**: CPU/GPU/ASIC miner\n3. **Mining Pool**: Coordinates mining efforts\n4. **Wallet**: Receives mining rewards\n\n### Data Flow\n\n```\nBitcoin Node â†’ Mining Software â†’ Mining Pool â†’ Rewards\n```\n\n---\n\n## Mining Software Setup\n\n### CPU Mining (cpuminer-opt)\n\n**Installation:**\n\n```bash\n# Install dependencies\nbrew install automake autoconf libtool curl gmp jansson\n\n# Clone and build\ngit clone https://github.com/JayDDee/cpuminer-opt.git\ncd cpuminer-opt\n./build.sh\n```\n\n**Configuration:**\n\n```bash\n# Start mining (replace with your pool URL and credentials)\n./cpuminer -a sha256d \\\n  -o stratum+tcp://<pool_url>:<port> \\\n  -u <your_bitcoin_address>.worker \\\n  -p <password> \\\n  -t <thread_count>\n```\n\n### Configuration Parameters\n\n- **Algorithm**: `sha256d` (Bitcoin)\n- **Pool URL**: Your chosen mining pool's Stratum URL\n- **Username**: Your Bitcoin address + worker name\n- **Password**: Pool password (often `x` for default)\n- **Threads**: Number of CPU threads to use\n\n---\n\n## Pool Configuration\n\n### Choosing a Pool\n\n**Considerations:**\n- **Payout method**: PPS, PPLNS, SOLO\n- **Fee structure**: Pool fees\n- **Minimum payout**: Minimum withdrawal amount\n- **Reliability**: Uptime and stability\n- **Location**: Geographic proximity\n\n### Pool Types\n\n**Pay Per Share (PPS):**\n- Fixed payment per share\n- Predictable income\n- Higher pool fees\n\n**Pay Per Last N Shares (PPLNS):**\n- Payment based on recent shares\n- Variable income\n- Lower pool fees\n\n**Solo Mining:**\n- Mine independently\n- Keep full block reward\n- Very low probability\n\n---\n\n## Monitoring Hash Rate\n\n### Real-Time Monitoring\n\n**Mining Software Output:**\n\n```\n[2024-01-15 10:30:45] accepted: 1/1 (100.00%), 85.23 kH/s\n[2024-01-15 10:30:50] accepted: 2/2 (100.00%), 85.45 kH/s\n```\n\n**Key Metrics:**\n- **Hash Rate**: Hashes per second (H/s, kH/s, MH/s)\n- **Accepted Shares**: Shares accepted by pool\n- **Rejected Shares**: Shares rejected (stale/invalid)\n- **Efficiency**: Accepted / Total shares\n\n### Hash Rate Calculation\n\n```\nHash Rate = Total Hashes / Time\n```\n\n**Example:**\n```\n85,230 hashes in 1 second = 85.23 kH/s\n```\n\n---\n\n## Share Submission\n\nA share is a [proof-of-work](/docs/glossary#proof-of-work-pow) submission that:\n- Meets pool [difficulty](/docs/glossary#difficulty) (lower than network difficulty)\n- Proves mining work was done\n- Entitles miner to proportional reward\n\n### Share Difficulty\n\n**Pool Difficulty:**\n- Lower than network difficulty\n- Allows more frequent shares\n- Enables proportional rewards\n\n**Network Difficulty:**\n- Actual Bitcoin network difficulty\n- Must be met to find block\n- Very high (currently ~80T)\n\n### Share Acceptance\n\n**Accepted Share:**\n- Meets pool difficulty\n- Valid proof-of-work\n- Counts toward rewards\n\n**Rejected Share:**\n- Stale (block already found)\n- Invalid proof-of-work\n- Doesn't count toward rewards\n\n---\n\n## Reward Calculation\n\n### Proportional Rewards\n\n**PPLNS Example:**\n```\nTotal pool hash rate: 100 PH/s\nYour hash rate: 100 kH/s\nYour contribution: 0.000001%\n\nBlock reward: 3.125 BTC + fees\nYour share: 3.125 BTC Ã— 0.000001% = 0.00003125 BTC\n```\n\n### Payout Schedule\n\n**Factors:**\n- Pool payout method\n- Minimum payout threshold\n- Pool fees\n- Network confirmation requirements\n\n**Typical Schedule:**\n- Daily or weekly payouts\n- Minimum 0.001 BTC\n- After 100+ confirmations\n\n---\n\n## Performance Optimization\n\n### CPU Mining\n\n**Thread Optimization:**\n- Use all CPU cores\n- Monitor temperature\n- Balance performance vs. heat\n\n**Example:**\n```\n10-core CPU: Use 8-10 threads\nLeave 1-2 cores for system\n```\n\n### System Load\n\n**Monitor:**\n- CPU usage: 80-100%\n- Temperature: 60-80Â°C (varies by hardware)\n- Power consumption: Varies by CPU and system\n- Fan noise: May increase with load\n\n### Thermal Management\n\n**Best Practices:**\n- Monitor temperature\n- Reduce threads if overheating\n- Improve ventilation\n- Consider stopping if too hot\n\n---\n\n## Troubleshooting\n\n### Low Hash Rate\n\n**Causes:**\n- Too few threads\n- CPU throttling\n- System load\n- Mining software issues\n\n**Solutions:**\n- Increase thread count\n- Check CPU temperature\n- Reduce other system load\n- Update mining software\n\n### High Rejection Rate\n\n**Causes:**\n- Network latency\n- Stale shares\n- Pool issues\n- Clock synchronization\n\n**Solutions:**\n- Check network connection\n- Use closer pool server\n- Sync system clock\n- Contact pool support\n\n### No Shares Accepted\n\n**Causes:**\n- Wrong pool configuration\n- Invalid credentials\n- Network issues\n- Pool downtime\n\n**Solutions:**\n- Verify pool URL\n- Check username/password\n- Test network connection\n- Check pool status\n\n---\n\n## Security Considerations\n\n### Wallet Security\n\n**Best Practices:**\n- Use dedicated receiving address\n- Don't use main wallet\n- Monitor for payouts\n- Secure private keys\n\n### Pool Security\n\n**Considerations:**\n- Choose reputable pools\n- Verify pool website\n- Use secure connections (SSL/TLS)\n- Monitor payouts\n\n---\n\n## Educational Value\n\n### What You Learn\n\n1. **Proof-of-Work**: How mining works\n2. **Hash Functions**: SHA256D algorithm\n3. **Network Difficulty**: How difficulty adjusts\n4. **Pool Coordination**: How pools work\n5. **Economic Incentives**: Mining economics\n\n### Technical Concepts\n\n- **Block Headers**: 80-byte mining target\n- **Nonce Space**: 4.3 billion possible values\n- **Merkle Trees**: Transaction organization\n- **Difficulty Target**: Network-wide target\n- **Block Rewards**: Miner compensation\n\n---\n\n## Expected Results\n\n### Realistic Expectations\n\n**CPU Mining:**\n- Hash Rate: Varies by CPU (typically kH/s range)\n- Network Hash Rate: ~700 EH/s\n- Your Contribution: Negligible percentage\n- Probability of Finding Block: Essentially zero\n- Pool Rewards: Very small but consistent\n\n**Reality Check:**\n- CPU mining is educational\n- Real mining requires ASICs\n- Pool rewards are minimal\n- Focus on learning, not profit\n\n---\n\n## Summary\n\nPool mining provides:\n\n- **Educational Value**: Learn how mining works\n- **Network Support**: Contribute to network security\n- **Small Rewards**: Proportional pool payouts\n- **Real-Time Monitoring**: Track hash rate and shares\n- **Technical Understanding**: Deep dive into proof-of-work\n\nUnderstanding pool mining helps explain Bitcoin's security model and economic incentives.\n\n---\n\n## Related Topics\n\n- [Bitcoin Mining](/docs/mining) - Mining fundamentals\n- [Proof-of-Work](/docs/mining/proof-of-work) - The consensus mechanism\n- [Mining Pools](/docs/mining/pools) - How pools coordinate miners\n- [Mining Economics](/docs/mining/economics) - Profitability and incentives\n",
    "filename": "pool-mining.md"
  },
  "/docs/bitcoin-development/price-tracking": {
    "content": "# Bitcoin Price Tracking\n\nIntegrating Bitcoin price data into applications requires API integration, caching strategies, and handling rate limits. This guide covers best practices.\n\n## API Providers\n\n### CoinGecko\n\n**Advantages:**\n- Free tier available\n- Good rate limits\n- Historical data\n- Multiple currencies\n\n:::code-group\n```rust\nuse reqwest;\nuse serde_json::Value;\n\nasync fn get_price_coingecko() -> Result<f64, Box<dyn std::error::Error>> {\n    let url = \"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd\";\n    let resp: Value = reqwest::get(url).await?.json().await?;\n    Ok(resp[\"bitcoin\"][\"usd\"].as_f64().unwrap_or(0.0))\n}\n```\n\n```python\nimport requests\n\ndef get_price_coingecko():\n    url = \"https://api.coingecko.com/api/v3/simple/price\"\n    params = {\"ids\": \"bitcoin\", \"vs_currencies\": \"usd,eur\"}\n    response = requests.get(url, params=params)\n    return response.json()[\"bitcoin\"][\"usd\"]\n```\n\n```cpp\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n\ndouble get_price_coingecko() {\n    CURL* curl = curl_easy_init();\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_URL,\n        \"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd\");\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    curl_easy_perform(curl);\n    curl_easy_cleanup(curl);\n    auto json = nlohmann::json::parse(response);\n    return json[\"bitcoin\"][\"usd\"].get<double>();\n}\n```\n\n```javascript\nasync function getPriceCoingecko() {\n  const url = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd,eur';\n  const response = await fetch(url);\n  const data = await response.json();\n  return data.bitcoin.usd;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getPriceCoinGecko() (float64, error) {\n\turl := \"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar data map[string]map[string]float64\n\tif err := json.Unmarshal(body, &data); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn data[\"bitcoin\"][\"usd\"], nil\n}\n\nfunc main() {\n\tprice, err := getPriceCoinGecko()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Bitcoin price: $%.2f\\n\", price)\n}\n```\n:::\n\n### Mempool.space API\n\nAn alternative source using the mempool.space API:\n\n:::code-group\n```rust\nasync fn get_price_mempool() -> Result<f64, Box<dyn std::error::Error>> {\n    let url = \"https://mempool.space/api/v1/prices\";\n    let resp: Value = reqwest::get(url).await?.json().await?;\n    Ok(resp[\"USD\"].as_f64().unwrap_or(0.0))\n}\n```\n\n```python\ndef get_price_mempool():\n    response = requests.get(\"https://mempool.space/api/v1/prices\")\n    return response.json()[\"USD\"]\n```\n\n```cpp\ndouble get_price_mempool() {\n    // Similar to CoinGecko example with different URL\n    std::string url = \"https://mempool.space/api/v1/prices\";\n    // ... fetch and parse JSON\n    return json[\"USD\"].get<double>();\n}\n```\n\n```javascript\nasync function getPriceMempool() {\n  const response = await fetch('https://mempool.space/api/v1/prices');\n  const data = await response.json();\n  return data.USD;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\nfunc getPriceMempool() (float64, error) {\n\turl := \"https://mempool.space/api/v1/prices\"\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tdefer resp.Body.Close()\n\n\tbody, err := io.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tvar data map[string]float64\n\tif err := json.Unmarshal(body, &data); err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn data[\"USD\"], nil\n}\n\nfunc main() {\n\tprice, err := getPriceMempool()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"Bitcoin price: $%.2f\\n\", price)\n}\n```\n:::\n\n---\n\n## Centralized Price Service\n\n### Service Architecture\n\n**Benefits:**\n- Single source of truth\n- Caching reduces API calls\n- Fallback mechanisms\n- Rate limit management\n\n**Implementation:**\n\n```python\nclass BitcoinPriceService:\n    def __init__(self):\n        self.cache = {}\n        self.cache_duration = 60  # seconds\n        self.rate_limiter = RateLimiter()\n    \n    def get_price(self, currency='USD'):\n        # Check cache first\n        cache_key = f\"price_{currency}\"\n        if cache_key in self.cache:\n            cached_price, timestamp = self.cache[cache_key]\n            if time.time() - timestamp < self.cache_duration:\n                return cached_price\n        \n        # Try CoinGecko first\n        try:\n            price = self._get_price_coingecko(currency)\n            self.cache[cache_key] = (price, time.time())\n            return price\n        except Exception:\n            # Fallback to Yahoo Finance\n            price = self._get_price_yahoo(currency)\n            self.cache[cache_key] = (price, time.time())\n            return price\n```\n\n---\n\n## Caching Strategies\n\n### In-Memory Caching\n\n:::code-group\n```rust\nuse std::collections::HashMap;\nuse std::time::{Duration, Instant};\n\nstruct PriceCache {\n    cache: HashMap<String, (f64, Instant)>,\n    duration: Duration,\n}\n\nimpl PriceCache {\n    fn get(&self, currency: &str) -> Option<f64> {\n        self.cache.get(currency).and_then(|(price, time)| {\n            if time.elapsed() < self.duration { Some(*price) } else { None }\n        })\n    }\n\n    fn set(&mut self, currency: &str, price: f64) {\n        self.cache.insert(currency.to_string(), (price, Instant::now()));\n    }\n}\n```\n\n```python\nimport time\n\ncache = {}\nCACHE_DURATION = 60  # seconds\n\ndef get_cached_price(currency):\n    key = f\"price_{currency}\"\n    if key in cache:\n        price, timestamp = cache[key]\n        if time.time() - timestamp < CACHE_DURATION:\n            return price\n    return None\n\ndef set_cached_price(currency, price):\n    cache[f\"price_{currency}\"] = (price, time.time())\n```\n\n```cpp\n#include <unordered_map>\n#include <chrono>\n\nclass PriceCache {\n    std::unordered_map<std::string, std::pair<double, std::chrono::steady_clock::time_point>> cache;\n    std::chrono::seconds duration{60};\npublic:\n    std::optional<double> get(const std::string& currency) {\n        auto it = cache.find(currency);\n        if (it != cache.end()) {\n            auto elapsed = std::chrono::steady_clock::now() - it->second.second;\n            if (elapsed < duration) return it->second.first;\n        }\n        return std::nullopt;\n    }\n    void set(const std::string& currency, double price) {\n        cache[currency] = {price, std::chrono::steady_clock::now()};\n    }\n};\n```\n\n```javascript\nconst cache = new Map();\nconst CACHE_DURATION = 60000; // milliseconds\n\nfunction getCachedPrice(currency) {\n  const entry = cache.get(currency);\n  if (entry && Date.now() - entry.timestamp < CACHE_DURATION) {\n    return entry.price;\n  }\n  return null;\n}\n\nfunction setCachedPrice(currency, price) {\n  cache.set(currency, { price, timestamp: Date.now() });\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype PriceCache struct {\n\tcache    map[string]priceEntry\n\tduration time.Duration\n\tmu       sync.RWMutex\n}\n\ntype priceEntry struct {\n\tprice     float64\n\ttimestamp time.Time\n}\n\nfunc NewPriceCache(duration time.Duration) *PriceCache {\n\treturn &PriceCache{\n\t\tcache:    make(map[string]priceEntry),\n\t\tduration: duration,\n\t}\n}\n\nfunc (pc *PriceCache) Get(currency string) (float64, bool) {\n\tpc.mu.RLock()\n\tdefer pc.mu.RUnlock()\n\n\tentry, exists := pc.cache[currency]\n\tif !exists {\n\t\treturn 0, false\n\t}\n\n\tif time.Since(entry.timestamp) < pc.duration {\n\t\treturn entry.price, true\n\t}\n\n\treturn 0, false\n}\n\nfunc (pc *PriceCache) Set(currency string, price float64) {\n\tpc.mu.Lock()\n\tdefer pc.mu.Unlock()\n\n\tpc.cache[currency] = priceEntry{\n\t\tprice:     price,\n\t\ttimestamp: time.Now(),\n\t}\n}\n\nfunc main() {\n\tcache := NewPriceCache(60 * time.Second)\n\tcache.Set(\"USD\", 50000.0)\n\n\tif price, ok := cache.Get(\"USD\"); ok {\n\t\tfmt.Printf(\"Cached price: $%.2f\\n\", price)\n\t}\n}\n```\n:::\n\n---\n\n## Rate Limiting\n\n### Implementing Rate Limits\n\n**Simple Rate Limiter:**\n\n```python\nimport time\nfrom collections import deque\n\nclass RateLimiter:\n    def __init__(self, max_calls=10, period=60):\n        self.max_calls = max_calls\n        self.period = period\n        self.calls = deque()\n    \n    def can_call(self):\n        now = time.time()\n        # Remove old calls\n        while self.calls and self.calls[0] < now - self.period:\n            self.calls.popleft()\n        \n        if len(self.calls) < self.max_calls:\n            self.calls.append(now)\n            return True\n        return False\n```\n\n### Respecting API Limits\n\n**Best Practices:**\n- Check rate limits before calling\n- Implement exponential backoff\n- Use caching to reduce calls\n- Monitor API usage\n\n---\n\n## Multi-Source Fallbacks\n\n### Fallback Chain\n\n**Priority Order:**\n\n1. **Primary**: CoinGecko (best rate limits)\n2. **Secondary**: Yahoo Finance (backup)\n3. **Tertiary**: Local cache (if available)\n\n**Implementation:**\n\n```python\ndef get_price_with_fallback(currency='USD'):\n    # Try primary source\n    try:\n        return get_price_coingecko(currency)\n    except Exception as e:\n        print(f\"CoinGecko failed: {e}\")\n    \n    # Try secondary source\n    try:\n        return get_price_yahoo(currency)\n    except Exception as e:\n        print(f\"Yahoo Finance failed: {e}\")\n    \n    # Try cache\n    cached = get_cached_price(currency)\n    if cached:\n        return cached\n    \n    # All failed\n    raise Exception(\"All price sources failed\")\n```\n\n---\n\n## Error Handling\n\n### API Errors\n\n**Handle Common Errors:**\n\n```python\ndef get_price_safe(currency='USD'):\n    try:\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout:\n        # Handle timeout\n        return get_cached_price(currency)\n    except requests.exceptions.HTTPError as e:\n        # Handle HTTP errors\n        if e.response.status_code == 429:\n            # Rate limited, use cache\n            return get_cached_price(currency)\n        raise\n    except Exception as e:\n        # Handle other errors\n        return get_cached_price(currency)\n```\n\n---\n\n## Thread Safety\n\n### Concurrent Access\n\n**Thread-Safe Cache:**\n\n```python\nimport threading\n\nclass ThreadSafePriceService:\n    def __init__(self):\n        self.cache = {}\n        self.lock = threading.Lock()\n    \n    def get_price(self, currency='USD'):\n        with self.lock:\n            # Check cache\n            if currency in self.cache:\n                price, timestamp = self.cache[currency]\n                if time.time() - timestamp < 60:\n                    return price\n            \n            # Fetch new price\n            price = self._fetch_price(currency)\n            self.cache[currency] = (price, time.time())\n            return price\n```\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Use Caching**: Reduce API calls\n2. **Implement Fallbacks**: Multiple data sources\n3. **Rate Limiting**: Respect API limits\n4. **Error Handling**: Handle all error cases\n5. **Thread Safety**: Support concurrent access\n\n### For Performance\n\n1. **Cache Duration**: Balance freshness vs. API calls\n2. **Batch Requests**: Request multiple currencies at once\n3. **Connection Pooling**: Reuse HTTP connections\n4. **Async Operations**: Use async/await for I/O\n\n---\n\n## Common Issues\n\n### Rate Limit Exceeded\n\n**Problem**: API rate limit reached\n\n**Solutions:**\n- Implement caching\n- Use multiple API sources\n- Reduce request frequency\n- Upgrade API tier (if available)\n\n### Stale Data\n\n**Problem**: Cached data too old\n\n**Solutions:**\n- Reduce cache duration\n- Implement cache invalidation\n- Add timestamp checks\n- Force refresh option\n\n### API Downtime\n\n**Problem**: API service unavailable\n\n**Solutions:**\n- Implement fallback sources\n- Use cached data\n- Retry with exponential backoff\n- Monitor API status\n\n---\n\n## Summary\n\nPrice tracking requires:\n\n- **API Integration**: Multiple data sources\n- **Caching**: Reduce API calls and improve performance\n- **Rate Limiting**: Respect API limits\n- **Fallbacks**: Multiple sources for reliability\n- **Error Handling**: Handle all error cases\n- **Thread Safety**: Support concurrent access\n\n---\n\n## Related Topics\n\n- [Getting Started](/docs/development) - Bitcoin development introduction\n- [Libraries & SDKs](/docs/development/libraries) - HTTP client libraries for each language\n- [Blockchain Monitoring](/docs/bitcoin-development/blockchain-monitoring) - Real-time blockchain data\n",
    "filename": "price-tracking.md"
  },
  "/docs/bitcoin-development/script-patterns": {
    "content": "# Bitcoin Script Patterns\n\nCommon Bitcoin Script patterns provide reusable templates for building smart contracts. Understanding these patterns helps developers implement common use cases efficiently. Build these patterns in [Stack Lab](/stack-lab).\n\n## Common Patterns\n\n### 1. Pay-to-Pubkey-Hash (P2PKH)\n\nStandard single-signature:\n\n```text\nScriptPubKey:\nOP_DUP OP_HASH160 <pubkey_hash> OP_EQUALVERIFY OP_CHECKSIG\n\nScriptSig:\n<signature> <pubkey>\n```\n\n### 2. Multisig\n\nMultiple signatures required:\n\n```text\nScriptPubKey:\n<M> <pubkey1> <pubkey2> ... <pubkeyN> <N> OP_CHECKMULTISIG\n\nScriptSig:\nOP_0 <sig1> <sig2> ... <sigM>\n```\n\n### 3. Hash Lock\n\nReveal secret to spend:\n\n```text\nScriptPubKey:\nOP_HASH256 <hash> OP_EQUAL\n\nScriptSig:\n<secret>\n```\n\n### 4. Time Lock\n\nAbsolute timelock:\n\n```text\nScriptPubKey:\n<locktime> OP_CHECKLOCKTIMEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n\nScriptSig:\n<signature>\n```\n\n### 5. Relative Time Lock\n\nRelative timelock:\n\n```text\nScriptPubKey:\n<blocks> OP_CHECKSEQUENCEVERIFY OP_DROP <pubkey> OP_CHECKSIG\n\nScriptSig:\n<signature>\n```\n\n---\n\n## Advanced Patterns\n\n### Escrow Contract\n\nThree-party escrow:\n\n```text\n2-of-3 Multisig:\n- Buyer + Seller\n- Buyer + Escrow\n- Seller + Escrow\n```\n\n### Vault Contract\n\nTime-delayed recovery:\n\n```text\nStructure:\n- Hot key: Immediate spend (small)\n- Cold key: Delayed spend (large)\n- Recovery: Longer delay\n```\n\n### Inheritance Contract\n\nTime-locked beneficiary:\n\n```text\nStructure:\n- Beneficiary key\n- Time lock (absolute)\n- Can claim after date\n```\n\n---\n\n## Code Examples\n\n### Creating Common Patterns\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\n\n// P2PKH\nfn create_p2pkh_script(pubkey_hash: &[u8; 20]) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    script.push_opcode(OP_DUP);\n    script.push_opcode(OP_HASH160);\n    script.push_slice(pubkey_hash);\n    script.push_opcode(OP_EQUALVERIFY);\n    script.push_opcode(OP_CHECKSIG);\n    script\n}\n\n// Hash Lock\nfn create_hash_lock_script(hash: &[u8; 32]) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    script.push_opcode(OP_HASH256);\n    script.push_slice(hash);\n    script.push_opcode(OP_EQUAL);\n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_DUP, OP_HASH160, OP_EQUALVERIFY, OP_CHECKSIG\nfrom bitcoin.core.script import OP_HASH256, OP_EQUAL\n\n# P2PKH\ndef create_p2pkh_script(pubkey_hash):\n    return CScript([\n        OP_DUP,\n        OP_HASH160,\n        pubkey_hash,\n        OP_EQUALVERIFY,\n        OP_CHECKSIG,\n    ])\n\n# Hash Lock\ndef create_hash_lock_script(hash_value):\n    return CScript([\n        OP_HASH256,\n        hash_value,\n        OP_EQUAL,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\n// P2PKH\nbc::script create_p2pkh_script(const bc::short_hash& pubkey_hash) {\n    bc::script script;\n    script.push_operation(bc::opcode::dup);\n    script.push_operation(bc::opcode::hash160);\n    script.push_data(bc::to_chunk(pubkey_hash));\n    script.push_operation(bc::opcode::equalverify);\n    script.push_operation(bc::opcode::checksig);\n    return script;\n}\n\n// Hash Lock\nbc::script create_hash_lock_script(const bc::hash_digest& hash) {\n    bc::script script;\n    script.push_operation(bc::opcode::hash256);\n    script.push_data(bc::to_chunk(hash));\n    script.push_operation(bc::opcode::equal);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\n// P2PKH\nfunc createP2PKHScript(pubkeyHash []byte) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddOp(txscript.OP_DUP)\n\tbuilder.AddOp(txscript.OP_HASH160)\n\tbuilder.AddData(pubkeyHash)\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\treturn builder.Script()\n}\n\n// Hash Lock\nfunc createHashLockScript(hash []byte) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\tbuilder.AddOp(txscript.OP_HASH256)\n\tbuilder.AddData(hash)\n\tbuilder.AddOp(txscript.OP_EQUAL)\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\n// P2PKH\nfunction createP2PKHScript(pubkeyHash) {\n    return bitcoin.script.compile([\n        bitcoin.opcodes.OP_DUP,\n        bitcoin.opcodes.OP_HASH160,\n        pubkeyHash,\n        bitcoin.opcodes.OP_EQUALVERIFY,\n        bitcoin.opcodes.OP_CHECKSIG,\n    ]);\n}\n\n// Hash Lock\nfunction createHashLockScript(hash) {\n    return bitcoin.script.compile([\n        bitcoin.opcodes.OP_HASH256,\n        hash,\n        bitcoin.opcodes.OP_EQUAL,\n    ]);\n}\n```\n:::\n\n---\n\n## Miniscript\n\n[Miniscript](/docs/bitcoin-development/miniscript) is a structured language for expressing spending *policies* that compiles to [Bitcoin Script](/docs/bitcoin/script). Instead of writing raw [OP codes](/docs/bitcoin/op-codes) directly, you define *what* must hold (e.g., \"2-of-3 keys\" or \"key A and after block N\") and tools produce correct, analyzable Script.\n\n### Policy vs. Script\n\n- **Policy**: High-level conditions (e.g., `2 of [pk(A), pk(B), pk(C)]` or `and(pk(A), after(100))`).\n- **Script**: The actual bytecode that [nodes](/docs/glossary#full-node) execute; Miniscript compiles policy â†’ Script.\n\n### Fragments and Composition\n\nMiniscript uses composable **fragments** (`pk`, `thresh`, `and`, `or`, `after`, `older`, `hash`, `multi`, etc.) that map to Script. This makes it easier to:\n\n- Combine conditions (AND, OR, m-of-n) without hand-rolled [scriptSig](/docs/glossary#scriptsig)/witness.\n- Analyze **correctness** and **safety** (no unintended spends, no dust).\n- Estimate **satisfaction size** (witness size, number of [signatures](/docs/bitcoin/cryptography)).\n\n### When to Use Miniscript\n\n- **Wallets**: Multisig, [timelocks](/docs/bitcoin/timelocks), and recovery policies.\n- **Contracts**: [Vaults](/docs/wallets/smart-contracts), [Atomic Swaps](/docs/advanced/atomic-swaps)-style hashlocks, and [Taproot](/docs/bitcoin/taproot) script trees.\n- **Protocols**: [Lightning](/docs/lightning), [DLCs](/docs/advanced/dlcs), and other [smart contract](/docs/wallets/smart-contracts) templates.\n\nSee [Miniscript](/docs/bitcoin-development/miniscript) for the full specification, fragment set, and [Tapscript](/docs/glossary#tapscript) support.\n\n---\n\n## Best Practices\n\n### For Developers\n\n1. **Use established patterns**: Don't reinvent\n2. **Prefer Miniscript for complex policies**: Compile from policy when possible\n3. **Test thoroughly**: Script bugs are costly\n4. **Consider Taproot**: Better privacy and efficiency\n5. **Document patterns**: Explain what contracts do\n\n---\n\n## Related Topics\n\n- [Bitcoin Script](/docs/bitcoin/script) - Script system\n- [OP Codes](/docs/bitcoin/op-codes) - Available operations\n- [Miniscript](/docs/bitcoin-development/miniscript) - Policy-to-script compiler\n- [Smart Contracts](/docs/wallets/smart-contracts) - Contract patterns\n\n---\n\n## Resources\n\n- [Bitcoin Script Patterns](https://en.bitcoin.it/wiki/Script)\n- [Miniscript](https://bitcoin.sipa.be/miniscript/) - Playground and reference\n",
    "filename": "script-patterns.md"
  },
  "/docs/bitcoin-development/miniscript": {
    "content": "# Miniscript\n\n**Miniscript** is a structured language for writing [Bitcoin Script](/docs/bitcoin/script) that is easier to analyze, compose, and reason about than raw Script. It maps to a well-defined subset of Script and provides guarantees about spending conditions, costs, and the number and type of signatures required.\n\n## Why Miniscript?\n\nRaw Bitcoin Script is flexible but hard to work with:\n\n- **Opaque**: Deciding what a script does, what can satisfy it, and how much it costs requires careful analysis.\n- **Brittle**: Small changes can produce invalid or unexpected scripts.\n- **Composition**: Combining scripts (e.g., \"2-of-3 OR after 90 days\") is error-prone when done by hand.\n\nMiniscript addresses this by:\n\n- **Policy vs. script**: You express a *policy* (high-level spending conditions); Miniscript compiles it to Script.\n- **Fragments**: A small set of composable *fragments* (e.g., `pk`, `thresh`, `after`) that map to Script.\n- **Analyzable**: Tools can compute correctness, [satisfaction](/docs/glossary#witness) size, and signature requirements automatically.\n\n---\n\n## Policy and Fragments\n\n### Policy\n\nA **policy** is a high-level description of who can spend and under what conditions. Examples:\n\n```text\npk(A)                          â€” Aâ€™s key alone\n2 of [pk(A), pk(B), pk(C)]     â€” 2-of-3 multisig\nand(pk(A), after(100))         â€” A, but only after 100 blocks\nor(2 of [pk(A),pk(B),pk(C)], and(pk(D), after(1000)))\n  â€” 2-of-3 multisig, or D after 1000 blocks\n```\n\n### Core Fragments\n\n| Fragment | Meaning | Script equivalent (conceptually) |\n|----------|---------|----------------------------------|\n| `pk(K)` | Key K must sign | `K OP_CHECKSIG` |\n| `pk_h(K)` | Hash of K; reveal in witness | P2PKH-style |\n| `thresh(n, A, B, ...)` | At least n of the sub-policies | Combined `OP_CHECKSIG` / `OP_CHECKMULTISIG`-style |\n| `and(A, B)` | Both A and B | A then B in sequence |\n| `or(A, B)` | A or B | `OP_IF` / `OP_ELSE` / `OP_ENDIF` |\n| `after(N)` | Absolute [timelock](/docs/bitcoin/timelocks) (block height) | `N OP_CHECKLOCKTIMEVERIFY OP_DROP` |\n| `older(N)` | Relative timelock (N blocks) | `N OP_CHECKSEQUENCEVERIFY OP_DROP` |\n| `hash(H)` | Reveal preimage of H | `OP_HASH256 H OP_EQUAL` |\n| `multi(n, K1, K2, ...)` | n-of-m multisig | `n K1 K2 ... m OP_CHECKMULTISIG` |\n\nMiniscript supports more fragments (e.g., `and_v`, `or_c`, `andor`) for different Script encodings and [sighash](/docs/glossary#sighash) behavior. The exact set is defined in the [Miniscript specification](https://github.com/bitcoin/bips/blob/master/bip-0382.mediawiki).\n\n---\n\n## Correctness and Safety\n\nMiniscript distinguishes:\n\n- **Correctness**: Every valid satisfaction (according to the policy) is accepted by the compiled Script.\n- **Safety**: No satisfaction is possible that the policy was not meant to allow; in particular, no **dust** or non-canonical spend that could lose funds.\n\nNot every Miniscript expression is **safe**; the compiler and analyzers can report whether a given Miniscript is safe and what it requires to spend.\n\n---\n\n## Compilation to Script\n\nA Miniscript policy is compiled down to [Script](/docs/bitcoin/script) (and thus to [P2WSH](/docs/glossary#p2wsh-pay-to-witness-script-hash) or [P2TR](/docs/bitcoin/taproot) [Tapscript](/docs/glossary#tapscript)). The exact output depends on:\n\n- The target (pre-Taproot P2WSH vs [Taproot](/docs/bitcoin/taproot) Tapscript)\n- Optimization options (e.g., minimize size, minimize signature count)\n\nLibraries such as `rust-miniscript` and `miniscript` (C++) (and the reference `miniscript` site) perform this compilation.\n\n---\n\n## Use Cases\n\n- **Wallets**: Encode withdrawal policies (multisig, [timelocks](/docs/bitcoin/timelocks), recovery) and compile to Script; derive [addresses](/docs/wallets/address-types) and [PSBT](/docs/bitcoin-development/psbt) flows.\n- **Vaults and covenants**: Express \"can only go to addresses of type X\" or \"must wait N blocks\"; with proposed [covenant](/docs/advanced/covenants) opcodes, Miniscript could target those too.\n- **Protocols**: [Lightning](/docs/lightning), [DLCs](/docs/advanced/dlcs), and other protocols use script templates that Miniscript can represent and analyze.\n\n---\n\n## Taproot and Miniscript\n\n[Taproot](/docs/bitcoin/taproot) and [Tapscript](/docs/bitcoin/script) add:\n\n- **Schnorr** and `OP_CHECKSIGADD`\n- New rules and limits (e.g., 32-byte x-only [pubkeys](/docs/bitcoin/cryptography))\n\nMiniscript has been extended (see [BIP 382](https://github.com/bitcoin/bips/blob/master/bip-0382.mediawiki) and implementations) to support **Tapscript**, so the same policy language can target both pre-Taproot [P2WSH](/docs/glossary#p2wsh-pay-to-witness-script-hash) and Taproot script paths.\n\n---\n\n## Tools and Libraries\n\n- **[miniscript.bitcoin.sipa.be](https://bitcoin.sipa.be/miniscript/)** â€“ Playground and reference\n- **rust-miniscript** â€“ Rust; used in [BDK](https://github.com/bitcoindevkit/bdk) and other wallets\n- **C++ miniscript** â€“ In [Bitcoin Core](https://github.com/bitcoin/bitcoin) (e.g., for descriptors and output script analysis)\n- **Policy-to-Miniscript**: Higher-level policy languages can target Miniscript, which then compiles to Script\n\n---\n\n## Related Topics\n\n- [Bitcoin Script](/docs/bitcoin/script) - Script system\n- [Script Patterns](/docs/bitcoin-development/script-patterns) - Common patterns and Miniscript\n- [Smart Contracts](/docs/wallets/smart-contracts) - Contract patterns and Miniscript\n- [Taproot](/docs/bitcoin/taproot) - Tapscript and Miniscript\n- [Covenants](/docs/advanced/covenants) - Proposed opcodes and policy\n\n---\n\n## Resources\n\n- [Miniscript (bitcoin.sipa.be)](https://bitcoin.sipa.be/miniscript/) - Playground and specification\n- [BIP 382: Miniscript for Tapscript](https://github.com/bitcoin/bips/blob/master/bip-0382.mediawiki)\n- [rust-miniscript](https://github.com/rust-bitcoin/rust-miniscript) - Rust implementation\n",
    "filename": "miniscript.md"
  },
  "/docs/controversies": {
    "content": "# Bitcoin Controversies\n\nBitcoin's history is marked by intense debates that have shaped its development and philosophy. These controversies reveal the tensions inherent in a decentralized system: how do you change something designed to resist change? Who decides the rules when there is no ruler?\n\n## Why Controversies Matter\n\nEvery major Bitcoin controversy teaches us something about decentralized governance:\n\n- **The Blocksize Wars** showed that users, not miners or corporations, ultimately control Bitcoin\n- **Mt. Gox** taught us \"not your keys, not your coins\"\n- **Energy debates** force us to articulate why [proof-of-work](/docs/glossary#proof-of-work-pow) matters\n- **Criminal-use accusations** remind us that money is a neutral tool and that illicit activity overwhelmingly occurs in traditional currencies\n- **Faketoshi claims** demonstrate the importance of cryptographic proof over authority\n\nUnderstanding these battles is essential for anyone who wants to understand Bitcoin's culture and design philosophy.\n\n---\n\n## The Nature of Bitcoin Debates\n\nBitcoin controversies tend to follow a pattern:\n\n1. **A proposal emerges** that would change Bitcoin's rules or purpose\n2. **Camps form** around different visions for Bitcoin's future\n3. **Technical arguments** mix with economic and philosophical ones\n4. **The network decides** through the messy process of rough consensus\n5. **Lessons are learned** and absorbed into Bitcoin's culture\n\nThese debates are often heated because the stakes are high. Bitcoin is real money used by real people. Changes can't be rolled back. And there's no CEO to make the final call.\n\n---\n\n## Major Controversies\n\n### Protocol Debates\n\n[**The Blocksize Wars (2015-2017)**](/docs/controversies/blocksize-wars)\nThe defining battle over Bitcoin's scaling approach. Big blockers wanted larger blocks for more transactions; small blockers prioritized [decentralization](/docs/glossary#decentralization) and layer-2 solutions. The outcome: Bitcoin kept small blocks, [SegWit](/docs/glossary#segwit-segregated-witness) activated, and Bitcoin Cash [forked](/docs/glossary#hard-fork) off.\n\n[**The OP_RETURN Debate**](/docs/controversies/op-return)\nAn ongoing controversy about data storage on Bitcoin. Should Bitcoin allow arbitrary data in transactions? The 2024 Bitcoin Core v30 changes reignited debates about Bitcoin's purpose: is it purely money, or a platform for broader applications?\n\n[**Ordinals and Inscriptions**](/docs/controversies/ordinals)\nSince 2023, Ordinals and inscriptions (data attached to satoshis via witness) have divided the community: critics call them spam that raises fees and distorts Bitcoinâ€™s purpose; supporters argue they are legitimate, fee-paying use of blockspace and that censoring them conflicts with permissionlessness.\n\n### External Challenges\n\n[**Energy Consumption**](/docs/controversies/energy-consumption)\nCritics claim Bitcoin wastes energy; supporters argue it's the most efficient use of energy ever invented. This debate touches on environmental concerns, the nature of value, and whether proof-of-work is a feature or a bug.\n\n[**Bitcoin and criminal use**](/docs/controversies/criminal-use)\nCritics claim Bitcoin is the currency of choice for criminals. In reality, Bitcoin is just money. What people do with it is their responsibility. The vast majority of illicit financial activity occurs in US dollars and the traditional banking system.\n\n[**Bitcoin ETF rejections (2017â€“2023)**](/docs/controversies/etf-rejections)\nThe SEC repeatedly rejected or delayed spot Bitcoin ETF applications, citing manipulation, custody, and market maturity. A court ruling in the Grayscale case and political pressure helped pave the way for the January 2024 approvals.\n\n### Historical Events\n\n[**Mt. Gox Collapse (2014)**](/docs/controversies/mt-gox)\nThe catastrophic failure of the world's largest Bitcoin exchange. 850,000 BTC lost. The event that made \"not your keys, not your coins\" a community mantra and shaped how we think about custody and trust.\n\n[**Craig Wright / \"Faketoshi\"**](/docs/controversies/craig-wright)\nThe ongoing saga of a man claiming to be Satoshi Nakamoto. Failed cryptographic proofs, forged documents, and legal battles culminated in a 2024 UK court ruling definitively stating Wright is not Satoshi.\n\n---\n\n## Learning from Controversy\n\nThese debates aren't just historical curiosities. They reveal:\n\n- **What Bitcoiners value**: decentralization, self-sovereignty, censorship resistance\n- **How Bitcoin evolves**: slowly, carefully, with broad consensus\n- **Why Bitcoin is resilient**: it survives attacks, scams, and internal conflicts\n\n---\n\n## Antifragile by Design\n\nBitcoin is **antifragile**: a term coined by Nassim Taleb for systems that don't just survive stress, but grow stronger from it.\n\nEvery attack has hardened Bitcoin's defenses. Every scam has educated its users. Every internal conflict has clarified its values. The Blocksize Wars didn't weaken Bitcoin; they proved that no corporation or mining cartel could capture it. Mt. Gox didn't kill Bitcoin; it taught a generation to hold their own keys.\n\nThis is not an accident. Bitcoin's decentralized design means there's no single point of failure to attack, no CEO to arrest, no server to shut down. Attackers face a system that learns from every assault and emerges more resilient.\n\nThe controversies documented here are not signs of weakness. They are evidence of antifragility in action.\n",
    "filename": "overview.md"
  },
  "/docs/controversies/blocksize-wars": {
    "content": "# The Blocksize Wars\n\nThe Blocksize Wars (2015-2017) were a period of intense debate and conflict within the Bitcoin community over whether to increase Bitcoin's [block size](/docs/glossary#block-size) limit. This controversy ultimately led to the [hard fork](/docs/glossary#hard-fork) that created Bitcoin Cash and fundamentally shaped Bitcoin's development philosophy.\n\n## The Core Issue\n\n### The Problem\n\nBitcoin's block size was limited to **1 MB** (set by Satoshi Nakamoto in 2010). As Bitcoin adoption grew, this limit became a bottleneck:\n\n- **Transaction Backlog**: Transactions waiting hours or days for [confirmation](/docs/glossary#confirmation)\n- **Rising Fees**: [Fees](/docs/glossary#transaction-fee) increased as users competed for limited block space\n- **Scalability Concerns**: Could Bitcoin handle global adoption with 1 MB blocks?\n\n### The Question\n\n**Should Bitcoin increase its block size limit?**\n\nThis seemingly simple question divided the community into two camps with fundamentally different visions for Bitcoin's future.\n\n---\n\n## The Two Sides\n\n### Big Blockers\n\n**Core Belief:**\n- Bitcoin should scale on-chain\n- Increase block size to handle more transactions\n- Keep all transactions on the main chain\n- Lower fees through increased capacity\n\n**Proposed Solutions:**\n- Increase to 2 MB, 8 MB, or even 32 MB blocks\n- Remove block size limit entirely\n- Let the market decide optimal block size\n\n**Key Advocates:**\n- Bitcoin XT (2 MB proposal)\n- Bitcoin Classic (2 MB proposal)\n- Bitcoin Unlimited (removable limit)\n- Bitcoin Cash (8 MB, later increased)\n\n### Small Blockers\n\n**Core Belief:**\n- Bitcoin should scale off-chain\n- Keep blocks small to preserve decentralization\n- Use Layer 2 solutions (Lightning Network)\n- Maintain low node operation costs\n\n**Proposed Solutions:**\n- Keep 1 MB limit\n- Implement [Segregated Witness (SegWit)](/docs/glossary#segwit-segregated-witness)\n- Build [Lightning Network](/docs/glossary#lightning-network) for scaling\n- Optimize transaction efficiency\n\n**Key Advocates:**\n- Bitcoin Core developers\n- Most node operators\n- [Decentralization](/docs/glossary#decentralization)-focused community\n\n---\n\n## Timeline of Events\n\n### 2010: The 1 MB Limit\n\n- **Satoshi Nakamoto** sets 1 MB block size limit\n- Initially a spam protection measure\n- Blocks were mostly empty at the time\n- Limit was meant to be temporary\n\n### 2015: Early Proposals\n\n**Bitcoin XT (August 2015)**\n- Proposed increasing to 2 MB, then 8 MB\n- Required 75% miner support\n- Controversial hard fork proposal\n- Rejected by community\n\n**Bitcoin Classic (January 2016)**\n- Proposed 2 MB block size increase\n- Simpler proposal than XT\n- Gained some miner support\n- Eventually abandoned\n\n### 2016: Bitcoin Unlimited\n\n**Bitcoin Unlimited (March 2016)**\n- Proposed removing block size limit entirely\n- Let miners vote on block size\n- \"Emergent consensus\" mechanism\n- Gained significant miner support (~30-40%)\n\n### 2017: The Resolution\n\n**SegWit Activation (August 2017)**\n- Segregated Witness [soft fork](/docs/glossary#soft-fork) activated\n- Increased effective block capacity to ~2 MB\n- Fixed [transaction malleability](/docs/glossary#transaction-malleability)\n- Enabled Lightning Network\n\n**Bitcoin Cash Hard Fork (August 1, 2017)**\n- Big blockers created Bitcoin Cash (BCH)\n- 8 MB block size limit\n- Separate blockchain from Bitcoin\n- Permanent chain split\n\n---\n\n## Key Arguments\n\n### Arguments for Bigger Blocks\n\n1. **On-Chain Scaling**\n   - More transactions per block = lower fees\n   - Simpler solution (no complex Layer 2)\n   - Users want on-chain transactions\n\n2. **User Experience**\n   - Faster confirmations\n   - Lower fees\n   - Better for everyday payments\n\n3. **Technical Feasibility**\n   - Storage is cheap\n   - Bandwidth has improved\n   - Modern hardware can handle larger blocks\n\n4. **Satoshi's Vision**\n   - Satoshi mentioned increasing block size\n   - Was meant to be temporary limit\n   - Should adapt to demand\n\n### Arguments for Small Blocks\n\n1. **Decentralization**\n   - Larger blocks = higher node operation costs\n   - Fewer people can run [full nodes](/docs/glossary#full-node)\n   - Centralization risk\n\n2. **Network Security**\n   - Slower block propagation with larger blocks\n   - More orphan blocks\n   - Weaker network security\n\n3. **Off-Chain Scaling**\n   - Lightning Network can handle millions of transactions\n   - On-chain for settlement, off-chain for payments\n   - Better long-term solution\n\n4. **Economic Security**\n   - Higher fees = better security\n   - Miners need fees after [halvings](/docs/glossary#halving)\n   - Fee market is important\n\n---\n\n## Technical Details\n\n### Block Size Limits\n\n**Bitcoin (BTC):**\n- Base block size: 1 MB\n- With SegWit: ~2-4 MB effective capacity\n- Weight limit: 4,000,000 [weight units](/docs/glossary#weight-units)\n\n**Bitcoin Cash (BCH):**\n- Started: 8 MB\n- Current: 32 MB\n- Plans for even larger blocks\n\n### SegWit Solution\n\nSegregated Witness (SegWit) was the compromise solution:\n\n- **Soft Fork**: Backward compatible\n- **Witness Data**: Moved outside base block\n- **Effective Capacity**: ~2 MB (up to 4 MB with witness)\n- **Transaction Malleability**: Fixed\n- **Lightning Network**: Enabled\n\n### Network Metrics\n\n**Bitcoin (BTC) - 2024:**\n- Average block size: ~1.5-2 MB (with SegWit)\n- Transactions per block: ~2,000-3,000\n- Average fee: Variable ($1-50+)\n- Full node count: ~15,000-20,000\n\n**Bitcoin Cash (BCH) - 2024:**\n- Average block size: ~100-500 KB\n- Transactions per block: ~500-2,000\n- Average fee: Very low (<$0.01)\n- Full node count: ~1,000-2,000\n\n---\n\n## The Outcome\n\n### Bitcoin (BTC) Won\n\n**Results:**\n- Maintained 1 MB base block size\n- Implemented SegWit for scaling\n- Lightning Network developed\n- Focus on decentralization preserved\n\n**Current Status:**\n- ~80% of transactions use SegWit\n- Lightning Network growing\n- Fees remain variable but manageable\n- Strong decentralization\n\n### Bitcoin Cash (BCH) Split\n\n**Results:**\n- Created separate blockchain\n- 8 MB blocks (later increased to 32 MB)\n- Lower fees but less decentralization\n- Smaller network and ecosystem\n\n**Current Status:**\n- Separate cryptocurrency\n- Lower market cap than Bitcoin\n- Different development path\n- Still active but smaller community\n\n---\n\n## Lessons Learned\n\n### 1. Hard Forks Are Risky\n- Created permanent chain split\n- Divided community and resources\n- Both chains continue separately\n\n### 2. Soft Forks Preferred\n- SegWit was a soft fork (backward compatible)\n- No chain split\n- Gradual adoption\n\n### 3. Decentralization Matters\n- Small block supporters prioritized decentralization\n- This has proven important for Bitcoin's security\n- Node count remains high\n\n### 4. Scaling Solutions Evolve\n- Lightning Network emerged as solution\n- Multiple approaches can coexist\n- Innovation continues\n\n---\n\n## Impact on Bitcoin\n\n### Positive Outcomes\n\n1. **Clarified Vision**: Bitcoin's focus on decentralization was reinforced\n2. **SegWit Activation**: Enabled Lightning Network and other innovations\n3. **Community Cohesion**: Core developers and community aligned\n4. **Innovation**: Led to development of Layer 2 solutions\n\n### Negative Outcomes\n\n1. **Community Division**: Deep split that still exists\n2. **Resources Split**: Development resources divided\n3. **Confusion**: Users confused about different Bitcoin versions\n4. **Delayed Scaling**: Took years to resolve\n\n---\n\n## Current Status\n\n### Bitcoin (BTC)\n- **Block Size**: 1 MB base, ~2-4 MB with SegWit\n- **Scaling**: Lightning Network + SegWit\n- **Philosophy**: Decentralization first\n- **Status**: Dominant Bitcoin implementation\n\n### Bitcoin Cash (BCH)\n- **Block Size**: 32 MB\n- **Scaling**: On-chain only\n- **Philosophy**: Big blocks, low fees\n- **Status**: Separate cryptocurrency\n\n---\n\n## Related Topics\n\n- [OP_RETURN Debate](/docs/controversies/op-return) - Another major Bitcoin controversy\n- [History: Forks](/docs/history/forks) - Complete fork history including Bitcoin Cash\n- [Lightning Network](/docs/lightning) - The scaling solution that emerged\n",
    "filename": "blocksize-wars.md"
  },
  "/docs/controversies/op-return": {
    "content": "# The OP_RETURN Debate: Bitcoin as Database vs. Financial Network\n\nAn analysis of the ongoing debate about OP_RETURN, carrier size limits, and Bitcoin's fundamental purpose. `OP_RETURN` is a Bitcoin [Script](/docs/glossary#script) [opcode](/docs/glossary#opcode) that creates **provably unspendable outputs**. When executed, it immediately terminates script execution and marks the transaction as invalid.\n\n**Script Pattern:**\n```\nOP_RETURN <data>\n```\n\n**Key Characteristics:**\n- [Outputs](/docs/glossary#output) are **unspendable**: they cannot be used as [inputs](/docs/glossary#input) in future transactions\n- Data is **permanently stored** on the blockchain (immutable)\n- Data does **not contribute to [UTXO set](/docs/glossary#utxo-set)**: can be pruned by nodes\n- Originally limited to **80 bytes** of data per output\n\n**How it works:** (1) **Script execution:** when `OP_RETURN` is encountered, script execution immediately fails; the transaction is marked as invalid (cannot be spent) but the transaction itself is still valid and included in blocks. (2) **Data storage:** data follows `OP_RETURN` in the script, stored in the transaction output's `[scriptPubKey](/docs/glossary#scriptpubkey)`, permanently recorded in blockchain history. (3) **UTXO set impact:** since outputs are unspendable, they don't add to UTXO set; nodes can prune OP_RETURN data after validation, reducing long-term storage burden compared to regular outputs.\n\n**Example:**\n```\nOP_RETURN 48656c6c6f20576f726c64  (hex for \"Hello World\")\n```\n\n---\n\n## The Technical Reality\n\n### Current Implementation (Bitcoin Core v30+)\n\n#### Default Limits\n\n**Before v30 (Historical):**\n- Default limit: **80 bytes** per OP_RETURN output\n- Configurable via `-datacarriersize` parameter\n- Multiple OP_RETURN outputs allowed, but total size limited\n\n**After v30 (Current):**\n- Default limit: **~1 MB** (MAX_STANDARD_TX_WEIGHT / WITNESS_SCALE_FACTOR)\n- Effectively: Up to **~4 MB** per transaction (block size limit)\n- Configurable via `-datacarriersize` parameter\n- Can be disabled entirely with `-datacarrier=0`\n\n#### Key Technical Points\n\n1. **Policy, Not [Consensus](/docs/glossary#consensus):** OP_RETURN limits are **relay policy**, not [consensus rules](/docs/glossary#consensus-rules)\n   - Nodes can reject transactions as \"non-standard\"\n   - But if included in a block, they're still valid\n   - Miners can include non-standard transactions if they choose\n\n2. **Cumulative Limit:** The limit applies to **total size** across all OP_RETURN outputs in a transaction\n   - Not per-output, but total across all outputs\n   - Multiple OP_RETURN outputs are allowed\n\n3. **Configurable:** Node operators can set their own limits\n   - `-datacarrier=0` disables OP_RETURN entirely\n   - `-datacarriersize=<bytes>` sets custom limit\n   - Default changed from 80 bytes to ~1 MB in v30\n\n### Script Size Limits\n\n**Consensus Limits (Hard):**\n- Maximum script size: **10,000 bytes** (consensus rule)\n- Maximum script element size: **520 bytes** (for most opcodes)\n- Maximum transaction size: **4 MB** (block size limit)\n\n**Policy Limits (Soft):**\n- Standard transaction weight: **400,000 weight units** (~100 KB virtual size)\n- OP_RETURN data carrier size: Configurable (default ~1 MB in v30)\n\n---\n\n## The Historical Context\n\n### 2009-2013: Early Days\n\n- **No OP_RETURN:** Initially, people used other methods to store data\n  - Encoding data in addresses ([P2PKH](/docs/glossary#p2pkh-pay-to-pubkey-hash) outputs)\n  - Using fake addresses with embedded data\n  - These methods bloated the UTXO set\n\n### 2014: OP_RETURN Introduced\n\n- **BIP Proposal:** Introduced to provide a clean way to store data\n- **Purpose:** Enable timestamping, asset protocols, messages\n- **Initial Limit:** 40 bytes (very restrictive)\n- **Rationale:** Prevent blockchain bloat while allowing legitimate use cases\n\n### 2015: Limit Increased to 80 Bytes\n\n- **Community Consensus:** Increased to 80 bytes\n- **Use Cases:** \n  - Timestamping documents\n  - Proof of existence\n  - Small metadata\n  - Early token protocols\n\n### 2017-2024: Status Quo\n\n- **80-byte limit maintained** in Bitcoin Core\n- **Alternative implementations:** Some forks/alternatives had different limits\n- **Growing tension:** Between data storage advocates and financial purists\n\n### 2024-2025: The v30 Controversy\n\n- **Bitcoin Core v30:** Removed default 80-byte limit\n- **New default:** ~1 MB (effectively up to block size limit)\n- **Community split:** Major controversy and debate\n- **Alternative implementations:** Bitcoin Knots maintains stricter limits\n\n---\n\n## The Recent Controversy\n\n### Bitcoin Core v30 Changes\n\n**What Changed:**\n- Default `-datacarriersize` increased from 80 bytes to ~1 MB\n- Effectively allows up to 4 MB of data per transaction (block size limit)\n- Can still be configured by node operators\n\n**Why the Change:**\n- Proponents argued 80 bytes was arbitrary and limiting\n- Modern use cases need more data (NFTs, complex protocols, etc.)\n- Users pay fees, so they should decide how to use block space\n\n### Community Reaction\n\n**Supporters:**\n- Innovation advocates\n- Protocol developers building on Bitcoin\n- Those who see Bitcoin as a platform, not just money\n\n**Opponents:**\n- Bitcoin maximalists focused on \"sound money\"\n- Node operators concerned about costs\n- Those who see this as mission creep\n\n**Result:**\n- **Bitcoin Core:** Implemented the change\n- **Bitcoin Knots:** Maintained stricter 80-byte default\n- **Community:** Deeply divided, ongoing debate\n\n---\n\n## Arguments For Increasing Limits\n\n### 1. \"Users Pay Fees\"\n\n**Argument:**\n- If users are willing to pay transaction fees, they should be able to use block space as they see fit\n- Market forces (fees) will naturally limit abuse\n- No one is forced to store the data: nodes can prune\n\n**Technical Support:**\n- OP_RETURN outputs don't bloat UTXO set (unspendable)\n- Data can be pruned after validation\n- Fees compensate miners for including data\n\n### 2. Innovation and Utility\n\n**Argument:**\n- Enables new use cases:\n  - Document timestamping\n  - Proof of existence\n  - Decentralized identity\n  - Asset protocols\n  - NFT metadata\n- Bitcoin should evolve and support innovation\n\n**Examples:**\n- Counterparty protocol (built on Bitcoin)\n- Omni Layer (USDT originally on Bitcoin)\n- Various timestamping services\n\n### 3. Technical Feasibility\n\n**Argument:**\n- Modern hardware can handle larger blockchains\n- Storage is cheap and getting cheaper\n- Bandwidth has improved significantly\n- Pruning makes it manageable\n\n**Data:**\n- Full node storage: ~500 GB (2024)\n- Pruned node: ~10 GB\n- Storage costs: ~$10-50/year\n\n### 4. Consistency with Block Size\n\n**Argument:**\n- If blocks can be 4 MB, why limit OP_RETURN to 80 bytes?\n- Inconsistent policy\n- Should align with actual block capacity\n\n### 5. Censorship Resistance\n\n**Argument:**\n- Limiting data storage is a form of censorship\n- Bitcoin should be permissionless\n- Who decides what's \"legitimate\" use?\n\n---\n\n## Arguments Against Increasing Limits\n\n### 1. Mission Creep\n\n**Argument:**\n- Bitcoin's purpose is to be \"sound money\"\n- Adding data storage dilutes the mission\n- Should focus on financial transactions, not general data storage\n\n### 2. Blockchain Bloat\n\n**Argument:**\n- Larger blockchain = higher costs for node operators\n- Slower initial sync times\n- More bandwidth required\n- Centralization risk (fewer people can run nodes)\n\n**Technical Reality:**\n- Full blockchain: ~500 GB and growing\n- Each 1 MB of data = permanent storage cost\n- Sync time already takes days/weeks for new nodes\n\n### 3. Spam and Abuse\n\n**Argument:**\n- Larger limits enable spam attacks\n- Malicious actors could fill blocks with garbage data\n- Legal risks (illegal content stored permanently)\n- No way to remove bad data\n\n**Examples of Potential Abuse:**\n- Storing illegal content (child abuse material, etc.)\n- Spam attacks filling blocks\n- Protest messages\n- Corporate advertising\n\n### 4. Node Operator Costs\n\n**Argument:**\n- Node operators bear the cost\n- Not just storage, but bandwidth, CPU, electricity\n- Could lead to centralization\n- Fewer nodes = less decentralization\n\n**Cost Breakdown:**\n- Storage: ~$10-50/year (cheap)\n- Bandwidth: Variable, can be significant\n- CPU: Minimal for validation\n- Electricity: ~$50-200/year\n\n### 5. Legal and Regulatory Risks\n\n**Argument:**\n- Storing illegal content creates legal liability\n- Node operators might be legally responsible\n- Could lead to Bitcoin being banned in some jurisdictions\n- Regulatory scrutiny increases\n\n### 6. Fee Market Distortion\n\n**Argument:**\n- Large data transactions compete with financial transactions\n- Could drive up fees for regular users\n- Distorts the fee market\n- Financial transactions should have priority\n\n---\n\n## Technical Implications\n\n### Storage Impact\n\n**Current Blockchain Size:**\n- ~500 GB (2024)\n- Growing ~50-100 GB per year\n- With increased OP_RETURN: Could grow faster\n\n**Pruning:**\n- OP_RETURN data can be pruned\n- But initial download still requires full chain\n- Historical data still stored by archival nodes\n\n### Network Impact\n\n**Bandwidth:**\n- Larger transactions = more bandwidth\n- Affects initial sync time\n- Ongoing bandwidth for new blocks\n- Could slow down network propagation\n\n**UTXO Set Impact:**\n- **Good News:** OP_RETURN outputs don't add to UTXO set\n- **Bad News:** Still stored in blockchain, still needs validation, still consumes block space\n\n### Fee Market Impact\n\n**Competition for Block Space:**\n- OP_RETURN transactions compete with financial transactions\n- If fees are high, data storage becomes expensive\n- If fees are low, could enable spam\n\n---\n\n## The Philosophical Divide\n\n### Two Competing Visions\n\n#### Vision 1: Bitcoin as \"Sound Money\"\n\n**Core Belief:**\n- Bitcoin should be focused solely on being digital gold\n- Financial transactions are the priority\n- Data storage is a distraction\n- \"Do one thing well\"\n\n**Key Principles:**\n- Minimalism\n- Focus on core function\n- Avoid mission creep\n- Preserve decentralization\n\n#### Vision 2: Bitcoin as a Platform\n\n**Core Belief:**\n- Bitcoin should be a versatile platform\n- Enable innovation and new use cases\n- Data storage is a feature, not a bug\n- \"Build on Bitcoin\"\n\n**Key Principles:**\n- Flexibility\n- Innovation-friendly\n- Permissionless\n- User choice\n\n### The Fundamental Question\n\n**\"What is Bitcoin for?\"**\n\nThis is the core question that divides the community:\n\n1. **Is Bitcoin money?** (Sound money vision)\n2. **Is Bitcoin a platform?** (Innovation vision)\n3. **Can it be both?** (Compromise position)\n\n---\n\n## Current Status and Alternatives\n\n### Bitcoin Core (v30+)\n\n**Status:**\n- Default limit: ~1 MB (effectively up to block size)\n- Configurable by node operators\n- Change implemented in v30\n\n**Configuration:**\n```bash\n# Disable OP_RETURN entirely\n-datacarrier=0\n\n# Set custom limit (in bytes)\n-datacarriersize=80\n\n# Use default (~1 MB)\n# (no configuration needed)\n```\n\n### Bitcoin Knots\n\n**Status:**\n- Maintains 80-byte default limit\n- Stricter policy\n- Alternative implementation for those who disagree with Core\n\n### Other Alternatives\n\n**1. Sidechains:**\n- Store data on separate chains\n- Pegged to Bitcoin\n- Examples: Liquid, Rootstock\n\n**2. Layer 2 Solutions:**\n- [Lightning Network](/docs/glossary#lightning-network) (for payments)\n- Other L2s for data storage\n\n**3. Separate Protocols:**\n- Build data storage on separate blockchains\n- Reference Bitcoin for security\n- Examples: IPFS, Arweave\n\n**4. Off-Chain Solutions:**\n- Store data outside blockchain\n- Hash references on-chain\n- Best of both worlds\n\n---\n\n## Conclusion\n\nThe OP_RETURN debate represents a fundamental philosophical divide in the Bitcoin community:\n\n**Technical Reality:**\n- OP_RETURN limits are **policy, not consensus**\n- Can be configured by node operators\n- Data can be pruned (doesn't bloat UTXO set)\n- But still consumes block space and bandwidth\n\n**Philosophical Divide:**\n- **Sound Money:** Bitcoin should focus on financial transactions\n- **Platform:** Bitcoin should enable innovation and data storage\n- **Compromise:** Some data storage is OK, but with limits\n\n**Current Status:**\n- Bitcoin Core v30: Larger default limits (~1 MB)\n- Bitcoin Knots: Maintains 80-byte default\n- Community: Deeply divided\n- Future: Unclear, likely ongoing debate\n\n**The Core Question:**\nWhat is Bitcoin's fundamental purpose? The answer to this question determines where you stand on OP_RETURN limits, and this debate will likely continue as long as Bitcoin exists.\n",
    "filename": "debate.md"
  },
  "/docs/controversies/ordinals": {
    "content": "# Ordinals and Inscriptions Controversy\n\n[Ordinals](/docs/glossary#ordinals) and [inscriptions](/docs/glossary#inscriptions) let users attach arbitrary dataâ€”images, text, JSONâ€”to individual [satoshis](/docs/glossary#sat-satoshi) using [witness](/docs/glossary#witness) data. Introduced in early 2023 by Casey Rodarmor, the Ordinals protocol and related tokens (e.g. [BRC-20](/docs/glossary#brc-20-tokens)) sparked a heated debate: are they legitimate use of [block space](/docs/glossary#block-size) or spam that raises [fees](/docs/glossary#fee-rate) and distorts Bitcoinâ€™s purpose?\n\n## What Are Ordinals and Inscriptions?\n\n- **Ordinals**: A numbering scheme that assigns a unique index to each satoshi and tracks how they move when [UTXOs](/docs/glossary#utxo-unspent-transaction-output) are spent. It does not change [consensus](/docs/glossary#consensus); it is an indexing convention.\n- **Inscriptions**: Data (images, text, JSON) embedded in [SegWit](/docs/glossary#segwit-segregated-witness) witness scripts and stored on-chain. The content is in the [blockchain](/docs/glossary#blockchain) but does not grow the [UTXO set](/docs/glossary#utxo-set) because it lives in prunable witness data.\n\nFor technical details, see [Ordinals & Inscriptions](/docs/advanced/ordinals-inscriptions).\n\n---\n\n## The Debate\n\n### â€œSpamâ€ / â€œBlockspace for Money Onlyâ€\n\n**Arguments:**\n\n- Bitcoin exists to be **sound money** and [peer-to-peer](/docs/glossary#peer-to-peer-p2p) cash. Storing images, JSON, or token metadata is not monetary use and **crowds out** normal [transactions](/docs/glossary#transaction).\n- Inscription-heavy activity has driven [mempool](/docs/mining/mempool) congestion and higher [fee rates](/docs/glossary#fee-rate), especially in 2023â€“2024, making cheap on-chain payments harder.\n- [Full node](/docs/glossary#full-node) and [IBD](/docs/glossary#ibd-initial-block-download) costs (bandwidth, storage) increase for data many consider nonâ€‘monetary.\n- BRC-20 and similar tokens depend on **off-chain indexers**; they are not enforced by consensus and add complexity and [trust](/docs/fundamentals/trust-model) outside the protocol.\n\n**Proposals:**\n\n- **Relay or miner policy**: Restrict or filter certain nonâ€‘standard scripts (e.g. common inscription patterns). Some node operators and projects (e.g. Bitcoin Knots, or ideas from Luke Dashjr) have explored or implemented filters.\n- **Capping witness size** or tightening standardness for large witness payloads. This would be **policy**, not consensus; miners can still include what they accept.\n\n### â€œInnovationâ€ / â€œPermissionless Use of Blockspaceâ€\n\n**Arguments:**\n\n- Bitcoin is **permissionless**. If someone pays [transaction fees](/docs/bitcoin/transaction-fees), they are bidding for block space; miners and the [fee market](/docs/bitcoin/transaction-fees) decide what gets included. No one gets to define â€œlegitimateâ€ use.\n- [SegWit](/docs/bitcoin/segwit) intentionally made witness data cheaper (1 [weight unit](/docs/glossary#weight-units) per byte) to enable [Layer 2](/docs/glossary#layer-2) and more efficient use. Inscriptions use the same rules; calling them â€œspamâ€ is a value judgment, not a technical one.\n- Ordinals, BRC-20, [Runes](/docs/glossary#runes-protocol), and similar experiments have drawn new users and capital to Bitcoin and highlighted demand for blockspace.\n- Censoring or filtering by content is a **slippery slope**: who decides what is â€œmoneyâ€ vs â€œdataâ€? It conflicts with [censorship resistance](/docs/glossary#censorship-resistance) and [neutrality](/docs/bitcoin/p2p-protocol) of the base layer.\n\n---\n\n## Relation to Other Disputes\n\n- **[OP_RETURN debate](/docs/controversies/op-return)**: OP_RETURN stores data in the base [transaction](/docs/bitcoin/transaction-lifecycle) and has explicit policy limits (e.g. `-datacarriersize`). Inscriptions use **witness** data, which is discounted and prunable; the limits and levers are different, but the underlying question is the same: how much nonâ€‘monetary data should Bitcoin carry?\n- **Blocksize wars**: Then, the fight was over **how much** capacity (bigger blocks vs [Layer 2](/docs/glossary#layer-2)). With Ordinals, the fight is over **what** uses that capacityâ€”only â€œmoneyâ€ or any feeâ€‘paying use.\n\n---\n\n## Current State\n\n- Ordinals and inscriptions are **valid** under current [consensus rules](/docs/glossary#consensus-rules). Changing that would require a [soft fork](/docs/glossary#soft-fork) or stricter relay/miner policy.\n- Some node and miner software offers **optional** filters; there is no network-wide standard. Miners can choose what to include based on [fee rate](/docs/glossary#fee-rate) and their own policy.\n- The controversy is ongoing: every fee spike or new token scheme (e.g. Runes) renews the â€œspam vs innovationâ€ debate.\n\n---\n\n## For Beginners\n\nUnderstanding Ordinals highlights two recurring themes in Bitcoin:\n\n1. **Neutrality**: The base layer does not distinguish â€œgoodâ€ vs â€œbadâ€ use of block space; it enforces [consensus](/docs/glossary#consensus) and [fee](/docs/glossary#transaction-fee) rules. Debates about inscriptions are largely about **policy** and **values**, not consensus.\n2. **Scarcity and the fee market**: Block space is limited. When demand is highâ€”from payments, [Lightning](/docs/glossary#lightning-network) channel opens, or inscriptionsâ€”[fees](/docs/bitcoin/transaction-fees) rise. That is by design; the argument is whether certain uses are desirable, not whether the fee market works.\n\n---\n\n## See Also\n\n- [Ordinals & Inscriptions](/docs/advanced/ordinals-inscriptions) â€“ Technical overview\n- [OP_RETURN Debate](/docs/controversies/op-return) â€“ Data on Bitcoin and policy limits\n- [Transaction Fees](/docs/bitcoin/transaction-fees) â€“ Fee market and fee estimation\n",
    "filename": "ordinals.md"
  },
  "/docs/controversies/energy-consumption": {
    "content": "# Energy Consumption\n\nBitcoin's energy consumption is one of the most debated topics in the cryptocurrency space. Critics argue that Bitcoin uses too much energy, while supporters point out that energy use is a security feature and that Bitcoin's consumption should be viewed in context with other global energy uses.\n\n## The Energy Debate\n\n### Energy Use Is Not Inherently Bad\n\nUsing energy is not a moral failing. It is the signature of civilization.\n\nThe Kardashev scale measures a civilization's advancement by its energy consumption. A Type I civilization harnesses all energy available on its planet. A Type II harnesses its star. A Type III harnesses its galaxy. By this measure, using *more* energy is not regression. It is evolution.\n\nEvery advancement in human history has required more energy: fire, agriculture, industry, computing, space exploration. The question has never been \"are we using too much energy?\" but rather \"are we using energy for things that matter?\"\n\n### The \"Too Much Energy\" Argument\n\nWhen someone says \"Bitcoin uses too much energy,\" they are not making a technical argument. They are making a **moral argument**: \"I don't think Bitcoin is valuable enough to justify its energy use.\"\n\nThis is an opinion about Bitcoin's worth, not a statement about physics or economics. Energy is neutral. It flows to wherever humans direct it.\n\nConsider what humanity chooses to spend energy on:\n\n- **Holiday lights**: ~200 TWh annually (more than Bitcoin)\n- **US military**: Trillions of dollars and immense energy to project force globally\n- **Air conditioning in the US alone**: ~6,500 TWh (50x Bitcoin's consumption)\n- **The global financial system**: ~5,000 TWh maintaining the infrastructure of fiat money\n\nIf Bitcoin's energy use is \"wasteful,\" then we must also ask: Is air conditioning wasteful? Are holiday lights? Is the military? These are not questions with objective answers, they are value judgments.\n\n### What Bitcoin's Energy Actually Does\n\nBitcoin's energy consumption is not waste. It performs a specific, irreplaceable function:\n\n- **Secures a global, permissionless monetary network**\n- **Provides financial sovereignty to billions of people**\n- **Creates a store of value immune to inflation and seizure**\n- **Enables instant, borderless value transfer**\n\nThe energy expenditure is the cost of removing trust from money. It replaces armies, banks, courts, and governments with mathematics and thermodynamics.\n\n### The Real Question\n\nThe debate is not about energy, it's about whether you believe Bitcoin is valuable.\n\nIf you believe a decentralized, censorship-resistant, inflation-proof monetary system is valuable, then Bitcoin's energy consumption is a bargain. If you don't believe Bitcoin is valuable, no amount of energy would be acceptable.\n\nThis is why the energy debate is ultimately unproductive. It disguises a subjective value judgment as an objective technical criticism. Those who oppose Bitcoin will always say it uses \"too much\" energy. Those who understand it will recognize that the energy is precisely what makes it work.\n\n---\n\n## Energy Use as a Security Feature\n\nBitcoin's [proof-of-work](/docs/glossary#proof-of-work-pow) mechanism requires significant computational resources, which translates to energy consumption. This is by design:\n\n- **Attack Cost**: To attack Bitcoin, an attacker would need to control more than 50% of the network's [hash rate](/docs/glossary#hash-rate), requiring enormous energy investment (see [51% attack](/docs/glossary#51-attack))\n- **Economic Security**: The cost of energy creates a real economic barrier to attacks\n- **Decentralization**: High energy costs prevent any single entity from controlling the network\n\n---\n\n## Renewable Energy Usage\n\nBitcoin mining has increasingly moved toward renewable energy sources:\n\n- **Hydroelectric Power**: Many mining operations use excess hydroelectric power\n- **Solar and Wind**: Mining operations located near renewable energy sources\n- **Flared Gas**: Some miners use otherwise-wasted natural gas from oil production\n- **Grid Balancing**: Mining can help balance renewable energy grids by consuming excess power\n\nAccording to the Bitcoin Mining Council (Q4 2021), Bitcoin mining used approximately 58.5% renewable energy.\n\n---\n\n## Energy Consumption in Context\n\nTo understand Bitcoin's energy consumption, it's helpful to compare it with other global energy uses. The following data is from 2021:\n\n### Global Energy Consumption Comparison\n\n| Sector | Annual Energy Consumption (TWh) | Notes |\n|--------|----------------------------------|-------|\n| **Total Global Energy** | ~165,000 TWh | All energy uses worldwide |\n| **Residential Buildings** | ~26,000 TWh | Global residential energy use |\n| **Air Conditioning (US alone)** | ~6,500 TWh | US air conditioning energy use |\n| **Construction** | ~6,000 TWh | Global construction industry |\n| **Finance & Insurance** | ~5,000 TWh | Global financial services sector |\n| **Aviation** | ~4,000 TWh | Global aviation industry |\n| **Banking** | ~750 TWh | Global banking sector |\n| **Gold Mining** | ~500 TWh | Global gold mining industry |\n| **Holiday Lights (US alone)** | ~200 TWh | US holiday lighting energy use |\n| **Bitcoin** | ~100-150 TWh | Bitcoin network (2021 estimate) |\n| **US Military** | ~30 TWh | US military energy consumption (30,000 GWh) |\n\n> Perspective on Energy Inequality\n> **350 million people in the US use more electricity for cooling than 1.1 billion people in Africa use for everything.**\n>\n> This stark comparison highlights the massive energy inequality between developed and developing nations. When evaluating Bitcoin's energy consumption, it's crucial to remember that energy use is not evenly distributed globally, and what seems like \"too much\" energy in one context may be trivial compared to other uses.\n\n\n### Key Observations\n\n1. **Bitcoin's Relative Size**: Bitcoin's energy consumption (~100-150 TWh) is a small fraction of global energy use (~165,000 TWh), representing approximately 0.06-0.09% of total global energy consumption.\n\n2. **Comparison to Other Industries**: Bitcoin uses less energy than:\n   - Residential buildings (26,000 TWh)\n   - US air conditioning alone (6,500 TWh)\n   - Construction industry (6,000 TWh)\n   - Finance & Insurance (5,000 TWh)\n   - Aviation (4,000 TWh)\n   - Banking (750 TWh)\n   - Gold mining (500 TWh)\n\n3. **Perspective**: US holiday lights alone consume more energy (~200 TWh) than Bitcoin's entire network (~100-150 TWh).\n\n---\n\n## Energy Efficiency Trends\n\nBitcoin mining has become more energy-efficient over time:\n\n- **Hardware Improvements**: [ASIC](/docs/glossary#asic-application-specific-integrated-circuit) miners have become more efficient\n- **Renewable Energy Adoption**: Increasing use of renewable energy sources\n- **Hash Rate Efficiency**: More hash power per unit of energy consumed\n- **[Mining Pool](/docs/glossary#mining-pool) Optimization**: Better coordination reduces wasted computation\n\n---\n\n## The Value Proposition\n\nSupporters argue that Bitcoin's energy consumption is justified by the value it provides:\n\n- **Financial Sovereignty**: Enables [censorship-resistant](/docs/glossary#censorship-resistance), borderless transactions\n- **Store of Value**: Provides a decentralized alternative to traditional monetary systems\n- **Network Security**: Energy consumption directly translates to network security\n- **Global Access**: Provides financial services to unbanked populations\n\n---\n\n## Environmental Concerns\n\n### Carbon Emissions\n\nThe environmental impact depends on the energy sources used:\n\n- **Renewable Energy**: Minimal carbon footprint\n- **Fossil Fuels**: Higher carbon emissions\n- **Mixed Sources**: Impact varies by region and energy mix\n\n### Mitigation Strategies\n\n- **Renewable Energy**: Increasing adoption of renewable energy sources\n- **Carbon Offsets**: Some mining operations purchase carbon offsets\n- **Efficiency Improvements**: Ongoing hardware and operational efficiency gains\n- **Location Optimization**: Mining operations moving to areas with excess renewable energy\n\n---\n\n## Future Outlook\n\n### Potential Changes\n\n- **Renewable Energy Growth**: As renewable energy becomes cheaper, mining will likely use more renewables\n- **Efficiency Gains**: Continued hardware improvements will increase efficiency\n- **Regulation**: Some jurisdictions may regulate mining energy use\n- **Technology**: Potential improvements in mining efficiency\n\n### Sustainability\n\nThe long-term sustainability of Bitcoin's energy consumption depends on:\n\n- **Renewable Energy Adoption**: How quickly mining moves to renewable sources\n- **Efficiency Improvements**: Rate of hardware and operational efficiency gains\n- **Network Growth**: How Bitcoin's energy consumption scales with adoption\n- **Regulatory Environment**: How governments regulate mining energy use\n\n---\n\n## Conclusion\n\nWhile Bitcoin does consume significant energy, it's important to view this consumption in context:\n\n- Bitcoin uses a relatively small fraction of global energy\n- Energy consumption is a security feature, not a bug\n- Mining increasingly uses renewable energy sources\n- The value provided by Bitcoin may justify its energy use\n\n---\n\n## Related Topics\n\n- [Proof-of-Work](/docs/mining/proof-of-work) - How Bitcoin's consensus mechanism works\n- [Mining Economics](/docs/mining/economics) - Economic incentives in Bitcoin mining\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - Another major Bitcoin controversy\n\n---\n\n## Resources\n\n- [Cambridge Bitcoin Electricity Consumption Index](https://ccaf.io/cbeci/index) - Real-time Bitcoin energy consumption estimates\n- [Bitcoin Energy Consumption](https://digiconomist.net/bitcoin-energy-consumption) - Alternative energy consumption estimates\n",
    "filename": "energy-consumption.md"
  },
  "/docs/controversies/criminal-use": {
    "content": "# Bitcoin and Criminal Use\n\nBitcoin is often framed as the currency of choice for criminals: drug dealers, ransom attacks, money launderers. Critics cite Silk Road, darknet markets, and ransomware as evidence that Bitcoin is inherently a tool for illicit activity. This framing is misleading. Bitcoin is just money. What people do with it is their decision. The vast majority of illicit financial activity globally occurs in US dollars and the traditional banking system, not in Bitcoin.\n\n## Money Is Neutral\n\n### A Tool, Not an Actor\n\nMoney is a tool. Like a knife, a car, or a phone, it can be used for good or ill. A knife can prepare dinner or commit violence. A car can transport family or flee a crime. Cash can pay rent or bribe an official. We do not blame the knife, the car, or the dollar bill for the choices of the person using it.\n\nBitcoin is no different. It is a [protocol](/docs/bitcoin) for transferring value. It does not judge. It does not refuse. It executes the rules that consensus agrees on. Holding Bitcoin responsible for criminal use is like holding the English language responsible for fraud because someone wrote a phishing email in it.\n\n### Responsibility Lies With the User\n\nThe person who chooses to break the law is responsible. The protocol that blindly processes valid [transactions](/docs/glossary#transaction) is not. Bitcoin does not know or care whether a [UTXO](/docs/glossary#utxo-unspent-transaction-output) was earned by mining, trading, or theft. It only checks signatures and rules.\n\nBlaming Bitcoin for crime confuses the instrument with the actor. The controversy is not really about Bitcoin: it is about whether we hold money itself responsible for its users' choices. The answer is no.\n\n---\n\n## The USD Reality\n\n### Where Illicit Activity Actually Lives\n\nMost illicit financial activity globally occurs in US dollars and the traditional banking system. Money laundering, sanctions evasion, corruption, drug trafficking, and fraud have used fiat currencies and banks for decades, long before Bitcoin existed.\n\nUNODC, FinCEN, and similar bodies consistently report that the bulk of illicit financial flows moves through correspondent banking, shell companies, and cash. Cryptocurrency represents a small fraction of illicit activity by volume. The US dollar remains the dominant currency for global crime precisely because it is the dominant currency for global commerce.\n\nBitcoin did not invent financial crime. It is one of many instruments that exist in a world where some people break the law. To single it out is to ignore where the problem actually lives.\n\n---\n\n## Why Bitcoin Gets the Blame\n\n### Transparency\n\nBitcoin's [blockchain](/docs/glossary#blockchain) is public. Every [transaction](/docs/glossary#transaction) is recorded. When Bitcoin appears in a crime (a ransom payment, a darknet sale), it is visible, traceable, and widely reported. Headlines follow.\n\nThe same cannot be said for cash. A briefcase of dollars changes hands in private. No public ledger. No headlines. Illicit use of fiat is largely invisible, so it is largely unremarked. Bitcoin gets blamed not because it is used more for crime, but because when it is used, we can see it.\n\n### Novelty\n\nBitcoin is new. \"Crypto\" attracts political and media attention. Fiat banking is ordinary; its role in crime is old news. The novelty of Bitcoin makes it a convenient villain and a useful narrative for regulators and politicians who want to justify [AML](/docs/glossary#aml-anti-money-laundering) and [KYC](/docs/glossary#kyc-know-your-customer) rules that extend state control over financial rails.\n\n### The Narrative Sells\n\nThe \"Bitcoin for criminals\" story fits agendas: more surveillance, more [KYC](/docs/glossary#kyc-know-your-customer), more gatekeepers at the borders of the [network](/docs/bitcoin/p2p-protocol). It is easier to rally support for cracking down on something that sounds dangerous and unfamiliar than to address the systemic role of fiat and banking in illicit flows.\n\n---\n\n## The Traceability Irony\n\nBitcoin is one of the *least* attractive currencies for sophisticated criminals who want to evade detection.\n\n- **Public ledger**: Every transaction is recorded. [Blockchain monitoring](/docs/bitcoin-development/blockchain-monitoring) and chain analysis can trace flows, cluster addresses, and link them to exchanges.\n- **KYC at off-ramps**: Converting Bitcoin to fiat usually requires an exchange or similar service that collects identity under [KYC](/docs/glossary#kyc-know-your-customer) and [AML](/docs/glossary#aml-anti-money-laundering) rules. That creates a durable link between on-chain activity and real-world identity.\n- **Cash is more anonymous**: Physical cash leaves no permanent record. For someone who wants to obscure the origin of funds, cash is far more convenient than a transparent, permanent blockchain.\n\nThis is why the narrative is ironic: the same transparency that makes Bitcoin's use in crime *visible* also makes it *traceable*. The idea that Bitcoin is the preferred tool for serious, organized crime does not hold up. It is used in some crimes because it is convenient for cross-border, digital payments, but so is the traditional banking system, at far greater scale.\n\n---\n\n## The Real Question\n\nThe question is not \"Is Bitcoin ever used by criminals?\" Any valuable tool is. The question is: **Should we hold money itself responsible for its users' choices?**\n\nThe answer is no. Bitcoin is neutral. It is a protocol. It does not have intentions, and it does not pick sides. The controversy is really about whether we treat money as a tool (something humans use, for better or worse) or as a moral agent to be blamed or praised.\n\nThose who condemn Bitcoin for criminal use while ignoring the role of the US dollar and the banking system in the vast majority of illicit finance are not making an honest argument about crime. They are making an argument about which forms of money they wish to control.\n\n---\n\n## Related Topics\n\n- [Blockchain Monitoring](/docs/bitcoin-development/blockchain-monitoring) - How on-chain activity can be traced and analyzed\n- [Wallet Privacy](/docs/wallets/privacy) - Privacy considerations when using Bitcoin\n- [Energy Consumption](/docs/controversies/energy-consumption) - Another external criticism of Bitcoin\n\n---\n\n## Resources\n\n- [UNODC Illicit Financial Flows](https://www.unodc.org/unodc/en/data-and-analysis/iff.html) and [FinCEN SAR Statistics](https://www.fincen.gov/reports/sar-stats): reports on illicit financial flows (predominantly fiat)\n- [Chainalysis Crypto Crime Report](https://www.chainalysis.com/reports/crypto-crime-2026/): research on the share of crypto transaction volume that is illicit (a small fraction of the total)\n",
    "filename": "criminal-use.md"
  },
  "/docs/controversies/etf-rejections": {
    "content": "# Bitcoin ETF Rejections (2017â€“2023)\n\nFor years, the U.S. Securities and Exchange Commission (SEC) rejected or delayed applications for a **spot** [Bitcoin ETF](/docs/glossary#bitcoin-etf). The main reasons were concerns about manipulation, custody, and market maturity. In January 2024, the SEC finally approved the first spot Bitcoin ETFs. The long refusal and eventual approval are an important part of Bitcoinâ€™s regulatory history.\n\n## What Is a Spot Bitcoin ETF?\n\nA **spot** Bitcoin ETF holds actual [bitcoin](/docs/glossary#btc) (or claims backed by it) and tracks its price. This is different from **futures-based** ETFs, which use Bitcoin futures contracts. Spot ETFs give traditional investors and institutions a familiar way to get price exposure without [self-custody](/docs/glossary#non-custodial-wallet) or [exchange](/docs/glossary#exchange) accounts.\n\n---\n\n## The Rejection Era (2017â€“2023)\n\n### Main SEC Concerns\n\nThe SEC repeatedly pointed to:\n\n1. **Manipulation**: Bitcoin spot markets were seen as more exposed to manipulation (wash trading, spoofing, limited oversight) than regulated futures markets. The SEC doubted that a spot ETF could have â€œsurveillance-sharingâ€ or similar safeguards.\n2. **Custody**: [Not your keys, not your coins](/docs/glossary#not-your-keys-not-your-coins). The SEC questioned whether issuers could custody bitcoin safely and whether investors would be adequately protected.\n3. **Market maturity**: Global spot markets were viewed as fragmented and less mature than established securities markets, making it harder to argue that manipulation could be detected and addressed.\n\n### Timeline of Rejections and Delays\n\n- **2017â€“2018**: The Winklevoss twinsâ€™ application for a spot Bitcoin ETF was rejected. Other applicants (ProShares, Direxion, GraniteShares, etc.) were also rejected. The SEC often cited the same manipulation and custody concerns.\n- **2019â€“2021**: More applications (e.g. VanEck, WisdomTree) were filed and repeatedly delayed; several were ultimately denied.\n- **2021**: The first **futures-based** Bitcoin ETF (ProShares Bitcoin Strategy ETF) was **approved**. The SEC treated the CMEâ€™s regulated futures market as a sufficiently controlled environment. Spot applications, by contrast, continued to be rejected or delayed.\n- **2022â€“2023**: Spot applications (including from BlackRock, Fidelity, and others) piled up. The SEC delayed decisions; court challenges and political pressure increased.\n\n### The Grayscale Lawsuit\n\nGrayscale had run a Bitcoin trust (GBTC) for years and sought to convert it into a spot ETF. After the SEC denied the conversion, Grayscale sued. In August 2023, a federal court ruled that the SECâ€™s denial was arbitrary and capricious because it had approved futures-based Bitcoin ETFs but rejected Grayscaleâ€™s spot product without adequately explaining the different treatment. The court did not order approval, but it forced the SEC to reâ€‘evaluate. This ruling strengthened the case for eventual spot ETF approval.\n\n---\n\n## January 2024: Spot Bitcoin ETFs Approved\n\nOn **January 10, 2024**, the SEC approved 11 spot Bitcoin ETF applications (including from BlackRock, Fidelity, Grayscale, and others). Trading began shortly after. The approvals followed:\n\n- The Grayscale court loss and pressure to treat spot and futures products consistently\n- Improved custody and surveillance arrangements proposed by issuers\n- Long-standing demand from institutional and retail investors\n\nThe approval is a major [milestone](/docs/history) for Bitcoinâ€™s integration with traditional finance: [Bitcoin ETF](/docs/glossary#bitcoin-etf) is now a standard term, and billions of dollars have flowed into these products.\n\n---\n\n## Why This Controversy Matters\n\n- **Regulation vs innovation**: The rejections showed that regulators can block or delay access to Bitcoin for a long time, even when demand exists. Approval showed that legal and political pressure, plus better-structured products, can change the outcome.\n- **Custody and trust**: ETF buyers do **not** hold [bitcoin](/docs/glossary#btc) directly; they rely on the issuer and its custodians. The â€œnot your keys, not your coinsâ€ [principle](/docs/glossary#not-your-keys-not-your-coins) still applies. ETFs are a **convenience and compliance** trade-off, not self-custody.\n- **Neutrality of Bitcoin**: The [Bitcoin network](/docs/glossary#bitcoin-network) kept operating regardless of ETF approvals or rejections. The controversy was about **access** in the traditional system, not about the [protocol](/docs/bitcoin) itself.\n\n---\n\n## See Also\n\n- [Bitcoin ETF](/docs/glossary#bitcoin-etf) â€“ Glossary definition\n- [Historical Milestones](/docs/history) â€“ 2024 Spot Bitcoin ETFs\n- [Not Your Keys, Not Your Coins](/docs/glossary#not-your-keys-not-your-coins) â€“ Self-custody\n",
    "filename": "etf-rejections.md"
  },
  "/docs/controversies/mt-gox": {
    "content": "# Mt. Gox Collapse\n\nMt. Gox was once the world's largest Bitcoin exchange, handling over 70% of all Bitcoin transactions at its peak. In February 2014, it collapsed spectacularly, losing approximately 850,000 BTC (worth ~$450 million at the time, and tens of billions at later prices). The Mt. Gox disaster became Bitcoin's defining cautionary tale and permanently shaped how the community thinks about custody, exchange security, and the principle of \"not your keys, not your coins.\"\n\n## The Rise of Mt. Gox\n\n### Origins\n\nMt. Gox began as a trading platform for Magic: The Gathering cards (the name stands for \"Magic: The Gathering Online eXchange\"). In 2010, programmer Jed McCaleb repurposed it as a Bitcoin exchange when Bitcoin was still worth pennies.\n\nIn 2011, McCaleb sold Mt. Gox to Mark KarpelÃ¨s, a French developer living in Japan. Under KarpelÃ¨s, the exchange grew rapidly alongside Bitcoin's rising price and popularity.\n\n### Dominance\n\nBy 2013, Mt. Gox was:\n- Handling 70%+ of global Bitcoin trading volume\n- The primary price discovery mechanism for Bitcoin\n- The de facto \"Bitcoin exchange\" for most users worldwide\n\nThis concentration of power in a single exchange was a ticking time bomb.\n\n---\n\n## The Collapse\n\n### Warning Signs\n\nProblems had been brewing for years:\n\n- **2011 Hack**: Mt. Gox was hacked, losing 25,000 BTC. This was kept quiet.\n- **Withdrawal Delays**: Users increasingly reported slow or failed withdrawals throughout 2013.\n- **Banking Issues**: Traditional banks were reluctant to work with Mt. Gox, causing fiat withdrawal problems.\n- **Technical Incompetence**: The codebase was reportedly a mess, with poor security practices.\n\n### The Final Days\n\nIn February 2014, events accelerated:\n\n1. **February 7**: Mt. Gox halted all Bitcoin withdrawals, citing \"transaction malleability\" issues.\n2. **February 10**: Other exchanges issued a joint statement distancing themselves from Mt. Gox.\n3. **February 24**: The website went completely offline.\n4. **February 25**: A leaked document revealed Mt. Gox had lost 744,408 BTC from customer deposits plus 100,000 of its own BTC.\n5. **February 28**: Mt. Gox filed for bankruptcy protection in Tokyo.\n\n### The Missing Bitcoin\n\nThe total loss was approximately:\n- **744,408 BTC** from customer accounts\n- **100,000 BTC** owned by Mt. Gox\n- **~$28 million** in fiat currency\n\nAt 2014 prices (~$450/BTC), this was about $450 million. At Bitcoin's 2021 peak (~$69,000/BTC), the lost coins would have been worth over $58 billion.\n\n---\n\n## What Happened?\n\n### The Official Story\n\nMt. Gox blamed \"[transaction malleability](/docs/glossary#transaction-malleability)\", a known Bitcoin quirk where [transaction IDs](/docs/glossary#transaction-id-txid) could be changed before [confirmation](/docs/glossary#confirmation) without invalidating the transaction. The exchange claimed hackers exploited this to steal Bitcoin over time.\n\n### The Reality\n\nInvestigations revealed a more damning picture:\n\n- **Theft Over Years**: The Bitcoin had been draining from Mt. Gox [wallets](/docs/glossary#wallet) since at least 2011.\n- **Poor Security**: [Private keys](/docs/glossary#private-key) were stored insecurely. The codebase was amateurish.\n- **No Audits**: Mt. Gox never conducted proper audits that would have revealed the missing funds.\n- **Possible Inside Job**: Some investigators believe insiders were involved in the theft.\n\nIn 2015, Mark KarpelÃ¨s was arrested in Japan on charges of embezzlement and data manipulation (though not directly for the Bitcoin theft). He was eventually convicted of data manipulation but acquitted of embezzlement.\n\n---\n\n## The Aftermath\n\n### Victims\n\nApproximately 24,000 creditors lost funds. Many were early Bitcoin adopters who had their entire holdings on the exchange. The bankruptcy proceedings have dragged on for nearly a decade.\n\n### Bitcoin Price Impact\n\nBitcoin's price crashed from ~$850 to under $400 in the months following the collapse. The broader cryptocurrency market was shaken.\n\n### Recovery Efforts\n\nIn a twist of fate, 200,000 BTC were later \"found\" in old Mt. Gox wallets. Combined with Bitcoin's price appreciation, the bankruptcy estate eventually had enough to potentially repay creditors in full, though the legal process has taken years.\n\nCreditor repayments finally began in 2024, over a decade after the collapse.\n\n---\n\n## Lessons Learned\n\n### \"Not Your Keys, Not Your Coins\"\n\nThe Mt. Gox collapse became the defining argument for self-custody. When you leave Bitcoin on an exchange:\n- You don't own Bitcoin; you own an IOU\n- You trust the exchange's security, competence, and honesty\n- You have no recourse if they fail\n\nThis mantra became foundational to Bitcoin culture.\n\n### Exchange Security Standards\n\nThe industry responded with:\n- **Proof of Reserves**: Cryptographic audits showing exchanges hold customer funds\n- **Cold Storage**: Keeping most funds offline\n- **[Multisig](/docs/glossary#multisig-multi-signature) Wallets**: Requiring multiple keys to move funds\n- **Regular Audits**: Independent verification of holdings\n\n### Regulatory Awareness\n\nMt. Gox operated in a regulatory gray zone. Its collapse prompted:\n- Increased regulatory scrutiny of exchanges\n- Licensing requirements in many jurisdictions\n- Debates about consumer protection vs. Bitcoin's permissionless ethos\n\n---\n\n## The Ongoing Saga\n\n### Bankruptcy Proceedings\n\nThe Mt. Gox bankruptcy has been one of the longest and most complex in cryptocurrency history:\n\n- **Civil Rehabilitation**: In 2018, proceedings converted from bankruptcy to civil rehabilitation, allowing creditors to receive Bitcoin rather than the (much lower) 2014 fiat value.\n- **Creditor Claims**: Complex legal battles over who is owed what.\n- **Distribution**: Final distribution began in 2024.\n\n### Market Impact\n\nEven a decade later, Mt. Gox affects markets:\n- Large creditor payouts create selling pressure fears\n- The \"Mt. Gox Bitcoin\" is tracked as a potential market-moving event\n- Each distribution milestone makes headlines\n\n---\n\n## Historical Significance\n\nMt. Gox represents a pivotal moment in Bitcoin history:\n\n1. **End of Innocence**: Bitcoin's early, naive era ended. The community learned that enthusiasm wasn't enough; security and proper engineering mattered.\n\n2. **Decentralization Validated**: The collapse showed the danger of centralized points of failure, reinforcing Bitcoin's core philosophy.\n\n3. **Culture Defined**: \"Not your keys, not your coins\" became more than a slogan. It became a core principle of Bitcoin culture.\n\n4. **Industry Matured**: Surviving exchanges implemented better practices. New exchanges learned from Mt. Gox's failures.\n\n5. **Bitcoin Survived**: Despite losing the dominant exchange, Bitcoin itself continued. The network was unaffected. Only the centralized exchange failed; the decentralized protocol kept running.\n\n---\n\n## Conclusion\n\nMt. Gox is the ghost that haunts every Bitcoin exchange. Its collapse cost early adopters billions of dollars and years of legal limbo. But it also taught the Bitcoin community invaluable lessons about the importance of self-custody, the dangers of centralization, and the difference between trusting Bitcoin the protocol and trusting businesses built on top of it.\n\nWhen you hear Bitcoiners say \"not your keys, not your coins,\" they're speaking the language of Mt. Gox survivors.\n\n---\n\n## Related Topics\n\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - Another major Bitcoin controversy\n- [Energy Consumption](/docs/controversies/energy-consumption) - The energy debate\n- [OP_RETURN Debate](/docs/controversies/op-return) - Data storage on Bitcoin\n\n---\n\n## Resources\n\n- [Mt. Gox Legal](https://www.mtgox.com/) - Official bankruptcy proceedings\n- [Wizsec Research](https://blog.wizsec.jp/) - Detailed investigation into the Mt. Gox hack\n",
    "filename": "mt-gox.md"
  },
  "/docs/controversies/craig-wright": {
    "content": "# Craig Wright / \"Faketoshi\"\n\nCraig Steven Wright is an Australian computer scientist who has claimed since 2016 to be Satoshi Nakamoto, the pseudonymous creator of Bitcoin. Despite years of assertions, lawsuits, and media appearances, Wright has never provided cryptographic proof of his claim. This is something the real Satoshi could trivially do by signing a message with Satoshi's known private keys.\n\nThe Bitcoin community overwhelmingly rejects Wright's claims, derisively calling him \"Faketoshi.\" His saga has become one of Bitcoin's strangest and most persistent controversies, involving forged documents, failed proofs, billion-dollar lawsuits, and the creation of Bitcoin SV (BSV).\n\n## The Claim\n\n### What Would Prove It\n\nThe real Satoshi Nakamoto has access to:\n- [Private keys](/docs/glossary#private-key) that mined the earliest Bitcoin blocks\n- The private key behind the [genesis block](/docs/glossary#genesis-block)\n- Keys controlling approximately 1 million unmoved BTC\n\nTo prove identity, Satoshi need only **sign a message** with one of these keys. This is trivial to do and impossible to fake. Every legitimate Bitcoiner would accept this as proof.\n\nCraig Wright has never done this.\n\n### What Wright Has Provided\n\nInstead of cryptographic proof, Wright has offered:\n- **Personal testimony**: \"Trust me, I'm Satoshi\"\n- **Documents**: Later shown to be backdated or forged\n- **Vague technical claims**: Often containing errors\n- **Private demonstrations**: To a few individuals, later disputed\n- **Legal threats**: Against anyone who publicly denies his claim\n\n---\n\n## Timeline of Events\n\n### 2015: Initial Leaks\n\nIn December 2015, Wired and Gizmodo published articles suggesting Craig Wright might be Satoshi, based on leaked documents and emails. Within days, Australian police raided Wright's home (related to tax issues, not Bitcoin).\n\nInitial excitement quickly faded as researchers found problems with the \"evidence.\"\n\n### 2016: The Failed Proof\n\nIn May 2016, Wright came forward publicly, claiming to be Satoshi in interviews with the BBC and The Economist. He demonstrated a signature verification to several prominent Bitcoin figures, including [Gavin Andresen](/docs/history/people#gavin-andresen) (an early Bitcoin developer).\n\n**The problem**: Wright's \"proof\" was quickly debunked. He had used a signature that was already publicly available on the blockchain, not a new signature proving key access. It was a sleight of hand, not cryptographic proof.\n\nWhen challenged to provide real proof, Wright wrote a blog post promising to move coins from a known Satoshi address. The post was deleted and replaced with an apology, claiming he didn't have the \"courage\" to continue. He never provided the proof.\n\nGavin Andresen later said he was \"bamboozled\" and regretted supporting Wright's claim.\n\n### 2017: Bitcoin Cash and Drama\n\nWright became involved in the Bitcoin Cash (BCH) community after the August 2017 fork. He positioned himself as a thought leader, claiming his Satoshi status gave him authority.\n\n### 2018: Bitcoin SV Fork\n\nIn November 2018, Wright led a contentious [hard fork](/docs/glossary#hard-fork) of Bitcoin Cash, creating Bitcoin Satoshi Vision (BSV). The fork was accompanied by threats of a \"[hash](/docs/glossary#hash-rate) war\" to destroy the original BCH chain.\n\nBSV was explicitly designed around Wright's interpretation of Satoshi's \"vision\", primarily larger blocks and removing protocol changes. The fork was backed by Calvin Ayre, an online gambling billionaire who has been Wright's primary financial supporter.\n\n### 2019â€“2023: The Lawsuit Era\n\nWright launched an aggressive legal campaign:\n\n- **Kleiman v. Wright (2021)**: The estate of Dave Kleiman, a deceased computer forensics expert, sued Wright for half of Satoshi's Bitcoin (~1.1 million BTC). Wright claimed he and Kleiman mined early Bitcoin together. A Florida jury found Wright liable for $100 million related to a joint venture, but the verdict didn't confirm or deny Wright was Satoshi.\n\n- **COPA v. Wright (2024)**: The Crypto Open Patent Alliance (backed by companies including Square, Coinbase, and others) sued Wright seeking a declaration that he is not Satoshi. In February 2024, a UK judge ruled definitively that **Craig Wright is not Satoshi Nakamoto** and that he had forged documents to support his claims.\n\n- **Defamation Threats**: Wright has threatened or sued numerous individuals and organizations for calling him a fraud, including Bitcoin developers, podcasters, and Twitter users.\n\n### 2024: The Verdict\n\nIn the COPA v. Wright trial, UK High Court Justice Mellor delivered a detailed ruling:\n\n- Craig Wright is **not Satoshi Nakamoto**\n- Wright **forged documents** on a \"grand scale\"\n- His evidence was \"deliberately false\"\n- The ruling was \"emphatic\"\n\nThe judge didn't mince words, describing Wright's claims as \"a lie\" and his evidence as fabricated.\n\n---\n\n## Evidence of Fraud\n\n### Forged Documents\n\nMultiple documents Wright presented as evidence have been proven to be backdated or fabricated:\n\n- **PGP keys**: Keys allegedly created in 2008 were shown to use cryptographic parameters that didn't exist until years later\n- **Blog posts**: Allegedly early writings about Bitcoin contained metadata showing they were created or modified much later\n- **Emails**: Headers and formatting inconsistent with claimed dates\n- **Academic papers**: Submitted to support his claims but containing anachronistic references\n\n### Failed Proofs\n\nEvery time Wright has been cornered into providing cryptographic proof, he has failed:\n\n- **May 2016**: Recycled a public signature instead of creating a new one\n- **Bonded Courier**: Claimed a bonded courier would deliver keys that would prove his identity; the courier never materialized\n- **Tulip Trust**: Claimed his Bitcoin was locked in a trust until 2020; when 2020 arrived, new excuses appeared\n\n### Technical Errors\n\nWright has made statements about Bitcoin that reveal misunderstandings a creator couldn't have:\n\n- Confused technical details about how Bitcoin works\n- Made claims about the protocol that are demonstrably false\n- Shown unfamiliarity with aspects of Bitcoin's design that Satoshi would know intimately\n\n---\n\n## Community Response\n\n### Bitcoin Community\n\nThe Bitcoin community overwhelmingly rejects Wright's claims:\n\n- **\"Faketoshi\"**: The derisive nickname is universally used\n- **Developers**: Bitcoin Core developers have been vocal in their rejection\n- **Researchers**: Cryptographers and security researchers have debunked his \"proofs\"\n- **Humor**: Wright has become a meme, with his claims treated as a running joke\n\n### BSV Community\n\nA small community of BSV supporters continues to believe Wright is Satoshi. BSV has experienced:\n- Declining market cap and relevance\n- Delistings from major exchanges (citing fraud concerns around Wright)\n- Isolation from the broader cryptocurrency ecosystem\n\n---\n\n## Why Does It Matter?\n\n### Protocol Control\n\nIf Wright were accepted as Satoshi, he could claim authority over Bitcoin's direction. His vision involves:\n- Massive block sizes (128MB+)\n- Removing privacy features\n- Making Bitcoin more amenable to government oversight\n- Aggressive patent enforcement\n\nThe community's rejection of Wright is partly about protecting Bitcoin from capture.\n\n### Legal Precedent\n\nWright's lawsuits have targeted:\n- Bitcoin developers (for alleged copyright infringement)\n- Anyone who publicly calls him a fraud\n- The Bitcoin whitepaper's distribution\n\nA successful Wright legal campaign could have chilling effects on Bitcoin development and free speech.\n\n### Reputation\n\nWright's saga damages Bitcoin's reputation with mainstream audiences who don't understand the nuances. Headlines about \"Satoshi suing developers\" or \"Bitcoin founder\" create confusion.\n\n---\n\n## The Real Satoshi\n\nWhile Wright is not Satoshi, the real Satoshi's identity remains unknown. Key facts:\n\n- **Satoshi's coins haven't moved**: The ~1 million BTC from early mining remain untouched since 2010\n- **No public appearances**: Satoshi stopped communicating in 2011 and has never returned\n- **Cryptographic proof pending**: Anyone with access to Satoshi's keys could prove it instantly\n\nThe contrast is stark: the real Satoshi has remained silent for 15+ years, while Wright can't stop claiming the title without ever providing proof.\n\n---\n\n## Conclusion\n\nThe Craig Wright saga is a bizarre footnote in Bitcoin history: a man who claims to be the creator but cannot prove it, who has forged documents and lost lawsuits, yet continues to assert his identity backed by a wealthy patron.\n\nFor the Bitcoin community, Wright serves as a useful reminder:\n\n- **Proof of work matters**: Claims require evidence. In Bitcoin, cryptographic proof is king.\n- **Decentralization protects**: Bitcoin has no CEO or founder who can be captured. Even if someone credibly claimed to be Satoshi, they couldn't control the protocol.\n- **The community decides**: [Consensus](/docs/glossary#consensus) (whether about code or identity) emerges from the network, not from proclamations.\n\nCraig Wright is not Satoshi Nakamoto. A UK High Court has ruled it. The cryptographic evidence (or lack thereof) proves it. And the Bitcoin community has always known it.\n\n---\n\n## Related Topics\n\n- [Mt. Gox Collapse](/docs/controversies/mt-gox) - Exchange disaster that shaped Bitcoin culture\n- [Blocksize Wars](/docs/controversies/blocksize-wars) - The scaling debate that led to Bitcoin Cash\n- [OP_RETURN Debate](/docs/controversies/op-return) - Data storage controversy\n\n---\n\n## Resources\n\n- [COPA v. Wright Judgment](https://www.judiciary.uk/judgments/copa-v-wright/) - The full UK court ruling\n- [Wizsec: Wright's Fake Documents](https://blog.wizsec.jp/2018/02/kleiman-v-craig-wright-bitcoins.html) - Detailed forensic analysis\n- [stopcraigwright.com](https://stopcraigwright.com/) - Community documentation of Wright's claims\n",
    "filename": "craig-wright.md"
  },
  "/docs/advanced": {
    "content": "# Advanced Topics\n\nThis section covers advanced, experimental, and specialized Bitcoin topics that extend beyond the core protocol and standard development practices.\n\n## What's in This Section\n\n### Layer 2 & Scaling Solutions\n\n- **[Sidechains & Layer 2](/docs/advanced/sidechains)** - Alternative scaling approaches including Liquid Network and Rootstock\n- **[Statechains](/docs/advanced/statechains)** - Federated sidechains for state transfer\n- **[Zero-Conf Channels](/docs/advanced/zero-conf-channels)** - Experimental Lightning channels usable before confirmation\n- **[Trampoline Routing](/docs/advanced/trampoline-routing)** - Advanced Lightning routing for mobile clients\n\n### Smart Contracts & Advanced Protocols\n\n- **[Atomic Swaps](/docs/advanced/atomic-swaps)** - Trustless cross-chain and cross-asset exchanges\n- **[Discreet Log Contracts (DLCs)](/docs/advanced/dlcs)** - Oracle-based smart contracts for Bitcoin\n\n### Privacy & Optimization\n\n- **[Bloom Filters](/docs/advanced/bloom-filters)** - Privacy-preserving SPV client technology\n\n### Data & Tokens on Bitcoin\n\n- **[Ordinals & Inscriptions](/docs/advanced/ordinals-inscriptions)** - Attaching data to satoshis; BRC-20, Runes, and blockspace impact\n\n### Governance & Evolution\n\n- **[Governance & Evolution](/docs/advanced/governance)** - How Bitcoin evolves through rough consensus and the BIP process\n- **[Covenants](/docs/advanced/covenants)** - Proposed opcodes (OP_CTV, SIGHASH_ANYPREVOUT) that would constrain how outputs can be spent\n\n---\n\n## Prerequisites\n\nBefore diving into advanced topics, ensure you understand:\n\n- [Bitcoin Protocol fundamentals](/docs/bitcoin)\n- [Lightning Network basics](/docs/lightning)\n- [Bitcoin Script](/docs/bitcoin/script)\n- [Transaction construction](/docs/bitcoin-development/transactions)\n\n---\n\n## Experimental Features\n\n**Warning**: Some topics in this section describe experimental or early-stage features:\n\n- **Zero-Conf Channels**: Requires trust assumptions\n- **Trampoline Routing**: Limited implementation support\n- **DLCs**: Emerging technology, active development\n- **Statechains**: Research stage, limited deployment\n\nAlways verify current implementation status and security considerations before using experimental features in production.\n\n---\n\n## Related Sections\n\n- [Bitcoin Protocol](/docs/bitcoin) - Core protocol documentation\n- [Lightning Network](/docs/lightning) - Standard Lightning features\n- [Wallets](/docs/wallets) - Privacy techniques and smart contracts\n- [Setup & Infrastructure](/docs/development) - Setup and infrastructure for Bitcoin development\n- [Bitcoin Development](/docs/bitcoin-development) - Practical development tasks\n",
    "filename": "overview.md"
  },
  "/docs/advanced/governance": {
    "content": "# Governance & Evolution\n\nBitcoin has no central authority. Its evolution happens through a decentralized process of rough consensus, where changes are proposed, discussed, and adopted (or rejected) by the community.\n\n## How Bitcoin Evolves\n\n### The Process\n\n```text\n1. Proposal: BIP (Bitcoin Improvement Proposal)\n2. Discussion: Community review and debate\n3. Implementation: Code written and tested\n4. Activation: Network-wide adoption\n5. Deployment: Soft fork or hard fork\n```\n\n### Key Principles\n\n- **Rough consensus**: No formal voting, but broad agreement needed\n- **Code is law**: Running code determines network rules\n- **Backward compatibility**: Soft forks preferred over hard forks\n- **Conservative changes**: Slow, careful evolution\n\n---\n\n## Bitcoin Improvement Proposals (BIPs)\n\n### BIP Types\n\n| Type | Description | Examples |\n|------|-------------|----------|\n| **Standards Track** | Protocol changes | BIP 141 (SegWit), BIP 341 (Taproot) |\n| **Informational** | Guidelines, information | BIP 2 (BIP Process) |\n| **Process** | Process changes | BIP 1, BIP 2 |\n\n### BIP Lifecycle\n\n```text\nDraft â†’ Proposed â†’ Final â†’ Withdrawn/Replaced\n```\n\n---\n\n## Activation Mechanisms\n\n### Soft Fork Activation\n\n**BIP 9 (Version Bits)**:\n- Miners signal in block version\n- Requires 95% threshold\n- Grace period for activation\n\n**User-Activated Soft Fork (UASF)**:\n- Nodes enforce rules\n- Community-driven\n- Used for SegWit activation\n\n### Hard Fork Activation\n\n- Requires all nodes to upgrade\n- Or acceptance of chain split\n- Rarely used (Bitcoin Cash split)\n\n---\n\n## Key Stakeholders\n\n### Miners\n\n- **Role**: Secure network, process transactions\n- **Influence**: Can signal for soft forks\n- **Limits**: Can't force unwanted changes\n\n### Developers\n\n- **Role**: Write code, propose changes\n- **Influence**: Technical expertise\n- **Limits**: Can't force adoption\n\n### Users/Node Operators\n\n- **Role**: Run nodes, validate rules\n- **Influence**: Ultimate authority (choose software)\n- **Power**: Can reject changes by not upgrading\n\n### Exchanges & Businesses\n\n- **Role**: Provide services, liquidity\n- **Influence**: Economic weight\n- **Limits**: Must follow network rules\n\n---\n\n## Historical Examples\n\n### SegWit Activation\n\n```text\nProcess:\n1. Proposed in 2015\n2. Years of debate (Blocksize Wars)\n3. UASF movement (BIP 148)\n4. Activated August 2017\n5. ~80% adoption today\n```\n\n### Taproot Activation\n\n```text\nProcess:\n1. Proposed 2018\n2. Community discussion\n3. BIP 9 activation\n4. Activated November 2021\n5. Growing adoption\n```\n\n---\n\n## Challenges\n\n### Coordination Problems\n\n- **No central authority**: Hard to coordinate changes\n- **Diverse interests**: Different stakeholders want different things\n- **Slow process**: Changes take years\n\n### Controversies\n\n- **Blocksize Wars**: Major debate over scaling\n- **Activation methods**: Disagreement on how to activate\n- **Philosophical differences**: Different visions for Bitcoin\n\n---\n\n## Best Practices\n\n### For Proposers\n\n1. **Write clear BIPs**: Document thoroughly\n2. **Get feedback**: Engage with community\n3. **Test thoroughly**: Extensive testing before activation\n4. **Be patient**: Changes take time\n\n### For Community\n\n1. **Participate**: Review proposals, provide feedback\n2. **Run nodes**: Your node validates rules\n3. **Stay informed**: Follow development discussions\n4. **Be respectful**: Constructive debate\n\n---\n\n## Related Topics\n\n- [BIPs](/docs/history/bips) - Bitcoin Improvement Proposals\n- [Forks](/docs/history/forks) - Protocol upgrades\n- [Controversies](/docs/controversies) - Major debates\n\n---\n\n## Resources\n\n- [BIP Repository](https://github.com/bitcoin/bips)\n- [Bitcoin Dev Mailing List](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n- [Bitcoin Optech](https://bitcoinops.org/) - Technical newsletter\n",
    "filename": "governance.md"
  },
  "/docs/advanced/sidechains": {
    "content": "# Sidechains & Layer 2 Alternatives\n\nSidechains are separate blockchains that are pegged to Bitcoin, allowing bitcoin to be moved between the main chain and sidechain. They provide alternative scaling solutions and specialized features.\n\n**Sidechains** are independent blockchains with their own consensus rules that are pegged to Bitcoin:\n\n```text\nBitcoin Mainnet:\nâ”œâ”€â”€ Lock bitcoin\nâ””â”€â”€ Receive sidechain tokens\n\nSidechain:\nâ”œâ”€â”€ Receive tokens\nâ”œâ”€â”€ Use sidechain features\nâ””â”€â”€ Unlock to return to Bitcoin\n```\n\n---\n\n## Major Sidechains\n\n### Liquid Network\n\n**Liquid** is a federated sidechain:\n\n```text\nFeatures:\n- Faster blocks (1 minute)\n- Confidential transactions\n- Asset issuance\n- Federated consensus (functionaries)\n```\n\n**Use cases**:\n- Exchange settlements\n- Faster transactions\n- Confidential amounts\n- Tokenized assets\n\n### Rootstock (RSK)\n\n**Rootstock** is a smart contract sidechain:\n\n```text\nFeatures:\n- EVM-compatible\n- Smart contracts\n- Merge mining with Bitcoin\n- Two-way peg\n```\n\n**Use cases**:\n- Smart contracts on Bitcoin\n- DeFi applications\n- Tokenization\n- Complex contracts\n\n---\n\n## How Sidechains Work\n\n### Two-Way Peg\n\n```text\n1. Lock bitcoin on mainnet\n2. Wait for confirmation period\n3. Receive tokens on sidechain\n4. Use sidechain features\n5. Lock tokens on sidechain\n6. Wait for confirmation\n7. Receive bitcoin on mainnet\n```\n\n### Peg Mechanisms\n\n**Federated Peg**:\n- Trusted functionaries\n- Faster, but requires trust\n- Used by Liquid\n\n**SPV Peg**:\n- Cryptographic proofs\n- More trustless\n- More complex\n\n---\n\n## Comparison with Lightning\n\n| Feature | Sidechains | Lightning Network |\n|---------|------------|-------------------|\n| **Trust Model** | Varies (federated/SPV) | Trustless |\n| **Speed** | Sidechain block time | Instant |\n| **Features** | Custom consensus | Payment channels |\n| **Complexity** | High | Medium |\n| **Use Case** | Specialized features | Payments |\n\n---\n\n## Limitations\n\n### Trust Requirements\n\n- **Federated sidechains**: Require trust in functionaries\n- **SPV sidechains**: More trustless but complex\n- **Security**: Sidechain security separate from Bitcoin\n\n### Trade-offs\n\n- **Trust vs. Features**: More features often require more trust\n- **Complexity**: More complex than Lightning\n- **Adoption**: Limited compared to Lightning\n\n---\n\n## Related Topics\n\n- [Lightning Network](/docs/lightning) - Payment channel network\n- [Statechains](/docs/advanced/statechains) - Alternative approach\n- [Governance](/docs/advanced/governance) - How Bitcoin evolves\n\n---\n\n## Resources\n\n- [Liquid Network](https://liquid.net/)\n- [Rootstock](https://www.rsk.co/)\n",
    "filename": "sidechains.md"
  },
  "/docs/advanced/atomic-swaps": {
    "content": "# Atomic Swaps\n\nAtomic swaps enable trustless peer-to-peer exchange of cryptocurrencies across different blockchains without requiring a trusted third party or centralized exchange.\n\n**Atomic swaps** use hash time-locked contracts (HTLCs) to ensure that either both parties receive their funds or neither does:\n\n```text\nAtomic Swap:\n- Alice wants to trade BTC for LTC\n- Bob wants to trade LTC for BTC\n- Either both succeed or both fail\n- No trusted intermediary needed\n```\n\n---\n\n## How Atomic Swaps Work\n\n### Process\n\n```text\n1. Alice creates HTLC on Bitcoin chain\n   - Locks BTC with hash lock\n   - Time lock for refund\n\n2. Bob creates HTLC on Litecoin chain\n   - Locks LTC with same hash\n   - Shorter time lock\n\n3. Alice reveals secret (preimage)\n   - Claims LTC from Bob's HTLC\n   - Reveals hash to Bob\n\n4. Bob uses secret to claim BTC\n   - Claims BTC from Alice's HTLC\n   - Swap complete\n```\n\n### Safety\n\n```text\nIf Alice doesn't reveal:\n- Bob's HTLC expires\n- Bob gets LTC back\n- Alice's HTLC expires\n- Alice gets BTC back\n\nIf Bob doesn't create HTLC:\n- Alice's HTLC expires\n- Alice gets BTC back\n- No loss for Alice\n```\n\n---\n\n## Code Examples\n\n### Creating HTLC\n\n:::code-group\n```rust\nuse bitcoin::{Script, ScriptBuf};\nuse bitcoin::opcodes::all::*;\n\nfn create_htlc_script(\n    hash: &[u8; 32],\n    recipient_pubkey: &[u8; 33],\n    refund_pubkey: &[u8; 33],\n    locktime: u32,\n) -> ScriptBuf {\n    let mut script = ScriptBuf::new();\n    \n    // Hash lock branch\n    script.push_opcode(OP_IF);\n    script.push_opcode(OP_HASH256);\n    script.push_slice(hash);\n    script.push_opcode(OP_EQUALVERIFY);\n    script.push_slice(recipient_pubkey);\n    script.push_opcode(OP_CHECKSIG);\n    \n    // Refund branch\n    script.push_opcode(OP_ELSE);\n    script.push_slice(locktime.to_le_bytes());\n    script.push_opcode(OP_CHECKLOCKTIMEVERIFY);\n    script.push_opcode(OP_DROP);\n    script.push_slice(refund_pubkey);\n    script.push_opcode(OP_CHECKSIG);\n    script.push_opcode(OP_ENDIF);\n    \n    script\n}\n```\n\n```python\nfrom bitcoin.core.script import CScript, OP_IF, OP_HASH256, OP_EQUALVERIFY\nfrom bitcoin.core.script import OP_CHECKSIG, OP_ELSE, OP_CHECKLOCKTIMEVERIFY\nfrom bitcoin.core.script import OP_DROP, OP_ENDIF\n\ndef create_htlc_script(hash_value, recipient_pubkey, refund_pubkey, locktime):\n    \"\"\"Create HTLC script for atomic swap.\"\"\"\n    return CScript([\n        OP_IF,\n        OP_HASH256,\n        hash_value,\n        OP_EQUALVERIFY,\n        recipient_pubkey,\n        OP_CHECKSIG,\n        OP_ELSE,\n        locktime,\n        OP_CHECKLOCKTIMEVERIFY,\n        OP_DROP,\n        refund_pubkey,\n        OP_CHECKSIG,\n        OP_ENDIF,\n    ])\n```\n\n```cpp\n#include <bitcoin/bitcoin.hpp>\n\nbc::script create_htlc_script(\n    const bc::hash_digest& hash,\n    const bc::ec_compressed& recipient_pubkey,\n    const bc::ec_compressed& refund_pubkey,\n    uint32_t locktime\n) {\n    bc::script script;\n    script.push_operation(bc::opcode::if_);\n    script.push_operation(bc::opcode::hash256);\n    script.push_data(bc::to_chunk(hash));\n    script.push_operation(bc::opcode::equalverify);\n    script.push_data(bc::to_chunk(recipient_pubkey));\n    script.push_operation(bc::opcode::checksig);\n    script.push_operation(bc::opcode::else_);\n    script.push_data(bc::to_chunk(locktime));\n    script.push_operation(bc::opcode::checklocktimeverify);\n    script.push_operation(bc::opcode::drop);\n    script.push_data(bc::to_chunk(refund_pubkey));\n    script.push_operation(bc::opcode::checksig);\n    script.push_operation(bc::opcode::endif);\n    return script;\n}\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/btcsuite/btcd/txscript\"\n)\n\nfunc createHTLCScript(\n\thash []byte,\n\trecipientPubkey []byte,\n\trefundPubkey []byte,\n\tlocktime uint32,\n) ([]byte, error) {\n\tbuilder := txscript.NewScriptBuilder()\n\t\n\t// Hash lock branch\n\tbuilder.AddOp(txscript.OP_IF)\n\tbuilder.AddOp(txscript.OP_HASH256)\n\tbuilder.AddData(hash)\n\tbuilder.AddOp(txscript.OP_EQUALVERIFY)\n\tbuilder.AddData(recipientPubkey)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\t\n\t// Refund branch\n\tbuilder.AddOp(txscript.OP_ELSE)\n\tbuilder.AddInt64(int64(locktime))\n\tbuilder.AddOp(txscript.OP_CHECKLOCKTIMEVERIFY)\n\tbuilder.AddOp(txscript.OP_DROP)\n\tbuilder.AddData(refundPubkey)\n\tbuilder.AddOp(txscript.OP_CHECKSIG)\n\tbuilder.AddOp(txscript.OP_ENDIF)\n\t\n\treturn builder.Script()\n}\n```\n\n```javascript\nconst bitcoin = require('bitcoinjs-lib');\n\nfunction createHTLCScript(hash, recipientPubkey, refundPubkey, locktime) {\n    return bitcoin.script.compile([\n        bitcoin.opcodes.OP_IF,\n        bitcoin.opcodes.OP_HASH256,\n        hash,\n        bitcoin.opcodes.OP_EQUALVERIFY,\n        recipientPubkey,\n        bitcoin.opcodes.OP_CHECKSIG,\n        bitcoin.opcodes.OP_ELSE,\n        bitcoin.script.number.encode(locktime),\n        bitcoin.opcodes.OP_CHECKLOCKTIMEVERIFY,\n        bitcoin.opcodes.OP_DROP,\n        refundPubkey,\n        bitcoin.opcodes.OP_CHECKSIG,\n        bitcoin.opcodes.OP_ENDIF,\n    ]);\n}\n```\n:::\n\n---\n\n## Lightning Network Swaps\n\nAtomic swaps can also work on Lightning Network:\n\n```text\nLightning Atomic Swap:\n- Swap between Lightning channels\n- Instant execution\n- Lower fees\n- Requires channel liquidity\n```\n\n---\n\n## Limitations\n\n### Requirements\n\n1. **Compatible blockchains**: Both must support HTLCs\n2. **Hash function compatibility**: Same hash function\n3. **Timing coordination**: Time locks must be coordinated\n4. **Liquidity**: Both parties need funds available\n\n### Challenges\n\n- **Complexity**: Requires technical knowledge\n- **Timing**: Time locks must be carefully set\n- **Liquidity**: Both chains need funds\n- **Adoption**: Limited user-friendly tools\n\n---\n\n## Related Topics\n\n- [HTLCs](/docs/lightning/routing/htlc) - Hash time-locked contracts\n- [Timelocks](/docs/bitcoin/timelocks) - Time-based conditions\n- [Lightning Network](/docs/lightning) - Off-chain swaps\n\n---\n\n## Resources\n\n- [Atomic Swaps](https://en.bitcoin.it/wiki/Atomic_swap)\n",
    "filename": "atomic-swaps.md"
  },
  "/docs/advanced/dlcs": {
    "content": "# Discreet Log Contracts (DLCs)\n\nDiscreet Log Contracts (DLCs) enable Bitcoin smart contracts that depend on external data (oracles) without revealing contract details on-chain until execution.\n\n**DLCs** are smart contracts that:\n\n- **Use oracles**: Depend on external data (prices, events)\n- **Privacy-preserving**: Contract terms hidden until execution\n- **Trustless**: No need to trust oracle (uses adaptor signatures)\n- **Bitcoin-native**: Work on Bitcoin blockchain\n\n---\n\n## How DLCs Work\n\n### Oracle Attestation\n\n```text\n1. Oracle signs outcome data\n2. Signature reveals outcome\n3. Contract parties use signature\n4. Contract executes based on outcome\n```\n\n### Adaptor Signatures\n\nDLCs use adaptor signatures:\n\n```text\nAdaptor Signature:\n- Pre-commits to outcome\n- Reveals outcome when used\n- Enables trustless oracle integration\n```\n\n---\n\n## Use Cases\n\n### Prediction Markets\n\n```text\nExample:\n- Contract: \"Bitcoin price > $50,000 on Jan 1\"\n- Oracle: Provides price data\n- Outcome: Funds go to correct party\n```\n\n### Derivatives\n\n```text\nExample:\n- Contract: Price difference payment\n- Oracle: Provides reference price\n- Settlement: Automatic based on price\n```\n\n### Insurance\n\n```text\nExample:\n- Contract: Weather-based insurance\n- Oracle: Provides weather data\n- Payout: Automatic if conditions met\n```\n\n---\n\n## Code Examples\n\n### Creating a DLC\n\n:::code-group\n```rust\n// DLC implementation requires specialized libraries\n// This is a conceptual example\n\nstruct DLCOutcome {\n    value: u64,\n    oracle_signature: [u8; 64],\n}\n\nfn execute_dlc(\n    contract: &DLCContract,\n    outcome: DLCOutcome,\n) -> Result<Transaction, DLCError> {\n    // Verify oracle signature\n    verify_oracle_signature(&outcome)?;\n    \n    // Create settlement transaction\n    let tx = create_settlement_tx(contract, outcome.value)?;\n    \n    Ok(tx)\n}\n```\n\n```python\n# DLC implementation requires specialized libraries\n# This is a conceptual example\n\ndef execute_dlc(contract, outcome):\n    \"\"\"Execute DLC based on oracle outcome.\"\"\"\n    # Verify oracle signature\n    verify_oracle_signature(outcome.oracle_signature)\n    \n    # Create settlement transaction\n    tx = create_settlement_tx(contract, outcome.value)\n    \n    return tx\n```\n\n```cpp\n// DLC implementation requires specialized libraries\n// This is a conceptual example\n\nstruct DLCOutcome {\n    uint64_t value;\n    std::array<uint8_t, 64> oracle_signature;\n};\n\nbc::transaction execute_dlc(\n    const DLCContract& contract,\n    const DLCOutcome& outcome\n) {\n    // Verify oracle signature\n    verify_oracle_signature(outcome.oracle_signature);\n    \n    // Create settlement transaction\n    return create_settlement_tx(contract, outcome.value);\n}\n```\n\n```go\n// DLC implementation requires specialized libraries\n// This is a conceptual example\n\ntype DLCOutcome struct {\n    Value          uint64\n    OracleSignature [64]byte\n}\n\nfunc executeDLC(contract *DLCContract, outcome DLCOutcome) (*wire.MsgTx, error) {\n    // Verify oracle signature\n    if err := verifyOracleSignature(outcome.OracleSignature); err != nil {\n        return nil, err\n    }\n    \n    // Create settlement transaction\n    return createSettlementTx(contract, outcome.Value)\n}\n```\n\n```javascript\n// DLC implementation requires specialized libraries\n// This is a conceptual example\n\nfunction executeDLC(contract, outcome) {\n    // Verify oracle signature\n    verifyOracleSignature(outcome.oracleSignature);\n    \n    // Create settlement transaction\n    return createSettlementTx(contract, outcome.value);\n}\n```\n:::\n\n---\n\n## Oracle Providers\n\n### Types of Oracles\n\n1. **Single Oracle**: One data source\n2. **Multi-Oracle**: Multiple sources, consensus\n3. **Decentralized Oracles**: Distributed data sources\n\n### Trust Model\n\n```text\nOracle Trust:\n- Oracle provides data\n- Parties trust oracle accuracy\n- Adaptor signatures prevent oracle from stealing\n- Oracle can't change outcome after signing\n```\n\n---\n\n## Limitations\n\n### Current State\n\n- **Early stage**: Active development\n- **Limited tooling**: Few user-friendly implementations\n- **Oracle dependency**: Requires trusted oracles\n- **Complexity**: Technical knowledge required\n\n### Challenges\n\n- **Oracle reliability**: Need trustworthy data sources\n- **Contract complexity**: More complex than simple payments\n- **Adoption**: Limited awareness and usage\n\n---\n\n## Related Topics\n\n- [Smart Contracts](/docs/wallets/smart-contracts) - Bitcoin scripting\n- [Timelocks](/docs/bitcoin/timelocks) - Time-based conditions\n- [Taproot](/docs/bitcoin/taproot) - Better privacy for contracts\n\n---\n\n## Resources\n\n- [DLC Specification](https://github.com/discreetlogcontracts/dlcspecs)\n- [DLC Developers](https://bitcoinops.org/en/topics/discreet-log-contracts/)\n",
    "filename": "dlcs.md"
  },
  "/docs/advanced/statechains": {
    "content": "# Statechains\n\nStatechains are a scaling solution that allows transferring bitcoin ownership off-chain through a federated service without requiring on-chain transactions for each transfer.\n\n**Statechains** enable off-chain bitcoin transfers:\n\n```text\nConcept:\n- Lock bitcoin on-chain once\n- Transfer ownership off-chain\n- No on-chain transaction per transfer\n- Federated service manages state\n```\n\n---\n\n## How Statechains Work\n\n### Initial Setup\n\n```text\n1. User locks bitcoin on-chain\n2. Creates statechain entry\n3. Federated service holds key share\n4. User holds key share\n```\n\n### Transfers\n\n```text\n1. User transfers to recipient\n2. Key shares updated off-chain\n3. No on-chain transaction\n4. Recipient can continue transferring\n```\n\n### Unlocking\n\n```text\n1. User wants to unlock\n2. Cooperates with federated service\n3. Creates on-chain transaction\n4. Bitcoin unlocked\n```\n\n---\n\n## Benefits\n\n### Advantages\n\n- **No on-chain fees**: Per transfer\n- **Fast transfers**: Instant off-chain\n- **Bitcoin native**: Uses real bitcoin\n- **No channel limits**: No liquidity constraints\n\n### Limitations\n\n- **Federated trust**: Requires trusted service\n- **Key management**: Complex key sharing\n- **Limited adoption**: Early stage technology\n\n---\n\n## Comparison\n\n| Feature | Statechains | Lightning | Sidechains |\n|---------|-------------|-----------|------------|\n| **Trust** | Federated | Trustless | Varies |\n| **Fees** | Low | Very low | Sidechain fees |\n| **Speed** | Instant | Instant | Block time |\n| **Complexity** | High | Medium | High |\n\n---\n\n## Related Topics\n\n- [Sidechains](/docs/advanced/sidechains) - Alternative scaling\n- [Lightning Network](/docs/lightning) - Payment channels\n- [Privacy Techniques](/docs/wallets/privacy) - Privacy improvements\n\n---\n\n## Resources\n\n- [Statechains Research](https://bitcoinwords.github.io/statechains-non-custodial-off-chain-bitcoin-transfer)\n",
    "filename": "statechains.md"
  },
  "/docs/advanced/ordinals-inscriptions": {
    "content": "# Ordinals & Inscriptions\n\nOrdinals and inscriptions are a method for attaching arbitrary data to individual [satoshis](/docs/glossary#sat-satoshi) on the Bitcoin blockchain. Introduced in early 2023 by Casey Rodarmor, the Ordinals protocol assigns unique identifiers to satoshis and allows \"inscribing\" content (images, text, JSON, or other files) into [witness data](/docs/glossary#witness) that gets stored on-chain.\n\nThe **Ordinals protocol** assigns a unique, sequential number to each satoshi based on the order it was mined. This creates a way to identify and track individual sats through [transactions](/docs/glossary#transaction) and [UTXOs](/docs/glossary#utxo-unspent-transaction-output). Key concepts: **Ordinal number** (a satoshi's position in the total supply, 0 to 2.1 quadrillion minus 1), **Ordinal theory** (tracks which ordinal numbers are in which UTXOs when [inputs](/docs/glossary#input) are spent, first-in-first-out by default), **Rare sats** (certain ordinals considered \"rare,\" e.g., first sat of a [halving](/docs/history/halvings) or [block](/docs/glossary#block) subsidy). When Bitcoin is spent, inputs are consumed in the order they appear and their ordinal numbers transfer to outputs in order (default: FIFO). Ordinals do not require a [soft fork](/docs/glossary#soft-fork) or [consensus](/docs/glossary#consensus) change; they are an agreed-upon numbering and tracking scheme that [full nodes](/docs/glossary#full-node) do not need to implement, only indexers and wallets that support Ordinals do.\n\n---\n\n## Inscriptions\n\n**Inscriptions** use the Ordinals protocol to attach content to a specific satoshi. The content is stored in the [witness](/docs/glossary#witness) (SegWit) portion of a transaction, often in an `OP_IF`/`OP_ENDIF` or similar pattern that is pruned from the [UTXO set](/docs/glossary#utxo-set) but remains in the blockchain.\n\n### Inscription Structure\n\n```text\n1. Envelope: Wrapped in script that is never executed (e.g., OP_FALSE OP_IF ... OP_ENDIF)\n2. Content type: MIME type (e.g., image/png, text/plain, application/json)\n3. Content: Raw bytes of the inscribed data\n```\n\n### Why Witness Data?\n\n- [SegWit](/docs/bitcoin/segwit) witness data is **discounted** in [block weight](/docs/glossary#block-size) (1 WU per byte vs 4 for non-witness)\n- Inscription data does not expand the UTXO set\n- Same consensus rules as other valid SegWit [scripts](/docs/bitcoin/script)\n\n---\n\n## BRC-20 and Other Token Standards\n\n**BRC-20** is an experimental, [fungible](/docs/glossary#fungibility) token standard on Bitcoin that uses JSON inscriptions to define \"transfer\" and \"mint\" operations. Similar in concept to [ERC-20](https://ethereum.org) on Ethereum, BRC-20 tokens do not use [Bitcoin Script](/docs/bitcoin/script) for logic; they rely on external indexers to parse inscription content and track balances.\n\n### Characteristics\n\n- **Inefficient**: Each \"transfer\" or \"mint\" typically requires a separate on-chain inscription and [transaction fees](/docs/bitcoin/transaction-fees)\n- **Indexer-dependent**: Balances and transfers are not enforced by consensus; they require off-chain indexing\n- **Blockspace**: During 2023â€“2024, BRC-20 and Ordinals activity contributed to [mempool](/docs/mining/mempool) congestion and higher [fee rates](/docs/glossary#fee-rate)\n\n### Runes\n\n**Runes** (by Casey Rodarmor, 2024) is an alternative fungible token protocol on Bitcoin designed to be more efficient than BRC-20 by using the OP_RETURN-style output and a more compact on-chain representation. Like BRC-20, it requires indexers to interpret protocol messages.\n\n---\n\n## Impact on Bitcoin\n\n### Blockspace and Fees\n\n- Inscriptions and BRC-20 can generate many [transactions](/docs/bitcoin/transaction-lifecycle) competing for [block](/docs/bitcoin/blocks) space\n- During peaks, [fee rates](/docs/bitcoin/transaction-fees) increased, affecting users making ordinary [on-chain](/docs/glossary#on-chain) payments\n\n### Consensus and Policy\n\n- Ordinals and inscriptions use existing [SegWit](/docs/bitcoin/segwit) and [Taproot](/docs/bitcoin/taproot) rules; they are **valid** under current [consensus rules](/docs/glossary#consensus-rules)\n- Limits on data size (e.g., `-datacarriersize` for [OP_RETURN](/docs/controversies/op-return)) are **relay policy**, not consensus; witness-based inscriptions are subject to node policy (e.g., non-standard or size limits) in some configurations\n\n### Debate\n\nViews in the Bitcoin community vary:\n\n- **Supporters**: Ordinals demonstrate programmability, bring new use cases and users, and show that blockspace is a scarce resource with a [fee market](/docs/bitcoin/transaction-fees).\n- **Critics**: They argue inscriptions and token protocols consume blockspace for non-monetary data, raise fees for [peer-to-peer](/docs/bitcoin/p2p-protocol) cash use, and rely on extra-protocol indexing.\n\n---\n\n## Technical Summary\n\n| Aspect | Ordinals | Inscriptions |\n|--------|----------|---------------|\n| **Purpose** | Number and track satoshis | Attach data to a satoshi |\n| **Storage** | No extra data; ordering only | Witness (SegWit) data |\n| **Consensus** | Not enforced by nodes | Must be valid SegWit script |\n| **Indexing** | Required for tracking | Required for content retrieval |\n\n---\n\n## Related Topics\n\n- [OP_RETURN Debate](/docs/controversies/op-return) â€“ Data on Bitcoin and blockspace use\n- [SegWit](/docs/bitcoin/segwit) â€“ Witness discount and structure\n- [Transaction Fees](/docs/bitcoin/transaction-fees) â€“ Fee market and fee estimation\n- [Mempool](/docs/mining/mempool) â€“ How transactions are queued\n\n---\n\n## Resources\n\n- [Ordinals Handbook](https://docs.ordinals.com/) â€“ Official Ordinals documentation\n- [BRC-20 Spec](https://domo-2.gitbook.io/brc-20-experiment/) â€“ BRC-20 experiment description\n- [Runes](https://runes.network/) â€“ Runes protocol overview\n",
    "filename": "ordinals-inscriptions.md"
  },
  "/docs/advanced/bloom-filters": {
    "content": "# Bloom Filters\n\nBloom filters are a probabilistic data structure used by SPV (Simplified Payment Verification) clients to request relevant transactions from full nodes without revealing exactly which addresses they're interested in.\n\n**Bloom filters** allow SPV clients to:\n\n- **Request transactions**: Without revealing addresses\n- **Privacy**: Partial privacy protection\n- **Efficiency**: Compact representation\n- **False positives**: Possible but manageable\n\n---\n\n## How Bloom Filters Work\n\n### Construction\n\n```text\n1. Add addresses to filter\n2. Hash addresses multiple times\n3. Set bits in filter array\n4. Send filter to full node\n5. Node filters transactions\n6. Returns matching transactions\n```\n\n### Querying\n\n```text\nFull Node:\n1. Receives bloom filter\n2. Checks each transaction\n3. If filter matches, includes transaction\n4. May include false positives\n5. Sends matching transactions\n```\n\n---\n\n## Privacy Trade-offs\n\n### Privacy Benefits\n\n- **Address hiding**: Doesn't reveal exact addresses\n- **Plausible deniability**: False positives provide cover\n\n### Privacy Limitations\n\n- **Pattern analysis**: Multiple queries reveal patterns\n- **False positive rate**: Can be analyzed\n- **Not perfect**: Better than nothing, but not anonymous\n\n---\n\n## Modern Alternatives\n\n### Compact Block Filters (BIP 158)\n\n**Compact block filters** replace bloom filters:\n\n```text\nBenefits:\n- Better privacy\n- More efficient\n- Standardized format\n- Used by modern SPV clients\n```\n\n### Comparison\n\n| Feature | Bloom Filters | Compact Block Filters |\n|---------|---------------|----------------------|\n| **Privacy** | Partial | Better |\n| **Efficiency** | Good | Better |\n| **Standardization** | BIP 37 | BIP 158 |\n| **Adoption** | Legacy | Modern |\n\n---\n\n## Code Examples\n\n### Creating a Bloom Filter\n\n:::code-group\n```rust\nuse bitcoin::bloom::BloomFilter;\nuse bitcoin::hashes::Hash;\nuse bitcoin::hash_types::FilterHash;\n\nfn create_bloom_filter(addresses: &[String]) -> BloomFilter {\n    let mut filter = BloomFilter::new(10000, 0.001, 0, 0);\n    \n    for address in addresses {\n        let hash = FilterHash::hash(address.as_bytes());\n        filter.insert(&hash);\n    }\n    \n    filter\n}\n```\n\n```python\nimport mmh3\nimport struct\n\ndef create_bloom_filter(addresses, size=10000, error_rate=0.001):\n    \"\"\"Create bloom filter for addresses.\"\"\"\n    import bitarray\n    filter_array = bitarray.bitarray(size)\n    filter_array.setall(0)\n    \n    num_hashes = int(-size * math.log(error_rate) / (math.log(2) ** 2))\n    \n    for address in addresses:\n        for i in range(num_hashes):\n            hash_val = mmh3.hash(address, i) % size\n            filter_array[hash_val] = 1\n    \n    return filter_array\n```\n\n```cpp\n#include <vector>\n#include <bitset>\n#include <functional>\n\nclass BloomFilter {\nprivate:\n    std::bitset<10000> bits;\n    size_t num_hashes;\n    \npublic:\n    BloomFilter(double error_rate) {\n        num_hashes = -10000 * log(error_rate) / (log(2) * log(2));\n    }\n    \n    void add(const std::string& item) {\n        for (size_t i = 0; i < num_hashes; ++i) {\n            std::hash<std::string> hasher;\n            size_t hash = hasher(item + std::to_string(i));\n            bits[hash % 10000] = true;\n        }\n    }\n    \n    bool contains(const std::string& item) const {\n        for (size_t i = 0; i < num_hashes; ++i) {\n            std::hash<std::string> hasher;\n            size_t hash = hasher(item + std::to_string(i));\n            if (!bits[hash % 10000]) return false;\n        }\n        return true;\n    }\n};\n```\n\n```go\npackage main\n\nimport (\n\t\"hash/fnv\"\n)\n\ntype BloomFilter struct {\n\tbits      []bool\n\tsize      int\n\tnumHashes int\n}\n\nfunc NewBloomFilter(size int, errorRate float64) *BloomFilter {\n\tnumHashes := int(-float64(size) * math.Log(errorRate) / (math.Log(2) * math.Log(2)))\n\treturn &BloomFilter{\n\t\tbits:      make([]bool, size),\n\t\tsize:      size,\n\t\tnumHashes: numHashes,\n\t}\n}\n\nfunc (bf *BloomFilter) Add(item string) {\n\tfor i := 0; i < bf.numHashes; i++ {\n\t\thash := fnv.New32a()\n\t\thash.Write([]byte(item + string(rune(i))))\n\t\tindex := int(hash.Sum32()) % bf.size\n\t\tbf.bits[index] = true\n\t}\n}\n```\n\n```javascript\nclass BloomFilter {\n    constructor(size = 10000, errorRate = 0.001) {\n        this.bits = new Array(size).fill(false);\n        this.size = size;\n        this.numHashes = Math.ceil(-size * Math.log(errorRate) / (Math.log(2) ** 2));\n    }\n    \n    add(item) {\n        for (let i = 0; i < this.numHashes; i++) {\n            const hash = this.hash(item + i);\n            this.bits[hash % this.size] = true;\n        }\n    }\n    \n    hash(str) {\n        let hash = 0;\n        for (let i = 0; i < str.length; i++) {\n            hash = ((hash << 5) - hash) + str.charCodeAt(i);\n            hash = hash & hash;\n        }\n        return Math.abs(hash);\n    }\n}\n```\n:::\n\n---\n\n## Related Topics\n\n- [SPV](/docs/glossary#spv-simplified-payment-verification) - Simplified payment verification\n- [Node Types](/docs/development/node-types) - Different node configurations\n- [Privacy Techniques](/docs/wallets/privacy) - Privacy improvements\n\n---\n\n## Resources\n\n- [BIP 37: Bloom Filters](https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki)\n- [BIP 158: Compact Block Filters](https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki)\n",
    "filename": "bloom-filters.md"
  },
  "/docs/advanced/zero-conf-channels": {
    "content": "# Zero-Conf Channels\n\nZero-conf channels (also called turbo channels) allow Lightning channels to be used immediately after the funding transaction is broadcast, without waiting for blockchain confirmations.\n\n## The Confirmation Problem\n\nStandard Lightning channel opening requires:\n\n1. Broadcast funding transaction\n2. Wait for 3-6 confirmations (30-60 minutes)\n3. Channel becomes usable\n\n**Impact**: Users must wait before they can send or receive payments through the new channel.\n\n---\n\n## How Zero-Conf Works\n\nZero-conf channels allow immediate use by accepting unconfirmed funding:\n\n```text\nStandard Channel:\nFund tx broadcast â†’ Wait 3-6 blocks â†’ Channel active\n\nZero-Conf Channel:\nFund tx broadcast â†’ Channel active immediately\n                  â†’ Funds usable right away\n                  â†’ Confirmation happens in background\n```\n\n### Trust Requirement\n\nZero-conf requires trusting the channel funder:\n\n- **Single-funded**: The funder could double-spend before confirmation\n- **Dual-funded**: More complex trust considerations\n- **Receiving side trust**: Recipient trusts funder won't double-spend\n\n---\n\n## Use Cases\n\n### Lightning Service Providers (LSPs)\n\nMost common use case:\n\n```text\nUser â†’ LSP: \"I want inbound liquidity\"\nLSP â†’ User: Opens zero-conf channel\nUser: Can receive payments immediately\nLSP: Trusts their own funding tx won't double-spend\n```\n\nThe LSP trusts themselves (they created the funding tx).\n\n### Merchant Onboarding\n\nFast onboarding for new merchants:\n\n```text\n1. Merchant requests channel\n2. LSP opens zero-conf channel to merchant\n3. Merchant can accept payments in seconds\n4. No 1-hour wait for first customer\n```\n\n### Mobile Wallets\n\nInstant setup for mobile users:\n\n```text\n1. User installs wallet\n2. Wallet provider opens channel\n3. User can receive immediately\n4. Seamless first-time experience\n```\n\n---\n\n## Trust Model\n\n### Who Trusts Whom?\n\n| Scenario | Trust Required |\n|----------|----------------|\n| LSP opens to user | LSP trusts itself |\n| User opens to LSP | LSP trusts user (risky) |\n| Peer-to-peer | Mutual trust needed |\n\n### Risk Assessment\n\nThe receiver of zero-conf funds takes the risk:\n\n```text\nAttack Vector:\n1. Alice opens zero-conf channel to Bob\n2. Bob accepts, provides service/goods\n3. Alice double-spends funding tx\n4. Channel never existed, Bob loses out\n```\n\n**Mitigation**: Only accept zero-conf from trusted parties (typically LSPs opening TO users).\n\n---\n\n## Implementation\n\n### LND Configuration\n\n```bash\n# lnd.conf - Enable zero-conf channels\n[protocol]\nprotocol.option-scid-alias=true\nprotocol.zero-conf=true\n\n# Per-peer trust (open with --zero_conf flag)\nlncli openchannel --node_key=<pubkey> --local_amt=100000 --zero_conf\n```\n\n### Accepting Zero-Conf\n\n```bash\n# Configure which peers you trust for zero-conf\n# In lnd.conf or via RPC\n\n# Accept zero-conf from specific peer\nlncli updatechanpolicy --zero_conf_accepted=true --chan_point=<chan_point>\n```\n\n### SCID Alias\n\nZero-conf channels use SCID (Short Channel ID) aliases because they don't have a confirmed funding transaction to derive a real SCID:\n\n```text\nReal SCID: block_height:tx_index:output_index\n           (requires confirmation)\n\nAlias SCID: Randomly generated\n            (works before confirmation)\n```\n\n---\n\n## Feature Negotiation\n\nZero-conf requires both peers to support:\n\n| Feature Bit | Name | Purpose |\n|-------------|------|---------|\n| 44/45 | option_scid_alias | Alias-based channel IDs |\n| 50/51 | option_zeroconf | Zero-conf support |\n\n### Channel Type\n\nWhen opening a channel, request zero-conf:\n\n```text\nChannel Type Bits:\n- 12: static_remotekey\n- 22: anchors_zero_fee_htlc_tx\n- 50: option_zeroconf (zero-conf request)\n- 44: option_scid_alias (required for zero-conf)\n```\n\n---\n\n## Limitations\n\n### No Forwarding\n\nZero-conf channels cannot forward payments until confirmed:\n\n```text\nBefore Confirmation:\n- Can send through channel: Yes\n- Can receive to channel: Yes\n- Can route THROUGH channel: No\n```\n\nThis prevents routing nodes from being exploited.\n\n### Confirmation Still Matters\n\nZero-conf doesn't eliminate confirmation need:\n\n- Funding tx must eventually confirm\n- If it doesn't confirm, channel fails\n- RBF attacks can invalidate channel\n\n### Maximum HTLC Limits\n\nUntil confirmed, prudent to limit HTLC sizes:\n\n```text\nUnconfirmed: Limit HTLCs to small amounts\nConfirmed: Full channel capacity available\n```\n\n---\n\n## Security Considerations\n\n### Double-Spend Attack\n\nMost significant risk:\n\n```text\n1. Attacker opens zero-conf channel\n2. Victim accepts and provides value\n3. Attacker broadcasts competing tx (double-spend)\n4. Funding tx never confirms\n5. Channel never existed\n```\n\n**Defenses**:\n- Only accept from trusted parties\n- Limit value at risk before confirmation\n- Monitor mempool for conflicts\n\n### RBF Concerns\n\nReplace-By-Fee can replace the funding tx:\n\n```text\n1. Attacker opens channel with low-fee funding tx\n2. Victim accepts zero-conf\n3. Attacker RBFs with different outputs\n4. Channel funding invalidated\n```\n\n**Mitigation**: Ensure funding tx is not RBF-signaling (nSequence).\n\n---\n\n## Best Practices\n\n### For LSPs\n\n1. **Only open TO users**: Don't accept zero-conf from untrusted peers\n2. **Monitor funding txs**: Watch for conflicts in mempool\n3. **Limit exposure**: Cap zero-conf channel sizes\n4. **Fast confirmation**: Use appropriate fees for quick confirmation\n\n### For Users\n\n1. **Trust your LSP**: Only use reputable providers\n2. **Small channels first**: Don't open huge zero-conf channels\n3. **Verify confirmation**: Monitor that channel eventually confirms\n\n### For Developers\n\n```text\nImplementation Checklist:\nâ–¡ Support option_scid_alias\nâ–¡ Support option_zeroconf  \nâ–¡ Implement alias-based routing\nâ–¡ Disable forwarding until confirmed\nâ–¡ Monitor funding tx status\nâ–¡ Handle confirmation failures gracefully\n```\n\n---\n\n## Flow Diagram\n\n```text\nZero-Conf Channel Open:\n\nUser                    LSP\n  â”‚                      â”‚\n  â”‚â”€â”€â”€Request channelâ”€â”€â”€>â”‚\n  â”‚                      â”‚\n  â”‚<â”€â”€Accept (zero-conf)â”€â”‚\n  â”‚                      â”‚\n  â”‚<â”€â”€Funding tx createdâ”€â”‚\n  â”‚                      â”‚\n  â”‚<â”€â”€Channel active!â”€â”€â”€â”€â”‚  (no wait)\n  â”‚                      â”‚\n  â”‚   Use channel...     â”‚\n  â”‚                      â”‚\n  â”‚   (Meanwhile...)     â”‚\n  â”‚                      â”‚\n  â”‚<â”€â”€Funding confirmedâ”€â”€â”‚  (background)\n  â”‚                      â”‚\n  â”‚   Full functionality â”‚\n```\n\n---\n\n## Comparison\n\n| Aspect | Standard | Zero-Conf |\n|--------|----------|-----------|\n| Time to use | 30-60 min | Seconds |\n| Trust needed | None | Yes (funder) |\n| Can forward | Yes | After confirm |\n| Double-spend risk | None | Yes |\n| Best for | Peer-to-peer | LSP services |\n\n---\n\n## Summary\n\nZero-conf channels provide:\n\n- **Instant usability**: No waiting for confirmations\n- **Better UX**: Seamless onboarding experience\n- **LSP friendly**: Perfect for liquidity providers\n- **Trust trade-off**: Speed in exchange for trust assumption\n\n---\n\n## When to Use Zero-Conf\n\n**Good fit**:\n- LSP opening channel to user\n- Merchant onboarding via trusted provider\n- Mobile wallet initial setup\n\n**Poor fit**:\n- Peer-to-peer with strangers\n- Large channel amounts\n- When you're the one providing value upfront\n\n---\n\n## Related Topics\n\n- [Channels](/docs/lightning/channels) - Channel lifecycle\n- [Anchor Outputs](/docs/lightning/anchor-outputs) - Modern channel format\n\n---\n\n## Resources\n\n- [BOLT 2: Zero-Conf](https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-channel_type-feature)\n- [LND Zero-Conf Guide](https://docs.lightning.engineering/lightning-network-tools/pool/zero-confirmation-channels)\n",
    "filename": "zero-conf-channels.md"
  },
  "/docs/advanced/trampoline-routing": {
    "content": "# Trampoline Routing\n\nTrampoline routing allows lightweight Lightning clients to delegate pathfinding to intermediate nodes. Instead of computing the entire route, the sender specifies trampoline nodes that find the path to the destination.\n\n## The Mobile Routing Problem\n\nStandard Lightning routing requires:\n\n1. Downloading the entire network graph (~100MB+)\n2. Keeping the graph synchronized\n3. Computing routes through thousands of nodes\n\n**Problems for mobile**:\n- Bandwidth: Downloading/syncing graph uses data\n- Storage: Graph too large for some devices\n- Battery: Graph sync and pathfinding drain power\n- Time: Initial sync takes minutes\n\n---\n\n## How Trampoline Works\n\nInstead of full pathfinding, the sender:\n\n1. Picks one or more \"trampoline nodes\"\n2. Creates an onion to the first trampoline\n3. Tells the trampoline where to forward (next trampoline or destination)\n4. Trampoline computes the actual route\n\n```text\nStandard Routing:\nSender â†’ A â†’ B â†’ C â†’ D â†’ Recipient\n(Sender knows entire path)\n\nTrampoline Routing:\nSender â†’ T1 â†’ [?] â†’ T2 â†’ [?] â†’ Recipient\n(Sender only knows trampolines, trampolines find actual hops)\n```\n\n---\n\n## Architecture\n\n### Two-Layer Onion\n\nTrampoline uses nested onion routing:\n\n```text\nOuter Onion (sender builds):\nâ”œâ”€â”€ Layer 1: First hop\nâ”œâ”€â”€ Layer 2: Second hop\nâ””â”€â”€ Layer 3: Trampoline T1\n    â””â”€â”€ Inner Onion (trampoline instruction):\n        â”œâ”€â”€ Next trampoline: T2\n        â””â”€â”€ Or: Final destination\n\nTrampoline T1 receives:\nâ”œâ”€â”€ Outer onion layer (decrypts)\nâ”œâ”€â”€ Inner onion (trampoline payload)\nâ”œâ”€â”€ Instructions: \"Forward to T2\"\nâ””â”€â”€ Builds new outer onion: T1 â†’ [...] â†’ T2\n```\n\n### Payment Flow\n\n```text\n1. Sender builds outer onion to T1\n   - Contains inner onion with \"forward to Recipient via T2\"\n   \n2. T1 receives, decrypts outer layer\n   - Reads inner onion: \"forward to T2\"\n   - Computes route: T1 â†’ X â†’ Y â†’ T2\n   - Builds new outer onion for X â†’ Y â†’ T2\n   - Includes inner onion for T2\n\n3. T2 receives, decrypts\n   - Reads inner onion: \"deliver to Recipient\"\n   - Computes route: T2 â†’ Z â†’ Recipient\n   - Builds final outer onion\n\n4. Recipient receives payment\n```\n\n---\n\n## Privacy Trade-offs\n\n### What Trampolines Learn\n\n| Information | Standard | Trampoline |\n|-------------|----------|------------|\n| Sender identity | Hidden | Hidden from T2+, known to T1 |\n| Recipient identity | Hidden | Known to final trampoline |\n| Payment amount | Partial | Yes (for fee calculation) |\n| Route length | Hidden | Partially visible |\n\n### Privacy Considerations\n\n**Reduced sender privacy**:\n- First trampoline knows you're the sender\n- Uses your channel to them as first hop\n\n**Reduced recipient privacy**:\n- Final trampoline knows the destination\n- May learn payment patterns\n\n**Mitigation**:\n- Use multiple trampolines\n- Rotate trampoline selection\n- Add dummy hops\n\n---\n\n## Implementation\n\n### Feature Bits\n\nTrampoline support advertised via:\n\n| Bit | Name | Description |\n|-----|------|-------------|\n| 56/57 | trampoline_routing | Trampoline node support |\n\n### TLV Payload\n\nTrampoline data in inner onion:\n\n```text\nType 66100: Trampoline packet\nâ”œâ”€â”€ Version (1 byte)\nâ”œâ”€â”€ Public key (33 bytes) - Next trampoline or recipient\nâ”œâ”€â”€ Amount to forward (var)\nâ”œâ”€â”€ Outgoing CLTV (4 bytes)\nâ”œâ”€â”€ Features (var)\nâ””â”€â”€ Encrypted payload for next trampoline\n```\n\n### Fee Handling\n\nTrampolines charge for:\n- Their routing services\n- The actual route fees (which they pay)\n\n```text\nSender pays: sender_fee + T1_fee + T2_fee + route_fees\nT1 pays: route fees to T2\nT2 pays: route fees to recipient\n```\n\n---\n\n## Use Cases\n\n### Mobile Wallets\n\nPrimary use case:\n\n```text\nMobile App:\n- No graph storage needed\n- Instant payments (no route calculation)\n- Lower bandwidth usage\n- Better battery life\n```\n\n### Hardware Wallets\n\nLimited devices benefit from delegation:\n\n```text\nHardware Wallet:\n- Limited processing power\n- Small storage\n- Delegate heavy computation to trampoline\n```\n\n### Constrained Environments\n\nIoT and embedded devices:\n\n```text\nIoT Device:\n- Minimal resources\n- Pay via trampoline\n- No graph maintenance\n```\n\n---\n\n## Current Support\n\n### Phoenix Wallet (ACINQ)\n\nPrimary trampoline implementation:\n\n- Uses ACINQ nodes as trampolines\n- Fully mobile-optimized\n- No graph download required\n\n### Eclair\n\nACINQ's node implementation supports trampoline.\n\n### LND/CLN\n\nLimited or experimental support as of 2024.\n\n---\n\n## Comparison\n\n| Aspect | Standard | Trampoline |\n|--------|----------|------------|\n| Graph needed | Yes (~100MB) | No |\n| Pathfinding | Client | Trampoline node |\n| Privacy | Maximum | Reduced |\n| Latency | Higher (compute) | Lower |\n| Fees | Direct | + Trampoline fee |\n| Mobile friendly | No | Yes |\n\n---\n\n## Security Considerations\n\n### Trust in Trampolines\n\nYou trust trampolines to:\n- Actually forward your payment\n- Not charge excessive fees\n- Maintain privacy (within limits)\n\n**Mitigations**:\n- Use reputable trampoline providers\n- Specify max fees in payment\n- Use multiple trampolines for larger payments\n\n### Probing Attacks\n\nTrampolines could:\n- Probe to learn channel balances\n- Correlate payments across users\n\n**Mitigations**:\n- Trampoline rotation\n- Payment splitting\n- Multiple trampoline chains\n\n---\n\n## Multi-Trampoline Routes\n\nFor better privacy and reliability:\n\n```text\nSingle Trampoline:\nSender â†’ T1 â†’ [...] â†’ Recipient\n(T1 knows sender AND recipient)\n\nMulti-Trampoline:\nSender â†’ T1 â†’ [...] â†’ T2 â†’ [...] â†’ Recipient\n(T1 knows sender, T2 knows recipient, neither knows both)\n```\n\n### Benefits\n\n- **Better privacy**: No single node sees full picture\n- **Redundancy**: Multiple routing options\n- **Decentralization**: Not dependent on single provider\n\n---\n\n## Fee Structure\n\nTrampoline fees typically include:\n\n```text\nBase Fee: Fixed per-payment charge\nProportional: Percentage of amount\nRoute Budget: Max for underlying route\n\nExample:\nPayment: 100,000 sats\nTrampoline base: 1,000 msat\nTrampoline proportional: 0.1%\nRoute budget: 500 sats max\n\nTotal max: 1 sat + 100 sats + 500 sats = 601 sats\n```\n\n---\n\n## Future Developments\n\n### BOLT12 Integration\n\nTrampoline may integrate with offers:\n\n- Recipient specifies preferred trampolines\n- Automatic trampoline selection\n- Better privacy through randomization\n\n### Trampoline Networks\n\nPotential for specialized trampoline networks:\n\n- Competing trampoline providers\n- Fee market for pathfinding\n- Quality-of-service differentiation\n\n---\n\n## Summary\n\nTrampoline routing provides:\n\n- **Mobile optimization**: No graph sync needed\n- **Delegated pathfinding**: Trampolines compute routes\n- **Reduced bandwidth**: Minimal data requirements\n- **Battery savings**: Less computation on device\n- **Privacy trade-off**: Trampolines learn more than regular hops\n\n---\n\n## When to Use Trampoline\n\n**Good fit**:\n- Mobile wallets\n- Hardware wallets\n- Constrained devices\n- Casual users prioritizing convenience\n\n**Poor fit**:\n- Privacy-focused users\n- Routing nodes\n- When you need full control over route selection\n\n---\n\n## Related Topics\n\n- [Onion Routing](/docs/lightning/onion) - Privacy-preserving routing\n- [Routing & HTLCs](/docs/lightning/routing) - Standard routing mechanics\n\n---\n\n## Resources\n\n- [Trampoline Routing Proposal](https://github.com/lightning/bolts/pull/829)\n- [ACINQ Trampoline Blog](https://medium.com/@ACINQ/introducing-phoenix-5c5cc76c7f9e)\n- [Phoenix Wallet](https://phoenix.acinq.co/) - Trampoline-based wallet\n",
    "filename": "trampoline-routing.md"
  },
  "/docs/advanced/covenants": {
    "content": "# Covenants\n\n**Covenants** are a *proposed* type of [Bitcoin Script](/docs/bitcoin/script) constraint that would restrict how [outputs](/docs/glossary#output) from a [transaction](/docs/bitcoin/transaction-lifecycle) can be spent in **future** transactions. Unlike todayâ€™s scripts, which only define â€œwho can spend and under what conditions,â€ covenants would allow â€œthis [UTXO](/docs/glossary#utxo-unspent-transaction-output) may only be spent in a transaction that looks like Xâ€ (e.g., only to certain [address](/docs/glossary#address) types, or only after passing through a timelocked recovery path).\n\nNo covenant opcodes are in [consensus](/docs/glossary#consensus) today. This page describes the design space and main proposals. A **covenant** restricts the *shape* or *destination* of the transaction that spends an [output](/docs/glossary#output):\n\n- **Shape**: e.g., â€œthe spending transaction must have exactly N outputsâ€ or â€œthe first output must be to this script.â€\n- **Destination**: e.g., â€œoutputs may only go to [addresses](/docs/wallets/address-types) of type P2WPKHâ€ or â€œonly to this prespecified [script](/docs/bitcoin/script).â€\n- **Recursion**: Some designs allow outputs that are *again* covenant-constrained, creating multi-step flows (vaults, [Lightning](/docs/lightning)-like channels, etc.).\n\nCovenants enable:\n\n- **Vaults**: Funds can only move to a â€œcooling-offâ€ or recovery [script](/docs/bitcoin/script) first; direct spending is disallowed.\n- **Layered security**: e.g., â€œcan only be sent to a 2-of-3 [multisig](/docs/wallets/multisig) or to a timelocked recovery path.â€\n- **L2 and protocols**: Channel factories, [Lightning](/docs/lightning)-style constructs, and other protocols could use covenants to enforce on-chain structure.\n\n---\n\n## Main Proposals\n\n### OP_CAT (and similar)\n\n**OP_CAT** (concatenate two values on the stack) was disabled in early Bitcoin. Re-enabling it (or adding a constrained variant) could, in combination with [hashing](/docs/bitcoin/cryptography) and equality checks, allow [scripts](/docs/bitcoin/script) to inspect and constrain parts of the *spending* transaction (e.g., by [sighash](/docs/glossary#sighash) or by committing to a hash of allowed shapes). OP_CAT is very general; the main concern is that it might enable scripts that are complex, hard to analyze, or that risk [consensus](/docs/glossary#consensus) or performance issues. Proposals often restrict what can be concatenated or how the result is used.\n\n### OP_CTV (CheckTemplateVerify)\n\n**OP_CTV** (or **OP_CHECKTEMPLATEVERIFY**) commits to a **hash of a specific spending transaction template**. The [script](/docs/bitcoin/script) would specify the exact [inputs](/docs/glossary#input) (by [outpoint](/docs/glossary#outpoint)) and [outputs](/docs/glossary#output) (scriptPubKey + amount) of the *only* transaction that can spend the [UTXO](/docs/glossary#utxo-unspent-transaction-output). This is a **one-step** covenant: the *next* spend is fully fixed; you cannot recursively chain OP_CTV in arbitrarily complex ways without further opcodes.\n\nUse cases: vaults with a single recovery path, [Lightning](/docs/lightning) [anchor](/docs/lightning/anchor-outputs) or channel-like structures where the on-chain spend must match a known template, and congestion-control or batch-spend patterns.\n\n- **BIP**: [BIP 119](https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki) (OP_CTV / CheckTemplateVerify)\n\n### SIGHASH_ANYPREVOUT (APO)\n\n**SIGHASH_ANYPREVOUT** (APO) is a [sighash](/docs/glossary#sighash) flag that would allow a [signature](/docs/bitcoin/cryptography) to be valid when the signed [input](/docs/glossary#input) comes from *any* [outpoint](/docs/glossary#outpoint) (or from a set of allowed ones), rather than a single outpoint. That makes signatures **reusable** across different [transactions](/docs/bitcoin/transaction-lifecycle) that share the same structure (e.g., same [outputs](/docs/glossary#output)), which can be used to build covenant-like behavior: the signer effectively agrees to â€œthis spend is only valid if the rest of the tx looks like X,â€ and the [script](/docs/bitcoin/script) can enforce that the signer only signs such shapes.\n\nAPO is particularly relevant for [Lightning](/docs/lightning) and [channel](/docs/lightning/channels) designs: [commitment](/docs/glossary#commitment-transaction) and [HTLC](/docs/lightning/routing/htlc) transactions could use a more flexible signing model. It is also a building block for [vaults](/docs/wallets/smart-contracts) and other covenant patterns.\n\n- **BIP / spec**: See [Bitcoin Optech](https://bitcoinops.org/) and the [bitcoin-dev](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev) mailing list for current APO and â€œAPO as covenantâ€ proposals.\n\n### Other and Combined\n\nOther ideas (e.g., **OP_TXHASH**, **OP_TX**, or limited forms of **OP_CAT**) aim to expose part of the spending [transaction](/docs/bitcoin/transaction-lifecycle) to [script](/docs/bitcoin/script) so it can be constrained. Some designs combine:\n\n- **OP_CTV** for â€œexactly this next spend,â€ and\n- **APO** or similar for â€œthis signature is valid for any prevout with this structure,â€\n\nto get both one-off templates and more flexible, multi-step covenant flows.\n\n---\n\n## Risks and Trade-offs\n\n- **Recursion and complexity**: Covenants that can chain arbitrarily may make [scripts](/docs/bitcoin/script) harder to reason about, audit, and fee-estimate. Proposals often limit recursion or the power of the opcode.\n- **Fungibility and censorship**: Very strict covenants could create [outputs](/docs/glossary#output) that are distinguishable and easier to blacklist or to treat differently in [mempool](/docs/mining/mempool) or [mining](/docs/mining) policy.\n- **Consensus and consensus risk**: New opcodes require [soft fork](/docs/glossary#soft-fork) and careful [consensus](/docs/glossary#consensus) review. The community weighs benefits (vaults, L2, etc.) against added complexity and risk.\n\n---\n\n## Status\n\nAs of this writing:\n\n- **OP_CTV**: BIP 119 exists; no [soft fork](/docs/glossary#soft-fork) has been adopted. Discussion continues on [bitcoin-dev](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev).\n- **SIGHASH_ANYPREVOUT / APO**: Active design and discussion; not yet in [consensus](/docs/glossary#consensus).\n- **OP_CAT**: Re-enable or constrained variants are discussed; not in [consensus](/docs/glossary#consensus).\n\nImplementations (e.g., [Miniscript](/docs/bitcoin-development/miniscript)) and higher-level tools may add *draft* support for CTV or APO so that, if one of these is adopted, wallets and [smart contracts](/docs/wallets/smart-contracts) can use them quickly.\n\n---\n\n## Related Topics\n\n- [Smart Contracts](/docs/wallets/smart-contracts) - Covenant-like patterns and Miniscript\n- [Miniscript](/docs/bitcoin-development/miniscript) - Policy and script; future covenant targets\n- [Sighash Types](/docs/bitcoin/sighash-types) - How signing commits to transaction parts; APO extends this\n- [Lightning](/docs/lightning) - Potential use of covenants / APO\n- [Governance](/docs/advanced/governance) - How opcodes and soft forks are proposed and adopted\n\n---\n\n## Resources\n\n- [BIP 119: CheckTemplateVerify (OP_CTV)](https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki)\n- [Bitcoin Optech: Covenants](https://bitcoinops.org/en/topics/covenants/)\n- [bitcoin-dev mailing list](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev) - Covenant and APO discussion\n",
    "filename": "covenants.md"
  },
  "/docs/investment": {
    "content": "# Bitcoin as Investment\n\n![Bitcoin Icon](/icons/bitcoin.png)\n\nBitcoin represents a unique investment opportunity that combines technological innovation with monetary properties never before seen in human history. Whether you're considering your first Bitcoin purchase or looking to deepen your understanding of Bitcoin as an asset, these guides will help you make informed decisions.\n\n---\n\n## Why Consider Bitcoin?\n\nUnderstanding Bitcoin as an investment requires recognizing both its potential and its risks. Bitcoin exhibits several characteristics that make it attractive as an investment:\n\n**Scarcity:** With a fixed supply cap, Bitcoin cannot be inflated or diluted. The issuance schedule is predictable and decreases over time through [halvings](/docs/history/halvings), creating a deflationary monetary policy.\n\n**Portability:** Bitcoin can be transferred globally, 24/7, without intermediaries. This makes it valuable for international transfers and as a hedge against currency devaluation.\n\n**Verifiability:** Cryptographic proof ensures that Bitcoin cannot be counterfeited. Anyone can verify the authenticity of bitcoin and the integrity of the network.\n\n**Censorship Resistance:** No central authority can freeze accounts or prevent transactions. This property becomes increasingly valuable in regions with financial restrictions or currency controls.\n\n**Network Effects:** As adoption grows, Bitcoin's value proposition strengthens. More users, merchants, and institutions accepting Bitcoin increases its utility and potential value.\n\nFor more on Bitcoin's monetary properties, see [Monetary Properties](/docs/fundamentals/monetary-properties).\n\n---\n\n## Invest Only What You Understand\n\nA fundamental principle among experienced Bitcoin investors is: **only invest as much as you understand Bitcoin.**\n\nThis principle serves multiple purposes:\n\n### Risk Management\n\nBitcoin is a volatile asset. If you don't understand why Bitcoin has value, how it works, or what makes it different from other assets, you're more likely to:\n\n- Panic sell during market downturns\n- Make emotional decisions based on fear or FOMO\n- Fall victim to scams or poor investment advice\n- Invest more than you can afford to lose\n\n### Education Creates Conviction\n\nThe more you learn about Bitcoin, the more you understand:\n\n- Its [technical foundations](/docs/bitcoin) and security model\n- Its [monetary properties](/docs/fundamentals/monetary-properties) and economic incentives\n- Its [history](/docs/history) and evolution\n- The problems it solves and its potential impact\n\nThis knowledge builds conviction that helps you weather volatility and make informed decisions rather than reacting to market noise.\n\n### Progressive Investment\n\nAs your understanding deepens, you may naturally feel more comfortable increasing your allocation. This creates a natural risk management mechanism:\n\n- **Beginner:** Start with a small amount while learning the basics\n- **Intermediate:** Increase allocation as you understand the technology and economics\n- **Advanced:** Further increase as you understand the broader implications and long-term potential\n\nThis approach aligns your investment size with your knowledge, reducing the risk of making decisions you don't fully understand.\n\n---\n\n## Education First\n\nBefore investing, prioritize education:\n\n1. **Understand the technology:** Learn how Bitcoin works at a technical level\n2. **Study the economics:** Understand monetary policy, supply dynamics, and network effects\n3. **Review the history:** Study Bitcoin's evolution, major events, and market cycles\n4. **Practice with small amounts:** Start with small investments while learning\n5. **Secure your holdings:** Learn about [wallet security](/docs/investment/wallet-security) and best practices\n\nThe more you learn, the better equipped you'll be to make informed investment decisions. Bitcoin rewards those who take the time to understand it deeply.\n\n---\n\n## Related Topics\n\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Economic characteristics of Bitcoin\n- [Wallet Security & Self-Custody](/docs/investment/wallet-security) - Securing your Bitcoin holdings\n- [Investment Strategy](/docs/investment-strategy) - DCA and long-term holding strategies\n- [Understanding Market Cycles](/docs/investment/market-cycles) - Navigating volatility and market psychology\n- [Trust Model](/docs/fundamentals/trust-model) - Understanding Bitcoin's security model\n\n---\n\nStay humble, stack sats.\n",
    "filename": "overview.md"
  },
  "/docs/investment/risk-management": {
    "content": "# Risk Management\n\nInvesting in Bitcoin carries significant risks that every investor should understand. This guide helps you identify, assess, and manage these risks appropriately.\n\n---\n\n## Key Risks\n\n### Volatility Risk\n\n**What it is:** Bitcoin's price can experience dramatic swings. Short-term volatility can be 20-50% or more in a single day.\n\n**Why it happens:** Bitcoin is a relatively new asset class with a smaller market cap than traditional assets. Lower liquidity and market sentiment can cause significant price movements.\n\n**How to manage:**\n- Only invest what you can afford to lose\n- Take a long-term perspective (volatility decreases over longer time horizons)\n- Use [Dollar Cost Averaging](/docs/investment-strategy) to smooth out volatility\n- Avoid checking prices constantly (reduces emotional stress)\n- Understand that volatility is part of Bitcoin's nature\n\n**Remember:** Volatility works both ways. While it can cause significant losses, it can also create significant gains. The key is maintaining perspective and not making emotional decisions.\n\n---\n\n### Regulatory Risk\n\n**What it is:** Government regulations can impact Bitcoin's price and accessibility. Regulations vary by jurisdiction and can change.\n\n**Why it matters:** Governments may restrict Bitcoin trading, impose taxes, or ban Bitcoin entirely in some jurisdictions. Regulatory uncertainty can cause price volatility.\n\n**How to manage:**\n- Stay informed about regulations in your jurisdiction\n- Understand tax implications of Bitcoin ownership\n- Use compliant exchanges and services\n- Consider the regulatory environment when choosing where to store Bitcoin\n- Understand that Bitcoin's decentralized nature makes it difficult to ban completely\n\n**Note:** While regulations can impact short-term prices, Bitcoin's decentralized nature means it cannot be easily shut down. The network operates globally, regardless of any single country's regulations.\n\n---\n\n### Technical Risk\n\n**What it is:** While Bitcoin's network has been secure since 2009, technical vulnerabilities, bugs, or protocol changes could theoretically impact the network.\n\n**Why it's low:** Bitcoin has been battle-tested for over 15 years. The network has never been successfully hacked, and the protocol is extremely conservative about changes.\n\n**How to manage:**\n- Understand that Bitcoin's security model is based on proof-of-work and economic incentives\n- Stay informed about protocol upgrades and changes\n- Use reputable wallets and services\n- Understand that Bitcoin's conservatism is a feature, not a bug\n- Keep your software updated\n\n**Reality check:** The risk of a catastrophic technical failure is extremely low. Bitcoin's network has proven remarkably resilient, and the protocol's conservative approach to changes minimizes risk.\n\n---\n\n### Custody Risk\n\n**What it is:** Holding Bitcoin requires securing private keys. Loss of keys means permanent loss of funds. This is one of the most significant risks for individual investors.\n\n**Why it matters:** Unlike traditional banking, there's no password recovery for Bitcoin. If you lose your private keys or seed phrase, your Bitcoin is gone forever.\n\n**How to manage:**\n- Learn about [wallet security](/docs/investment/wallet-security) and self-custody\n- Use hardware wallets for significant amounts\n- Create secure backups of your seed phrase\n- Never store seed phrases digitally (photos, cloud, email)\n- Test your recovery process before storing significant amounts\n- Consider multi-signature wallets for large holdings\n- Use reputable custodians if you're not comfortable with self-custody (understand the trade-offs)\n\n**Critical:** Custody risk is entirely within your control. With proper security practices, you can minimize this risk significantly.\n\n---\n\n### Market Risk\n\n**What it is:** Bitcoin is still a relatively new asset class. Adoption could stall, or competing technologies could emerge.\n\n**Why it exists:** Bitcoin's value depends on adoption and network effects. If adoption stalls or a superior technology emerges, Bitcoin's value could decline.\n\n**How to manage:**\n- Understand Bitcoin's network effects and first-mover advantage\n- Recognize that Bitcoin's simplicity and security are features, not bugs\n- Stay informed about the broader cryptocurrency and technology landscape\n- Understand that Bitcoin's value proposition is unique and difficult to replicate\n- Take a long-term view (Bitcoin has survived many challenges)\n\n**Perspective:** Bitcoin has survived numerous \"Bitcoin killers\" and challenges over the years. Its network effects, security, and simplicity make it difficult to displace.\n\n---\n\n### No Guarantees\n\n**What it means:** Unlike traditional investments, Bitcoin has no backing, no dividends, and no intrinsic value beyond what the market assigns. Its value depends entirely on adoption and network effects.\n\n**Why it matters:** Bitcoin's value is purely based on market demand. There's no company, government, or asset backing it.\n\n**How to think about it:**\n- Bitcoin's value comes from its properties: scarcity, portability, verifiability, censorship resistance\n- Network effects create value as adoption grows\n- Bitcoin is a bet on the future of money and financial sovereignty\n- Only invest what you can afford to lose\n- Understand that this is a high-risk, high-reward investment\n\n---\n\n## Risk Assessment Framework\n\n### Before Investing, Ask Yourself:\n\n1. **Can I afford to lose this money?** Only invest what you can afford to lose completely.\n\n2. **Do I understand Bitcoin?** Your investment size should match your understanding. Start small and increase as you learn.\n\n3. **What's my time horizon?** Bitcoin is best suited for long-term investment. Short-term trading is extremely risky.\n\n4. **Am I emotionally prepared for volatility?** Bitcoin's price swings can be dramatic. Can you hold through 50%+ drawdowns?\n\n5. **Do I have proper security?** Have you learned about wallet security and self-custody? Are your keys secure?\n\n6. **What's my risk tolerance?** Bitcoin is a high-risk asset. Does it fit your risk profile?\n\n---\n\n## Risk Mitigation Strategies\n\n### Diversification\n\nWhile Bitcoin can be a significant part of a portfolio, consider:\n\n- Not putting all your savings into Bitcoin\n- Maintaining an emergency fund in traditional currency\n- Diversifying across different asset classes\n- Understanding that Bitcoin is a high-risk, high-reward investment\n\n### Dollar Cost Averaging\n\nRegular, automated purchases reduce timing risk and help you build a position over time without trying to time the market.\n\n### Long-term Perspective\n\nBitcoin's volatility decreases over longer time horizons. Taking a long-term view (years, not months) reduces the impact of short-term volatility.\n\n### Education\n\nThe more you understand Bitcoin, the better equipped you are to make informed decisions and avoid common mistakes.\n\n### Security\n\nProper wallet security and self-custody practices are essential. Learn about [wallet security](/docs/investment/wallet-security) before storing significant amounts.\n\n---\n\n## Common Risk Management Mistakes\n\n**Investing more than you can afford to lose:** This is the most common mistake. Only invest what you can afford to lose completely.\n\n**Panic selling during downturns:** Volatility is part of Bitcoin's nature. Selling during downturns locks in losses and defeats the purpose of long-term investment.\n\n**FOMO buying during euphoria:** Buying when prices are surging often leads to buying at the top. Stick to your investment plan.\n\n**Neglecting security:** Not properly securing your Bitcoin is one of the biggest risks. Learn about wallet security before storing significant amounts.\n\n**Trading instead of investing:** Short-term trading is extremely risky and often leads to losses. Bitcoin is best suited for long-term investment.\n\n---\n\n## Related Topics\n\n- [Wallet Security & Self-Custody](/docs/investment/wallet-security) - Securing your Bitcoin holdings\n- [Investment Strategy](/docs/investment-strategy) - DCA and long-term holding strategies\n- [Understanding Market Cycles](/docs/investment/market-cycles) - Navigating volatility and market psychology\n- [Privacy](/docs/investment/privacy) - Privacy considerations and regulatory implications\n- [Tools & Resources](/docs/investment/tools) - Exchange selection and security considerations\n\n---\n",
    "filename": "risk-management.md"
  },
  "/docs/investment-strategy": {
    "content": "# Investment Strategy\n\nInvestment strategies for Bitcoin focus on disciplined approaches that help you build and maintain a position over time, regardless of short-term market volatility. This guide covers proven strategies used by long-term Bitcoin investors.\n\n---\n\n## Dollar Cost Averaging\n\n**Dollar Cost Averaging (DCA)** is an investment strategy where you invest a fixed amount of money at regular intervals, regardless of the asset's price. This approach helps reduce the impact of volatility and removes the need to time the market.\n\nInstead of investing a large lump sum at once, DCA involves:\n\n1. **Regular intervals:** Weekly, bi-weekly, or monthly purchases\n2. **Fixed amounts:** The same dollar amount each time\n3. **Automatic execution:** Reduces emotional decision-making\n\n### Benefits of DCA for Bitcoin\n\n**Reduces timing risk:** You don't need to predict when Bitcoin is at its lowest price. By buying consistently, you average out the purchase price over time.\n\n**Disciplined approach:** Regular, automated purchases help maintain a long-term perspective and avoid panic selling during market downturns.\n\n**Psychological comfort:** Smaller, regular investments feel less risky than large lump-sum purchases, making it easier to stick with the strategy during volatility.\n\n**Volatility smoothing:** Bitcoin's price can be highly volatile. DCA helps smooth out the impact of short-term price swings.\n\nThis approach helps avoid the common mistake of buying too much during euphoric highs or missing opportunities during fear-driven lows.\n\n### How DCA Works\n\n#### Example Scenario\n\nImagine you decide to invest $100 per week in Bitcoin:\n\n- **Week 1:** Bitcoin at $50,000 â†’ You buy 0.002 BTC\n- **Week 2:** Bitcoin at $45,000 â†’ You buy 0.0022 BTC\n- **Week 3:** Bitcoin at $55,000 â†’ You buy 0.0018 BTC\n- **Week 4:** Bitcoin at $48,000 â†’ You buy 0.0021 BTC\n\nOver time, you accumulate Bitcoin at an average price that smooths out the volatility. You're not trying to time the market; you're consistently building your position.\n\n#### Frequency Options\n\n**Weekly DCA:** More frequent purchases, smoother averaging, but requires more active management.\n\n**Bi-weekly DCA:** Balanced approach between frequency and convenience.\n\n**Monthly DCA:** Most convenient, less frequent transactions, but larger price swings between purchases.\n\nChoose a frequency that fits your budget and lifestyle. The key is consistency, not the specific interval.\n\n### DCA vs Lump Sum\n\n#### When DCA Makes Sense\n\n- You have a steady income stream\n- You want to reduce timing risk\n- You prefer a disciplined, automated approach\n- You're building a position over time\n- You want to avoid emotional decision-making\n\n#### When Lump Sum Might Make Sense\n\n- You have a large amount to invest and believe Bitcoin is undervalued\n- You have strong conviction about current price levels\n- You're comfortable with higher risk\n- You want to maximize time in the market\n\n**Note:** Historically, lump sum investing has often outperformed DCA because time in the market typically beats timing the market. However, DCA provides psychological benefits and risk management that may be worth the potential opportunity cost.\n\n### Implementing DCA\n\n#### Automated Platforms\n\nMany exchanges and services offer automated DCA:\n\n- Set your amount and frequency\n- Automatically purchase Bitcoin at regular intervals\n- Reduces the temptation to time the market\n- Builds discipline and consistency\n\n#### Manual DCA\n\nYou can also implement DCA manually:\n\n- Set calendar reminders for your purchase dates\n- Use the same exchange or service each time\n- Stick to your predetermined amount\n- Avoid checking prices before purchasing (to reduce emotional influence)\n\n### Common DCA Mistakes\n\n**Stopping during downturns:** One of the biggest mistakes is stopping your DCA when prices fall. This defeats the purpose of the strategy. DCA works best when you continue buying through all market conditions.\n\n**Increasing amounts during euphoria:** Don't increase your DCA amount when prices are surging. Stick to your predetermined plan.\n\n**Checking too frequently:** Constantly monitoring prices can lead to emotional decisions. Set your DCA and let it run.\n\n**Not having a long-term plan:** DCA works best over years, not months. Have a clear timeline and goal for your DCA strategy.\n\n---\n\n## HODLing\n\nThe **HODLing** philosophy (holding Bitcoin for the long term regardless of short-term price volatility) has become a cornerstone of Bitcoin investment strategy. This approach aligns with Bitcoin's monetary properties and helps you maintain psychological resilience through market cycles.\n\n### What is HODLing?\n\n**HODL** (originally a typo of \"hold\" that became a meme) refers to the strategy of buying and holding Bitcoin for the long term, regardless of short-term price movements. The philosophy is simple: **time in the market beats timing the market.**\n\nHODLing is based on the belief that Bitcoin's fundamental value proposition (scarcity, portability, verifiability, censorship resistance, and network effects) will appreciate over time as adoption grows.\n\n### Why Long-term Holding Makes Sense\n\n#### Bitcoin's Monetary Properties\n\nBitcoin is designed as **sound money** with properties that reward long-term holding:\n\n- **Fixed supply:** Only 21 million bitcoin will ever exist\n- **Deflationary issuance:** The supply growth rate decreases over time through halvings\n- **Network effects:** As adoption grows, Bitcoin's value proposition strengthens\n- **No counterparty risk:** You own Bitcoin directly, not a claim on Bitcoin\n\nThese properties create a natural incentive to hold Bitcoin long-term rather than trade it frequently.\n\n#### Time Horizons Matter\n\n**Short-term (days to months):** Bitcoin is extremely volatile. Short-term price movements are driven by sentiment, news, and market psychology. Trying to time these movements is extremely difficult and risky.\n\n**Medium-term (1-4 years):** Bitcoin's price tends to follow halving cycles. These cycles create longer-term trends, but still include significant volatility.\n\n**Long-term (4+ years):** Over longer time horizons, Bitcoin's fundamental properties (scarcity and network effects) tend to drive price appreciation. Historical data shows that long-term holders have been rewarded.\n\n#### Historical Perspective\n\nSince Bitcoin's creation in 2009, long-term holders have been consistently rewarded:\n\n- **2010-2014:** Early adopters saw massive gains as Bitcoin went from cents to hundreds of dollars\n- **2014-2017:** Those who held through the 2014-2015 bear market were rewarded in the 2017 bull run\n- **2017-2021:** HODLers who didn't sell during the 2018-2019 bear market saw new all-time highs in 2021\n- **2021-present:** The pattern continues as Bitcoin matures\n\n**Key Insight:** While past performance doesn't guarantee future results, Bitcoin's history shows that long-term holding has been more successful than trying to time the market.\n\n### Time Horizons\n\n#### 1 Year Horizon\n\n**Characteristics:**\n- High volatility\n- Subject to market cycles and sentiment\n- Can see 50%+ drawdowns\n- Can see 100%+ gains\n\n**Strategy:**\n- Only invest what you can afford to lose\n- Prepare for significant volatility\n- Focus on learning and building conviction\n- Don't check prices constantly\n\n**Best for:** Building initial position, learning about Bitcoin, testing your risk tolerance.\n\n#### 4 Year Horizon (Halving Cycle)\n\n**Characteristics:**\n- Aligns with Bitcoin's halving cycle\n- Captures full market cycle (bull and bear)\n- Reduces impact of short-term volatility\n- Historically strong returns\n\n**Strategy:**\n- Use Dollar Cost Averaging to build position\n- Hold through bear markets\n- Take profits if needed, but maintain core position\n- Focus on Bitcoin's fundamentals, not price\n\n**Best for:** Serious investors, those building significant positions, retirement planning.\n\n#### 10+ Year Horizon\n\n**Characteristics:**\n- Maximum time for network effects to play out\n- Minimal impact of short-term volatility\n- Best alignment with Bitcoin's monetary properties\n- Potential for significant appreciation\n\n**Strategy:**\n- Buy and hold, don't trade\n- Focus on Bitcoin's long-term thesis\n- Ignore short-term price movements\n- Consider Bitcoin as a store of value, not a trading asset\n\n**Best for:** Long-term wealth preservation, generational wealth, maximum conviction holders.\n\n### The HODLing Philosophy\n\n#### Core Principles\n\n1. **Time in the market beats timing the market:** Rather than trying to buy low and sell high, simply hold Bitcoin over time.\n\n2. **Bitcoin's fundamentals matter more than price:** Focus on Bitcoin's properties and adoption, not daily price movements.\n\n3. **Volatility is temporary, adoption is permanent:** Short-term price swings are noise. Long-term adoption trends are the signal.\n\n4. **You can't predict the future:** No one knows where Bitcoin's price will be tomorrow, next month, or next year. But Bitcoin's fundamentals suggest long-term appreciation.\n\n5. **Patience is rewarded:** Bitcoin rewards those who take a long-term view and resist the temptation to trade.\n\n#### Why HODLing Works\n\n**Reduces emotional decision-making:** By committing to hold long-term, you remove the temptation to make emotional decisions based on price movements.\n\n**Captures full upside:** You don't miss out on unexpected price surges because you're always holding.\n\n**Avoids timing mistakes:** You don't have to predict when to buy or sell. You simply hold.\n\n**Aligns with Bitcoin's properties:** Bitcoin is designed as sound money. Holding aligns with this design.\n\n**Reduces transaction costs:** Less trading means fewer fees and less tax complexity.\n\n### Psychological Resilience\n\n#### The Emotional Challenge\n\nHODLing is psychologically difficult because:\n\n- **Volatility is stressful:** Watching your investment drop 50%+ is emotionally challenging\n- **FOMO and FUD:** Fear of missing out and fear, uncertainty, and doubt can drive poor decisions\n- **Social pressure:** Friends, family, and media may question your strategy during downturns\n- **Doubt:** It's natural to question your decision during bear markets\n\n#### Building Resilience\n\n**Education:** The more you understand Bitcoin, the more conviction you'll have. Education builds resilience.\n\n**Community:** Connect with other Bitcoiners. Having a community that understands your strategy helps during difficult times.\n\n**Focus on fundamentals:** When prices drop, remind yourself of Bitcoin's fundamental properties. The technology hasn't changed.\n\n**Avoid constant price checking:** Checking prices constantly increases stress and emotional volatility. Check less frequently.\n\n**Have a plan:** Know your time horizon and strategy. Stick to your plan regardless of short-term price movements.\n\n**Remember your why:** Why did you invest in Bitcoin? Remind yourself of your reasons during difficult times.\n\n#### Common Psychological Traps\n\n**FOMO (Fear of Missing Out):** Buying when prices are surging because you're afraid of missing gains. This often leads to buying at the top.\n\n**FUD (Fear, Uncertainty, Doubt):** Selling when prices are dropping because of fear. This locks in losses.\n\n**Anchoring:** Fixating on a previous price (like an all-time high) and making decisions based on that anchor rather than current fundamentals.\n\n**Recency bias:** Overweighting recent price movements and assuming they'll continue.\n\n**Avoid these traps:** Stick to your plan, focus on fundamentals, and maintain a long-term perspective.\n\n### HODLing vs Trading\n\n#### HODLing\n\n**Pros:**\n- Simpler strategy\n- Lower transaction costs\n- Less time and stress\n- Captures full upside\n- Aligns with Bitcoin's properties\n- Better tax treatment (in many jurisdictions)\n\n**Cons:**\n- Misses short-term trading opportunities\n- Requires holding through drawdowns\n- Requires strong conviction\n\n#### Trading\n\n**Pros:**\n- Potential for short-term gains\n- Can take profits during bull markets\n- Can buy more during bear markets\n\n**Cons:**\n- Extremely difficult to time correctly\n- Higher transaction costs\n- More time and stress\n- Tax complexity\n- Often leads to worse returns than HODLing\n- Requires constant attention\n\n**Reality:** Most traders underperform HODLers. The data consistently shows that long-term holding produces better results for most people.\n\n### Practical HODLing Strategies\n\n#### Buy and Hold\n\n**Strategy:** Buy Bitcoin and hold it indefinitely. Don't sell unless you need the money.\n\n**Best for:** Maximum conviction, long-term wealth preservation, simplicity.\n\n#### Dollar Cost Averaging + HODL\n\n**Strategy:** Use Dollar Cost Averaging to build your position, then hold everything you've accumulated.\n\n**Best for:** Building a position over time, reducing timing risk, maintaining discipline.\n\n#### Core + Satellite\n\n**Strategy:** Hold a core position long-term (HODL), but allow yourself to trade a smaller \"satellite\" portion if you want to be more active.\n\n**Best for:** Those who want to HODL but also want some trading flexibility.\n\n#### Gradual Profit-Taking\n\n**Strategy:** Hold long-term, but take small profits at predetermined milestones (e.g., sell 10% at 2x, 20% at 5x).\n\n**Best for:** Those who want to lock in some gains while maintaining a core position.\n\n### When to Consider Selling\n\nWhile HODLing is generally recommended, there are legitimate reasons to sell:\n\n**You need the money:** If you need funds for essential expenses, selling is appropriate.\n\n**Your thesis has changed:** If you no longer believe in Bitcoin's long-term value proposition, selling makes sense.\n\n**Risk management:** If your Bitcoin allocation has grown too large relative to your risk tolerance, taking profits is reasonable.\n\n**Life changes:** Major life events (retirement, buying a house, etc.) may require selling some Bitcoin.\n\n**Important:** Have a plan for when you might sell. Don't make emotional decisions during market volatility.\n\n### Common HODLing Mistakes\n\n**Panic selling during downturns:** This is the opposite of HODLing. If you're going to HODL, commit to it through bear markets.\n\n**FOMO buying during euphoria:** Buying more when prices are surging often leads to buying at the top. Stick to your plan.\n\n**Checking prices constantly:** This increases stress and emotional volatility. Check less frequently.\n\n**Not having a plan:** HODLing without a clear plan or time horizon makes it harder to stick with the strategy.\n\n**Ignoring security:** HODLing means you'll hold Bitcoin for a long time. Proper [wallet security](/docs/investment/wallet-security) is essential.\n\n---\n\n## Combining DCA and HODLing\n\nDCA and HODLing work exceptionally well together:\n\n**DCA + HODL:** Use Dollar Cost Averaging to build your position over time, then hold everything you've accumulated. This combines the discipline of DCA with the long-term perspective of HODLing.\n\n**Strategy:** Use DCA to build your position, then hold everything you've accumulated. This approach reduces timing risk while maximizing time in the market.\n\n---\n\n## Related Topics\n\n- [Risk Management](/docs/investment/risk-management) - Understanding investment risks\n- [Tools & Resources](/docs/investment/tools) - Where to execute your investment strategy\n- [Wallet Security & Self-Custody](/docs/investment/wallet-security) - Securing your Bitcoin holdings\n- [Understanding Market Cycles](/docs/investment/market-cycles) - Navigating volatility and market psychology\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin's properties reward holding\n\n---\n\n**Remember:** Investment strategy is about discipline, patience, and conviction. DCA helps you build a position systematically, while HODLing helps you maintain it through market cycles. Bitcoin rewards those who take a long-term perspective and resist the temptation to make emotional decisions based on short-term price movements.\n\nStay humble, stack sats.\n",
    "filename": "overview.md"
  },
  "/docs/investment/tools": {
    "content": "# Tools & Resources\n\nThis guide provides an overview of essential tools and resources for Bitcoin investors, from exchanges and wallets to blockchain explorers and educational materials. The focus is on reputable, well-established tools that can help you invest, manage, and learn about Bitcoin.\n\n---\n\n## Exchanges\n\nExchanges are platforms where you can buy, sell, and trade Bitcoin. Understanding the different types of exchanges and their trade-offs is essential for making informed decisions.\n\n### Centralized Exchanges (CEX)\n\n**What they are:** Traditional [exchanges](/docs/glossary#exchange) that act as intermediaries, holding your funds and matching buy/sell orders.\n\n**Characteristics:**\n- Custodial (they hold your Bitcoin)\n- Require KYC in most jurisdictions\n- High liquidity\n- User-friendly interfaces\n- Various features (trading, staking, etc.)\n\n**Major Exchanges Comparison:**\n\n| Exchange | Best For | Fees | Security | KYC | Availability |\n|----------|----------|------|----------|-----|--------------|\n| **[Coinbase](https://www.coinbase.com)** | Beginners | Higher | Strong, insured | Required | Many countries |\n| **[Kraken](https://www.kraken.com)** | All levels | Lower | Strong reputation | Required | Many jurisdictions |\n| **[Binance](https://www.binance.com)** | Advanced traders | Low | Good | Required | Some restrictions |\n| **[Gemini](https://www.gemini.com)** | Compliance-focused | Medium | Strong | Required | Limited |\n| **[Bitstamp](https://www.bitstamp.net)** | European users | Medium | Good | Required | Europe-focused |\n| **[Bitfinex](https://www.bitfinex.com)** | Advanced trading | Low | Good | Required | Limited |\n\n**KYC Requirements:**\n- Most CEXs require KYC for larger amounts\n- Requirements vary by jurisdiction\n- Typically: ID, proof of address, sometimes biometrics\n- KYC limits vary (often $1,000-10,000 per day without full KYC)\n\n**Features:**\n- **DCA (Dollar Cost Averaging):** Automated recurring purchases\n- **Staking:** Some exchanges offer staking (though Bitcoin itself doesn't stake)\n- **Trading:** Spot, margin, futures, options\n- **Mobile Apps:** Most have mobile applications\n- **Educational Resources:** Many provide learning materials\n\n**Security Considerations:**\n- **Custodial Risk:** They hold your keys\n- **Hack Risk:** Exchanges can be hacked\n- **Regulatory Risk:** Can freeze accounts or halt withdrawals\n- **Insurance:** Some exchanges have insurance (limited coverage)\n- **Best Practice:** Don't leave more than necessary on exchanges\n\n**When to Use CEX:**\n- Buying Bitcoin with fiat currency\n- Need high liquidity\n- Want convenience and ease of use\n- Trading (though long-term holding is generally better)\n- Need specific features (margin, derivatives, etc.)\n\n**Security Best Practices:**\n- Use strong, unique passwords\n- Enable two-factor authentication (2FA)\n- Use hardware security keys when possible\n- Withdraw Bitcoin to self-custody for long-term holding\n- Don't leave more than necessary on exchanges\n- Research exchange security practices\n\n---\n\n### Decentralized Exchanges (DEX)\n\n**What DEXs are:** [Decentralized exchanges (DEXs)](/docs/glossary#dex-decentralized-exchange) that operate without a central authority, using smart contracts or peer-to-peer protocols.\n\n| Aspect | DEX/P2P | CEX |\n|--------|---------|-----|\n| **KYC Required** | No (usually) | Yes |\n| **Privacy** | High | Low |\n| **Liquidity** | Lower | Higher |\n| **Ease of Use** | More complex | User-friendly |\n| **Speed** | Slower | Faster |\n| **Fees** | Often higher | Lower |\n| **Custody** | Self-custody | Custodial |\n\n**Popular Options:**\n\n| Platform | Type | KYC | Best For |\n|----------|------|-----|----------|\n| **[Bisq](https://bisq.network)** | Desktop P2P | No | Privacy-conscious, desktop users |\n| **[Hodl Hodl](https://hodlhodl.com)** | P2P | No | Privacy, various payment methods |\n\n**When to Use DEX:**\n- Want to avoid KYC\n- Value privacy highly\n- Comfortable with more complex interfaces\n- Willing to accept lower liquidity\n- Want to support decentralized infrastructure\n\n---\n\n### Peer-to-Peer (P2P) Exchanges\n\n**P2P trading explained:** Direct trading between individuals without a central exchange.\n\n**How it works:**\n- Find a trading partner\n- Agree on terms (price, payment method)\n- Use escrow or other security mechanisms\n- Complete the trade\n\n**Privacy Benefits:**\n- No KYC (in most cases)\n- Direct transactions\n- More control over the process\n- Can use cash for maximum privacy\n\n**Popular Platforms:**\n\n**Bisq**\n- Decentralized P2P exchange\n- No central authority\n- Various payment methods\n- Escrow system\n- Good for privacy\n\n**LocalBitcoins Alternatives:**\n- Various P2P platforms exist\n- Research carefully (some have shut down or have issues)\n- Always verify platform reputation\n\n**Safety Considerations:**\n- **Escrow:** Use platforms with good escrow systems\n- **Reputation:** Check user ratings and reviews\n- **Payment Methods:** Cash is safest, but be careful with in-person meets\n- **Scams:** Be aware of common scams\n- **Amounts:** Start with small amounts to test\n- **Verification:** Verify the other party's identity when possible\n\n**When to Use P2P:**\n- Want maximum privacy\n- Avoiding KYC\n- Comfortable with direct trading\n- Have time to find trading partners\n- Want to use cash\n\n---\n\n### Exchange Selection Criteria\n\n| Criteria | What to Look For | Red Flags |\n|----------|------------------|-----------|\n| **Security** | Cold storage, 2FA, insurance, good track record | History of hacks, poor security practices |\n| **Privacy** | Minimal KYC, clear privacy policy, data protection | Excessive data collection, sharing with third parties |\n| **Fees** | Transparent fee structure, competitive rates | Hidden fees, high withdrawal costs |\n| **Features** | DCA automation, mobile apps, good UX | Limited features, poor interface |\n| **Compliance** | Licensed in your jurisdiction, regulatory compliance | Regulatory issues, banned in your country |\n| **Reputation** | Positive reviews, industry standing, longevity | Poor reviews, recent scandals, new/unproven |\n| **Practical** | Available in your country, good payment methods | Limited availability, poor customer support |\n\n---\n\n## Wallet Tools\n\nWallets are essential for storing and managing your Bitcoin. For detailed information on wallet security, see [Wallet Security & Self-Custody](/docs/investment/wallet-security).\n\n### Wallet Types Comparison\n\n| Wallet Type | Security | Convenience | Best For | Examples |\n|-------------|----------|-------------|----------|----------|\n| **Hardware** | Highest | Medium | Significant amounts, long-term | Ledger, Trezor, Coldcard |\n| **Desktop** | High | High | Daily use, larger amounts | Electrum, Wasabi, Sparrow |\n| **Mobile** | Medium | Highest | Small amounts, daily use | Blue Wallet, Samourai |\n| **Web** | Lowest | Highest | Very small amounts only | Not recommended |\n\n**Hardware Wallets:**\n\n| Wallet | Open Source | Air-Gap | Best For |\n|--------|------------|---------|----------|\n| **Ledger** | No | No | Beginners, multi-crypto |\n| **Trezor** | Yes | No | Security-focused, Bitcoin |\n| **Coldcard** | Yes | Yes | Advanced users, maximum security |\n| **BitBox02** | Yes | No | Security, simplicity |\n\n**Software Wallets:**\n\n| Wallet | Type | Special Features |\n|--------|------|-----------------|\n| **Electrum** | Desktop | Lightweight, fast |\n| **Wasabi** | Desktop | Privacy (CoinJoin) |\n| **Sparrow** | Desktop | Advanced, technical |\n| **Bitcoin Core** | Desktop | Full node, most secure |\n| **Blue Wallet** | Mobile | User-friendly |\n| **Samourai** | Mobile | Privacy (Whirlpool) |\n| **Breez/Phoenix** | Mobile | Lightning-focused |\n\n---\n\n## Blockchain Explorers\n\n**What blockchain explorers are:** Web tools that let you view and search the Bitcoin blockchain.\n\n**What you can do:**\n- View transactions\n- Check addresses and balances\n- See block information\n- Track transaction confirmations\n- Analyze transaction history\n\n**Popular Explorers:**\n\n| Explorer | Best For | Privacy | Special Features |\n|----------|----------|---------|-----------------|\n| **mempool.space** | Real-time analysis | High (Tor support) | Mempool visualization, open-source |\n| **blockstream.info** | Reliability | Medium | Good API, Blockstream official |\n| **blockchain.com** | User-friendly | Low (tracking) | Mobile app, oldest explorer |\n| **btc.com** | Features | Medium | Good feature set |\n| **blockchair.com** | Multi-chain | Medium | Supports multiple blockchains |\n\n**How to Use Them:**\n- Enter a transaction ID (txid) to view a transaction\n- Enter an address to see its balance and history\n- View block information by block height or hash\n- Track your own transactions\n\n**Privacy Considerations:**\n- **IP Tracking:** Explorers can track your IP when you query addresses\n- **Address Linking:** Querying addresses links them to your IP\n- **Solutions:** Use Tor, VPN, or run your own node\n- **Best Practice:** Don't query addresses you control from your regular IP\n\n**When to Use:**\n- Verifying transactions\n- Checking address balances\n- Learning about the blockchain\n- Analyzing transaction patterns\n- Research and education\n\n---\n\n## Price Tracking & Analytics\n\n### Price Tracking Tools\n\n**What they do:** Track Bitcoin's price in real-time and provide historical data.\n\n**Popular Options:**\n- **CoinGecko:** Extensive price data, good charts\n- **CoinMarketCap:** Popular, good data and charts\n- **TradingView:** Advanced charting, technical analysis\n- **Yahoo Finance:** Traditional finance integration\n- **Various mobile apps:** Many options available\n\n**Features:**\n- Real-time price updates\n- Historical price charts\n- Price alerts\n- Market cap and volume data\n- Multiple currency pairs\n\n### Market Analysis Platforms\n\n**TradingView:**\n- Advanced charting tools\n- Technical indicators\n- Social features\n- Good for analysis\n\n**Glassnode:**\n- On-chain analytics\n- Market metrics\n- Advanced data visualization\n- Good for serious analysis\n\n**Other Analytics:**\n- Various on-chain analytics platforms\n- Market sentiment indicators\n- Exchange flow data\n\n### Portfolio Trackers\n\n**What they do:** Track your Bitcoin holdings and portfolio performance.\n\n**Features:**\n- Track multiple addresses\n- Calculate portfolio value\n- Performance metrics\n- Tax reporting (some)\n- Price alerts\n\n**Popular Options:**\n- **Blockfolio/FTX:** Popular mobile app\n- **Delta:** Good portfolio tracking\n- **Various other apps:** Many options available\n\n**Privacy Considerations:**\n- **Address Tracking:** You may need to provide addresses\n- **Data Storage:** Understand how your data is stored\n- **Best Practice:** Be careful about revealing all your addresses\n\n---\n\n## Educational Resources\n\n### Books\n\n**Essential Reading:**\n- **\"The Bitcoin Standard\" by Saifedean Ammous:** Economic perspective\n- **\"Mastering Bitcoin\" by Andreas M. Antonopoulos:** Technical deep dive\n- **\"The Internet of Money\" by Andreas M. Antonopoulos:** Philosophical perspective\n- **\"Programming Bitcoin\" by Jimmy Song:** Technical development\n- **Various other books:** Many excellent resources available\n\n### Podcasts\n\n**Popular Podcasts:**\n- **\"What Bitcoin Did\" by Peter McCormack**\n- **\"The Pomp Podcast\" by Anthony Pompliano**\n- **\"Bitcoin Magazine Podcast\"**\n- **\"Tales from the Crypt\" by Marty Bent**\n- **Various other podcasts:** Many great options\n\n### Websites & Communities\n\n**Educational Websites:**\n- **Bitcoin.org:** Official Bitcoin website\n- **Bitcoin Magazine:** News and education\n- **Various educational sites:** Many resources available\n\n**Communities:**\n- **Reddit:** r/Bitcoin, r/BitcoinBeginners\n- **Twitter/X:** Many Bitcoin educators and communities\n- **Discord/Slack:** Various Bitcoin communities\n- **Local Meetups:** In-person Bitcoin meetups\n\n### News Sources\n\n**Reliable News Sources:**\n- **Bitcoin Magazine**\n- **CoinDesk**\n- **The Block**\n- **Various other sources:** Research carefully, many sources have biases\n\n**Critical Thinking:**\n- Verify information from multiple sources\n- Be aware of biases and agendas\n- Focus on fundamentals, not hype\n- Avoid FOMO and emotional decisions\n\n### Developer Resources\n\n**For those who want to go deeper:**\n- **Bitcoin Core documentation**\n- **BIPs (Bitcoin Improvement Proposals)**\n- **Technical documentation**\n- **Developer communities**\n- **GitHub repositories**\n\n---\n\n## Other Helpful Tools\n\n### Tax Reporting Tools\n\n**What they do:** Help you calculate and report Bitcoin taxes.\n\n**Features:**\n- Import transaction history\n- Calculate gains/losses\n- Generate tax reports\n- Support for various jurisdictions\n\n**Popular Options:**\n- **Koinly:** Popular, supports many exchanges\n- **CoinTracker:** Good features, user-friendly\n- **TokenTax:** Complete tax solution\n- **Various other tools:** Many options available\n\n**Important:**\n- Tax laws vary by jurisdiction\n- Consult a tax professional\n- Keep records of all transactions\n- Understand your local tax obligations\n\n### DCA Automation Services\n\n**What they do:** Automate regular Bitcoin purchases.\n\n**Features:**\n- Scheduled purchases\n- Automatic execution\n- Various payment methods\n- Lower fees than manual purchases\n\n**Options:**\n- **Exchange DCA features:** Most major exchanges offer this\n- **Third-party services:** Various services available\n- **Self-hosted solutions:** For advanced users\n\n**Benefits:**\n- Reduces timing risk\n- Disciplined investing\n- Convenience\n- Emotion-free investing\n\n### Alert Services\n\n**What they do:** Notify you of price changes, transactions, or other events.\n\n**Types:**\n- **Price alerts:** Notify when price reaches certain levels\n- **Transaction alerts:** Notify when transactions are confirmed\n- **Block alerts:** Notify of new blocks\n- **Custom alerts:** Various other notifications\n\n**Popular Options:**\n- **Mobile apps:** Many wallet apps include alerts\n- **Web services:** Various alert services\n- **Exchange notifications:** Most exchanges offer alerts\n\n### Fee Estimation Tools\n\n**What they do:** Help you estimate transaction fees.\n\n**Features:**\n- Real-time fee estimates\n- Mempool analysis\n- Fee recommendations\n- Historical fee data\n\n**Popular Options:**\n- **mempool.space:** Excellent fee estimation\n- **Various wallet features:** Many wallets include fee estimation\n- **Other tools:** Various fee estimation services\n\n**Why it matters:**\n- Fees vary based on network congestion\n- Overpaying wastes money\n- Underpaying delays transactions\n- Good estimation saves money and time\n\n---\n\n## Tool Selection Criteria\n\n| Criteria | Key Questions |\n|----------|---------------|\n| **Security** | Good reputation? Open-source? Security practices? |\n| **Privacy** | KYC required? Data collection? Privacy features? |\n| **Usability** | Easy to use? Good documentation? Learning curve? |\n| **Features** | Meets your needs? Additional features? Integrations? |\n| **Cost** | Transparent fees? Good value? Free alternatives? |\n| **Reputation** | Positive reviews? Industry standing? Longevity? |\n| **Support** | Good customer service? Active community? Regular updates? |\n\n---\n\n## Related Topics\n\n- [Wallet Security & Self-Custody](/docs/investment/wallet-security) - Securing your Bitcoin holdings\n- [Privacy](/docs/investment/privacy) - Privacy considerations and tools\n- [Investment Strategy](/docs/investment-strategy) - DCA and long-term holding strategies\n- [Risk Management](/docs/investment/risk-management) - Understanding and managing investment risks\n\n---\n\n**Important Disclaimer:** This guide provides information about tools and resources but does not constitute financial, legal, or tax advice. Always:\n\n- Do your own research (DYOR)\n- Verify tool reputations and security\n- Understand the risks involved\n- Consult professionals for legal and tax advice\n- Start with small amounts when trying new tools\n- Never invest more than you can afford to lose\n\nThe Bitcoin ecosystem evolves rapidly. Tools and services change, new ones emerge, and some may shut down. Stay informed and adapt as needed.\n",
    "filename": "tools.md"
  },
  "/docs/investment/wallet-security": {
    "content": "# Wallet Security & Self-Custody\n\n**[Not your keys, not your coins](/docs/glossary#not-your-keys-not-your-coins).** This fundamental principle of Bitcoin ownership means that if you don't control your private keys, you don't truly own your Bitcoin. This guide explains how to securely store your Bitcoin using [cold wallets](/docs/glossary#cold-storage-wallet), hardware wallets, and air-gapped systems.\n\n---\n\n## Why Self-Custody Matters\n\nWhen you store Bitcoin on an exchange or custodial service, you're trusting a third party with your funds. While this may be convenient, it comes with significant risks:\n\n- **Exchange hacks:** Exchanges can be hacked, leading to loss of funds\n- **Regulatory risk:** Exchanges can freeze accounts or halt withdrawals\n- **Counterparty risk:** The exchange could go bankrupt or disappear\n- **No true ownership:** You don't control your private keys\n\n**[Self-custody](/docs/glossary#self-custody)** means you control your private keys, giving you true ownership of your Bitcoin. However, with great power comes great responsibility: you must secure your keys properly.\n\n---\n\n## Understanding Private Keys and Seed Phrases\n\n### Private Keys\n\nA **private key** is a secret cryptographic key that proves ownership of Bitcoin. Whoever controls the private key controls the Bitcoin. If you lose your private key, you lose your Bitcoin forever. There's no password recovery.\n\n### Seed Phrases\n\nA **seed phrase** (also called a recovery phrase or mnemonic) is a human-readable backup of your private keys. It's typically 12 or 24 words that can be used to recover all your Bitcoin if you lose access to your wallet.\n\n**Critical:** Your seed phrase IS your Bitcoin. Anyone who has your seed phrase can steal your Bitcoin. Protect it accordingly.\n\n---\n\n## Types of Wallets\n\n| Wallet Type | Connection | Security | Convenience | Best For |\n|-------------|------------|----------|-------------|----------|\n| **Hot Wallets** | Internet-connected | Lower | High | Small amounts, daily use, frequent transactions |\n| **Cold Wallets** | Offline | Highest | Lower | Long-term storage, significant amounts |\n\n**[Hot Wallets](/docs/glossary#hot-wallet):** Mobile apps, desktop software, web wallets. Easy to use but more vulnerable to hacking.\n\n**[Cold Wallets](/docs/glossary#cold-storage-wallet):** Hardware wallets, air-gapped systems. Private keys never touch the internet. Much more secure but less convenient.\n\n---\n\n## Hardware Wallets\n\nA **hardware wallet** is a physical device designed specifically for storing private keys securely. It's a specialized computer that:\n\n- Generates private keys offline\n- Signs transactions without exposing keys to your computer\n- Stores keys in a secure chip (secure element)\n- Requires physical confirmation for transactions\n\n### How Hardware Wallets Work\n\n1. **Key Generation:** Private keys are generated on the device and never leave it\n2. **Transaction Signing:** When you want to send Bitcoin, the transaction is sent to the device\n3. **Physical Confirmation:** You confirm the transaction on the device itself\n4. **Secure Signing:** The device signs the transaction with your private key (which never leaves the device)\n5. **Transaction Broadcast:** The signed transaction is sent back to your computer and broadcast to the network\n\n**Key Point:** Your private keys never leave the hardware wallet. Even if your computer is infected with malware, your keys remain secure.\n\n### Popular Hardware Wallets\n\n| Wallet | Open Source | Air-Gap | Multi-Crypto | Best For |\n|--------|------------|---------|-------------|----------|\n| **Ledger** | No | No | Yes | Beginners, multi-crypto users |\n| **Trezor** | Yes | No | Yes (Bitcoin-focused) | Security-conscious, open-source preference |\n| **Coldcard** | Yes | Yes | Bitcoin-only | Advanced users, maximum security |\n| **BitBox02** | Yes | No | Bitcoin-only | Simplicity, open-source |\n\n**Important:** Always purchase hardware wallets directly from the manufacturer or authorized resellers. Never buy used hardware wallets, as they may be compromised.\n\n---\n\n## Air-Gapped Systems\n\nAn **air-gapped** system is a computer or device that has never been connected to the internet. This provides the highest level of security because:\n\n- No network attacks possible\n- No malware can reach the device\n- Private keys are completely isolated\n\n### Air-Gapped Wallet Setup\n\n1. **Use a dedicated device:** A computer that will never connect to the internet\n2. **Install wallet software:** Download and install Bitcoin wallet software on the air-gapped device\n3. **Generate keys offline:** Create your wallet and seed phrase on the air-gapped device\n4. **Create watch-only wallet:** On your internet-connected computer, create a watch-only wallet using your public keys (not private keys)\n5. **Receive Bitcoin:** Use the watch-only wallet to generate receiving addresses\n6. **Sign transactions offline:** Create transactions on your internet-connected computer, transfer to air-gapped device, sign offline, then transfer back\n\n**Advanced:** This approach provides maximum security but requires more technical knowledge and setup.\n\n---\n\n## Seed Phrase Security\n\n### Physical Storage\n\n**Best practices:**\n- Write your seed phrase on paper or metal (fire/water resistant)\n- Store in multiple secure locations\n- Never store digitally (photos, cloud, email, notes apps)\n- Consider splitting your seed phrase across multiple locations\n- Use a metal backup for fire/water protection\n\n### What NOT to Do\n\nâŒ **Never store digitally:** No photos, cloud storage, email, or digital notes  \nâŒ **Never share:** Don't share your seed phrase with anyone  \nâŒ **Never store all copies in one place:** Use multiple locations  \nâŒ **Never use online generators:** Only generate seed phrases on trusted, offline devices  \nâŒ **Never type into a computer:** If possible, write it down manually\n\n### Seed Phrase Backup Strategies\n\n| Strategy | Security | Complexity | Risk of Loss | Risk of Theft |\n|----------|----------|------------|-------------|---------------|\n| **Single Location** | Medium | Low | High (single point of failure) | Medium |\n| **Multiple Locations** | High | Medium | Low | Higher (if not secured) |\n| **Split Storage** | Highest | High | Low (need all parts) | Low (parts separated) |\n| **Metal Backup** | High | Medium | Low (fire/water resistant) | Depends on storage |\n\n**Best Practice:** Combine strategies - use multiple locations with metal backups for maximum security.\n\n---\n\n## Multi-Signature Wallets\n\nA **multi-signature (multisig)** wallet requires multiple private keys to authorize a transaction. For example, a [2-of-3 multisig](/docs/glossary#2-of-3-multisig) requires 2 out of 3 keys to sign.\n\n### Benefits\n\n- **No single point of failure:** Losing one key doesn't mean losing your Bitcoin\n- **Enhanced security:** Requires compromise of multiple keys\n- **Flexibility:** Can distribute keys across different locations and people\n- **Recovery options:** Can set up with trusted parties or locations\n\n### Example Setup\n\n**2-of-3 Multisig:**\n- Key 1: Your hardware wallet (primary)\n- Key 2: Backup hardware wallet (stored securely)\n- Key 3: Trusted party or secure location\n\n**Benefits:** If you lose one key, you still have access. If one key is compromised, your funds are still safe.\n\n**When to use:** Large holdings, institutional custody, high-security requirements.\n\n---\n\n## Security Best Practices by Amount\n\n| Amount | Wallet Type | Seed Backup | Additional Security |\n|--------|-------------|-------------|---------------------|\n| **< $1,000** | Mobile wallet | Paper/metal, single location | Reputable software, keep updated |\n| **$1,000 - $10,000** | Hardware wallet | Multiple locations, metal backup | Test recovery process |\n| **> $10,000** | Hardware/air-gapped | Multiple locations, metal backups | Multisig (2-of-3 or 3-of-5), professional consultation |\n\n---\n\n## Common Security Mistakes\n\n**Storing seed phrase digitally:** Photos, cloud storage, email, or notes apps can be hacked. Never store seed phrases digitally.\n\n**Sharing seed phrase:** Never share your seed phrase with anyone, even if they claim to be from support or an exchange.\n\n**Using custodial wallets for large amounts:** While convenient, custodial wallets add counterparty risk. Use self-custody for significant amounts.\n\n**Not testing recovery:** Always test that you can recover your wallet from your seed phrase before storing significant amounts.\n\n**Buying used hardware wallets:** Used hardware wallets may be compromised. Always buy new from the manufacturer.\n\n**Not verifying addresses:** Always verify receiving addresses on your hardware wallet screen, not just on your computer.\n\n---\n\n## Physical Security\n\n### Home Storage\n\n- Use a fireproof safe\n- Consider a safety deposit box for backups\n- Don't store all copies in one location\n- Tell trusted family members where backups are (but not the seed phrase itself)\n\n### Travel Considerations\n\n- Don't travel with your seed phrase\n- Use a hardware wallet for travel (can be replaced if lost)\n- Keep seed phrase backups in secure home locations\n- Consider a travel wallet with small amounts separate from main holdings\n\n---\n\n## Recovery Planning\n\n### Test Your Recovery\n\nBefore storing significant amounts:\n\n1. Create a test wallet\n2. Write down the seed phrase\n3. Delete the wallet\n4. Restore from seed phrase\n5. Verify you can access the wallet\n\n**Critical:** If you can't recover your test wallet, you won't be able to recover your real wallet. Fix your backup process before storing significant amounts.\n\n### Estate Planning\n\nConsider how your Bitcoin will be accessed if something happens to you:\n\n- Store seed phrase backups in locations accessible to trusted family members\n- Document your wallet setup and recovery process\n- Consider multi-signature with trusted parties\n- Update your will or estate plan to include Bitcoin holdings\n\n**Important:** Balance security with accessibility. If you're the only one who knows where your seed phrase is, your Bitcoin may be lost if something happens to you.\n\n---\n\n## When to Use Custodial Services\n\nWhile self-custody is generally recommended, custodial services may make sense for:\n\n- **Very small amounts:** Convenience may outweigh risk\n- **Active trading:** Exchanges are necessary for trading\n- **Institutional needs:** Some institutions require custodial services\n- **Lack of technical knowledge:** If you're not comfortable with self-custody, use a reputable custodian while you learn\n\n**Trade-offs:** Understand that custodial services add counterparty risk. Use reputable, regulated services if you choose this route.\n\n---\n\n## Getting Started\n\n1. **Start small:** Begin with a small amount while you learn\n2. **Choose a hardware wallet:** Research and purchase a reputable hardware wallet\n3. **Set up securely:** Follow the device's setup instructions carefully\n4. **Backup seed phrase:** Write it down on paper and metal, store securely\n5. **Test recovery:** Delete and restore your wallet to verify your backup works\n6. **Gradually increase:** As you become more comfortable, you can increase your holdings\n\n---\n\n## Related Topics\n\n- [Risk Management](/docs/investment/risk-management) - Understanding investment risks, including custody risk\n- [Privacy](/docs/investment/privacy) - Privacy considerations for protecting your financial information\n- [Tools & Resources](/docs/investment/tools) - Wallet tools and other helpful resources\n- [Wallet Development](/docs/wallets) - Technical wallet development (for developers)\n- [Key Management](/docs/bitcoin-development/keys) - Technical key management (for developers)\n\n---\n\n**Remember:** Your Bitcoin is only as secure as your private keys. Take the time to learn proper security practices before storing significant amounts. The security of your Bitcoin is entirely in your hands.\n",
    "filename": "wallet-security.md"
  },
  "/docs/investment/privacy": {
    "content": "# Privacy\n\nBitcoin transactions are **pseudonymous, not anonymous**. While Bitcoin addresses don't directly reveal your identity, sophisticated blockchain analysis can link transactions and potentially identify you. This guide covers practical privacy considerations for Bitcoin investors, helping you understand the risks and tools available to protect your financial privacy.\n\n---\n\n## Understanding Bitcoin Privacy\n\n### Pseudonymity vs Anonymity\n\n**Pseudonymity** means your transactions are linked to addresses, not your real-world identity. However, if someone connects an address to your identity (through KYC, address reuse, or other methods), they can trace your entire transaction history.\n\n**Anonymity** would mean your transactions cannot be linked to you at all. Bitcoin does not provide true anonymity by default.\n\n### Why Privacy Matters for Investors\n\nPrivacy is important for several reasons:\n\n- **Financial Security:** Revealing your Bitcoin holdings can make you a target for theft or extortion\n- **Personal Safety:** Large holdings can attract unwanted attention\n- **Business Confidentiality:** Investment strategies and positions may be sensitive\n- **Regulatory Compliance:** Understanding privacy helps you comply with regulations while protecting your rights\n- **Financial Sovereignty:** Privacy is a fundamental aspect of financial freedom\n\n**Remember:** Privacy is a spectrum, not all-or-nothing. You can improve your privacy incrementally based on your needs and risk tolerance.\n\n---\n\n## KYC (Know Your Customer)\n\n**KYC (Know Your Customer)** is a regulatory requirement that forces financial institutions, including Bitcoin exchanges, to verify your identity by collecting personal information such as:\n\n- Government-issued ID\n- Proof of address\n- Social Security Number or equivalent\n- Sometimes biometric data (photos, fingerprints)\n\n### Why Exchanges Require KYC\n\nExchanges implement KYC to:\n\n- Comply with anti-money laundering (AML) regulations\n- Prevent fraud and financial crimes\n- Meet regulatory requirements in their jurisdiction\n- Reduce legal liability\n\n### Privacy Implications of KYC\n\n**Critical concern:** When you complete KYC, you're linking your real-world identity to your Bitcoin addresses permanently. This creates several privacy risks:\n\n- **Permanent Linkage:** Your identity is now connected to all Bitcoin you purchase through that exchange\n- **Data Breaches:** Exchanges can be hacked, exposing your personal information\n- **Government Surveillance:** KYC data can be accessed by governments and law enforcement\n- **Third-Party Sharing:** Exchanges may share your data with partners, advertisers, or other third parties\n- **Transaction Tracking:** Once your identity is linked, all future transactions from those addresses can be traced back to you\n\n### KYC vs Non-KYC Options\n\n| Aspect | KYC Exchanges | Non-KYC Options |\n|--------|---------------|-----------------|\n| **Examples** | Coinbase, Kraken, Binance | Bisq, P2P platforms, Bitcoin ATMs |\n| **Privacy** | Low (identity linked to addresses) | High (no identity required) |\n| **Convenience** | High (user-friendly, fast) | Low (more complex, slower) |\n| **Liquidity** | High | Lower |\n| **Legal Status** | Required by law in most jurisdictions | Legal but may have limits |\n| **Best For** | Large purchases, convenience, trading | Privacy, smaller amounts, avoiding surveillance |\n| **Trade-offs** | Privacy vs convenience | Convenience vs privacy |\n\n### When KYC Might Be Necessary vs When to Avoid It\n\n| Use KYC When | Avoid KYC When |\n|--------------|----------------|\n| Large purchases quickly | Value privacy highly |\n| Need trading features (margin, derivatives) | Making smaller purchases |\n| Required by law in your jurisdiction | Prefer decentralized solutions |\n| Want convenience and insurance | Concerned about data breaches |\n| Need fiat on-ramps | Want identity separation |\n\n### Regulatory Considerations\n\n**Important:** Laws vary by jurisdiction. Some considerations:\n\n- **Legal Requirements:** In many countries, KYC is legally required for exchanges above certain thresholds\n- **Tax Implications:** KYC exchanges provide tax reporting documents, which may be required\n- **Compliance:** Using non-KYC methods doesn't mean you're avoiding legal obligations (taxes, reporting, etc.)\n- **Future Regulations:** Regulations are evolving and may become stricter\n\n**Always consult with a tax professional and understand your local regulations.**\n\n### Alternatives to KYC Exchanges\n\nIf you want to minimize KYC exposure:\n\n1. **Use P2P Exchanges:** Platforms like Bisq allow direct peer-to-peer trading without KYC\n2. **Bitcoin ATMs:** Many ATMs have KYC limits (often $900-1,000 per transaction)\n3. **In-Person Cash Trades:** Meet with trusted individuals for cash transactions\n4. **Earn Bitcoin:** Get paid in Bitcoin for work or services\n5. **Mining:** Mine Bitcoin yourself (requires significant investment)\n6. **DEXs:** Decentralized exchanges (though liquidity may be limited)\n\n**Trade-off:** Non-KYC options are often less convenient, have lower liquidity, and may involve higher fees or risks.\n\n---\n\n## Mixing UTXOs (CoinJoin)\n\n**UTXO mixing** (also called **[CoinJoin](/docs/glossary#coinjoin)**) is a privacy technique that combines multiple users' transactions into a single transaction, making it difficult to determine which inputs belong to which outputs.\n\n### Why It Matters\n\nWhen you spend Bitcoin, blockchain analysts can use sophisticated techniques to link your transactions:\n\n- **Common-Input-Ownership Heuristic:** If multiple inputs are spent together, they're likely owned by the same person\n- **Change Output Analysis:** [Change outputs](/docs/glossary#change-output) often go back to the sender\n- **Timing Analysis:** Transactions made close together may be linked\n- **Address Clustering:** [Reusing addresses](/docs/glossary#address-reuse) links all transactions to that address\n\nMixing breaks these links by combining your UTXOs with others, making it much harder to trace your Bitcoin.\n\n### CoinJoin Explained (For Investors)\n\n**Simple analogy:** Imagine you and several friends put money into a hat, mix it up, then each take out the same amount. An observer can't tell whose money is whose.\n\n**In Bitcoin:**\n- Multiple users contribute inputs (UTXOs) to a single transaction\n- The transaction creates outputs for each participant\n- External observers can't determine which input belongs to which output\n- This breaks the link between your old addresses and new addresses\n\n### Popular Mixing Services/Wallets\n\n| Service | Type | Ease of Use | Fees | Best For |\n|---------|------|-------------|------|----------|\n| **Wasabi Wallet** | Desktop wallet | Beginner-friendly | 0.1-0.3% per round | Beginners, desktop users |\n| **Samourai Wallet (Whirlpool)** | Mobile wallet | Intermediate | 0.1-0.3% per round | Mobile users, privacy-focused |\n| **JoinMarket** | Command-line | Advanced | Lower (can earn fees) | Advanced users, technical |\n\n### When to Consider Mixing\n\nConsider mixing if you:\n\n- Want to break links between your old and new addresses\n- Have Bitcoin from KYC exchanges that you want to \"clean\"\n- Value privacy and want to make tracking difficult\n- Are moving significant amounts\n- Want to protect your financial privacy\n\n**Note:** Mixing is most effective when done before spending, not after receiving \"dirty\" coins.\n\n### Costs and Trade-offs\n\n| Aspect | Impact |\n|--------|--------|\n| **Fees** | 0.1-0.3% per mixing round |\n| **Time** | Requires coordination, can be slow |\n| **Complexity** | Requires understanding of the process |\n| **Privacy Gain** | High (especially with multiple rounds) |\n| **Exchange Risk** | Some exchanges may flag mixed coins |\n| **Legal Status** | Legal in most jurisdictions |\n\n### Legal Considerations\n\n**Important legal notes:**\n\n- **Legality:** CoinJoin/mixing is legal in most jurisdictions\n- **Exchange Policies:** Some exchanges may flag or reject mixed coins\n- **Regulatory Scrutiny:** Mixed coins may attract additional scrutiny\n- **Tax Obligations:** Mixing doesn't eliminate tax obligations\n- **Compliance:** Understand your local regulations\n\n**Always consult legal counsel if you have concerns about mixing in your jurisdiction.**\n\n---\n\n## Running Your Own Node\n\n### Why Running Your Own Node Improves Privacy\n\nWhen you use a wallet that connects to someone else's node (like most mobile and desktop wallets), you're revealing information:\n\n- **Your IP Address:** The node operator can see your IP\n- **Your Addresses:** You query the node about addresses you control\n- **Your Transactions:** You broadcast transactions through their node\n- **Your Balance:** Balance queries reveal which addresses you're checking\n\n**Running your own node** eliminates these privacy leaks because you're querying your own node, not a third party's.\n\n### How Nodes Protect Your Privacy\n\n**No Third-Party Queries:**\n- Your wallet connects to your own node\n- No one else sees your queries\n- Your IP isn't exposed to third-party node operators\n- You control all data\n\n**Full Verification:**\n- You verify all blocks yourself\n- No trust in third-party data\n- Complete sovereignty over your Bitcoin experience\n\n### Basic Node Setup Options\n\n| Option | Ease of Use | Storage Required | Hardware | Best For |\n|--------|-------------|------------------|----------|----------|\n| **Bitcoin Core** | Advanced | 400+ GB | Desktop/server | Technical users, full control |\n| **Umbrel** | Beginner-friendly | 400+ GB | Raspberry Pi/PC | Beginners, all-in-one solution |\n| **Raspiblitz** | Intermediate | 400+ GB | Raspberry Pi | DIY enthusiasts |\n| **MyNode** | Beginner-friendly | 400+ GB | Raspberry Pi | Pre-configured setup |\n| **Nodl** | Beginner-friendly | 400+ GB | Commercial hardware | Plug-and-play solution |\n| **Cloud Nodes** | Easy | N/A | Cloud service | Convenience (less private) |\n\n### Privacy Benefits vs Convenience Trade-offs\n\n**Privacy Benefits:**\n- No third-party sees your queries\n- Your IP isn't exposed\n- Complete control over your Bitcoin experience\n- Better security (you verify everything)\n\n**Convenience Trade-offs:**\n- Requires hardware and setup\n- Needs significant storage space\n- Requires internet bandwidth\n- Initial cost (hardware, electricity)\n- Maintenance and updates\n\n### When It Makes Sense for Investors\n\nRunning your own node makes sense if you:\n\n- Value privacy highly\n- Have significant Bitcoin holdings\n- Want complete sovereignty\n- Have technical knowledge or willingness to learn\n- Have space for hardware and good internet connection\n- Want to support the Bitcoin network\n\n**For most investors:** Using a reputable wallet with good privacy practices may be sufficient. Running a node is the gold standard but not necessary for everyone.\n\n---\n\n## Additional Privacy Topics\n\n### Address Reuse and Why to Avoid It\n\n**Address reuse** means using the same Bitcoin address for multiple transactions.\n\n**Why it's bad:**\n- Links all transactions to that address\n- Reveals your transaction history\n- Makes blockchain analysis easier\n- Reduces privacy significantly\n\n**Best practice:** Always use a new address for each transaction. Modern wallets (HD wallets) do this automatically.\n\n### Change Outputs and Privacy Implications\n\nWhen you spend Bitcoin, you often create a **change output** that goes back to you.\n\n**Privacy implications:**\n- Change outputs can be identified by blockchain analysts\n- They reveal how much you spent\n- They link your old and new addresses\n- They're a major privacy leak\n\n**Mitigation:**\n- Use wallets with good coin selection\n- Consider mixing before spending\n- Use multiple addresses\n- Understand that perfect privacy is difficult\n\n### Timing Analysis and How to Reduce It\n\n**Timing analysis** uses the timing of transactions to link them:\n\n- Transactions made close together may be related\n- Patterns in transaction timing can reveal behavior\n- Regular transactions (like DCA) create patterns\n\n**How to reduce:**\n- Vary transaction timing\n- Use mixing to break timing links\n- Batch transactions when possible\n- Be aware of patterns you create\n\n### IP Address Privacy\n\n**The problem:** When you broadcast transactions or query nodes, your IP address can be logged.\n\n**Solutions:**\n- **Tor:** Route Bitcoin traffic through Tor network\n- **VPN:** Use a VPN (though less private than Tor)\n- **Run your own node:** Eliminates third-party IP exposure\n- **Lightning Network:** Off-chain transactions don't reveal on-chain IPs\n\n**Note:** Tor and VPNs add complexity and may slow down transactions.\n\n### Lightning Network Privacy Benefits\n\nThe **Lightning Network** provides additional privacy benefits:\n\n- **Off-chain transactions:** Not visible on the blockchain\n- **Payment routing:** Payments are routed through multiple nodes\n- **No on-chain footprint:** Small, regular payments don't create blockchain records\n- **Reduced linkability:** Harder to trace payment flows\n\n**Trade-off:** Lightning requires technical setup and has its own considerations.\n\n### Privacy vs Convenience Trade-offs\n\n| Privacy Technique | Privacy Gain | Convenience Cost | When to Use |\n|------------------|--------------|------------------|-------------|\n| Running your own node | High | Medium-High | Significant holdings, high privacy needs |\n| CoinJoin/Mixing | High | Medium | Breaking transaction links, cleaning KYC coins |\n| Avoiding KYC | High | High | Privacy-first approach, smaller amounts |\n| Using Tor | Medium | Medium | Hiding IP address, querying explorers |\n| Address reuse avoidance | Medium | Low (automatic) | Always (HD wallets do this automatically) |\n| Lightning Network | Medium-High | Medium | Small regular payments, off-chain privacy |\n\n**Key insight:** Find the right balance for your needs. Perfect privacy may not be necessary or practical for everyone.\n\n### Practical Privacy Tips for Everyday Use\n\n1. **Use HD Wallets:** Automatically generate new addresses\n2. **Avoid Address Reuse:** Never reuse addresses\n3. **Be Careful with KYC:** Understand what you're revealing\n4. **Consider Mixing:** For significant amounts or high privacy needs\n5. **Run Your Own Node:** If privacy is a high priority\n6. **Use Lightning:** For small, regular payments\n7. **Be Aware of Patterns:** Regular transactions create patterns\n8. **Understand Trade-offs:** Privacy vs convenience\n9. **Stay Informed:** Privacy techniques evolve\n10. **Don't Overthink It:** Basic practices go a long way\n\n---\n\n## Privacy Best Practices for Investors\n\n### Privacy-Aware Exchange Selection\n\nWhen choosing exchanges, consider:\n\n- **KYC Requirements:** What information do they require?\n- **Data Retention:** How long do they keep your data?\n- **Privacy Policy:** What do they do with your information?\n- **Security:** How well do they protect your data?\n- **Reputation:** Have they had data breaches?\n\n**Remember:** Even the best exchange can be hacked. Minimize the data you provide.\n\n### Privacy-Preserving Transaction Patterns\n\n**Good patterns:**\n- Use new addresses for each transaction\n- Avoid consolidating UTXOs unnecessarily\n- Consider mixing before large transactions\n- Use Lightning for small, regular payments\n- Vary transaction timing\n\n**Bad patterns:**\n- Reusing addresses\n- Consolidating all UTXOs at once\n- Making transactions at predictable times\n- Linking all your addresses together\n\n### When Privacy Matters Most\n\nPrivacy is especially important when:\n\n- You have significant holdings\n- You're in a high-risk jurisdiction\n- You're concerned about personal safety\n- You want to protect business information\n- You value financial sovereignty\n- You're making large transactions\n\n### Balancing Privacy with Practical Needs\n\n**Reality check:** Perfect privacy is difficult and often impractical. Consider:\n\n- **Your threat model:** What are you protecting against?\n- **Your risk tolerance:** How much privacy do you need?\n- **Practical constraints:** What's feasible for you?\n- **Cost-benefit:** Is the privacy gain worth the cost?\n\n**Most investors** can achieve good privacy with basic practices:\n- Using HD wallets (automatic)\n- Avoiding address reuse (automatic with good wallets)\n- Being thoughtful about KYC\n- Understanding the basics\n\n**Advanced privacy** (mixing, running nodes, avoiding KYC) may be necessary for:\n- High-value holdings\n- High-risk situations\n- Strong privacy preferences\n- Specific threat models\n\n---\n\n## Related Topics\n\n- [Wallet Security & Self-Custody](/docs/investment/wallet-security) - Securing your Bitcoin holdings\n- [Privacy Techniques](/docs/wallets/privacy) - Technical privacy techniques (for developers)\n- [UTXO Model](/docs/fundamentals/utxos) - Understanding how [UTXOs](/docs/glossary#utxo-unspent-transaction-output) work\n- [Coin Selection](/docs/wallets/coin-selection) - Privacy-aware coin selection strategies\n- [Lightning Network](/docs/lightning) - Off-chain privacy benefits\n- [Tools for Investors](/docs/investment/tools) - Privacy-aware tools and resources\n\n---\n\nPrivacy is a journey, not a destination. Start with the basics and improve over time as you learn more and your needs evolve. Remember: even small privacy improvements are valuable.\n",
    "filename": "privacy.md"
  },
  "/docs/investment/market-cycles": {
    "content": "# Understanding Market Cycles\n\nBitcoin's price is characterized by extreme volatility and cyclical patterns. Understanding these cycles (driven by halving events, market psychology, and adoption waves) can help you navigate Bitcoin's market without making emotional decisions.\n\n---\n\n## Bitcoin's Volatility\n\n### Why Bitcoin is Volatile\n\nBitcoin's volatility comes from several factors:\n\n**Small market cap:** Compared to traditional assets, Bitcoin's market cap is relatively small. This means large buy or sell orders can significantly impact price.\n\n**24/7 trading:** Bitcoin trades 24/7 globally, with no market close. This continuous trading can amplify price movements.\n\n**Market sentiment:** Bitcoin's price is heavily influenced by sentiment, news, and social media. This can create rapid price swings.\n\n**Low liquidity:** During certain periods, Bitcoin has lower liquidity than traditional markets, making prices more sensitive to large orders.\n\n**Speculation:** A significant portion of Bitcoin trading is speculative, which can amplify volatility.\n\n**Adoption waves:** Bitcoin experiences waves of adoption, each bringing new buyers and price appreciation, followed by consolidation.\n\n### Volatility is a Feature, Not a Bug\n\nWhile volatility can be stressful, it's also what creates opportunities:\n\n- **Entry opportunities:** Volatility creates buying opportunities during downturns\n- **Price discovery:** Volatility helps the market discover Bitcoin's true value\n- **Weeding out weak hands:** Volatility separates long-term holders from short-term speculators\n- **Network security:** Price appreciation funds mining, which secures the network\n\n**Key Insight:** Bitcoin's volatility decreases over longer time horizons. While daily or weekly volatility can be extreme, annual volatility is more manageable, and multi-year trends are clearer.\n\n---\n\n## The Halving Cycle\n\nA **halving** is an event where Bitcoin's block subsidy (the reward miners receive) is cut in half. This happens approximately every four years (every 210,000 blocks).\n\nHalvings are programmed into Bitcoin's code and will continue until the block subsidy reaches zero (around 2140). After that, miners will be compensated solely through transaction fees.\n\n### Historical Halvings\n\n| Year | Block Reward Before | Block Reward After | Block Height |\n|------|-------------------|-------------------|--------------|\n| 2012 | 50 BTC | 25 BTC | 210,000 |\n| 2016 | 25 BTC | 12.5 BTC | 420,000 |\n| 2020 | 12.5 BTC | 6.25 BTC | 630,000 |\n| 2024 | 6.25 BTC | 3.125 BTC | 840,000 |\n\n### The Four-Year Cycle\n\nBitcoin tends to follow a four-year cycle aligned with halvings:\n\n| Phase | Duration | Description |\n|-------|----------|------------|\n| **Halving Event** | Day 0 | Supply growth rate is cut in half |\n| **Bull Market** | 12-18 months | Price appreciation as reduced supply meets growing demand |\n| **Peak** | Variable | Price reaches new all-time high |\n| **Bear Market** | 12-18 months | Price correction and consolidation |\n| **Accumulation Phase** | Variable | Price stabilizes, new cycle begins |\n\n**Important:** This is a general pattern, not a guarantee. Each cycle is different, and past performance doesn't guarantee future results.\n\n### Why Halvings Matter\n\n**Supply shock:** Halvings reduce the rate of new Bitcoin creation, creating a supply shock.\n\n**Increased scarcity:** With less new Bitcoin entering the market, existing Bitcoin becomes relatively scarcer.\n\n**Mining economics:** Halvings reduce miner revenue, potentially impacting mining economics and network security (though transaction fees help offset this).\n\n**Market psychology:** Halvings create anticipation and media attention, potentially driving adoption and price appreciation.\n\n**Key Insight:** While halvings don't guarantee price appreciation, they create structural changes to Bitcoin's supply dynamics that historically have coincided with bull markets.\n\n---\n\n## Market Psychology\n\n### The Emotional Cycle\n\nBitcoin markets follow a predictable emotional cycle:\n\n| Phase | Emotion | Market Condition | Investor Behavior |\n|-------|---------|------------------|-------------------|\n| 1 | **Optimism** | Early price appreciation | Early buyers enter |\n| 2 | **Excitement** | Rapid price gains | FOMO begins |\n| 3 | **Euphoria** | Prices peak, media attention peaks | Everyone wants Bitcoin |\n| 4 | **Anxiety** | Prices start to decline | Early euphoria turns to anxiety |\n| 5 | **Denial** | Continued decline | Investors deny the decline |\n| 6 | **Fear** | Prices continue falling | Fear sets in |\n| 7 | **Desperation** | Significant losses | Investors panic |\n| 8 | **Capitulation** | Bottom approaches | Investors give up and sell |\n| 9 | **Depression** | Prices bottom | Media turns negative |\n| 10 | **Hope** | Prices stabilize | Early signs of recovery |\n| 11 | **Relief** | Prices begin to recover | Relief sets in |\n| 12 | **Optimism** | Recovery continues | Cycle begins again |\n\n**Understanding this cycle helps you:**\n- Recognize when you're in euphoria (be cautious)\n- Recognize when you're in capitulation (potential buying opportunity)\n- Avoid making emotional decisions\n- Maintain perspective during extreme market conditions\n\n### Common Psychological Patterns\n\n| Pattern | Description | Risk |\n|---------|-------------|------|\n| **FOMO** (Fear of Missing Out) | Buying when prices are surging because you're afraid of missing gains | Often leads to buying at the top |\n| **FUD** (Fear, Uncertainty, Doubt) | Selling when prices are dropping because of fear | Often leads to selling at the bottom |\n| **Anchoring** | Fixating on a previous price (like an all-time high) and making decisions based on that anchor | Decisions based on past, not current fundamentals |\n| **Recency bias** | Overweighting recent price movements and assuming they'll continue | Assumes current trend will continue indefinitely |\n| **Confirmation bias** | Seeking information that confirms your existing beliefs while ignoring contradictory information | Prevents objective analysis |\n\n**Avoid these patterns:** Stick to your plan, focus on fundamentals, and maintain a long-term perspective.\n\n---\n\n## Bull Markets\n\n### Characteristics\n\n| Indicator | Description |\n|-----------|-------------|\n| **Rising prices** | Sustained upward price movement over months or years |\n| **High volume** | Increased trading volume as more participants enter |\n| **Media attention** | Positive media coverage and mainstream adoption stories |\n| **FOMO** | Fear of missing out drives new buyers into the market |\n| **Euphoria** | Extreme optimism, \"this time is different\" narratives |\n| **New all-time highs** | Price breaks previous records |\n\n### Warning Signs\n\n| Warning Sign | What It Means | Action |\n|--------------|---------------|--------|\n| **Extreme euphoria** | Everyone is talking about Bitcoin and predicting continued gains | Be cautious |\n| **Rapid price appreciation** | Unsustainable price growth | Often precedes corrections |\n| **Media frenzy** | Mainstream media is overwhelmingly positive | The top may be near |\n| **New investor influx** | Many new, inexperienced investors enter | Market may be overheated |\n| **Leverage and speculation** | High levels of leverage and speculation | Often precedes corrections |\n\n### How to Navigate Bull Markets\n\n**Stick to your plan:** Don't let euphoria change your strategy.\n\n**Take profits if needed:** If your allocation has grown too large, consider taking some profits.\n\n**Avoid FOMO:** Don't buy more just because prices are rising. Stick to your [Dollar Cost Averaging](/docs/investment-strategy) plan.\n\n**Maintain perspective:** Remember that bull markets don't last forever. Corrections are normal.\n\n**Don't trade:** Trying to time the top is extremely difficult. Most people fail.\n\n---\n\n## Bear Markets\n\n### Characteristics\n\n| Indicator | Description |\n|-----------|-------------|\n| **Falling prices** | Sustained downward price movement over months or years |\n| **Low volume** | Reduced trading volume as participants exit or wait |\n| **Negative media** | Negative media coverage and \"Bitcoin is dead\" narratives |\n| **FUD** | Fear, uncertainty, and doubt dominate market sentiment |\n| **Capitulation** | Investors give up and sell at a loss |\n| **Price consolidation** | Prices stabilize at lower levels |\n\n### Opportunities\n\n| Opportunity | Benefit |\n|------------|---------|\n| **Buying opportunities** | Bear markets create buying opportunities for those with a long-term perspective |\n| **Lower prices** | You can accumulate Bitcoin at lower prices |\n| **Weeding out weak hands** | Bear markets separate long-term holders from short-term speculators |\n| **Building conviction** | Surviving bear markets builds conviction and resilience |\n| **Network continues** | Bitcoin's network continues to operate and improve, regardless of price |\n\n### How to Navigate Bear Markets\n\n**Maintain perspective:** Remember that bear markets are temporary. Bitcoin has survived many.\n\n**Focus on fundamentals:** Bitcoin's technology and properties haven't changed. Focus on fundamentals, not price.\n\n**Continue DCA:** [Dollar Cost Averaging](/docs/investment-strategy) is particularly effective during bear markets.\n\n**Avoid panic selling:** Don't make emotional decisions. Stick to your long-term plan.\n\n**Use the time to learn:** Bear markets are a good time to deepen your understanding of Bitcoin.\n\n**Build resilience:** Surviving bear markets builds psychological resilience for future cycles.\n\n---\n\n## Market Phases\n\n| Phase | Characteristics | Strategy |\n|-------|----------------|----------|\n| **Accumulation** | â€¢ Prices are low and stable<br>â€¢ Low media attention<br>â€¢ Few new investors<br>â€¢ Long-term holders accumulate | This is an ideal time to build your position through Dollar Cost Averaging. |\n| **Markup** | â€¢ Prices begin to rise<br>â€¢ Increasing media attention<br>â€¢ More investors enter<br>â€¢ Optimism grows | Continue your accumulation strategy. Don't let FOMO drive decisions. |\n| **Distribution** | â€¢ Prices peak<br>â€¢ Maximum media attention<br>â€¢ Euphoria and FOMO<br>â€¢ Everyone wants Bitcoin | Be cautious. Consider taking profits if your allocation has grown too large. Avoid buying more due to FOMO. |\n| **Markdown** | â€¢ Prices decline<br>â€¢ Negative media coverage<br>â€¢ Investors exit<br>â€¢ Fear and capitulation | This is a buying opportunity for those with a long-term perspective. Avoid panic selling. |\n\n---\n\n## Navigating Cycles Without Emotion\n\n### Have a Plan\n\n**Before investing:**\n- Define your time horizon\n- Set your investment strategy ([DCA](/docs/investment-strategy), lump sum, etc.)\n- Determine your risk tolerance\n- Decide when you might sell (if ever)\n\n**Stick to your plan:** Don't let market cycles change your strategy.\n\n### Focus on Fundamentals\n\n**Bitcoin's properties haven't changed:**\n- Scarcity remains\n- Network effects continue to grow\n- Technology continues to improve\n- Adoption continues to increase\n\n**Price is noise, fundamentals are signal:** Focus on Bitcoin's properties, not daily price movements.\n\n### Avoid Constant Price Checking\n\n**Check less frequently:**\n- Daily price checking increases stress\n- Weekly or monthly checks are sufficient\n- Focus on your strategy, not price\n\n### Maintain Perspective\n\n**Remember:**\n- Volatility is normal for Bitcoin\n- Bear markets are temporary\n- Bull markets don't last forever\n- Long-term trends matter more than short-term movements\n\n### Build a Community\n\n**Connect with other Bitcoiners:**\n- Share experiences and strategies\n- Get support during difficult times\n- Learn from others' experiences\n- Maintain perspective through community\n\n---\n\n## Historical Patterns\n\n### Past Cycles\n\n| Period | Cycle Phase | Key Events | Peak Price |\n|--------|-------------|------------|------------|\n| **2010-2013** | Early adoption, first major bull run | First exchanges, early adoption | ~$1,000 |\n| **2014-2016** | Bear market, consolidation | Mt. Gox collapse, accumulation phase | - |\n| **2017** | Major bull run | ICO boom, mainstream attention | ~$20,000 |\n| **2018-2019** | Bear market, consolidation | Regulatory uncertainty, accumulation | - |\n| **2020-2021** | Major bull run | Institutional adoption, ETF approval | ~$69,000 |\n| **2022-2023** | Bear market, consolidation | Macroeconomic headwinds, accumulation | - |\n| **2024-present** | New cycle beginning | Halving event, continued adoption | TBD |\n\n**Key Insight:** Each cycle is different, but the general pattern of bull markets followed by bear markets followed by accumulation has repeated. However, past performance doesn't guarantee future results.\n\n### What's Different Each Cycle\n\n| Factor | How It Changes |\n|--------|----------------|\n| **Market cap** | Each cycle starts with a larger market cap |\n| **Adoption** | More people and institutions adopt Bitcoin each cycle |\n| **Infrastructure** | Better infrastructure and tools each cycle |\n| **Regulation** | Evolving regulatory environment |\n| **Media attention** | Increasing mainstream attention |\n\n**Important:** While patterns repeat, each cycle is unique. Don't assume the next cycle will be exactly like previous ones.\n\n---\n\n## Common Mistakes During Cycles\n\n| Mistake | Why It's Problematic | Better Approach |\n|---------|----------------------|-----------------|\n| **Buying at the top** | FOMO-driven purchases during euphoria often lead to buying at peaks | Stick to your DCA plan |\n| **Selling at the bottom** | Panic selling during bear markets locks in losses | Maintain long-term perspective |\n| **Trying to time the market** | Extremely difficult and often leads to worse results than holding | Focus on time in market, not timing |\n| **Emotional decisions** | Decisions based on fear or greed rather than your plan | Stick to your predetermined strategy |\n| **Ignoring fundamentals** | Focusing on price instead of Bitcoin's fundamental properties | Focus on Bitcoin's properties |\n| **Over-leveraging** | Using too much leverage during bull markets often leads to liquidation | Avoid excessive leverage |\n\n---\n\n## Related Topics\n\n- [Investment Strategy](/docs/investment-strategy) - DCA and long-term holding strategies for navigating cycles\n- [Risk Management](/docs/investment/risk-management) - Understanding and managing investment risks\n- [Halvings](/docs/history/halvings) - Understanding Bitcoin's halving events and their impact\n\n---\n\n**Remember:** Market cycles are a feature of Bitcoin, not a bug. Understanding these cycles helps you navigate them without making emotional decisions. Focus on Bitcoin's fundamentals, stick to your plan, and maintain a long-term perspective. Bitcoin rewards those who can see through the noise of short-term volatility.\n",
    "filename": "market-cycles.md"
  },
  "/docs/adoption": {
    "content": "# Bitcoin Adoption\n\nBitcoin is more than code and cryptography. It's a tool being used by real people to solve real problems. From energy producers monetizing waste to rural communities accessing financial services, Bitcoin adoption is happening in diverse and innovative ways around the world.\n\n---\n\n![Bitcoin vs Internet Adoption](/images/docs/adoption.jpg)\n\n## Why Real-World Examples Matter\n\nUnderstanding Bitcoin's technical foundations is essential, but seeing how Bitcoin is actually used reveals its practical value:\n\n- **Energy Innovation**: Bitcoin mining is turning wasted energy into economic value, from flared natural gas to excess renewable capacity\n- **Financial Inclusion**: Communities without traditional banking are using Bitcoin for remittances, savings, and daily transactions\n- **Economic Freedom**: People in high-inflation countries are preserving wealth and accessing global markets\n- **Humanitarian Aid**: Non-profits are using Bitcoin to deliver aid directly to those in need, bypassing corrupt intermediaries\n\nThese use cases demonstrate Bitcoin's unique properties in action: [censorship resistance](/docs/fundamentals/trust-model), [portability](/docs/fundamentals/monetary-properties), [verifiability](/docs/bitcoin/cryptography), and [decentralization](/docs/fundamentals/decentralization).\n\n---\n\n## Adoption Stories\n\n### [Stranded Energy and Flared Gas](/docs/adoption/stranded-energy)\n\nBitcoin mining is uniquely suited to use energy that would otherwise be wasted. Oil fields flare natural gas because it's not economical to transport. Hydroelectric plants curtail excess generation when demand is low. Wind and solar farms produce energy that can't be stored or transmitted.\n\nBitcoin miners can operate anywhere, turn on and off instantly, and monetize energy that has no other use. This creates economic value from waste while providing security to the Bitcoin network.\n\n**Examples:**\n- Crusoe Energy converting flared gas to Bitcoin mining\n- Hydroelectric plants using excess capacity for mining\n- Wind farms monetizing curtailed generation\n\n### [Rural Communities and Financial Inclusion](/docs/adoption/rural-communities)\n\nBillions of people lack access to traditional banking. Bitcoin, combined with the Lightning Network, enables financial services without banks:\n\n- **Remittances**: Send money across borders without intermediaries\n- **Savings**: Store value in a currency that can't be inflated\n- **Payments**: Make micro-payments and daily transactions\n- **Access**: All you need is a smartphone and internet connection\n\nFrom El Salvador's national adoption to African communities using Bitcoin for remittances, real people are using Bitcoin to solve real problems.\n\n### [Other Use Cases](/docs/adoption/use-cases)\n\nBitcoin adoption spans individuals, businesses, and nations:\n\n- **Remittances**: Cross-border payments without banks\n- **Store of Value**: Preserving wealth in high-inflation economies\n- **Corporate Adoption**: Companies holding Bitcoin as treasury reserves\n- **Country-Level Adoption**: Nations recognizing Bitcoin as legal tender\n- **Humanitarian Aid**: Direct aid delivery without intermediaries\n\n---\n\n## The Adoption Cycle\n\nBitcoin adoption follows a pattern:\n\n1. **Early Adopters**: Technical users and cypherpunks understand Bitcoin's potential\n2. **Use Case Discovery**: People find specific problems Bitcoin solves\n3. **Network Effects**: As more people use Bitcoin, its value increases\n4. **Mainstream Awareness**: Media coverage and institutional interest grow\n5. **Infrastructure Development**: Tools, services, and education improve\n6. **Mass Adoption**: Bitcoin becomes part of everyday life\n\nWe're still in the early stages of this cycle. Each new use case strengthens Bitcoin's network effects and demonstrates its unique value proposition.\n\n---\n\n## Related Topics\n\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin has value\n- [Energy Consumption](/docs/controversies/energy-consumption) - The energy debate\n- [Lightning Network](/docs/lightning) - Fast, cheap payments\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin enables trustless transactions\n- [Decentralization](/docs/fundamentals/decentralization) - Why Bitcoin can't be stopped\n- [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) - How ideas and culture drive adoption\n\n---\n\nBitcoin is being adopted because it solves real problems for real people. These stories show what's possible when money is programmable, borderless, and resistant to censorship.\n",
    "filename": "overview.md"
  },
  "/docs/adoption/stranded-energy": {
    "content": "# Stranded Energy and Flared Gas\n\nBitcoin mining has a unique property: it can monetize energy that would otherwise be wasted. This creates economic value from stranded energy sources like flared natural gas, excess hydroelectric capacity, and curtailed renewable generation.\n\n---\n\n![Bitcoin mine in remote Zambia](/images/docs/bitcoin-africa.webp)\n\n*Bitcoin mine in remote Zambia*\n\n## What is Stranded Energy?\n\n**Stranded energy** is energy that is produced but cannot be economically used, stored, or transmitted. Common sources include:\n\n- **Flared natural gas**: Gas produced at oil wells that's burned off because it's not economical to transport\n- **Excess renewable capacity**: Solar and wind generation that exceeds grid demand\n- **Hydroelectric curtailment**: Excess generation when demand is low\n- **Off-grid renewable**: Solar or wind in remote locations without transmission infrastructure\n\nTraditional energy consumers need:\n- **Reliable demand**: Consistent, predictable consumption\n- **Location flexibility**: Ability to connect to transmission infrastructure\n- **Economic viability**: Sufficient value to justify infrastructure investment\n\nBitcoin mining needs none of these. Miners can:\n- **Operate anywhere**: No need for transmission infrastructure\n- **Turn on/off instantly**: Respond to energy availability in real-time\n- **Monetize any amount**: Even small amounts of energy can be profitable\n- **Use waste energy**: Energy that has no other economic use\n\nThis makes Bitcoin mining uniquely suited to monetize stranded energy.\n\n---\n\n## Flared Natural Gas\n\n### The Problem\n\nOil production often produces natural gas as a byproduct. In many locations, this gas:\n- Has no pipeline infrastructure to transport it\n- Is too expensive to capture and process\n- Must be flared (burned) to prevent dangerous buildup\n- Represents wasted energy and environmental impact\n\nThe World Bank estimates that over 140 billion cubic meters of natural gas are flared annually worldwide, enough to power entire countries.\n\n### The Solution\n\nBitcoin miners can be deployed directly at oil fields to use flared gas:\n\n1. **Capture the gas**: Instead of flaring, capture the natural gas\n2. **Generate electricity**: Use generators to convert gas to electricity\n3. **Mine Bitcoin**: Use the electricity to power mining equipment\n4. **Create value**: Turn waste into economic value\n\nThis approach:\n- **Reduces flaring**: Less gas is burned, reducing environmental impact\n- **Creates revenue**: Oil producers earn money from otherwise wasted gas\n- **Secures Bitcoin**: Provides hash rate to the Bitcoin network\n- **Is economically viable**: Even small amounts of gas can be profitable\n\n### Case Studies\n\n**Crusoe Energy** has deployed Bitcoin mining operations at oil fields across the United States, converting flared gas into Bitcoin mining. Their operations:\n- Reduce flaring by capturing and using gas that would be burned\n- Provide revenue to oil producers\n- Operate in remote locations without grid infrastructure\n\n**Upstream Data** provides similar services, deploying mobile mining units at oil production sites to monetize flared gas.\n\n---\n\n## Excess Renewable Energy\n\n### The Problem\n\nRenewable energy sources like solar and wind have variable output:\n- **Solar**: Generates during daylight hours, peak at midday\n- **Wind**: Generates when wind is blowing, often at night\n- **Grid demand**: Doesn't always match generation patterns\n\nWhen generation exceeds demand:\n- **Curtailment**: Renewable generators must reduce output\n- **Wasted energy**: Clean energy is produced but not used\n- **Economic loss**: Generators lose revenue from curtailed generation\n- **Storage limitations**: Batteries are expensive and have capacity limits\n\n### The Solution\n\nBitcoin miners can consume excess renewable energy:\n\n1. **Grid priority**: Renewable energy serves the grid first\n2. **Excess mining**: When generation exceeds demand, miners consume the excess\n3. **Instant response**: Miners can turn on/off instantly as energy becomes available\n4. **Revenue generation**: Renewable operators earn revenue from otherwise wasted energy\n\nThis creates a symbiotic relationship:\n- **Renewable operators**: Earn revenue from excess generation\n- **Bitcoin network**: Gets clean energy hash rate\n- **Grid stability**: Helps balance supply and demand\n- **Environmental benefit**: More renewable energy is utilized\n\n### Case Studies\n\n**Hydroelectric plants** in regions with excess capacity have deployed Bitcoin mining to monetize energy that would otherwise be curtailed. During low-demand periods, excess generation powers mining operations.\n\n**Solar farms** in remote locations without transmission infrastructure use Bitcoin mining to monetize generation that can't reach the grid.\n\n---\n\n## Environmental Benefits\n\nBitcoin mining using stranded energy has several environmental benefits:\n\n### Reducing Waste\n\n- **Less flaring**: Using flared gas reduces methane emissions\n- **More renewable utilization**: Excess renewable energy is used instead of curtailed\n- **Efficient energy use**: Energy that would be wasted creates value\n\n### Economic Incentives\n\n- **Renewable development**: Revenue from mining can fund renewable energy projects\n- **Grid stability**: Mining can help balance supply and demand\n- **Energy innovation**: Creates economic incentives for energy innovation\n\n### Criticisms and Responses\n\nCritics argue that Bitcoin mining incentivizes energy production. However:\n- **Stranded energy exists regardless**: Flaring and curtailment happen with or without Bitcoin\n- **Bitcoin uses waste**: Mining stranded energy doesn't increase total energy production\n- **Grid priority**: Renewable energy serves the grid first; mining uses excess\n\nFor more on the energy debate, see [Energy Consumption](/docs/controversies/energy-consumption).\n\n---\n\n## Economic Model\n\nBitcoin mining with stranded energy creates a unique economic model:\n\n### For Energy Producers\n\n- **New revenue stream**: Monetize energy that has no other use\n- **Reduced waste**: Less flaring, less curtailment\n- **Flexible operations**: Miners can operate when energy is available\n- **No infrastructure needed**: Miners can be deployed anywhere\n\n### For Bitcoin Miners\n\n- **Low-cost energy**: Stranded energy is often very cheap or free\n- **Competitive advantage**: Lower energy costs improve profitability\n- **Sustainable operations**: Using waste energy addresses environmental concerns\n- **Diverse locations**: Access to energy sources not available to traditional consumers\n\n### For the Bitcoin Network\n\n- **Hash rate security**: More hash rate makes the network more secure\n- **Geographic distribution**: Mining in diverse locations improves decentralization\n- **Clean energy**: More hash rate from renewable sources\n- **Network resilience**: Diverse energy sources improve network resilience\n\n---\n\n## Challenges and Limitations\n\n### Technical Challenges\n\n- **Intermittent supply**: Stranded energy may be intermittent\n- **Remote locations**: Deploying and maintaining equipment in remote areas\n- **Scaling**: Small amounts of energy may not justify mining operations\n- **Regulatory**: Regulations vary by jurisdiction\n\n### Economic Challenges\n\n- **Bitcoin price volatility**: Mining profitability depends on Bitcoin price\n- **Equipment costs**: Mining hardware requires upfront investment\n- **Operational costs**: Maintenance and operations in remote locations\n- **Energy price fluctuations**: Energy costs may change over time\n\n### Solutions\n\n- **Modular deployment**: Mobile mining units can be deployed quickly\n- **Flexible operations**: Miners can turn on/off based on energy availability\n- **Partnerships**: Energy producers and miners can form partnerships\n- **Technology improvements**: More efficient mining hardware improves economics\n\n---\n\n## Future Potential\n\nThe potential for Bitcoin mining to use stranded energy is significant:\n\n- **Flared gas**: Billions of cubic meters of gas are flared annually\n- **Renewable curtailment**: Growing renewable capacity increases curtailment\n- **Off-grid renewables**: Remote renewable projects without transmission\n- **Energy storage**: Mining can complement battery storage systems\n\nAs Bitcoin mining technology improves and energy infrastructure evolves, the opportunities to monetize stranded energy will continue to grow.\n\n---\n\n## Related Topics\n\n- [Energy Consumption](/docs/controversies/energy-consumption) - The broader energy debate\n- [Proof-of-Work](/docs/mining/proof-of-work) - How Bitcoin mining works\n- [Mining Economics](/docs/mining/economics) - The economics of Bitcoin mining\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin has value\n\n---\n\nBitcoin mining's ability to monetize stranded energy demonstrates how Bitcoin creates value from resources that would otherwise be wasted. This economic model benefits energy producers, secures the Bitcoin network, and can reduce environmental waste.\n",
    "filename": "stranded-energy.md"
  },
  "/docs/adoption/rural-communities": {
    "content": "# Rural Communities and Financial Inclusion\n\nBitcoin, combined with the Lightning Network, is enabling financial services for communities that traditional banking has failed to serve. From remittances to savings to daily payments, Bitcoin is providing financial access to billions of people worldwide.\n\n---\n\n## The Banking Gap\n\n### The Problem\n\nOver 1.7 billion adults worldwide lack access to traditional banking services. They face:\n\n- **No bank accounts**: Banks don't operate in remote or underserved areas\n- **High fees**: Remittances can cost 10-20% of the amount sent\n- **Slow transfers**: International transfers can take days or weeks\n- **Currency restrictions**: Limited ability to hold or transfer foreign currencies\n- **Inflation risk**: Local currencies can lose value rapidly\n- **Censorship**: Accounts can be frozen or restricted\n\nTraditional banking requires:\n- **Physical infrastructure**: Branches, ATMs, payment networks\n- **Regulatory compliance**: KYC/AML requirements that exclude many people\n- **Minimum balances**: Account requirements that many can't meet\n- **Credit history**: Requirements that exclude the unbanked\n\n### The Solution\n\nBitcoin requires only:\n- **A smartphone**: Most people in developing countries have smartphones\n- **Internet connection**: Mobile data is widely available\n- **No bank account**: Bitcoin operates without banks\n- **No permission**: Anyone can use Bitcoin\n\nThis makes Bitcoin uniquely suited to serve the unbanked.\n\n---\n\n## Remittances\n\n### The Traditional Remittance Problem\n\nRemittances (money sent by migrant workers to their families) are a lifeline for millions. But traditional remittances have major problems:\n\n- **High fees**: Average fees of 6-10%, often much higher\n- **Slow transfers**: Can take days to arrive\n- **Limited access**: Recipients may need to travel to pickup locations\n- **Currency conversion**: Multiple currency conversions add costs\n- **Limited hours**: Services may only be available during business hours\n\n### Bitcoin Remittances\n\nBitcoin, especially via the Lightning Network, solves these problems:\n\n- **Low fees**: Lightning Network fees are typically less than 1%\n- **Instant transfers**: Lightning payments settle in seconds\n- **24/7 availability**: Bitcoin works anytime, anywhere\n- **Direct transfer**: No intermediaries, no pickup locations needed\n- **Single currency**: Bitcoin is the same currency everywhere\n\n### Real-World Examples\n\n**El Salvador**: After adopting Bitcoin as legal tender, remittances became faster and cheaper. Families receive money directly in Bitcoin wallets, avoiding traditional remittance fees.\n\n**African countries**: Services like Bitnob and Strike enable Bitcoin remittances across Africa, reducing costs and increasing speed compared to traditional services.\n\n**Philippines**: Companies like Coins.ph enable Bitcoin remittances, allowing overseas workers to send money home instantly and cheaply.\n\n---\n\n## Savings and Store of Value\n\n### The Inflation Problem\n\nMany developing countries experience high inflation:\n- **Venezuela**: Hyperinflation destroyed the bolivar's value\n- **Argentina**: Persistent high inflation erodes savings\n- **Turkey**: Currency devaluation reduces purchasing power\n- **Zimbabwe**: Historical hyperinflation destroyed the currency\n\nIn these environments, saving in local currency means losing value over time.\n\n### Bitcoin as Savings\n\nBitcoin offers:\n- **Fixed supply**: Only 21 million bitcoin will ever exist\n- **No inflation**: Bitcoin's supply schedule is predictable and decreasing\n- **Global value**: Bitcoin's value isn't tied to any single country\n- **Self-custody**: You control your Bitcoin; no bank can freeze it\n- **Portable**: Bitcoin can be taken across borders\n\n### Real-World Examples\n\n**Venezuela**: Despite government restrictions, Venezuelans use Bitcoin to preserve savings as the bolivar hyperinflates.\n\n**Nigeria**: Nigerians use Bitcoin to protect savings from currency devaluation and capital controls.\n\n**Lebanon**: During the 2019-2020 financial crisis, Lebanese turned to Bitcoin as the banking system collapsed.\n\n---\n\n## Daily Payments\n\n### The Payment Problem\n\nIn many rural and developing areas:\n- **Cash-only**: Limited acceptance of digital payments\n- **No credit cards**: Card networks don't serve these areas\n- **Mobile money limitations**: Services like M-Pesa have restrictions and fees\n- **Currency volatility**: Local currency value can change rapidly\n\n### Lightning Network Payments\n\nThe Lightning Network enables:\n- **Micro-payments**: Pay for small purchases (coffee, phone credit, etc.)\n- **Instant settlement**: Payments confirm in seconds\n- **Low fees**: Fees are fractions of a cent\n- **Global currency**: Bitcoin works the same everywhere\n- **No intermediaries**: Direct peer-to-peer payments\n\n### Real-World Examples\n\n**El Salvador**: After Bitcoin adoption, merchants accept Bitcoin via Lightning. People use Bitcoin for daily purchases like groceries and transportation.\n\n**African communities**: Lightning Network enables micro-payments for services like phone credit, internet access, and small purchases.\n\n**Remote areas**: Where banking infrastructure doesn't exist, Bitcoin and Lightning provide payment capabilities.\n\n---\n\n## El Salvador: National Adoption\n\n### The Experiment\n\nIn September 2021, El Salvador became the first country to adopt Bitcoin as legal tender. The government:\n- **Made Bitcoin legal tender**: Bitcoin must be accepted alongside the US dollar\n- **Created Chivo wallet**: Government wallet with $30 in Bitcoin for each citizen\n- **Installed Bitcoin ATMs**: Infrastructure for buying and selling Bitcoin\n- **Mined Bitcoin with geothermal energy**: Using volcanic energy for mining\n\n### Results and Challenges\n\n**Successes:**\n- **Faster remittances**: Money from abroad arrives instantly\n- **Lower fees**: Remittances cost less than traditional services\n- **Financial inclusion**: More people have access to digital payments\n- **Tourism**: Bitcoin adoption attracted Bitcoin tourists\n\n**Challenges:**\n- **Technical complexity**: Many citizens struggled with wallet usage\n- **Volatility**: Bitcoin price fluctuations created uncertainty\n- **Infrastructure**: Limited internet and smartphone access in rural areas\n- **Education**: Learning curve for using Bitcoin\n\n### Lessons Learned\n\nEl Salvador's experiment shows:\n- **Bitcoin can work as legal tender**: The technology functions\n- **Education is critical**: Users need training and support\n- **Infrastructure matters**: Internet and smartphone access are prerequisites\n- **Volatility is a challenge**: Price fluctuations create uncertainty\n\nDespite challenges, El Salvador demonstrated that national Bitcoin adoption is technically feasible.\n\n---\n\n## Challenges and Solutions\n\n### Technical Challenges\n\n**Internet access**: Bitcoin requires internet connectivity\n- **Solution**: Mobile data is increasingly available, even in rural areas\n- **Offline options**: Some wallets support offline transaction signing\n\n**Smartphone availability**: Bitcoin wallets need smartphones\n- **Solution**: Smartphone adoption is growing rapidly worldwide\n- **Lightweight clients**: SPV wallets reduce resource requirements\n\n**User education**: Bitcoin has a learning curve\n- **Solution**: Simplified wallets, educational resources, community support\n- **Gradual adoption**: Start with simple use cases (remittances) before advanced features\n\n### Economic Challenges\n\n**Volatility**: Bitcoin price can fluctuate significantly\n- **Solution**: Lightning Network enables instant conversion to local currency\n- **Education**: Understanding volatility helps users make informed decisions\n- **Gradual adoption**: Start small, learn, then increase usage\n\n**Liquidity**: Converting Bitcoin to local currency\n- **Solution**: Bitcoin ATMs, peer-to-peer exchanges, merchant acceptance\n- **Growing infrastructure**: More options for buying and selling Bitcoin\n\n### Regulatory Challenges\n\n**Government restrictions**: Some governments restrict Bitcoin\n- **Solution**: Bitcoin is censorship-resistant; restrictions are difficult to enforce\n- **Education**: Demonstrating Bitcoin's benefits can change attitudes\n- **Advocacy**: Working with governments to create favorable regulations\n\n---\n\n## Future Potential\n\nThe potential for Bitcoin to serve the unbanked is enormous:\n\n- **1.7 billion unbanked adults**: Massive addressable market\n- **Growing smartphone adoption**: More people can access Bitcoin\n- **Improving infrastructure**: Better internet and mobile networks\n- **Lightning Network growth**: Faster, cheaper payments\n- **Education and awareness**: More people learning about Bitcoin\n\nAs Bitcoin infrastructure improves and adoption grows, more communities will gain access to financial services through Bitcoin.\n\n---\n\n## Related Topics\n\n- [Lightning Network](/docs/lightning) - Fast, cheap payments\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin has value\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin enables trustless transactions\n- [Wallets](/docs/wallets) - How to use Bitcoin wallets\n- [Decentralization](/docs/fundamentals/decentralization) - Why Bitcoin can't be stopped\n\n---\n\nBitcoin is providing financial access to communities that traditional banking has failed to serve. From remittances to savings to daily payments, Bitcoin is enabling financial inclusion for billions of people worldwide.\n",
    "filename": "rural-communities.md"
  },
  "/docs/adoption/use-cases": {
    "content": "# Bitcoin Use Cases\n\nBitcoin adoption spans individuals, businesses, and nations. From remittances to corporate treasuries to national adoption, Bitcoin is being used in diverse and innovative ways.\n\n---\n\n## Remittances\n\n### The Global Remittance Market\n\nRemittances (money sent by migrant workers to their families) total over $800 billion annually. Traditional remittances face:\n\n- **High fees**: Average 6-10%, often much higher for small amounts\n- **Slow transfers**: Can take days or weeks\n- **Limited access**: Recipients may need to travel to pickup locations\n- **Currency restrictions**: Multiple conversions add costs\n\n### Bitcoin Remittances\n\nBitcoin, especially via the Lightning Network, offers:\n\n- **Low fees**: Typically less than 1%\n- **Instant settlement**: Lightning payments in seconds\n- **24/7 availability**: Works anytime, anywhere\n- **Direct transfer**: No intermediaries needed\n- **Global currency**: Same Bitcoin everywhere\n\n### Examples\n\n- **Strike**: Enables instant, low-cost remittances using Bitcoin and Lightning\n- **Bitnob**: Bitcoin remittances across Africa\n- **Coins.ph**: Remittances to the Philippines\n- **El Salvador**: National adoption reduced remittance costs\n\n---\n\n## Store of Value\n\n### The Inflation Hedge\n\nBitcoin's fixed supply and predictable issuance make it attractive as a store of value, especially in high-inflation environments:\n\n- **Fixed supply**: Only 21 million bitcoin will ever exist\n- **No inflation**: Supply schedule is predictable and decreasing\n- **Global value**: Not tied to any single country's economy\n- **Self-custody**: You control your Bitcoin\n- **Portable**: Can be taken across borders\n\n### High-Inflation Countries\n\n**Venezuela**: Citizens use Bitcoin to preserve savings as the bolivar hyperinflates\n\n**Argentina**: Bitcoin protects savings from persistent high inflation\n\n**Turkey**: Bitcoin provides hedge against currency devaluation\n\n**Lebanon**: During banking crisis, Bitcoin became store of value\n\n**Nigeria**: Bitcoin protects against currency devaluation and capital controls\n\n### Long-Term Holding\n\nMany investors hold Bitcoin as a long-term store of value, similar to gold but with digital advantages. See [Long-Term Holding](/docs/investment/long-term-holding) for strategies.\n\n---\n\n## Corporate Adoption\n\n### Treasury Reserves\n\nCompanies are holding Bitcoin as part of their treasury reserves:\n\n**MicroStrategy**: The largest corporate Bitcoin holder, with over 190,000 BTC as of 2024. The company uses Bitcoin as a treasury reserve asset, raising debt to purchase Bitcoin.\n\n**Tesla**: Briefly held Bitcoin, accepting it as payment for vehicles before suspending due to environmental concerns.\n\n**Block (formerly Square)**: Holds Bitcoin in treasury and enables Bitcoin services through Cash App.\n\n**Other companies**: Growing list of companies holding Bitcoin in treasury, including:\n- Coinbase\n- Marathon Digital Holdings\n- Hut 8 Mining\n- Galaxy Digital\n\n### Rationale\n\nCompanies hold Bitcoin for:\n- **Inflation hedge**: Protect against currency devaluation\n- **Diversification**: Non-correlated asset\n- **Store of value**: Long-term value preservation\n- **Network effects**: Bitcoin's value increases with adoption\n\n---\n\n## Country-Level Adoption\n\n### El Salvador\n\nIn September 2021, El Salvador became the first country to adopt Bitcoin as legal tender:\n\n- **Legal tender status**: Bitcoin must be accepted alongside US dollar\n- **Government wallet**: Chivo wallet with $30 in Bitcoin for citizens\n- **Infrastructure**: Bitcoin ATMs, mining with geothermal energy\n- **Results**: Faster remittances, lower fees, increased financial inclusion\n\n### Central African Republic\n\nIn 2022, CAR adopted Bitcoin as legal tender, though implementation faced challenges due to infrastructure limitations.\n\n### Other Countries\n\nSeveral countries are exploring or have favorable Bitcoin regulations:\n- **Ukraine**: Accepts Bitcoin donations, favorable regulations\n- **Switzerland**: Bitcoin-friendly regulations\n- **Portugal**: Tax-friendly for Bitcoin\n- **Singapore**: Regulatory clarity for Bitcoin businesses\n\n---\n\n## Humanitarian Aid\n\n### The Problem\n\nTraditional aid delivery faces challenges:\n- **Corruption**: Aid can be stolen or misdirected\n- **Intermediaries**: Multiple layers add costs and delays\n- **Restrictions**: Governments can block or restrict aid\n- **Currency issues**: Local currency volatility and restrictions\n\n### Bitcoin Aid\n\nBitcoin enables direct aid delivery:\n\n- **Direct transfer**: Send Bitcoin directly to recipients\n- **No intermediaries**: Reduce corruption and costs\n- **Censorship-resistant**: Governments can't block Bitcoin\n- **Transparent**: Blockchain provides transparency\n- **Fast**: Lightning Network enables instant transfers\n\n### Examples\n\n**Ukraine**: During the 2022 invasion, Ukraine received millions in Bitcoin donations, enabling direct aid delivery.\n\n**Non-profits**: Organizations like GiveDirectly and others use Bitcoin to deliver aid directly to recipients.\n\n**Disaster relief**: Bitcoin enables rapid aid delivery in disaster situations.\n\n---\n\n## Individual Adoption Stories\n\n### Financial Freedom\n\nIndividuals use Bitcoin for:\n- **Wealth preservation**: Protect savings from inflation\n- **Cross-border transfers**: Send money internationally\n- **Censorship resistance**: Access money when accounts are frozen\n- **Privacy**: Financial transactions without banks\n- **Self-sovereignty**: Control your own money\n\n### Real Stories\n\n- **Venezuelans**: Using Bitcoin to preserve savings and receive remittances\n- **Nigerians**: Bypassing capital controls and currency restrictions\n- **Afghans**: Accessing money when banking system collapsed\n- **Ukrainians**: Receiving aid and preserving wealth during war\n- **Chinese**: Bypassing capital controls (before restrictions)\n\n---\n\n## Business Integration\n\n### Payment Acceptance\n\nBusinesses accept Bitcoin for:\n- **Global payments**: Accept payments from anywhere\n- **Lower fees**: Especially with Lightning Network\n- **No chargebacks**: Bitcoin transactions are final\n- **New customers**: Reach Bitcoin-using customers\n- **Innovation**: Early adopter advantage\n\n### Examples\n\n- **Overstock**: Early Bitcoin acceptance\n- **Microsoft**: Accepts Bitcoin for digital purchases\n- **AT&T**: Accepts Bitcoin for bill payments\n- **Various merchants**: Growing list of businesses accepting Bitcoin\n\n### Challenges\n\n- **Volatility**: Bitcoin price fluctuations\n- **Regulatory**: Varying regulations by jurisdiction\n- **Technical**: Integration complexity\n- **Education**: Customer and staff education needed\n\n---\n\n## Investment and Speculation\n\n### Investment Use Case\n\nMany people hold Bitcoin as an investment:\n- **Portfolio diversification**: Non-correlated asset\n- **Inflation hedge**: Protect against currency devaluation\n- **Growth potential**: Potential for price appreciation\n- **Store of value**: Long-term value preservation\n\nSee [Bitcoin as Investment](/docs/investment) for detailed investment strategies and considerations.\n\n### Speculation\n\nSome people trade Bitcoin for short-term gains:\n- **Volatility**: Price swings create trading opportunities\n- **24/7 markets**: Trade anytime\n- **Global markets**: Access to worldwide liquidity\n- **High risk**: Speculation carries significant risk\n\n---\n\n## Adoption Metrics\n\n### Growing Adoption\n\nBitcoin adoption is growing across multiple metrics:\n\n- **Number of users**: Millions of Bitcoin users worldwide\n- **Transaction volume**: Growing transaction volume\n- **Hash rate**: Increasing network security\n- **Merchant acceptance**: More businesses accepting Bitcoin\n- **Institutional interest**: Growing corporate and institutional adoption\n\n### Network Effects\n\nAs adoption grows, Bitcoin's value increases:\n- **More users**: Increases utility and value\n- **More merchants**: More places to spend Bitcoin\n- **More infrastructure**: Better tools and services\n- **More security**: More hash rate secures the network\n\n---\n\n## Challenges to Adoption\n\n### Technical Challenges\n\n- **Complexity**: Bitcoin has a learning curve\n- **Scalability**: On-chain transactions have capacity limits\n- **User experience**: Wallets and services need improvement\n- **Infrastructure**: Requires internet and smartphones\n\n### Economic Challenges\n\n- **Volatility**: Price fluctuations create uncertainty\n- **Regulatory uncertainty**: Varying regulations worldwide\n- **Tax complexity**: Tax treatment varies by jurisdiction\n- **Liquidity**: Converting Bitcoin to local currency\n\n### Social Challenges\n\n- **Education**: People need to learn about Bitcoin\n- **Misinformation**: False narratives about Bitcoin\n- **Cultural resistance**: Resistance to new technology\n- **Regulatory hostility**: Some governments restrict Bitcoin\n\n---\n\n## Future Potential\n\nThe potential for Bitcoin adoption is enormous:\n\n- **Global remittances**: $800+ billion market\n- **Unbanked population**: 1.7 billion adults\n- **Corporate treasuries**: Trillions in corporate cash\n- **Store of value**: Competing with gold ($10+ trillion)\n- **Payment network**: Competing with payment networks\n\nAs Bitcoin infrastructure improves and adoption grows, these use cases will expand and new ones will emerge.\n\n---\n\n## Related Topics\n\n- [Monetary Properties](/docs/fundamentals/monetary-properties) - Why Bitcoin has value\n- [Lightning Network](/docs/lightning) - Fast, cheap payments\n- [Bitcoin as Investment](/docs/investment) - Investment strategies\n- [Trust Model](/docs/fundamentals/trust-model) - How Bitcoin enables trustless transactions\n- [Decentralization](/docs/fundamentals/decentralization) - Why Bitcoin can't be stopped\n\n---\n\nBitcoin adoption is happening across individuals, businesses, and nations. From remittances to corporate treasuries to national adoption, Bitcoin is being used to solve real problems and create real value.\n",
    "filename": "use-cases.md"
  },
  "/docs/glossary": {
    "content": "## 0-9\n\n### 51% Attack\nA theoretical attack where an entity controlling more than 50% of the network's hash rate could potentially double-spend transactions or prevent confirmations by mining an alternative chain faster than the honest network. The attack becomes exponentially more expensive as the network grows, and even with majority hash power, an attacker cannot steal coins or change consensus rules.\n\n### 2-of-3 Multisig\nA common multisignature configuration requiring 2 signatures from 3 possible signers to spend funds. This setup provides a balance between security and convenience: if one key is lost or compromised, funds remain accessible and secure.\n\n### 21 Million\nThe maximum supply of Bitcoin that will ever exist, enforced by the protocol's consensus rules and achieved through the halving schedule, with the last satoshi expected to be mined around the year 2140. The fixed supply creates a deflationary monetary policy that contrasts with traditional fiat currencies.\n\n---\n\n## A\n\n### Air-Gapped\nA computer or device that has never been connected to the internet, providing the highest level of security for Bitcoin wallets. Air-gapped systems cannot be attacked remotely, making them ideal for generating private keys, creating transactions, and signing them offline. The transaction is then transferred to an internet-connected device for broadcasting. This approach eliminates the risk of malware, network attacks, and key theft through online means.\n\n### Absolute Time Lock\nA time lock that prevents a transaction from being spent until a specific block height or Unix timestamp is reached, implemented using the OP_CHECKLOCKTIMEVERIFY (CLTV) opcode. Unlike relative time locks, absolute locks reference a fixed point in time rather than being relative to when the UTXO was created.\n\n### Address\nA public identifier where Bitcoin can be received, generated from a public key through hash functions. Different address types exist (P2PKH, P2SH, P2WPKH/P2WSH, P2TR) reflecting Bitcoin's evolution, with newer types offering lower fees and better privacy.\n\n### Address Reuse\nUsing the same Bitcoin address for multiple transactions, which is generally discouraged for both privacy and security reasons. Reusing addresses links transactions together on the public blockchain, making it easier to trace financial activity. Best practice is to generate a fresh address for each transaction, which HD wallets handle automatically.\n\n### Anchor Outputs\nA mechanism in Lightning Network that allows payment channels to be closed reliably even when on-chain fee rates have increased significantly since the channel was opened. Each commitment transaction includes small \"anchor\" outputs that either party can use to attach a child transaction with higher fees via CPFP (Child Pays for Parent), ensuring channels can always be closed in a timely manner.\n\n### ASIC (Application-Specific Integrated Circuit)\nSpecialized hardware designed and manufactured specifically for Bitcoin mining, optimized to perform SHA-256 hash calculations as efficiently as possible. ASICs are orders of magnitude more efficient than general-purpose CPUs or GPUs, making other hardware economically unviable for mining.\n\n### Atomic Swap\nA peer-to-peer exchange of cryptocurrencies between two parties without the need for a trusted third party or centralized exchange. Atomic swaps use hash time-locked contracts (HTLCs) to ensure that either both parties receive their funds or neither does, enabling trustless trading across different blockchains.\n\n### API (Application Programming Interface)\nA set of protocols and tools that allow applications to communicate with Bitcoin nodes, typically via JSON-RPC. The Bitcoin Core RPC API provides methods to query blockchain data, create and broadcast transactions, manage wallets, and monitor network status.\n\n### AML (Anti-Money Laundering)\nGovernment-imposed regulations on Bitcoin exchanges requiring them to collect personal data in the name of preventing crime. These rules compromise privacy and weaken security for all users, trading individual sovereignty for government control.\n\n### Ark\nA proposed Bitcoin Layer 2 scaling solution designed to allow fast, off-chain Bitcoin transactions while reducing liquidity constraints seen in other Layer 2 protocols. Ark enables users to send and receive bitcoin without requiring complex onboarding or liquidity locks.\n\n### Altcoin\nAny cryptocurrency other than Bitcoin. The term is often used when comparing Bitcoin to other digital assets. Bitcoin was the first and remains the dominant cryptocurrency by market cap, security, and adoption; altcoins typically differ in consensus rules, supply, or intended use.\n\n---\n\n## B\n\n### Bear Market\nA prolonged period of declining prices and pessimism. In a bear market, Bitcoinâ€™s price tends to fall or trade sideways, and sentiment is cautious. The term is used across traditional and crypto markets.\n\n### Bull Market\nA prolonged period of rising prices and optimism. In a bull market, Bitcoinâ€™s price tends to rise and sentiment is positive. The term is used across traditional and crypto markets; Bitcoinâ€™s cycles are often discussed in terms of bull and bear phases.\n\n### Batching\nCombining multiple payments into a single transaction to reduce fees by sharing the fixed overhead costs across many recipients. Multiple outputs are included in one transaction, significantly reducing the total bytes and thus fees paid. Exchanges and payment processors commonly use batching to process withdrawals efficiently.\n\n### Base58\nAn encoding scheme used in legacy Bitcoin addresses that provides a human-readable format while minimizing transcription errors. It's similar to Base64 but excludes visually ambiguous characters (0, O, I, l). Base58Check extends this with a 4-byte checksum appended to detect typos before funds are sent to an invalid address.\n\n### Bech32\nA checksummed base32 encoding format introduced with SegWit (BIP 173) that provides better error detection than Base58Check. Addresses start with `bc1` for mainnet or `tb1` for testnet, and use only lowercase letters and numbers. An updated version called Bech32m (BIP 350) is used for Taproot addresses.\n\n### Block\nA collection of transactions grouped together and permanently added to the blockchain approximately every 10 minutes. Each block contains a header with proof-of-work, a coinbase transaction that creates new Bitcoin, and typically thousands of user transactions. Blocks are limited in size, creating competition for space that drives the fee market.\n\n### Blockchain\nA distributed, append-only ledger of all Bitcoin transactions maintained by thousands of independent nodes worldwide. Blocks are cryptographically linked in chronological order, making historical data tamper-evident and immutable. Altering any past transaction would require re-mining all subsequent blocks, which becomes computationally infeasible as more blocks are added.\n\n### Block Header\nThe 80-byte metadata at the start of each block that miners hash repeatedly during proof-of-work. It contains six fields: version number, previous block hash, merkle root, timestamp, difficulty target, and nonce. Because the header is only 80 bytes, SPV clients can verify the chain's proof-of-work without downloading full blocks.\n\n### Block Height\nThe number of blocks in the chain before a given block, serving as a sequential identifier for blocks. The genesis block has height 0, and each subsequent block increments the height by one. Block height is used to reference specific points in Bitcoin's history and trigger protocol changes like halvings.\n\n### Block Reward\nThe amount of new Bitcoin created and awarded to miners for successfully mining a block, also called the block subsidy. Currently 3.125 BTC after the 2024 halving, this reward halves approximately every four years (210,000 blocks) until all 21 million Bitcoin are mined around 2140. The block reward, combined with transaction fees, provides the economic incentive for miners to secure the network.\n\n### Block Size\nThe size of a block measured in bytes or weight units, which is limited by consensus rules to prevent blockchain bloat. Bitcoin has a 1 MB base block size limit, but the SegWit upgrade introduced weight units that allow blocks to effectively reach ~4 MB when containing mostly SegWit transactions. This limit creates scarcity of block space, driving fee competition during high-demand periods.\n\n### Block Time\nThe average time between consecutive blocks, which Bitcoin targets at 10 minutes through automatic difficulty adjustment. This target represents a tradeoff between confirmation speed and security. The actual time between blocks varies due to the random nature of mining, and the 10-minute average is maintained by adjusting difficulty every 2016 blocks.\n\n### Block Template\nA data structure containing selected transactions and partially-filled block header fields that miners use to construct candidate blocks. Mining pools generate block templates by selecting transactions from the mempool (typically prioritizing by fee rate), computing the merkle root, and providing all header fields except the nonce. Miners then repeatedly hash variations of this template until finding a valid block.\n\n### BOLT (Basis of Lightning Technology)\nThe technical specifications that define the Lightning Network protocol, similar to how RFCs define internet protocols. BOLT documents specify everything from the peer-to-peer message format to channel construction, payment routing, and invoice encoding. Multiple independent implementations (LND, c-lightning, Eclair, LDK) follow these specs to ensure interoperability.\n\n### BIP (Bitcoin Improvement Proposal)\nA design document that proposes changes, additions, or informational content for the Bitcoin ecosystem, following a structured process for community review. BIPs are categorized as Standards Track (protocol changes), Informational, or Process documents. Notable examples include BIP 16 (P2SH), BIP 32 (HD wallets), BIP 39 (mnemonic seeds), BIP 141 (SegWit), and BIP 341 (Taproot).\n\n### Bitcoin Client\nSoftware that enables users to send and receive bitcoin. Bitcoin Core is the most widely used and trusted client, though others exist with varying features.\n\n### Bitcoin Core\nThe reference software for Bitcoin, developed and maintained by the open-source Bitcoin community. It acts as the most trusted and widely used implementation of the Bitcoin protocol.\n\n### Bitcoin ETF\nA financial product that tracks the price of bitcoin, allowing investors and funds to gain exposure to bitcoin's price movements without directly owning or managing bitcoin itself.\n\n### Bitcoin Network\nA global, decentralized system of nodes that broadcasts transactions and secures the blockchain, making Bitcoin's decentralized ledger possible.\n\n### Bitcoin Treasury Company\nCompanies that place bitcoin at the center of their balance sheet strategy, unlocking access to capital and absorbing bitcoin's supply as a form of capital preservation.\n\n### Block Subsidy\nThe new bitcoin that miners receive as part of the block reward for successfully mining a new block. It decreases over time through halvings and is the primary way new bitcoin enters circulation.\n\n### BRC-20 Tokens\nExperimental, fungible tokens on Bitcoin created using ordinal inscriptions, similar to Ethereum's ERC-20 tokens. They are an inefficient use of Bitcoin's block space, often leading to higher transaction fees and network congestion.\n\n### BTC\nThe ticker symbol for bitcoin, representing the asset in trading pairs. It's also sometimes used as shorthand for the Bitcoin Core software. See [Denominations](/docs/fundamentals/denominations) for the full unit table and converter.\n\n---\n\n## C\n\n### CLTV (CheckLockTimeVerify)\nAn opcode (OP_CHECKLOCKTIMEVERIFY) that enforces absolute time locks by making a transaction invalid if spent before a specified block height or Unix timestamp. Introduced in BIP 65, CLTV enables time-locked contracts where funds cannot be moved until a future date regardless of who holds the keys. This is essential for Lightning Network HTLCs, which require time-locked refund paths.\n\n### Coinbase Transaction\nThe first transaction in every block, which has no inputs and creates new Bitcoin as the block reward plus collected transaction fees. Miners construct the coinbase transaction to pay themselves, and it's the only transaction type that can create new coins. The coinbase includes an arbitrary data field (up to 100 bytes) where miners often include pool identifiers or other data. Coinbase outputs cannot be spent until 100 blocks have passed, preventing issues if the block is orphaned.\n\n### Coin Selection\nThe process of choosing which UTXOs to spend when creating a transaction, which significantly impacts fees, privacy, and future UTXO management. Various algorithms exist: largest-first minimizes input count but creates large change outputs; smallest-first consolidates dust but increases fees; branch-and-bound tries to find exact matches avoiding change entirely. Wallet software typically handles this automatically.\n\n### CoinJoin\nA privacy technique where multiple users combine their transactions into a single transaction, making it difficult for blockchain analysts to determine which inputs correspond to which outputs. Each participant signs only their own inputs, so no one can steal funds. CoinJoin breaks the common-input-ownership heuristic that chain analysis relies on, significantly improving transaction privacy when done correctly.\n\n### Commitment Transaction\nIn Lightning Network, a pre-signed transaction that represents the current state of a payment channel and can be broadcast to close the channel unilaterally. Both channel parties hold their own version of the commitment transaction, which pays out the current balance distribution. These transactions are updated off-chain every time a payment flows through the channel, with old states being invalidated through revocation keys.\n\n### Confirmation\nWhen a transaction is included in a block that is added to the blockchain, it receives its first confirmation; each subsequent block adds another confirmation. More confirmations increase certainty that the transaction is final because reversing it would require re-mining all those blocks. For small amounts, 1-3 confirmations are typically sufficient, while 6 confirmations (about 1 hour) is widely considered secure for large amounts.\n\n### Consensus\nAgreement among network participants about the current state of the blockchain, including which transactions are valid and which chain of blocks is authoritative. Bitcoin achieves consensus through proof-of-work and the longest chain rule: nodes accept the valid chain with the most accumulated work. This allows thousands of independent nodes to agree on a single transaction history without any central coordinator.\n\n### Consensus Rules\nThe set of rules that all Bitcoin nodes must follow to validate transactions and blocks, forming the foundation of network agreement. These include rules about block structure, transaction format, signature validity, coin supply, and timing. Any transaction or block that violates consensus rules is rejected by honest nodes, regardless of how much hash power supports it.\n\n### Censorship Resistance\nThe ability to make transactions that cannot be blocked, reversed, or seized by any central authority, government, or corporation. Bitcoin achieves this through decentralization: thousands of independent miners and nodes mean no single entity controls which transactions are included in blocks. Even if some miners refuse to include certain transactions, others will mine them for the fees.\n\n### ChaCha20\nA stream cipher designed by Daniel J. Bernstein that encrypts data by combining a key and nonce with a fast, ARX-based (Addition, Rotation, XOR) function. In the Bitcoin ecosystem, ChaCha20 is used in [BIP 324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki) (v2 P2P transport) to encrypt connections between nodes, providing confidentiality and integrity. It is often combined with the Poly1305 authenticator (ChaCha20-Poly1305) for authenticated encryption.\n\n### Change Output\nA transaction output that sends excess funds back to the sender, created because Bitcoin's UTXO model requires spending entire outputs. When input value exceeds the payment amount plus fees, the difference must be explicitly sent somewhere, typically a new address controlled by the sender. Wallets handle change automatically, but understanding it is important for privacy (change outputs can link transactions) and fee estimation.\n\n### CPFP (Child Pays For Parent)\nA fee bumping technique where a new transaction (the child) spends an unconfirmed output from a stuck transaction (the parent) with a high enough fee to make mining both transactions profitable. Miners evaluate transaction packages together, so a high-fee child incentivizes them to include the low-fee parent to collect both fees. This is useful when you're the recipient of a stuck transaction and can't use RBF because you didn't create the original.\n\n### CSV (CheckSequenceVerify)\nAn opcode (OP_CHECKSEQUENCEVERIFY) that enforces relative time locks, preventing a UTXO from being spent until a specified number of blocks or time has passed since it was confirmed. Unlike CLTV's absolute locks, CSV's relative locks start counting from when the UTXO was created, making them ideal for protocols that need \"wait N blocks after X happens\" logic. Essential for Lightning Network, where CSV ensures that a party has time to respond to a fraudulent channel close.\n\n### Compact Block\nA block relay protocol (BIP 152) that dramatically reduces bandwidth by sending only block headers and short transaction IDs instead of full transaction data. Since most transactions in a new block are already in a node's mempool, the node can reconstruct the full block locally using these short IDs. This optimization reduces block propagation time and bandwidth by roughly 90%.\n\n### Chain Reorganization\nA process where a Bitcoin client discovers a longer chain of blocks, replacing the previously recognized chain. Blocks excluded during this process become \"orphaned blocks.\"\n\n### CheckTemplateVerify (CTV)\nA proposed Bitcoin opcode enabling basic covenants by allowing users to predefine how their bitcoin can be spent in future transactions. Through transaction templates, CTV can enforce specific spending paths, enhancing security for applications like vault wallets and improving scalability.\n\n### Cold Storage Wallet\nAn offline Bitcoin wallet that isn't connected to the internet, providing enhanced security against hacking and theft. Typically used for long-term storage, it keeps private keys isolated from potential online threats. Hardware wallets and paper wallets are common forms of cold storage.\n\n### Covenants\nA proposed type of smart contract that allows users to set conditions or restrictions on how their bitcoin can be spent after the initial transaction. By embedding specific rules, covenants can add layers of control over future transactions, useful for applications like vaults or multi-stage payments.\n\n### Cross-Input Signature Aggregation (CISA)\nA proposed Bitcoin upgrade to reduce transaction size by combining multiple input signatures into a single signature. For example, if Alice spends two Taproot UTXOs, instead of providing separate signatures for each, CISA would aggregate them into one 16-vbyte MuSig-style signature, lowering fees for multi-input transactions.\n\n### Cryptocurrency\nA broad category of digital or virtual currencies that rely on cryptography to secure transactions and control the issuance of new units. The first and most notable cryptocurrency is Bitcoin, created by Satoshi Nakamoto in 2009.\n\n### Cryptography\nThe use of complex mathematics to secure data. Bitcoin relies on cryptographic techniques to protect funds, verify ownership, and ensure the integrity of the blockchain.\n\n### Cypherpunks\nActivists who advocate for using cryptography to protect privacy and personal freedom. They were members of the now-defunct Cypherpunk mailing list, active in the 1990s. Their work laid the foundation for privacy-preserving technologies like Bitcoin.\n\n### Channel\nA payment channel between two Lightning Network nodes that enables instant, low-cost payments without broadcasting each transaction to the blockchain. Channels are created by locking Bitcoin in a 2-of-2 multisig address on-chain, then updating balance distributions off-chain through signed commitment transactions. Payments can flow in either direction up to the channel's capacity, and channels can remain open indefinitely.\n\n### Channel Capacity\nThe total amount of Bitcoin locked in a Lightning payment channel, representing the maximum value that can flow through it at any moment. Capacity is set when the channel is opened and equals the sum of both parties' contributions (though single-funded channels are common). Importantly, capacity doesn't mean both parties can send that amount; each can only send up to their current balance in the channel.\n\n### Channel Closing\nThe process of finalizing a Lightning payment channel by broadcasting the final state to the Bitcoin blockchain, which settles the channel balance and unlocks funds. Cooperative closes are preferred: both parties agree on the final balance and sign a closing transaction with minimal fees and no time locks. Force closes occur when one party is unresponsive or disputes arise: the initiator broadcasts their latest commitment transaction and must wait for a timelock before accessing funds.\n\n### Channel Funding\nThe process of opening a Lightning payment channel by creating an on-chain transaction that locks Bitcoin in a 2-of-2 multisig address controlled by both channel parties. The funding transaction must be confirmed on the blockchain before the channel becomes usable, which typically takes 3-6 confirmations (30-60 minutes). Originally only one party funded channels, but dual-funded channels (where both contribute) are now supported.\n\n### Channel State\nThe current balance distribution in a Lightning payment channel, representing how much each party would receive if the channel were closed immediately. State is updated off-chain through signed commitment transactions every time a payment flows through the channel. Old states are invalidated through revocation keys, creating a penalty mechanism if anyone tries to broadcast an outdated state.\n\n### Cooperative Close\nThe preferred method of closing a Lightning payment channel where both parties agree on the final balance and sign a single closing transaction. Unlike force closes, cooperative closes have no time delays, lower fees, and settle immediately once confirmed on-chain. Both parties benefit from cooperative closes, so they're used in the vast majority of channel closures.\n\n---\n\n## D\n\n### DAO (Decentralized Autonomous Organization)\nA Decentralized Autonomous Organization (DAO) is governed by rules encoded in smart contracts, eliminating the need for centralized control. Bitcoin doesn't rely on DAOs, as it operates independently.\n\n### DCA (Dollar-Cost Averaging)\nA strategy where a fixed amount of money is used to buy bitcoin at regular intervals, smoothing out volatility by ignoring short-term price movements.\n\n### DEX (Decentralized Exchange)\nA decentralized exchange that allows users to trade cryptocurrencies without relying on a centralized entity. In Bitcoin, DEXs ensure users maintain control over their private keys during trades.\n\n### Decentralization\nThe distribution of control, decision-making, and infrastructure across many independent participants rather than a single central authority. Bitcoin achieves this through open-source code that anyone can audit, distributed mining across thousands of operations worldwide, and permissionless node operation that lets anyone verify the blockchain. This architecture means no government, company, or individual can unilaterally change the rules, censor transactions, or shut down the network.\n\n### Derivation Path\nA sequence of indices that specifies how to derive a specific key from a master seed in an HD (hierarchical deterministic) wallet, enabling organized key management. The format `m/purpose'/coin'/account'/change/index` creates a tree structure where the apostrophe indicates hardened derivation. Common paths include m/44'/0'/0' for legacy addresses, m/84'/0'/0' for native SegWit, and m/86'/0'/0' for Taproot.\n\n### Descriptors\nA standardized format (BIP 380-386) for describing how to derive addresses and spending conditions from keys, providing more complete wallet backup information than keys alone. Descriptors specify not just which keys to use but how to use them: the script type, derivation paths, and any multi-party arrangements. This enables wallet software to correctly reconstruct addresses and sign transactions without ambiguity.\n\n### DATUM\nA decentralized mining protocol that allows individual miners to construct their own block templates rather than accepting whatever the pool provides. This gives miners control over which transactions to include, addressing concerns about pool-level transaction censorship and centralization of block construction. DATUM represents a shift toward \"solo mining with pool payout variance smoothing,\" where miners maintain sovereignty over block content while still benefiting from pooled rewards.\n\n### Difficulty\nA measure of how computationally hard it is to find a valid block hash, automatically adjusted every 2016 blocks (roughly two weeks) to maintain approximately 10-minute block intervals. When blocks are found faster than target, difficulty increases; when slower, it decreases. This self-adjusting mechanism ensures consistent block times regardless of how much hash power joins or leaves the network.\n\n### Difficulty Target\nThe maximum hash value that is considered valid for a block, expressed as a 256-bit number that miners must beat. Miners repeatedly hash block headers with different nonces until finding a hash numerically below this target. Lower targets are harder to hit and represent higher difficulty. The target is stored compactly in each block header as \"nBits\" and decoded into the full 256-bit threshold for validation.\n\n### Double Spend\nAn attempt to spend the same Bitcoin twice by creating two conflicting transactions that both reference the same UTXO. Bitcoin's blockchain consensus mechanism prevents this by establishing a single authoritative transaction history. Once one transaction is confirmed in a block, conflicting transactions become invalid. Before confirmation, double spends are possible (which is why merchants wait for confirmations), but after even one confirmation, reversing the transaction requires mining a longer alternative chain.\n\n### Digital Cash\nCurrency in a digital format, designed to mimic the characteristics of physical cash, such as privacy and peer-to-peer transactions. Also called electronic cash. Bitcoin is often regarded as true digital (or electronic) cash because it enables direct, trustless transfers between users without intermediaries and operates without a central authority.\n\n### Digital Money\nAny form of money stored and transacted electronically. This can include both centralized forms like bank deposits and decentralized currencies like Bitcoin, which operates without a central authority.\n\n### Digital Signature\nA cryptographic proof that can be attached to a message to show that the sender is the owner of a private key corresponding to some public key while keeping the private key secret. It works by taking the hash of the message and then encrypting the hash with the private key.\n\n### Distributed Ledger\nBitcoin's distributed ledger, the blockchain, is stored across nodes worldwide. It's permissionless, meaning anyone can participate and verify transactions without needing approval.\n\n### Don't Trust, Verify\nA nod to Bitcoin's trustless nature, where users can verify transactions and ownership themselves, rather than relying on third parties or intermediaries.\n\n### Dust\nA transaction output so small that the fee required to spend it would exceed or approach its value, making it economically irrational to use. The dust threshold depends on fee rates but is typically around 546 satoshis for standard outputs and 294 satoshis for SegWit outputs. Dust outputs bloat the UTXO set without providing useful value, so Bitcoin Core rejects transactions that create dust by default.\n\n### DYOR (Do Your Own Research)\n\"Do Your Own Research,\" encouraging individuals to do their own due diligence about Bitcoin or any investible asset before making decisions.\n\n---\n\n## E\n\n### ECDSA (Elliptic Curve Digital Signature Algorithm)\nThe original cryptographic signature algorithm used in Bitcoin, based on the secp256k1 elliptic curve. ECDSA signatures prove ownership of private keys without revealing them, enabling secure authorization of transactions. Each signature is approximately 71-72 bytes and is mathematically tied to both the private key and the specific transaction data being signed. While still widely used, ECDSA is being supplemented by Schnorr signatures (introduced with Taproot), which offer better efficiency and enable signature aggregation.\n\n### ECDH (Elliptic Curve Diffie-Hellman)\nA key exchange protocol that allows two parties to establish a shared secret over an insecure channel using elliptic curve cryptography. In Lightning Network, ECDH is used in onion routing (Sphinx protocol) to derive shared secrets between each hop without revealing them to other nodes in the path. This enables private, trustless payment routing where no single node learns the full payment path.\n\n### eCash\nAn early form of digital currency developed in the 1980s by cryptographer David Chaum. It allowed for anonymous electronic transactions but required a central issuer. While eCash itself did not achieve widespread adoption, its principles influenced the development of later decentralized digital currencies like Bitcoin.\n\n### Electronic Money\nDigital representations of fiat currency that can be transferred electronically. Unlike Bitcoin, e-money typically requires a centralized entity, like a bank or payment processor, to manage transactions and balances.\n\n### Encryption\nThe process of converting information into a code to prevent unauthorized access. In Bitcoin, encryption is used to secure private keys and ensure the integrity of transactions.\n\n### Encryption Algorithm\nA piece of software that transforms readable data into an unreadable format using an encryption key. Only someone with the matching decryption key can reverse the process. In Bitcoin, encryption algorithms are used to secure transactions and protect sensitive information.\n\n### Exchange\nA platform where fiat currency is exchanged for bitcoin and vice versa. It serves as an onramp for buying bitcoin with fiat and an offramp for converting bitcoin back to fiat. Centralized exchanges often require KYC, while decentralized exchanges (DEXs) enable peer-to-peer trading without intermediaries.\n\n### Exchange Volume\nThe total amount of bitcoin traded on an exchange within a specific timeframe, indicating market activity and liquidity.\n\n---\n\n## F\n\n### Fee Bumping\nTechniques to increase the effective fee of an unconfirmed transaction to speed up confirmation when the original fee is too low for current network conditions. The two main methods are RBF (Replace-by-Fee), which replaces the stuck transaction with a higher-fee version, and CPFP (Child Pays for Parent), which spends an output from the stuck transaction with enough fee to make mining both worthwhile.\n\n### Fee Rate\nThe fee paid per virtual byte (vByte) of transaction size, expressed in satoshis per vByte (sat/vB), which determines a transaction's priority for inclusion in blocks. Miners typically sort transactions by fee rate and fill blocks from highest to lowest, so higher rates mean faster confirmation. Fee rates fluctuate based on network demand.\n\n### Force Close\nUnilaterally closing a Lightning payment channel by broadcasting your latest commitment transaction to the Bitcoin blockchain without the counterparty's cooperation. Force closes are necessary when the other party is offline, unresponsive, or attempting fraud, but they're more expensive and slower than cooperative closes. The initiator must wait for a timelock (typically 1-2 weeks) before accessing their funds, giving the counterparty time to dispute with a penalty transaction if an old state was broadcast.\n\n### Fiat\nGovernment-issued money that holds value because governments mandate its use for taxes and as legal tender. Stronger fiat currencies like the U.S. dollar or euro hold value relative to other fiat currencies but are rapidly losing value against hard assets like Bitcoin due to inflation.\n\n### FOMO (Fear Of Missing Out)\nThe anxiety that prices will rise and one will miss gains by not buying. FOMO often peaks during bull markets and can lead to buying at high prices. In Bitcoin, it is commonly discussed alongside [DYOR](/docs/glossary#dyor-do-your-own-research) and disciplined accumulation.\n\n### FUD (Fear, Uncertainty, and Doubt)\nNegative or misleading information spread to create fear, uncertainty, or doubt about an asset or project. In Bitcoin, \"FUD\" is often used to describe exaggerated criticism, regulatory scaremongering, or claims that Bitcoin has failed or will fail. The term is broader than Bitcoin but widely used in the community.\n\n### Finality\nThe assurance that a confirmed transaction cannot be reversed or altered, which in Bitcoin is probabilistic rather than absolute. Each additional confirmation makes reversal exponentially more difficult and expensive. After 6 confirmations, reversing a transaction would require an attacker to re-mine those 6 blocks plus stay ahead of the honest network. While never mathematically impossible, deep confirmations provide practical finality that approaches certainty for any realistic attacker.\n\n### Fork\nA divergence in the blockchain where two or more competing chains temporarily or permanently coexist, which can occur naturally or through protocol changes. Temporary forks happen when two miners find valid blocks simultaneously; the network resolves this by eventually building on one chain, orphaning the other. Hard forks create permanent splits when protocol changes make new blocks incompatible with old software, while soft forks tighten rules in a backward-compatible way.\n\n### Full Node\nA Bitcoin node that independently validates every transaction and block against consensus rules, maintaining a complete copy of the blockchain without trusting any external source. Full nodes download and verify ~600GB+ of historical data during initial sync, then validate new blocks as they arrive. Running a full node provides the highest level of security and privacy, as you verify your own transactions rather than trusting third parties.\n\n### Fungibility\nThe property that individual units of a currency or asset are interchangeable, one unit is equivalent to another. Bitcoin is fungible when one satoshi is treated the same as any other regardless of transaction history. Chain analysis can reduce fungibility by labeling or discriminating against certain coins based on their provenance.\n\n---\n\n## G\n\n### Genesis Block\nThe first block in the Bitcoin blockchain (block height 0), created by Satoshi Nakamoto on January 3, 2009. The coinbase transaction famously includes the text \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks,\" both proving the block wasn't pre-mined before that date and commenting on the financial system Bitcoin aimed to provide an alternative to. The genesis block is hardcoded into Bitcoin software as the starting point of the chain, and its 50 BTC reward is unspendable due to a quirk in the original code.\n\n### Gossip Protocol\nThe peer-to-peer mechanism by which Bitcoin nodes share information about new blocks, transactions, and network addresses with their connected peers. When a node receives valid new data, it announces it to peers who haven't seen it yet, creating a flooding pattern where information propagates across the network in seconds without any central coordinator. The gossip protocol includes mechanisms to prevent spam and denial-of-service attacks.\n\n### GPU (Graphics Processing Unit)\nSpecialized hardware originally used for video rendering. Early Bitcoin miners used GPUs to mine blocks, but they've since been replaced by ASICs, which are orders of magnitude more efficient for Bitcoin mining.\n\n---\n\n## H\n\n### Halving\nAn event that occurs every 210,000 blocks (approximately every four years) where the block reward paid to miners is cut in half, reducing Bitcoin's inflation rate. This mechanism is central to Bitcoin's monetary policy, creating a predictable and diminishing supply schedule that asymptotically approaches the 21 million cap. The most recent halving in April 2024 reduced the block reward from 6.25 to 3.125 BTC.\n\n### Hash\nA cryptographic function that takes any input and produces a fixed-size output (digest) that appears random but is deterministic: the same input always produces the same output. Hashing is the process of applying a hash function to data. Bitcoin uses SHA-256 for proof-of-work and transaction IDs, and RIPEMD-160 combined with SHA-256 for address generation. Hash functions are one-way, collision-resistant, and avalanche-sensitive (small input changes completely change the output).\n\n### Hash Rate\nThe total computational power dedicated to Bitcoin mining, measured in hashes per second, representing the network's security level. The network currently operates at approximately 500-700 EH/s (exahashes per second, or 10^18 hashes per second). Higher hash rate means the network is more secure against 51% attacks, as an attacker would need proportionally more resources.\n\n### Hard Fork\nA protocol change that loosens consensus rules, making previously invalid blocks or transactions valid, which is not backward-compatible. Nodes that don't upgrade will reject new blocks as invalid, potentially creating a permanent chain split where two incompatible networks exist. Hard forks are controversial in Bitcoin because they risk splitting the network and are generally avoided in favor of soft forks, which maintain backward compatibility.\n\n### HD Wallet (Hierarchical Deterministic Wallet)\nA wallet architecture (BIP 32) that generates all keys from a single master seed, typically represented as a 12-24 word mnemonic phrase for backup. The hierarchical structure allows deriving billions of addresses in an organized tree, with branches for different accounts, purposes (receiving vs. change), and address types. HD wallets revolutionized Bitcoin usability by making backups simple (one seed phrase backs up all past and future addresses) while also improving privacy by making fresh address generation trivial.\n\n### Hardware Wallet\nA physical device used to store private keys securely offline, providing protection from online hacks or malware. Hardware wallets are a form of [cold storage](/docs/glossary#cold-storage-wallet) and are widely used by Bitcoin holders for long-term storage, ensuring that their private keys remain safe from unauthorized access. Private keys never leave the device, and transactions are signed on the device itself, making them secure even when connected to compromised computers.\n\n### Hot Wallet\nA Bitcoin wallet that is connected to the internet, such as mobile apps, desktop software, or web wallets. Hot wallets are convenient for frequent transactions and daily use but are more vulnerable to hacking, malware, and online attacks since private keys are stored on internet-connected devices. Best practice is to use hot wallets only for small amounts and keep significant holdings in [cold storage wallets](/docs/glossary#cold-storage-wallet) or [hardware wallets](/docs/glossary#hardware-wallet).\n\n### HODL\nA Bitcoin culture term meaning to hold bitcoin through volatility instead of selling. It originated from a 2013 Bitcointalk post titled \"I AM HODLING\" (a typo for \"holding\") during a sharp price drop. \"HODL\" is often used as a verb and has come to symbolize long-term conviction and resistance to panic selling.\n\n### HTLC (Hash Time-Locked Contract)\nA conditional payment contract that forms the foundation of Lightning Network and atomic swaps, combining a hash lock with a time lock. The payment can only be claimed by revealing a secret (preimage) that hashes to a known value, and it automatically refunds to the sender if not claimed before the timeout expires. In Lightning, HTLCs chain across multiple channels to enable multi-hop payments, creating trustless routing where either the entire payment succeeds or it fails and refunds atomically.\n\n---\n\n## I\n\n### IBD (Initial Block Download)\nThe process of downloading and validating the entire blockchain history when first starting a Bitcoin full node, which can take hours to days depending on hardware and bandwidth. During IBD, the node downloads all ~600GB+ of block data, verifies every signature, checks all consensus rules, and builds the UTXO set from scratch. This process is intentionally thorough; it's how full nodes achieve trustless verification without relying on any external source.\n\n### Input\nA reference to a previous transaction output (UTXO) that is being consumed in a new transaction, essentially pointing to where the funds came from. Each input contains the previous transaction's ID, the output index being spent, and a script (or witness data) proving authorization to spend those funds. A transaction can have multiple inputs to combine UTXOs when the payment amount exceeds any single available output.\n\n### Immutable\nUnchangeable. In Bitcoin, once a transaction is confirmed and added to the blockchain, it cannot be altered or removed, ensuring the integrity of the timechain.\n\n### Inscriptions\nData embedded in individual satoshis using the Ordinals protocol, allowing users to attach arbitrary content, such as text, images, or other files, directly onto Bitcoin's blockchain. This functionality has sparked interest in NFTs on Bitcoin, but critics argue that it leads to inefficient use of block space and higher transaction fees.\n\n### Inflation\nThe general rise in prices, which is typically caused by an increase in the money supply. Bitcoin's fixed supply makes it resistant to inflation, unlike fiat currencies that are regularly inflated.\n\n### Intrinsic Value\nTraditionally refers to the non-monetary use of an asset, like gold's value stemming from its physical properties, rarity, and the effort required to extract it. In contrast, Bitcoin's value doesn't come from physical use but from its mathematical scarcity, robust security protocols, and decentralized nature.\n\n### Invoice\nA payment request in Lightning Network encoded as a BOLT11 string that contains all information needed to make a payment. Invoices typically start with `lnbc` for mainnet (or `lntb` for testnet), followed by an amount, and include the payment hash, recipient's node public key, expiry time, routing hints, and a signature. They're usually displayed as QR codes for easy mobile scanning.\n\n---\n\n## K\n\n### Key Pair\nA cryptographic pair consisting of a private key (a 256-bit secret number) and its corresponding public key (derived through elliptic curve multiplication). The private key signs transactions to prove ownership, while the public key allows anyone to verify those signatures without learning the private key. From the public key, Bitcoin addresses are generated through hashing, creating a one-way chain: private key â†’ public key â†’ address.\n\n### JoinMarket\nA decentralized coinjoin implementation that enhances Bitcoin privacy by allowing users to mix their coins with others, making transaction history harder to trace. Unlike centralized mixers, JoinMarket operates as a marketplace where \"makers\" provide liquidity for coinjoins and \"takers\" initiate them, creating an incentive-driven system for privacy.\n\n### Just-In-Time (JIT) Mining\nA strategy where miners delay finalizing a block until the last possible moment to include the most profitable transactions. By waiting until just before broadcasting a block, miners can prioritize high-fee transactions that were submitted moments earlier, maximizing their earnings.\n\n### Keysend\nA Lightning Network payment method that allows sending payments without requiring an invoice from the recipient. Instead of the receiver generating a payment hash and preimage (as with standard invoices), the sender generates the preimage themselves and includes it in the encrypted onion payload. The recipient's node extracts the preimage upon receiving the payment, enabling spontaneous payments to any node whose public key is known.\n\n### KYC (Know Your Customer)\nA regulation that requires financial institutions, including Bitcoin exchanges, to verify the identity of their users by collecting personal information. While KYC supposedly aims to prevent financial crimes, it undermines user privacy and conflicts with Bitcoin's principles of decentralization and financial sovereignty.\n\n---\n\n## L\n\n### LIFO (Last In, First Out)\nA data structure principle where the most recently added item is the first to be removed, like a stack of plates. Bitcoin Script uses a LIFO stack: operations push data onto the top and pop data from the top. This stack-based execution model is simple and predictable, contributing to Bitcoin Script's security by making script behavior easy to analyze and verify.\n\n### Little Endian\nA byte ordering format where the least significant byte is stored first (at the lowest memory address). Bitcoin uses little endian for most internal data structures, including transaction version numbers, input/output counts, satoshi amounts, lock times, and sequence numbers. However, block hashes and transaction IDs are typically displayed in big endian (reversed) for human readability.\n\n### Layer 2\nSecondary protocols built on top of Bitcoin's base layer, designed to improve scalability, reduce transaction fees, and increase speed, all while leveraging Bitcoin's security. The Lightning Network is the most prominent Layer 2 solution for Bitcoin.\n\n### Light Client\nA Bitcoin application that interacts with the Bitcoin network by querying nodes for specific transaction and block information, but does not download and store the entire blockchain. Typically used by wallets as a way to access balance and transaction information without requiring the significant RAM needed to maintain a full node.\n\n### Lightning Network\nA second-layer payment protocol built on top of Bitcoin that enables instant, high-volume, low-cost transactions through a network of payment channels. Instead of recording every payment on the blockchain, Lightning users open channels by locking Bitcoin in 2-of-2 multisig addresses, then exchange signed transactions off-chain to update balances. Payments can route through multiple channels, enabling payments to anyone on the network without direct channel connections.\n\n### Locktime\nA transaction-level field (nLockTime) that prevents the transaction from being valid until a specified block height or Unix timestamp is reached. When set to a block height (values < 500,000,000) or timestamp (values >= 500,000,000), nodes will not relay or mine the transaction until that condition is met. Locktime enables use cases like post-dated checks and is foundational to Lightning Network.\n\n---\n\n## M\n\n### Mainnet\nThe production Bitcoin network where real Bitcoin with actual monetary value is transacted, as opposed to test networks used for development. Mainnet addresses start with \"1\" (legacy), \"3\" (P2SH), or \"bc1\" (SegWit/Taproot), distinguishing them from testnet addresses. All consensus rules are fully enforced on mainnet, and transactions are irreversible.\n\n### Mempool\nThe collection of valid, unconfirmed transactions that a node has received and is holding in memory, waiting to be included in a block. Each node maintains its own mempool, and they may differ slightly based on when transactions were received and node-specific policies. Miners select transactions from their mempool when constructing blocks, typically prioritizing by fee rate. Mempool size fluctuates with network demand.\n\n### Medium Of Exchange\nOne of the three primary functions of money, and arguably the most closely aligned with the definition of money. It refers to an asset or currency used to facilitate trade between parties without the need for bartering. Bitcoin, with its decentralized nature, is increasingly seen as a medium of exchange.\n\n### Metal Backups\nThe use of durable, fireproof, and waterproof metal sheets or plates to store recovery seed phrases or private keys. Unlike paper backups, metal backups offer long-term resilience against physical damage, providing extra security for Bitcoin holders who need to protect their keys from destruction or loss.\n\n### Merkle Root\nA single hash that cryptographically summarizes all transactions in a block, created by repeatedly hashing pairs of transaction hashes in a tree structure until one root remains. The merkle root is included in the 80-byte block header, allowing the entire block's transactions to be verified from this single value. This enables Simplified Payment Verification (SPV), where light clients can verify transaction inclusion using only the merkle root and a small proof path, without downloading the full block.\n\n### Merkle Tree\nA binary tree structure where each leaf node is a hash of a transaction, and each parent node is the hash of its two children combined, ultimately producing a single root hash. This structure enables efficient proofs of inclusion: proving a transaction is in a block only requires logâ‚‚(n) hashes rather than all n transactions. Bitcoin uses Merkle trees for transaction summarization in block headers, and Taproot uses them for organizing spending conditions (MAST).\n\n### MAST (Merkle Abstract Syntax Tree)\nA technique implemented in Taproot that represents multiple spending conditions as leaves in a Merkle tree, with only the executed path revealed when spending. This dramatically improves privacy because unused conditions remain hidden. A complex contract with many possible outcomes looks identical to a simple payment when only one path is used. MAST also reduces transaction size and fees by only requiring proof of the executed branch.\n\n### MuSig\nA multi-signature scheme using Schnorr signatures that allows multiple parties to create a single aggregated signature indistinguishable from a regular single-key signature. Unlike traditional multisig (which requires listing all public keys and signatures), MuSig combines keys and signatures off-chain, producing an output that looks like a normal Taproot key-path spend on the blockchain. This provides significant privacy improvements and fee savings from the smaller signature size.\n\n### MPP (Multi-Part Payment)\nA Lightning Network feature that allows splitting a large payment into multiple smaller parts that route independently through different paths, then recombine at the destination. This improves payment success rates by utilizing multiple channels' liquidity simultaneously and enables payments larger than any single channel's capacity. The receiver waits until all parts arrive before revealing the preimage, ensuring atomicity: either the entire payment completes or none of it does.\n\n### Magic Internet Money\nA satirical term used to describe Bitcoin, often employed both by Bitcoiners (as self-deprecating humor) and critics (as dismissal). The phrase acknowledges Bitcoin's seemingly impossible nature (digital scarcity without a central issuer, global transfers without intermediaries) while hinting at its power. Despite the humorous framing, Bitcoin represents serious technology: cryptography, proof-of-work, and game-theoretic security. See [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) for how memes function in Bitcoin culture.\n\n### Meme\nIn Richard Dawkins' original definition, a meme is a unit of cultural transmissionâ€”an idea, behavior, or style that spreads from person to person within a culture. Bitcoin functions as a powerful meme: an idea that replicates itself through human minds, spreading from person to person, generation to generation, border to border. Bitcoin's memetic power comes from simple core narratives (21 million, \"don't trust, verify\"), clear antagonists (inflation, censorship), and visible success (network uptime, adoption growth). See [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) for how Bitcoin functions as a meme and the cultural expressions that have emerged.\n\n### Miniscript\nA structured language for writing Bitcoin Scripts that is easier to analyze, compose, and reason about than raw Script. Miniscript maps to a subset of valid Bitcoin Script but provides guarantees about spending conditions, costs, and required signatures that would be difficult to determine from raw opcodes. Wallets can automatically analyze Miniscript policies to determine all possible spending paths and compute worst-case transaction sizes for fee estimation.\n\n### Miner\nAn individual or entity that participates in Bitcoin mining by dedicating computational power to solve proof-of-work puzzles. Miners collect transactions from the mempool, construct candidate blocks, and repeatedly hash block headers searching for a valid hash below the difficulty target. When successful, they broadcast the block to the network and receive the block reward plus transaction fees.\n\n### Mining\nThe process of adding new blocks to the Bitcoin blockchain through proof-of-work computation. Mining serves two critical functions: processing and validating transactions, and issuing new bitcoin according to the predetermined supply schedule. Miners compete to find a valid block hash, with the winner receiving the block subsidy plus all transaction fees from included transactions.\n\n### Mining Pool\nA collective of miners who combine their computational power and share block rewards proportionally to each member's contributed work. Pools reduce payout variance: instead of rarely winning large rewards, miners receive frequent smaller payments based on submitted shares. The pool operator constructs blocks and distributes work to members, paying out when blocks are found.\n\n### Mixer\nA service that obfuscates transaction data by blending bitcoin from different users, making it difficult to trace the movement of specific coins on the blockchain. While they enhance privacy, mixers are frequently targeted by governments and the surveillance state, which seek to undermine financial anonymity.\n\n### Money\nA means to transact and purchase goods and services, functioning as a medium of exchange. It is a market good that is acquired not for its own sake, but as a tool to facilitate the acquisition of other goods. For something to be considered money, it must be widely accepted by the market as a medium of exchange. Beyond this, money also serves as a store of value and a unit of account.\n\n### Mt. Gox\nBitcoin's first major exchange and a pivotal platform in its early years. Originally a marketplace for Magic: The Gathering cards, it became notorious after a massive security breach led to the loss of 850,000 bitcoin. Mt. Gox's collapse highlighted the importance of secure, self-custodied bitcoin.\n\n### Multisig (Multi-Signature)\nA Bitcoin script pattern requiring multiple cryptographic signatures to authorize spending, providing enhanced security and enabling shared custody arrangements. Common configurations include 2-of-3 (any two of three keyholders can spend), 3-of-5 (majority required), or 2-of-2 (both parties must agree, as used in Lightning channels). Multisig protects against single points of failure: losing one key doesn't lose funds, and compromising one key doesn't enable theft.\n\n---\n\n## N\n\n### Node\nA computer running Bitcoin software that participates in the network by validating transactions and blocks, relaying data to peers, and maintaining its own view of the blockchain. Full nodes verify everything independently against consensus rules, while lightweight (SPV) nodes trust others for some validation. Running a node provides trustless verification of your own transactions and contributes to network decentralization.\n\n### Nakamoto Consensus\nBitcoin's decentralized protocol for achieving agreement on its blockchain state. It combines proof-of-work (PoW) mining and the longest-chain rule to secure the network and prevent double-spending. In this system, miners compete to add new blocks by expending computational power to find a valid hash below a specified target.\n\n### NFT (Non-Fungible Token)\nA unique digital token that represents ownership of a specific item or asset, making it non-interchangeable.\n\n### Node (Lightning)\nA computer running Lightning Network software (such as LND, Core Lightning, Eclair, or LDK) that participates in the payment network by opening channels, routing payments, and managing liquidity. Lightning nodes maintain connections to the Bitcoin network to monitor channel funding transactions and handle on-chain settlements. Each node has a unique public key identity and advertises its channels and fee policies to the network.\n\n### Non Custodial Wallet\nA type of wallet where the user has full control over their private keys and funds, without relying on a third party. This means the user is solely responsible for the security and management of their bitcoin. Unlike custodial wallets, where a service holds your keys, non-custodial wallets ensure that only the user can access and control their bitcoin.\n\n### Nonce\nA 32-bit number in the block header that miners increment while searching for a valid proof-of-work hash. When combined with other header fields and hashed, different nonce values produce different hashes. Miners try billions of nonces looking for one that produces a hash below the difficulty target. Since the nonce provides only 4 billion possibilities (2^32), modern miners also vary the extranonce in the coinbase transaction to expand the search space.\n\n### Not Your Keys, Not Your Coins\nA well-known phrase in Bitcoin, stressing that if you don't control your private keys, you don't truly own your bitcoin. Relying on third parties to hold your keys exposes you to risk, as they could lose or seize your funds.\n\n---\n\n## O\n\n### OP_RETURN\nAn opcode that marks a transaction output as provably unspendable, allowing data to be embedded in transactions without bloating the UTXO set. Since OP_RETURN outputs can never be spent, nodes can safely discard them rather than tracking them forever. This provides a way to store small amounts of data (up to 80 bytes per output) on the blockchain for timestamping, asset protocols, or other applications.\n\n### Orange Pill\nA reference to *The Matrix*, where taking the red pill means seeing reality as it truly is. The \"orange pill\" refers to the process of someone \"waking up\" to Bitcoin's implications: recognizing Bitcoin's unique properties, understanding its potential, and becoming convinced of its importance. The journey typically moves from skepticism to curiosity to deep investigation of Bitcoin's technical and economic foundations. The color orange references Bitcoin's logo and branding, but also represents the \"awakening\" process. See [Bitcoin, the Meme](/docs/fundamentals/bitcoin-meme) for how the orange pill process drives adoption and education.\n\n### OPCODE\nA single operation in Bitcoin's stack-based scripting language, used to define spending conditions for transaction outputs. Each opcode performs a specific function: OP_DUP duplicates the top stack item, OP_HASH160 hashes it, OP_CHECKSIG verifies a signature, OP_IF enables conditional execution, and so on. Standard transactions use well-known opcode patterns (like P2PKH or P2WPKH), while more complex contracts combine opcodes to create multisig, time locks, or hash locks.\n\n### Onion Routing\nA privacy technique used in Lightning Network (via the Sphinx protocol) where payment information is encrypted in multiple layers, like an onion, with each routing node only able to decrypt its layer. Each node learns only the previous hop (where the payment came from) and the next hop (where to forward it), never the full payment path or final amount. This provides strong privacy for payment routing.\n\n### Off Chain\nTransactions or data that occur outside of the Bitcoin blockchain. These transactions aren't immediately recorded on-chain but can be settled later. Off-chain activities include the Lightning Network for faster payments and exchanges, where users trade bitcoin without immediate on-chain settlement.\n\n### On Chain\nTransactions that are recorded directly on the Bitcoin blockchain and broadcast to all nodes. These transactions are publicly verified and included in the next available block.\n\n### OPSEC (Operations Security)\nIn Bitcoin, the practice of safeguarding personal data and actions to prevent revealing sensitive information, like your identity or private keys, that could compromise your privacy or funds.\n\n### Ordinals\nA method for assigning unique identifiers to individual satoshis, the smallest units of bitcoin, using the Ordinals protocol. This allows users to inscribe or attach arbitrary data, such as text, images, or other digital assets, directly onto a specific satoshi.\n\n### Orphan Block\nA valid block that was mined but is not part of the main chain because another block at the same height was adopted by the network instead. Also called a stale block. Orphans occur naturally when two miners find blocks nearly simultaneously; the network temporarily has two competing chain tips until one gets extended and becomes the longest chain. The \"losing\" block becomes orphaned (disconnected from the timechain), and its transactions return to the mempool to be included in future blocks.\n\n### Output\nA component of a Bitcoin transaction that specifies an amount of Bitcoin and the conditions (locking script or scriptPubKey) required to spend it. Each output represents a new UTXO that can later be used as an input in a future transaction. The locking script typically specifies a public key hash (address) that must provide a valid signature to spend, though more complex conditions are possible.\n\n### Outpoint\nA reference that uniquely identifies a UTXO: the transaction ID (txid) of the transaction that created it, plus the output index (vout) within that transaction. Every transaction input references an outpoint to specify which UTXO it is spending. The pair (txid, vout) is used in signatures (sighash) and by covenant proposals that need to pin or inspect specific inputs.\n\n---\n\n## P\n\n### Paper Wallet\nA physical document that contains a Bitcoin private key and its corresponding public address, usually in the form of a QR code. It allows users to store bitcoin offline, providing cold storage. While paper wallets offer strong protection against online hacks, they are vulnerable to physical damage or loss, and improper handling can expose the private key, compromising the funds.\n\n### Payjoin\nA privacy technique where both the sender and receiver contribute inputs to a transaction, breaking the common-input-ownership heuristic that blockchain analysis relies on. Normally, analysts assume all inputs to a transaction belong to the same entity. Payjoin defeats this by mixing ownership. The transaction looks like a normal payment on-chain, but the true amounts are obscured because inputs from both parties are combined.\n\n### Peer\nAnother Bitcoin node that your node maintains a direct TCP connection with for exchanging blocks, transactions, and network information. Nodes typically maintain 8-10 outbound connections (ones they initiated) and accept inbound connections (up to 125 total by default) from other nodes. Peer selection uses various heuristics to achieve diversity, connecting to nodes in different IP ranges, different parts of the world, and different ASNs to reduce the risk of eclipse attacks.\n\n### Peer-To-Peer (P2P)\nDirect interactions between participants without intermediaries or central authorities. In Bitcoin, this means transactions happen directly between users, with the network enforcing the rules rather than relying on a third party.\n\n### P2PKH (Pay-to-Pubkey-Hash)\nThe original and most common legacy Bitcoin script pattern, where funds are locked to the hash of a public key. Addresses start with \"1\" and spending requires providing the full public key and a valid signature. The hash provides an extra layer of protection: until funds are spent, only the hash is public. P2PKH was the dominant address type for Bitcoin's first years but is being superseded by more efficient SegWit formats.\n\n### P2SH (Pay-to-Script-Hash)\nA script pattern (BIP 16) that locks funds to the hash of an arbitrary script, with the actual script only revealed when spending. Addresses start with \"3\" and can encapsulate any valid script, most commonly multisig arrangements or wrapped SegWit. The sender only needs to know the script hash (address); the complexity of the actual spending conditions is hidden until redemption.\n\n### P2TR (Pay-to-Taproot)\nThe modern Bitcoin address type introduced with the Taproot upgrade (BIP 341), providing the best combination of privacy, efficiency, and flexibility. Addresses start with \"bc1p\" and can be spent either with a simple key signature (key path) or by revealing one of potentially many script conditions (script path via MAST). Crucially, key path spends look identical regardless of whether the underlying setup was single-sig or complex multisig, dramatically improving privacy.\n\n### P2WPKH (Pay-to-Witness-Pubkey-Hash)\nA native SegWit address type (BIP 141/173) that provides the same security as P2PKH but with lower fees by moving signature data to the witness section. Addresses start with \"bc1q\" followed by 42 characters and use Bech32 encoding for better error detection. P2WPKH transactions are approximately 38% cheaper than equivalent P2PKH transactions because witness data is discounted in the weight calculation.\n\n### P2WSH (Pay-to-Witness-Script-Hash)\nA native SegWit address type for complex scripts (like multisig), providing the same capabilities as P2SH but with SegWit's fee discount on witness data. Addresses start with \"bc1q\" but are longer than P2WPKH (62 characters) due to the larger script hash. Like P2SH, the actual script is only revealed when spending, but the witness discount makes complex redemptions significantly cheaper.\n\n### Payment Channel\nA mechanism that enables multiple Bitcoin transactions between two parties without broadcasting each one to the blockchain, using a 2-of-2 multisig address as the foundation. Funds are locked in the multisig through an on-chain funding transaction, then balance updates happen off-chain through exchanging signed transactions. Only the final state needs to be published to the blockchain, dramatically reducing fees and enabling instant transfers.\n\n### Payment Hash\nA cryptographic hash of the payment preimage, used in Lightning Network HTLCs to cryptographically link payment attempts across the network. The receiver generates a random preimage and provides its hash to the sender; the payment can only be claimed by revealing the preimage that produces this hash. This creates an atomic payment mechanism where either the entire path succeeds (preimage revealed) or fails (preimage never revealed).\n\n### Payment Preimage\nA random 32-byte secret generated by the payment recipient that, when hashed, produces the payment hash included in Lightning invoices. The preimage is the \"key\" that unlocks payment. The receiver reveals it to claim funds, and this revelation cascades back through all routing nodes to settle the HTLCs. Knowledge of the preimage serves as proof of payment, since only the original recipient could have revealed it.\n\n### Preimage\nThe original input data that produces a specific hash output through a cryptographic hash function. In general cryptography, finding a preimage from a hash should be computationally infeasible (preimage resistance). For the Lightning Network usage, see [Payment Preimage](#payment-preimage).\n\n### Propagation\nThe process by which new blocks and transactions spread across the Bitcoin network from node to node through the gossip protocol. Fast propagation is critical for network security; slow block propagation increases orphan rates and gives advantages to miners with better connectivity. Bitcoin Core includes optimizations like compact blocks and transaction relay improvements to minimize propagation delay.\n\n### Private Key\nA 256-bit secret number that cryptographically proves ownership of associated Bitcoin addresses, enabling the creation of valid signatures to spend funds. Private keys must be generated with sufficient randomness and kept absolutely secure. Anyone who obtains a private key can irreversibly steal all funds it controls. Modern wallets generate private keys from seed phrases using deterministic derivation, so users typically only need to secure the seed phrase.\n\n### Proof Of Keys\nThe act of withdrawing bitcoin from a third-party exchange into a wallet where you control the private keys. This movement is celebrated annually on January 3rd to promote self-custody and highlight the importance of personal control over your funds.\n\n### Proof-of-Work (PoW)\nThe consensus mechanism securing Bitcoin, requiring miners to expend computational resources to find a block hash below a target difficulty threshold. This work is easy to verify but expensive to produce, creating a cost to create blocks that prevents spam and makes chain reorganization economically infeasible. PoW also provides a fair mechanism for distributing new coins and achieves consensus without requiring identity or permission.\n\n### PSBT (Partially Signed Bitcoin Transaction)\nA standardized format (BIP 174) for creating, transferring, and signing Bitcoin transactions that require multiple steps or multiple signers. PSBTs contain all necessary information (UTXOs, derivation paths, scripts) for signers to validate and sign, then can be combined into a final transaction. This enables workflows like hardware wallet signing, multisig coordination, and air-gapped signing.\n\n### Protocol\nA set of rules that governs how participants in a network communicate and function. Bitcoin's protocol defines the rules for how transactions are processed, blocks are mined, and consensus is achieved across the network.\n\n### Public Key\nA cryptographic key derived from a private key through one-way elliptic curve multiplication (on the secp256k1 curve), used to verify signatures and generate addresses. Public keys can be safely shared since the mathematical relationship to the private key cannot be reversed. Bitcoin uses two forms: uncompressed (65 bytes) and compressed (33 bytes), with compressed now standard for efficiency.\n\n### Public Key Cryptography\nA method of encryption where every private key has a corresponding public key, from which it is impossible to determine the private key, and data encrypted with one key can be decrypted with the other. This lets you publish a key that lets anyone send encrypted messages to you without having to exchange a secret key first.\n\n---\n\n## R\n\n### RBF (Replace-by-Fee)\nA feature (BIP 125) that allows replacing an unconfirmed transaction with a new version paying higher fees, useful when the original fee was too low for timely confirmation. For RBF to work, the original transaction must signal replaceability (by setting a sequence number below 0xfffffffe), and the replacement must pay strictly higher fees. RBF is safer and more flexible than CPFP for fee bumping when you created the original transaction.\n\n### Regtest\nA local regression testing network mode where you can mine blocks instantly with minimal difficulty, creating a private blockchain for development and testing. Unlike testnet or signet, regtest runs entirely on your local machine with no connection to other nodes, giving complete control over block production and timing. This makes it ideal for automated testing, debugging, and developing applications that need predictable block times.\n\n### Relative Time Lock\nA time lock that prevents a UTXO from being spent until a certain number of blocks or time units have passed since the UTXO itself was confirmed, implemented using OP_CHECKSEQUENCEVERIFY (CSV) and the sequence field. Unlike absolute time locks (CLTV), relative locks count from when the spending UTXO was created, enabling \"wait N blocks after X happens\" logic. This is essential for Lightning Network, where CSV ensures parties have time to respond to channel disputes.\n\n### Relay\nThe act of receiving valid blocks or transactions from peers and forwarding them to other connected nodes, which is how information propagates across the decentralized Bitcoin network. Nodes validate data before relaying to prevent spam and invalid data from spreading. Relay policies can differ between nodes (some may reject transactions below certain fee rates or with specific characteristics), but blocks that meet consensus rules are always relayed.\n\n### RIPEMD-160\nA cryptographic hash function that produces a 160-bit (20-byte) output, used in Bitcoin address generation to create shorter addresses while maintaining security. The standard address derivation applies SHA-256 to the public key first, then RIPEMD-160 to that result, producing the 20-byte \"pubkey hash\" that forms the core of an address. This HASH160 operation (SHA256 + RIPEMD160) provides 160-bit security while keeping addresses reasonably short.\n\n### QR Code\nA scannable image often used in Bitcoin to represent a bitcoin address or a Lightning Network invoice. It allows for quick and easy transactions without manually entering long strings of characters.\n\n### Quantum Computing\nA form of computing based on quantum physics. Where classical computers rely on bits (zeros or ones) to make calculations, quantum computers use quantum bits (qubits) that leverage quantum mechanics to exist in a \"superposition\": a combination of zero and one, with some probability for each.\n\n### RPC (Remote Procedure Call)\nThe JSON-RPC protocol interface that Bitcoin Core exposes for programmatic interaction, allowing applications to query blockchain data, manage wallets, and create transactions. Common RPC commands include getblockchaininfo, getblock, getrawtransaction, sendrawtransaction, and wallet management functions. The RPC interface is how block explorers, payment processors, and other applications integrate with Bitcoin nodes.\n\n### RGB (Really Good Bitcoin)\nA layer-2 smart contract system designed for creating and managing assets, such as tokens, off-chain while using Bitcoin's security. RGB enables scalable, private, and customizable smart contracts. It allows users to issue, transfer, and verify assets without burdening the Bitcoin blockchain, preserving privacy and minimizing transaction fees.\n\n### Routing\nThe process of finding a path through the Lightning Network's channel graph from the payment sender to the recipient. Senders query the network gossip data to build a local graph of channels, then use pathfinding algorithms to find routes with sufficient liquidity and acceptable fees. Routes must have enough capacity at each hop, and the sender typically tries multiple paths if the first fails.\n\n### Routing Fee\nThe fee charged by Lightning nodes for forwarding payments through their channels, compensating them for providing liquidity and taking on channel management costs. Fees consist of two components: a base fee (fixed amount per forwarded payment) and a proportional fee (percentage of the payment amount). Routing nodes set their own fee policies, and senders choose routes partly based on total fees.\n\n### Runes Protocol\nA fungible token standard on Bitcoin, designed to create and manage tokens directly on the Bitcoin blockchain using its UTXO model. Developed by Casey Rodarmor, the creator of Ordinals, it aims to be a more efficient alternative to protocols like BRC-20 by minimizing on-chain footprint and improving UTXO management.\n\n---\n\n## S\n\n### Sat (Satoshi)\nA satoshi, or \"sat,\" is the smallest unit of bitcoin, equal to one hundred-millionth of a bitcoin (0.00000001 BTC). Named after Bitcoin's pseudonymous creator, [Satoshi Nakamoto](/docs/history/people#satoshi-nakamoto), sats are used to measure small amounts of bitcoin. This denomination enables Bitcoin to be used for micropayments despite any future price appreciation. The Lightning Network uses millisatoshis (1/1000 of a satoshi - not in this table) for routing fee calculations, though on-chain transactions are limited to whole satoshi precision. See [Denominations](/docs/fundamentals/denominations) for the full unit table and converter.\n\n### Satoshi Nakamoto\nThe pseudonymous creator of Bitcoin. He released the Bitcoin whitepaper in 2008 by mailing it to the Cypherpunk mailing list and mined the Genesis Block in 2009. Satoshi remained active until mid-2010, when he handed over control of Bitcoin's development to others and gradually disappeared. His identity remains unknown.\n\n### Seed Phrase\nA human-readable backup of a wallet's master secret, typically consisting of 12-24 words from a standardized BIP39 wordlist of 2048 words. This mnemonic phrase encodes the entropy used to derive all wallet keys through hierarchical deterministic (HD) derivation, allowing complete wallet recovery from just these words. Seed phrases should be stored securely offline and never entered into computers except during recovery. Also called a recovery phrase or mnemonic phrase.\n\n### Self-Custody\nThe practice of controlling your own private keys rather than entrusting them to a third party like an exchange or custodial service. Self-custody means you have true ownership of your Bitcoin, as expressed by the principle \"not your keys, not your coins.\" While self-custody provides full control and eliminates counterparty risk, it requires proper security practices including secure [seed phrase](/docs/glossary#seed-phrase) storage, [hardware wallet](/docs/glossary#hardware-wallet) usage, and understanding of security best practices.\n\n### Share\nA proof-of-work submission from a miner to a mining pool that meets the pool's difficulty target (lower than the actual network difficulty). Shares prove the miner is doing work without requiring them to find actual blocks, enabling fair reward distribution. Share counting allows pools to distribute block rewards proportionally to contributed hash power, dramatically reducing individual miner variance.\n\n### Script\nBitcoin's stack-based programming language used to define spending conditions for transaction outputs and provide proofs to satisfy them. Script is intentionally limited (not Turing complete) to ensure all programs terminate and can be analyzed for validity and resource consumption. Scripts execute by pushing data and running opcodes that manipulate a stack; a successful spend results in a non-empty stack with a true value on top.\n\n### ScriptPubKey\nThe locking script embedded in a transaction output that defines what conditions must be met to spend those funds. Named because it typically involves a public key or its hash, the scriptPubKey is essentially a puzzle that the spender must solve. Common patterns include requiring a signature matching a specific public key hash (P2PKH), satisfying a hashed script (P2SH), or meeting SegWit witness requirements (P2WPKH, P2WSH, P2TR).\n\n### ScriptSig\nThe unlocking script in a transaction input that provides the data needed to satisfy the referenced output's scriptPubKey conditions. For P2PKH outputs, the scriptSig contains the signature and public key; for P2SH, it contains the serialized redeem script and any necessary signatures. The scriptSig is concatenated with the scriptPubKey during validation, and the combined script must execute successfully to validate the spend.\n\n### SegWit (Segregated Witness)\nA major protocol upgrade activated in August 2017 (BIP 141) that moves signature data (\"witness\") outside the base transaction structure, fixing several important issues. SegWit resolved transaction malleability (which had blocked Lightning Network development), increased effective block capacity through a new weight-based limit, and enabled future upgrades like Taproot. By segregating witness data and applying a discount factor, SegWit transactions pay lower fees, typically 30-40% less than equivalent legacy transactions.\n\n### SHA-256\nA cryptographic hash function from the SHA-2 family that produces a 256-bit (32-byte) output, used extensively in Bitcoin for proof-of-work, transaction IDs, and block hashing. SHA-256 provides strong security properties: it's computationally infeasible to find an input that produces a specific hash (preimage resistance), to find two different inputs with the same hash (collision resistance), and small input changes completely change the output (avalanche effect).\n\n### SHA256D\nDouble SHA-256 hashing used throughout Bitcoin, where data is hashed twice in succession: `SHA256(SHA256(data))`. Block headers, transaction IDs, and merkle tree nodes all use SHA256D. This construction provides defense in depth: even if vulnerabilities were discovered in single SHA-256, attacking double-hashed values would remain difficult.\n\n### Schnorr Signature\nA digital signature scheme (BIP 340) introduced with Taproot that offers several advantages over the previously-used ECDSA. Schnorr signatures are mathematically simpler, provably secure under standard assumptions, and enable powerful features like signature aggregation (combining multiple signatures into one) and batch verification. With Schnorr, a transaction from a multisig wallet can look identical to a single-sig transaction on-chain, significantly improving privacy.\n\n### Selfish Mining\nAn attack strategy where a miner with significant hash power secretly mines blocks without broadcasting them, then strategically releases them to orphan honest miners' blocks. By withholding blocks and timing releases, an attacker can potentially earn more than their proportional share of hash power would suggest. Research shows selfish mining becomes profitable above roughly 25-33% of hash power, though no sustained attacks have been documented on Bitcoin.\n\n### Silent Payments\nA privacy protocol (BIP 352) enabling recipients to publish a static identifier from which senders can derive unique, unlinkable addresses for each payment. This solves the address reuse problem without requiring interaction, as the recipient doesn't need to generate and share new addresses for each payment. Senders use ECDH with their transaction inputs and the recipient's public key to derive a unique one-time address.\n\n### Signet\nA test network (BIP 325) that adds a signature requirement to block validity, enabling more controlled and realistic testing than regtest while avoiding testnet's issues with griefing and worthless coins. Signet blocks must be signed by specific keys, so only authorized parties can mine blocks, preventing the spam and instability that plagued testnet. Custom signets can be created for private testing networks.\n\n### Soft Fork\nA backward-compatible protocol change that tightens consensus rules, making some previously valid transactions or blocks now invalid. Non-upgraded nodes continue accepting new blocks but may not understand new features (they see transactions as \"anyone can spend\" but observe miners not spending them). Examples include SegWit (BIP 141) and Taproot (BIP 341). Because soft forks don't force the network to split, they're Bitcoin's preferred upgrade mechanism.\n\n### Sidechain\nA separate blockchain that's interoperable with Bitcoin, allowing bitcoin to move between the two chains via two-way pegs. Sidechains can offer additional features or scalability while using Bitcoin as the base layer for security.\n\n### Sighash\nA 1-byte flag in Bitcoin signatures that selects which parts of the transaction are committed to by the signature. Sighash types (e.g. SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE, SIGHASH_ANYPREVOUT) control whether the signer commits to all inputs and outputs, none, only the corresponding output, or allows the input to come from any outpoint. Sighash enables RBF (via sequence), contract protocols, and proposed covenants.\n\n### Signature\nA digital signature in a Bitcoin transaction proves that the owner of the corresponding private key authorized the transaction. It ensures the authenticity and security of the transfer.\n\n### Smart Contracts\nSelf-executing contracts where the terms are written in code rather than legal text. They automatically execute on blockchains when predefined conditions are met. While not native to Bitcoin, smart contracts can be implemented on Bitcoin through sidechains or other solutions.\n\n### Sphinx Protocol\nThe onion routing protocol used in Lightning Network to provide payment privacy, where route information is encrypted in layers like an onion. The sender constructs the entire encrypted packet, with each routing node only able to decrypt their layer to learn the next hop. Sphinx ensures that no intermediate node learns the payment origin, destination, or their position in the route. Sphinx is specified in BOLT 4 and is fundamental to Lightning's privacy guarantees.\n\n### SPV (Simplified Payment Verification)\nA method described in the Bitcoin whitepaper for lightweight clients to verify transactions without downloading the full blockchain, relying on merkle proofs and block headers. SPV clients download only block headers (~80 bytes each vs. megabytes of full blocks), then request merkle proofs for transactions affecting their addresses. By verifying the proof against the merkle root in the header and checking that header is part of the longest chain, SPV clients can confirm transaction inclusion with reasonable security.\n\n### Store Of Value\nAn asset that preserves its purchasing power over time. People use it to maintain wealth and protect against inflation. Gold and Bitcoin are often viewed as stores of value because they are resistant to inflation and currency devaluation, unlike fiat money, which loses value over time.\n\n### Stratum\nThe de facto standard protocol for communication between Bitcoin miners and mining pools, enabling work distribution and share submission. Stratum v1 has pools send work (block header template and target) to miners, who submit shares (valid proofs of work). Stratum V2 is a next-generation protocol that adds encryption, enables miners to select their own transactions (improving decentralization), and reduces bandwidth usage.\n\n### Stratum V2\nAn upgraded communication protocol for Bitcoin mining pools that improves efficiency, security, and decentralization. It allows miners more control over the construction of block templates and reduces the risk of centralization in mining pools. Stratum V2 also enhances network security by encrypting communication between miners and pools.\n\n### Sybil Attack\nAn attack where a malicious actor creates many fake identities (nodes) to gain disproportionate influence over the network, potentially to eclipse victims from honest nodes or manipulate peer discovery. Bitcoin mitigates Sybil attacks through several mechanisms: proof-of-work means mining power can't be faked, nodes limit connections per IP range, and the economic cost of running many nodes provides some resistance.\n\n---\n\n## T\n\n### Taproot\nA major Bitcoin protocol upgrade activated in November 2021 (BIPs 340, 341, 342) that significantly improves privacy, efficiency, and smart contract capabilities. Taproot combines Schnorr signatures, MAST (Merkle Abstract Syntax Trees), and a new script version to make complex transactions indistinguishable from simple payments when using the key path. This means multisig wallets, Lightning channels, and sophisticated contracts all look like normal single-signature transactions on-chain, dramatically improving privacy for everyone.\n\n### Tapscript\nThe scripting system used in Taprootâ€™s script path (BIP 341/342). Tapscript is the opcode set and validation rules for the leaves of the Taproot Merkle tree when spending via a script rather than the key path. It reuses Bitcoin Script opcodes and adds BIP 342 opcodes (e.g. OP_CHECKSIGADD) for Schnorr and Taproot-specific behavior. Miniscript and other policy compilers can target Tapscript for P2TR outputs.\n\n### Testnet\nA public Bitcoin network using worthless test coins, designed for development and testing without risking real money. Testnet uses different address prefixes (starting with \"m\", \"n\", \"2\", or \"tb1\") and different genesis block, ensuring testnet and mainnet transactions can never be confused. Testnet has had issues with griefing (malicious difficulty spikes) and coins sometimes acquiring value despite being meant to be free.\n\n### Time Lock\nA mechanism built into Bitcoin transactions that prevents funds from being spent until specified conditions are met, enabling time-based smart contracts. Absolute time locks (CLTV) prevent spending until a specific block height or Unix timestamp. Relative time locks (CSV) prevent spending until a certain time has passed since the UTXO was created. Time locks are fundamental to Lightning Network (for HTLC refunds), inheritance planning, vesting schedules, and various escrow arrangements.\n\n### TLV (Type-Length-Value)\nA flexible encoding format used extensively in Lightning Network protocol messages (BOLT specifications) that allows for extensible and forward-compatible data structures. Each TLV record contains a type identifier (what kind of data), a length (how many bytes), and the value itself. Nodes can safely ignore TLV types they don't understand while processing ones they do, enabling smooth protocol upgrades.\n\n### Transaction\nThe fundamental unit of value transfer in Bitcoin, consisting of inputs (references to previously unspent outputs being consumed), outputs (new UTXOs being created with specified amounts and spending conditions), and metadata. Every Bitcoin transaction must consume at least one existing UTXO and create at least one new one. The sum of input values must equal or exceed the sum of output values, with any difference becoming the miner fee.\n\n### Transaction Fee\nThe amount paid to miners as incentive for including a transaction in a block, calculated as the difference between total input value and total output value. Fees are paid in satoshis and typically expressed as a fee rate (satoshis per virtual byte) to account for transaction size. During periods of high demand, users compete by offering higher fee rates to get faster confirmation.\n\n### Transaction ID (TXID)\nA unique 256-bit identifier for a transaction, calculated as the SHA256D hash of the serialized transaction data. TXIDs are used to reference transactions in inputs (specifying which output to spend), in block merkle trees, and throughout the ecosystem for tracking and identification. Before SegWit, TXIDs could be changed by third parties through malleability attacks. SegWit introduced the WTXID (witness transaction ID) that includes witness data, while the TXID excludes it, fixing malleability for SegWit transactions.\n\n### Transaction Malleability\nA historical vulnerability where transaction signatures could be modified by third parties without invalidating them, causing the transaction ID to change even though the transaction itself remained valid. This was problematic for protocols that needed to reference unconfirmed transactions by TXID, like Lightning Network channels. SegWit (BIP 141) fixed malleability by moving signature data to a separate witness structure not included in the TXID calculation.\n\n### Triple Entry Bookkeeping\nAn advancement of traditional double-entry bookkeeping that incorporates cryptographic verification. In Bitcoin, each transaction is logged in a decentralized ledger (the blockchain), where all participants can verify the transaction. This provides enhanced transparency and security, reducing the risk of fraud and errors compared to traditional accounting systems.\n\n---\n\n## U\n\n### UTXO (Unspent Transaction Output)\nA transaction output that hasn't been spent yet, representing the actual \"coins\" in Bitcoin's accounting model. Unlike account-based systems (like bank accounts), Bitcoin tracks ownership through discrete UTXOs. Each is either entirely unspent or entirely consumed when used as an input. When you \"have 1 BTC\", you actually possess one or more UTXOs that sum to that amount. Spending requires consuming entire UTXOs and creating new ones, including change outputs when the input exceeds the payment.\n\n### UTXO Set\nThe complete database of all unspent transaction outputs at a given point in time, representing the current state of Bitcoin ownership. Full nodes maintain the UTXO set in memory or fast storage for quick transaction validation, checking that referenced inputs exist and aren't already spent. The UTXO set currently contains around 70-100 million entries requiring several gigabytes to store. Keeping the UTXO set manageable is important for node performance, which is why creating dust outputs and unnecessary UTXOs is discouraged.\n\n### Unconfirmed Transaction\nA transaction which is not yet part of a block. A confirmation is when a transaction is put into a block to permanently become part of the blockchain. \"6 confirmations\" means that the transaction is in a block and there are 5 blocks after it in the chain, which provides added assurance that the transaction is legitimate.\n\n### Unit Of Account\nOne of the three primary functions of money, alongside being a medium of exchange and a store of value. It refers to money's ability to provide a consistent standard for measuring and comparing the value of goods and services.\n\n---\n\n## V\n\n### vByte (Virtual Byte)\nA unit of transaction size measurement introduced with SegWit, calculated as weight units divided by 4, used for fee calculation and block space accounting. Virtual bytes provide backward compatibility with legacy fee estimation while incorporating SegWit's discount for witness data. A legacy transaction has equal vBytes and actual bytes, while SegWit transactions have fewer vBytes than actual bytes due to the witness discount.\n\n### Virgin Bitcoin\nNewly mined bitcoin that has never been used in any transactions. It is untainted by any transaction history and is sometimes valued more due to its clean transaction record.\n\n---\n\n## W\n\n### Wallet\nSoftware (or hardware) that manages Bitcoin private keys, tracks balances, and creates transactions on behalf of the user. Wallets can be full node (run their own node for verification), SPV (trust others for block validation), or custodial (third party holds keys). Hardware wallets store keys on secure devices that never expose private keys to potentially compromised computers. Modern wallets typically use HD (hierarchical deterministic) architecture, deriving all keys from a single seed phrase for easy backup.\n\n### Watchtower\nA service that monitors the Bitcoin blockchain on behalf of Lightning Network users, watching for attempts to close channels with outdated (fraudulent) states. When a channel counterparty broadcasts a revoked commitment transaction while you're offline, the watchtower detects it and broadcasts a penalty transaction to claim all channel funds on your behalf. Watchtowers solve the \"always online\" problem in Lightning, allowing users to go offline safely knowing their channels are monitored.\n\n### Weight Units\nThe measurement system introduced by SegWit for calculating transaction size and block capacity, where base transaction data counts as 4 weight units per byte and witness data counts as 1 weight unit per byte. This 4:1 discount for witness data incentivizes SegWit adoption and reduces the fee cost of signatures. The block limit is 4 million weight units, which translates to approximately 1 MB of base data plus additional witness data, enabling effective block sizes of around 2-4 MB for blocks full of SegWit transactions.\n\n### Witness\nThe segregated data structure in SegWit transactions containing signatures, public keys, and other unlocking data that proves authorization to spend inputs. By moving witness data outside the base transaction (and thus outside the TXID calculation), SegWit fixed transaction malleability and enabled the witness discount for fee calculation. The witness is committed to through a separate witness root in the coinbase transaction rather than affecting the main merkle tree.\n\n### Witness Discount\nA feature introduced in Bitcoin's SegWit upgrade, which reduces the cost of storing certain types of data, specifically witness data, by giving it a lower \"weight\" in terms of transaction fees. Witness data, which includes signatures, is given a discount to make Bitcoin transactions more efficient, promoting greater economic density on the timechain.\n\n---\n\n## X\n\n### XBT\nThe ISO currency code for bitcoin. Like XAU for gold, \"X\" is used to indicate a currency that isn't tied to any specific country, in contrast to BTC, the commonly used ticker symbol.\n\n### xPub (Extended Public Key)\nAn extended public key used by Hierarchical Deterministic (HD) wallets to generate multiple public addresses from one master key. This allows you to receive bitcoin while keeping your private keys securely offline.\n\n---\n\n## Y\n\n### Ypub\nAn extended public key format used in BIP49 wallets to generate SegWit addresses wrapped in P2SH. Unlike an Xpub, which is used for legacy P2PKH addresses, a Ypub derives addresses that start with \"3,\" offering lower transaction fees while maintaining compatibility with older wallets.\n\n---\n\n## Z\n\n### ZMQ (ZeroMQ)\nA high-performance messaging library integrated into Bitcoin Core that provides real-time publish-subscribe notifications for new blocks, transactions, and other events. Applications can subscribe to ZMQ topics (like \"rawtx\" for new transactions or \"hashblock\" for new blocks) and receive instant notifications without polling the RPC interface. This is essential for building responsive applications that need to react immediately to blockchain events.\n\n### Zero Confirmation Transaction\nA Bitcoin transaction that has been broadcasted to the network but hasn't yet been confirmed by miners and included in a block. It's considered riskier because it can still be reversed.\n\n### Zero Knowledge Proof (ZKP)\nA cryptographic method that allows one party (the prover) to prove to another party (the verifier) that they know a specific piece of information or that a statement is true, without revealing the information itself.\n\n### zk-SNARK (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)\nA cryptographic proof that allows one party to prove it has certain information without revealing the information itself. While zk-SNARKs are not used in Bitcoin, they are employed in other blockchain projects for privacy-focused transactions.\n\n### zk-STARKs (Zero-Knowledge Scalable Transparent Arguments of Knowledge)\nCryptographic proofs that allow a prover to demonstrate possession of certain information without revealing the information itself. This enables secure verification of computations or transactions while keeping the details private.\n",
    "filename": "terms.md"
  }
}